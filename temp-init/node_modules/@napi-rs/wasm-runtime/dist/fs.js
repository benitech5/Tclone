function _mergeNamespaces(n, m) {
	m.forEach(function (e) {
		e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
			if (k !== 'default' && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	});
	return Object.freeze(n);
}

var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof undefined !== 'undefined' ? undefined : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var lib$2 = {exports: {}};

var Stats = {};

var constants$2 = {};

var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;
	Object.defineProperty(constants$2, "__esModule", { value: true });
	constants$2.constants = void 0;
	constants$2.constants = {
	    O_RDONLY: 0,
	    O_WRONLY: 1,
	    O_RDWR: 2,
	    S_IFMT: 61440,
	    S_IFREG: 32768,
	    S_IFDIR: 16384,
	    S_IFCHR: 8192,
	    S_IFBLK: 24576,
	    S_IFIFO: 4096,
	    S_IFLNK: 40960,
	    S_IFSOCK: 49152,
	    O_CREAT: 64,
	    O_EXCL: 128,
	    O_NOCTTY: 256,
	    O_TRUNC: 512,
	    O_APPEND: 1024,
	    O_DIRECTORY: 65536,
	    O_NOATIME: 262144,
	    O_NOFOLLOW: 131072,
	    O_SYNC: 1052672,
	    O_SYMLINK: 2097152,
	    O_DIRECT: 16384,
	    O_NONBLOCK: 2048,
	    S_IRWXU: 448,
	    S_IRUSR: 256,
	    S_IWUSR: 128,
	    S_IXUSR: 64,
	    S_IRWXG: 56,
	    S_IRGRP: 32,
	    S_IWGRP: 16,
	    S_IXGRP: 8,
	    S_IRWXO: 7,
	    S_IROTH: 4,
	    S_IWOTH: 2,
	    S_IXOTH: 1,
	    F_OK: 0,
	    R_OK: 4,
	    W_OK: 2,
	    X_OK: 1,
	    UV_FS_SYMLINK_DIR: 1,
	    UV_FS_SYMLINK_JUNCTION: 2,
	    UV_FS_COPYFILE_EXCL: 1,
	    UV_FS_COPYFILE_FICLONE: 2,
	    UV_FS_COPYFILE_FICLONE_FORCE: 4,
	    COPYFILE_EXCL: 1,
	    COPYFILE_FICLONE: 2,
	    COPYFILE_FICLONE_FORCE: 4,
	};
	
	return constants$2;
}

var hasRequiredStats;

function requireStats () {
	if (hasRequiredStats) return Stats;
	hasRequiredStats = 1;
	Object.defineProperty(Stats, "__esModule", { value: true });
	Stats.Stats = void 0;
	const constants_1 = requireConstants$2();
	const { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;
	/**
	 * Statistics about a file/directory, like `fs.Stats`.
	 */
	let Stats$1 = class Stats {
	    static build(node, bigint = false) {
	        const stats = new Stats();
	        const { uid, gid, atime, mtime, ctime } = node;
	        const getStatNumber = !bigint ? number => number : number => BigInt(number);
	        // Copy all values on Stats from Node, so that if Node values
	        // change, values on Stats would still be the old ones,
	        // just like in Node fs.
	        stats.uid = getStatNumber(uid);
	        stats.gid = getStatNumber(gid);
	        stats.rdev = getStatNumber(node.rdev);
	        stats.blksize = getStatNumber(4096);
	        stats.ino = getStatNumber(node.ino);
	        stats.size = getStatNumber(node.getSize());
	        stats.blocks = getStatNumber(1);
	        stats.atime = atime;
	        stats.mtime = mtime;
	        stats.ctime = ctime;
	        stats.birthtime = ctime;
	        stats.atimeMs = getStatNumber(atime.getTime());
	        stats.mtimeMs = getStatNumber(mtime.getTime());
	        const ctimeMs = getStatNumber(ctime.getTime());
	        stats.ctimeMs = ctimeMs;
	        stats.birthtimeMs = ctimeMs;
	        if (bigint) {
	            stats.atimeNs = BigInt(atime.getTime()) * BigInt(1000000);
	            stats.mtimeNs = BigInt(mtime.getTime()) * BigInt(1000000);
	            const ctimeNs = BigInt(ctime.getTime()) * BigInt(1000000);
	            stats.ctimeNs = ctimeNs;
	            stats.birthtimeNs = ctimeNs;
	        }
	        stats.dev = getStatNumber(0);
	        stats.mode = getStatNumber(node.mode);
	        stats.nlink = getStatNumber(node.nlink);
	        return stats;
	    }
	    _checkModeProperty(property) {
	        return (Number(this.mode) & S_IFMT) === property;
	    }
	    isDirectory() {
	        return this._checkModeProperty(S_IFDIR);
	    }
	    isFile() {
	        return this._checkModeProperty(S_IFREG);
	    }
	    isBlockDevice() {
	        return this._checkModeProperty(S_IFBLK);
	    }
	    isCharacterDevice() {
	        return this._checkModeProperty(S_IFCHR);
	    }
	    isSymbolicLink() {
	        return this._checkModeProperty(S_IFLNK);
	    }
	    isFIFO() {
	        return this._checkModeProperty(S_IFIFO);
	    }
	    isSocket() {
	        return this._checkModeProperty(S_IFSOCK);
	    }
	};
	Stats.Stats = Stats$1;
	Stats.default = Stats$1;
	
	return Stats;
}

var Dirent = {};

var encoding = {};

var buffer$2 = {};

var base64Js = {};

var hasRequiredBase64Js;

function requireBase64Js () {
	if (hasRequiredBase64Js) return base64Js;
	hasRequiredBase64Js = 1;

	base64Js.byteLength = byteLength;
	base64Js.toByteArray = toByteArray;
	base64Js.fromByteArray = fromByteArray;

	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}

	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;

	function getLens (b64) {
	  var len = b64.length;

	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=');
	  if (validLen === -1) validLen = len;

	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4);

	  return [validLen, placeHoldersLen]
	}

	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}

	function toByteArray (b64) {
	  var tmp;
	  var lens = getLens(b64);
	  var validLen = lens[0];
	  var placeHoldersLen = lens[1];

	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

	  var curByte = 0;

	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen;

	  var i;
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)];
	    arr[curByte++] = (tmp >> 16) & 0xFF;
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4);
	    arr[curByte++] = tmp & 0xFF;
	  }

	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2);
	    arr[curByte++] = (tmp >> 8) & 0xFF;
	    arr[curByte++] = tmp & 0xFF;
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF);
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    );
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    );
	  }

	  return parts.join('')
	}
	return base64Js;
}

var base64JsExports = requireBase64Js();

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredIeee754;

function requireIeee754 () {
	if (hasRequiredIeee754) return ieee754;
	hasRequiredIeee754 = 1;
	ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? (nBytes - 1) : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];

	  i += d;

	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	};

	ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = (nBytes * 8) - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
	  var i = isLE ? 0 : (nBytes - 1);
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

	  value = Math.abs(value);

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }

	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128;
	};
	return ieee754;
}

var ieee754Exports = requireIeee754();

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;

const INSPECT_MAX_BYTES = 50;

const K_MAX_LENGTH = 0x7fffffff;
const kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  );
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1);
    const proto = { foo: function () { return 42 } };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
});

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
});

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value);
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
};

function allocUnsafe (size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
};

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0;
  let buf = createBuffer(length);

  const actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0;
  const buf = createBuffer(length);
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype);

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0;
    const buf = createBuffer(len);

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len);
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length;
  let y = b.length;

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  const buffer = Buffer.allocUnsafe(length);
  let pos = 0;
  for (i = 0; i < list.length; ++i) {
    let buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        );
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos);
    }
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length;
  const mustMatch = (arguments.length > 2 && arguments[2] === true);
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  let loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  const i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  const length = this.length;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  let str = '';
  const max = INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>'
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  let x = thisEnd - thisStart;
  let y = end - start;
  const len = Math.min(x, y);

  const thisCopy = this.slice(thisStart, thisEnd);
  const targetCopy = target.slice(start, end);

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1;
  let arrLength = arr.length;
  let valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i;
  if (dir) {
    let foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      let found = true;
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  const remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  const strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  let i;
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  let loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64JsExports.fromByteArray(buf)
  } else {
    return base64JsExports.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  const res = [];

  let i = start;
  while (i < end) {
    const firstByte = buf[i];
    let codePoint = null;
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1;

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = '';
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = '';
  end = Math.min(buf.length, end);

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = '';
  end = Math.min(buf.length, end);

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  let out = '';
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end);
  let res = '';
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  const newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype);

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  let val = this[offset];
  let mul = 1;
  let i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  let val = this[offset + --byteLength];
  let mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24;

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24;

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
});

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset];

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last;

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
});

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  let val = this[offset];
  let mul = 1;
  let i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  let i = byteLength;
  let mul = 1;
  let val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  const val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  const val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
});

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  const first = this[offset];
  const last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset];

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
});

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754Exports.read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754Exports.read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754Exports.read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754Exports.read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  let mul = 1;
  let i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  let i = byteLength - 1;
  let mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value & 0xff);
  this[offset + 1] = (value >>> 8);
  return offset + 2
};

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value >>> 8);
  this[offset + 1] = (value & 0xff);
  return offset + 2
};

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = (value >>> 24);
  this[offset + 2] = (value >>> 16);
  this[offset + 1] = (value >>> 8);
  this[offset] = (value & 0xff);
  return offset + 4
};

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = (value >>> 24);
  this[offset + 1] = (value >>> 16);
  this[offset + 2] = (value >>> 8);
  this[offset + 3] = (value & 0xff);
  return offset + 4
};

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);

  let lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);

  let lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
});

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
});

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  let i = 0;
  let mul = 1;
  let sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  let i = byteLength - 1;
  let mul = 1;
  let sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  this[offset] = (value & 0xff);
  this[offset + 1] = (value >>> 8);
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
  this[offset] = (value >>> 8);
  this[offset + 1] = (value & 0xff);
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  this[offset] = (value & 0xff);
  this[offset + 1] = (value >>> 8);
  this[offset + 2] = (value >>> 16);
  this[offset + 3] = (value >>> 24);
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = (value >>> 24);
  this[offset + 1] = (value >>> 16);
  this[offset + 2] = (value >>> 8);
  this[offset + 3] = (value & 0xff);
  return offset + 4
};

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
});

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
});

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  ieee754Exports.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  ieee754Exports.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  const len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0);
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  let i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding);
    const len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors$3 = {};
function E (sym, getMessage, Base) {
  errors$3[sym] = class NodeError extends Base {
    constructor () {
      super();

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      });

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`;
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name;
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  };
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError);
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError);
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg
  }, RangeError);

function addNumericalSeparator (val) {
  let res = '';
  let i = val.length;
  const start = val[0] === '-' ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`;
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset');
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : '';
    let range;
    {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`;
      }
    }
    throw new errors$3.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength);
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors$3.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors$3.ERR_OUT_OF_RANGE('offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors$3.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors$3.ERR_OUT_OF_RANGE('offset',
                                    `>= ${0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  let codePoint;
  const length = string.length;
  let leadSurrogate = null;
  const bytes = [];

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo;
  const byteArray = [];
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64JsExports.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i;
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef';
  const table = new Array(256);
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16;
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }
  return table
})();

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}

var buffer$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Buffer: Buffer,
	INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
	SlowBuffer: SlowBuffer,
	kMaxLength: kMaxLength
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(buffer$1);

var hasRequiredBuffer$1;

function requireBuffer$1 () {
	if (hasRequiredBuffer$1) return buffer$2;
	hasRequiredBuffer$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.bufferFrom = exports.bufferAllocUnsafe = exports.Buffer = void 0;
		const buffer_1 = require$$0$2;
		Object.defineProperty(exports, "Buffer", { enumerable: true, get: function () { return buffer_1.Buffer; } });
		function bufferV0P12Ponyfill(arg0, ...args) {
		    return new buffer_1.Buffer(arg0, ...args);
		}
		const bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
		exports.bufferAllocUnsafe = bufferAllocUnsafe;
		const bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
		exports.bufferFrom = bufferFrom;
		
	} (buffer$2));
	return buffer$2;
}

var errors$2 = {};

var assert$1 = {exports: {}};

var hasRequiredAssert;

function requireAssert () {
	if (hasRequiredAssert) return assert$1.exports;
	hasRequiredAssert = 1;
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message || 'Assertion failed')
	  }
	}

	assert$1.exports = assert;

	assert$1.exports.strictEqual = function strictEqual(a, b) {
	  if (a !== b) {
	    throw new Error(`Expected ${a} to strict equal ${b}`)
	  }
	};
	return assert$1.exports;
}

var browser$2 = {exports: {}};

var hasRequiredBrowser$2;

function requireBrowser$2 () {
	if (hasRequiredBrowser$2) return browser$2.exports;
	hasRequiredBrowser$2 = 1;
	// shim for using process in browser
	var process = browser$2.exports = {};

	// cached from whatever undefined is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ());
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the undefined object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the undefined object for 'this', hopfully our context correct otherwise it will throw a undefined error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the undefined object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the undefined object for 'this', hopfully our context correct otherwise it will throw a undefined error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] };

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };
	return browser$2.exports;
}

var browserExports = requireBrowser$2();
var process$1 = /*@__PURE__*/getDefaultExportFromCjs$1(browserExports);

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var primordials$1 = {exports: {}};

// back-patch in primordials in user-land

const createSafeIterator = (factory, next) => {
  class SafeIterator {
    constructor(iterable) {
      this._iterator = factory(iterable);
    }
    next() {
      return next(this._iterator);
    }
    [Symbol.iterator]() {
      return this;
    }
  }
  Object.setPrototypeOf(SafeIterator.prototype, null);
  Object.freeze(SafeIterator.prototype);
  Object.freeze(SafeIterator);
  return SafeIterator;
};

function getGetter(cls, getter) {
  // TODO: __lookupGetter__ is deprecated, but Object.getOwnPropertyDescriptor
  // doesn't work on built-ins like Typed Arrays.
  return Function.prototype.call.bind(cls.prototype.__lookupGetter__(getter));
}

function getterCaller(getter) {
  return (val) => {
    return val.constructor.prototype.__lookupGetter__(getter).call(val);
  };
}

function uncurryThis(func) {
  return Function.prototype.call.bind(func);
}

const copyProps = (src, dest) => {
  Array.prototype.forEach.call(Reflect.ownKeys(src), (key) => {
    if (!Reflect.getOwnPropertyDescriptor(dest, key)) {
      Reflect.defineProperty(
        dest,
        key,
        Reflect.getOwnPropertyDescriptor(src, key));
    }
  });
};

const makeSafe = (unsafe, safe) => {
  if (Symbol.iterator in unsafe.prototype) {
    const dummy = new unsafe();
    let next; // We can reuse the same `next` method.

    Array.prototype.forEach.call(Reflect.ownKeys(unsafe.prototype), (key) => {
      if (!Reflect.getOwnPropertyDescriptor(safe.prototype, key)) {
        const desc = Reflect.getOwnPropertyDescriptor(unsafe.prototype, key);
        if (typeof desc.value === 'function' && desc.value.length === 0) {
            const called = Function.prototype.call.call(desc.value, dummy) || {};
            if (Symbol.iterator in (typeof called === "object" ? called : {})) {
                const createIterator = uncurryThis(desc.value);
                if (next == null) {
                    next = uncurryThis(createIterator(dummy).next);
                }
                const SafeIterator = createSafeIterator(createIterator, next);
                desc.value = function() {
                    return new SafeIterator(this);
                };
            }
        }
        Reflect.defineProperty(safe.prototype, key, desc);
      }
    });
  } else {
    copyProps(unsafe.prototype, safe.prototype);
  }
  copyProps(unsafe, safe);

  Object.setPrototypeOf(safe.prototype, null);
  Object.freeze(safe.prototype);
  Object.freeze(safe);
  return safe;
};

const StringIterator =
  Function.prototype.call.bind(String.prototype[Symbol.iterator]);
const StringIteratorPrototype = Reflect.getPrototypeOf(StringIterator(''));

function ErrorCaptureStackTrace(targetObject) {
  const stack = new Error().stack;
  // Remove the second line, which is this function
  targetObject.stack = stack.replace(/.*\n.*/, '$1');
}

primordials$1.exports = {
  makeSafe, // exported for testing
  internalBinding(mod) {
    if (mod === 'config') {
      return {
        hasIntl: false,
      };
    }
    throw new Error(`unknown module: "${mod}"`);
  },
  Array,
  ArrayIsArray: Array.isArray,
  ArrayPrototypeFilter: Function.prototype.call.bind(Array.prototype.filter),
  ArrayPrototypeForEach: Function.prototype.call.bind(Array.prototype.forEach),
  ArrayPrototypeIncludes:
    Function.prototype.call.bind(Array.prototype.includes),
  ArrayPrototypeIndexOf: Function.prototype.call.bind(Array.prototype.indexOf),
  ArrayPrototypeJoin: Function.prototype.call.bind(Array.prototype.join),
  ArrayPrototypeMap: Function.prototype.call.bind(Array.prototype.map),
  ArrayPrototypePop: Function.prototype.call.bind(Array.prototype.pop),
  ArrayPrototypePush: Function.prototype.call.bind(Array.prototype.push),
  ArrayPrototypePushApply: Function.apply.bind(Array.prototype.push),
  ArrayPrototypeSlice: Function.prototype.call.bind(Array.prototype.slice),
  ArrayPrototypeSort: Function.prototype.call.bind(Array.prototype.sort),
  ArrayPrototypeSplice: Function.prototype.call.bind(Array.prototype.splice),
  ArrayPrototypeUnshift: Function.prototype.call.bind(Array.prototype.unshift),
  BigIntPrototypeValueOf:
    Function.prototype.call.bind(BigInt.prototype.valueOf),
  BooleanPrototypeValueOf:
    Function.prototype.call.bind(Boolean.prototype.valueOf),
  DatePrototypeGetTime: Function.prototype.call.bind(Date.prototype.getTime),
  DatePrototypeToISOString:
    Function.prototype.call.bind(Date.prototype.toISOString),
  DatePrototypeToString:
    Function.prototype.call.bind(Date.prototype.toString),
  ErrorCaptureStackTrace,
  ErrorPrototypeToString:
    Function.prototype.call.bind(Error.prototype.toString),
  FunctionPrototypeBind: Function.prototype.call.bind(Function.prototype.bind),
  FunctionPrototypeCall:
    Function.prototype.call.bind(Function.prototype.call),
  FunctionPrototypeToString:
    Function.prototype.call.bind(Function.prototype.toString),
  globalThis: (typeof globalThis === 'undefined') ? commonjsGlobal : globalThis,
  JSONStringify: JSON.stringify,
  MapPrototypeGetSize: getGetter(Map, 'size'),
  MapPrototypeEntries: Function.prototype.call.bind(Map.prototype.entries),
  MathFloor: Math.floor,
  MathMax: Math.max,
  MathMin: Math.min,
  MathRound: Math.round,
  MathSqrt: Math.sqrt,
  MathTrunc: Math.trunc,
  Number,
  NumberIsFinite: Number.isFinite,
  NumberIsNaN: Number.isNaN,
  NumberParseFloat: Number.parseFloat,
  NumberParseInt: Number.parseInt,
  NumberPrototypeToString: Function.prototype.call.bind(Number.prototype.toString),
  NumberPrototypeValueOf:
    Function.prototype.call.bind(Number.prototype.valueOf),
  Object,
  ObjectAssign: Object.assign,
  ObjectCreate: Object.create,
  ObjectDefineProperty: Object.defineProperty,
  ObjectGetOwnPropertyDescriptor: Object.getOwnPropertyDescriptor,
  ObjectGetOwnPropertyNames: Object.getOwnPropertyNames,
  ObjectGetOwnPropertySymbols: Object.getOwnPropertySymbols,
  ObjectGetPrototypeOf: Object.getPrototypeOf,
  ObjectIs: Object.is,
  ObjectKeys: Object.keys,
  ObjectPrototypeHasOwnProperty:
    Function.prototype.call.bind(Object.prototype.hasOwnProperty),
  ObjectPrototypePropertyIsEnumerable:
    Function.prototype.call.bind(Object.prototype.propertyIsEnumerable),
  ObjectSeal: Object.seal,
  ObjectSetPrototypeOf: Object.setPrototypeOf,
  ReflectApply: Reflect.apply,
  ReflectOwnKeys: Reflect.ownKeys,
  RegExp,
  RegExpPrototypeExec: Function.prototype.call.bind(RegExp.prototype.exec),
  RegExpPrototypeSymbolReplace: Function.prototype.call.bind(RegExp.prototype[Symbol.replace]),
  RegExpPrototypeSymbolSplit: Function.prototype.call.bind(RegExp.prototype[Symbol.split]),
  RegExpPrototypeTest: Function.prototype.call.bind(RegExp.prototype.test),
  RegExpPrototypeToString:
    Function.prototype.call.bind(RegExp.prototype.toString),
  SafeStringIterator: createSafeIterator(
    StringIterator,
    Function.prototype.call.bind(StringIteratorPrototype.next),
  ),
  SafeMap: makeSafe(
    Map,
    class SafeMap extends Map {
      constructor(i) { super(i); } // eslint-disable-line no-useless-constructor
    }),
  SafeSet: makeSafe(
    Set,
    class SafeSet extends Set {
      constructor(i) { super(i); } // eslint-disable-line no-useless-constructor
    }),
  SetPrototypeGetSize: getGetter(Set, 'size'),
  SetPrototypeValues: Function.prototype.call.bind(Set.prototype.values),
  String,
  StringPrototypeCharCodeAt:
    Function.prototype.call.bind(String.prototype.charCodeAt),
  StringPrototypeCodePointAt:
    Function.prototype.call.bind(String.prototype.codePointAt),
  StringPrototypeEndsWith:
    Function.prototype.call.bind(String.prototype.endsWith),
  StringPrototypeIncludes:
    Function.prototype.call.bind(String.prototype.includes),
  StringPrototypeIndexOf:
    Function.prototype.call.bind(String.prototype.indexOf),
  StringPrototypeLastIndexOf:
    Function.prototype.call.bind(String.prototype.lastIndexOf),
  StringPrototypeNormalize:
    Function.prototype.call.bind(String.prototype.normalize),
  StringPrototypePadEnd:
    Function.prototype.call.bind(String.prototype.padEnd),
  StringPrototypePadStart:
    Function.prototype.call.bind(String.prototype.padStart),
  StringPrototypeRepeat: Function.prototype.call.bind(String.prototype.repeat),
  StringPrototypeReplace:
    Function.prototype.call.bind(String.prototype.replace),
  StringPrototypeReplaceAll:
    Function.prototype.call.bind(String.prototype.replaceAll),
  StringPrototypeSlice: Function.prototype.call.bind(String.prototype.slice),
  StringPrototypeSplit: Function.prototype.call.bind(String.prototype.split),
  StringPrototypeStartsWith: Function.prototype.call.bind(String.prototype.startsWith),
  StringPrototypeToLowerCase:
    Function.prototype.call.bind(String.prototype.toLowerCase),
  StringPrototypeTrim: Function.prototype.call.bind(String.prototype.trim),
  StringPrototypeValueOf:
    Function.prototype.call.bind(String.prototype.valueOf),
  SymbolPrototypeToString:
    Function.prototype.call.bind(Symbol.prototype.toString),
  SymbolPrototypeValueOf:
    Function.prototype.call.bind(Symbol.prototype.valueOf),
  SymbolIterator: Symbol.iterator,
  SymbolFor: Symbol.for,
  SymbolToStringTag: Symbol.toStringTag,
  TypedArrayPrototypeGetLength: getterCaller('length'),
  Uint8Array,
  uncurryThis,
};

// Node 14
/* c8 ignore start */
if (!String.prototype.replaceAll) {
  // Lifted and simplified from core-js for the moment.  Will remove when we
  // drop node 14 support.

  function requireObjectCoercible(it) {
    if (it == null) throw new TypeError("Can't call method on " + it);
    return it;
  }

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    const tailPos = position + matched.length;
    const m = captures.length;
    let symbols = /\$([$&'`]|\d{1,2})/;
    return replacement.replace(symbols, (match, ch) => {
      let capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: { // \d\d?
          const n = +ch;
          if (n === 0) return match;
          if (n > m) {
            const f = Math.floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
        }
      }
      return capture === undefined ? '' : capture;
    });
  }

  primordials$1.exports.StringPrototypeReplaceAll = (str, searchValue, replaceValue) => {
    const O = requireObjectCoercible(str);
    let IS_REG_EXP, flags, replacer, replacement;
    let position = 0;
    let endOfLastMatch = 0;
    let result = '';
    if (searchValue != null) {
      IS_REG_EXP = searchValue instanceof RegExp;
      if (IS_REG_EXP) {
        flags = searchValue.flags;
        if (!~flags.indexOf('g')) {
          throw new TypeError('`.replaceAll` does not allow non-undefined regexes');
        }
      }
      replacer = searchValue[Symbol.replace];
      if (replacer) {
        return replacer.call(searchValue, O, replaceValue);
      }
    }
    const string = String(O);
    const searchString = String(searchValue);
    const functionalReplace = (typeof replaceValue === 'function');
    if (!functionalReplace) replaceValue = String(replaceValue);
    const searchLength = searchString.length;
    const advanceBy = Math.max(1, searchLength);
    position = string.indexOf(searchString, 0);
    while (position !== -1) {
      replacement = functionalReplace ?
        String(replaceValue(searchString, position, string)) :
        getSubstitution(searchString, string, position, [], undefined, replaceValue);
      result += string.slice(endOfLastMatch, position) + replacement;
      endOfLastMatch = position + searchLength;
      position = string.indexOf(searchString, position + advanceBy);
    }
    if (endOfLastMatch < string.length) {
      result += string.slice(endOfLastMatch);
    }
    return result;
  };
}
/* c8 ignore stop */

var primordialsExports = primordials$1.exports;

const ALL_PROXIES = new WeakMap();

// Wrap Proxy's to remember their details.
class Prxy {
  constructor(target, handler) {
    const p = new Proxy(target, handler);
    ALL_PROXIES.set(p, [target, handler]);
    // eslint-disable-next-line no-constructor-return
    return p;
  }
  static getProxyDetails(obj, getFullProxy = true) {
    const deets = ALL_PROXIES.get(obj);
    if (!deets) {
      return undefined;
    }
    if (getFullProxy) {
      return deets;
    }
    return deets[0];
  }
  static revocable(target, handler) {
    const p = Proxy.revocable(target, handler);
    ALL_PROXIES.set(p.proxy, [target, handler]);
    const revoke = p.revoke;
    p.revoke = () => {
      ALL_PROXIES.set(p.proxy, [null, null]);
      revoke();
    };
    return p;
  }
}

var proxy = {
  getProxyDetails: Prxy.getProxyDetails.bind(Prxy),
  Proxy: Prxy,
};

const prxy = proxy;
const ALL_PROPERTIES = 0;
const ONLY_ENUMERABLE = 2;
const kPending = Symbol('kPending');
const kRejected = Symbol('kRejected');

function getOwnNonIndexProperties(a, filter = ONLY_ENUMERABLE) {
  const desc = Object.getOwnPropertyDescriptors(a);
  const ret = [];
  for (const [k, v] of Object.entries(desc)) {
    if (!/^(0|[1-9][0-9]*)$/.test(k) ||
        (parseInt(k, 10) >= (2 ** 32 - 1))) { // Arrays are limited in size
      if ((filter === ONLY_ENUMERABLE) && !v.enumerable) {
        continue;
      }
      ret.push(k);
    }
  }
  for (const s of Object.getOwnPropertySymbols(a)) {
    const v = Object.getOwnPropertyDescriptor(a, s);
    if ((filter === ONLY_ENUMERABLE) && !v.enumerable) {
      continue;
    }
    ret.push(s);
  }
  return ret;
}

var util$1$1 = {
  constants: {
    kPending,
    kRejected,
    ALL_PROPERTIES,
    ONLY_ENUMERABLE,
  },
  getOwnNonIndexProperties,
  getPromiseDetails() { return [kPending, undefined]; },
  getProxyDetails: prxy.getProxyDetails,
  Proxy: prxy.Proxy,
  previewEntries(val) {
    return [[], false];
  },
  getConstructorName(val) {
    if (!val || typeof val !== 'object') {
      throw new Error('Invalid object');
    }
    if (val.constructor && val.constructor.name) {
      return val.constructor.name;
    }
    const str = Object.prototype.toString.call(val);
    // e.g. [object Boolean]
    const m = str.match(/^\[object ([^\]]+)\]/);
    if (m) {
      return m[1];
    }
    return 'Object';
  },
  getExternalValue() { return BigInt(0); },
};

// eslint-disable-next-line no-control-regex
const colorRegExp = /\u001b\[\d\d?m/g;

var util$4 = {
  customInspectSymbol: Symbol.for('nodejs.util.inspect.custom'),
  isError(e) {
    return e instanceof Error;
  },
  join: Array.prototype.join.call.bind(Array.prototype.join),
  removeColors(str) {
    return String.prototype.replace.call(str, colorRegExp, '');
  },
};

function assert(p) {
  if (!p) {
    throw new Error('Assertion failed');
  }
}

assert.fail = function fail(message) {
  throw new Error(message);
};

var assert_1 = assert;

/* eslint node-core/documented-errors: "error" */

var errors$1;
var hasRequiredErrors$2;

function requireErrors$2 () {
	if (hasRequiredErrors$2) return errors$1;
	hasRequiredErrors$2 = 1;

	// The whole point behind this internal module is to allow Node.js to no
	// longer be forced to treat every error message change as a semver-major
	// change. The NodeError classes here all expose a `code` property whose
	// value statically and permanently identifies the error. While the error
	// message may change, the code should not.

	const {
	  ArrayIsArray,
	  ArrayPrototypeIncludes,
	  ArrayPrototypeIndexOf,
	  ArrayPrototypeJoin,
	  ArrayPrototypePop,
	  ArrayPrototypePush,
	  ArrayPrototypeSplice,
	  ErrorCaptureStackTrace,
	  ObjectDefineProperty,
	  ReflectApply,
	  RegExpPrototypeTest,
	  SafeMap,
	  StringPrototypeEndsWith,
	  StringPrototypeIncludes,
	  StringPrototypeSlice,
	  StringPrototypeToLowerCase,
	} = primordialsExports;

	const messages = new SafeMap();
	const codes = {};

	const classRegExp = /^([A-Z][a-z0-9]*)+$/;
	// Sorted by a rough estimate on most frequently used entries.
	const kTypes = [
	  'string',
	  'function',
	  'number',
	  'object',
	  // Accept 'Function' and 'Object' as alternative to the lower cased version.
	  'Function',
	  'Object',
	  'boolean',
	  'bigint',
	  'symbol',
	];

	let userStackTraceLimit;
	const nodeInternalPrefix = '__node_internal_';

	// Lazily loaded
	let assert;
	let internalUtilInspect = null;
	function lazyInternalUtilInspect() {
	  if (!internalUtilInspect) {
	    internalUtilInspect = requireInspect$1();
	  }
	  return internalUtilInspect;
	}

	const addCodeToName = hideStackFrames(function addCodeToName(err, name, code) {
	  // Set the stack
	  err = captureLargerStackTrace(err);
	  // Add the error code to the name to include it in the stack trace.
	  err.name = `${name} [${code}]`;
	  // Access the stack to generate the error message including the error code
	  // from the name.
	  err.stack; // eslint-disable-line no-unused-expressions
	  // Reset the name to the actual name.
	  delete err.name;
	});

	function makeNodeErrorWithCode(Base, key) {
	  return function NodeError(...args) {
	    const limit = Error.stackTraceLimit;
	    Error.stackTraceLimit = 0;
	    const error = new Base();
	    // Reset the limit and setting the name property.
	    Error.stackTraceLimit = limit;
	    const message = getMessage(key, args, error);
	    ObjectDefineProperty(error, 'message', {
	      value: message,
	      enumerable: false,
	      writable: true,
	      configurable: true,
	    });
	    ObjectDefineProperty(error, 'toString', {
	      value() {
	        return `${this.name} [${key}]: ${this.message}`;
	      },
	      enumerable: false,
	      writable: true,
	      configurable: true,
	    });
	    addCodeToName(error, Base.name, key);
	    error.code = key;
	    return error;
	  };
	}

	// This function removes unnecessary frames from Node.js core errors.
	function hideStackFrames(fn) {
	  // We rename the functions that will be hidden to cut off the stacktrace
	  // at the outermost one
	  const hidden = nodeInternalPrefix + fn.name;
	  ObjectDefineProperty(fn, 'name', { value: hidden });
	  return fn;
	}

	// Utility function for registering the error codes. Only used here. Exported
	// *only* to allow for testing.
	function E(sym, val, def) {
	  // Special case for SystemError that formats the error message differently
	  // The SystemErrors only have SystemError as their base classes.
	  messages.set(sym, val);
	  codes[sym] = makeNodeErrorWithCode(def, sym);
	}

	function getMessage(key, args, self) {
	  const msg = messages.get(key);

	  if (assert === undefined) assert = assert_1;

	  assert(typeof msg === 'function');
	  assert(
	    msg.length <= args.length, // Default options do not count.
	    `Code: ${key}; The provided arguments length (${args.length}) does not ` +
	      `match the required ones (${msg.length}).`,
	  );
	  return ReflectApply(msg, self, args);
	}

	const captureLargerStackTrace = hideStackFrames(
	  function captureLargerStackTrace(err) {
	    userStackTraceLimit = Error.stackTraceLimit;
	    Error.stackTraceLimit = Infinity;
	    ErrorCaptureStackTrace(err);
	    // Reset the limit
	    Error.stackTraceLimit = userStackTraceLimit;

	    return err;
	  });

	let maxStack_ErrorName;
	let maxStack_ErrorMessage;
	/**
	 * Returns true if `err.name` and `err.message` are equal to engine-specific
	 * values indicating max call stack size has been exceeded.
	 * "Maximum call stack size exceeded" in V8.
	 * @param {Error} err
	 * @returns {boolean}
	 */
	function isStackOverflowError(err) {
	  if (maxStack_ErrorMessage === undefined) {
	    try {
	      function overflowStack() { overflowStack(); }
	      overflowStack();
	    } catch (err) {
	      maxStack_ErrorMessage = err.message;
	      maxStack_ErrorName = err.name;
	    }
	  }

	  return err && err.name === maxStack_ErrorName &&
	         err.message === maxStack_ErrorMessage;
	}

	errors$1 = {
	  codes,
	  hideStackFrames,
	  isStackOverflowError,
	};

	E('ERR_INVALID_ARG_TYPE',
	  (name, expected, actual) => {
	    assert(typeof name === 'string', "'name' must be a string");
	    if (!ArrayIsArray(expected)) {
	      expected = [expected];
	    }

	    let msg = 'The ';
	    if (StringPrototypeEndsWith(name, ' argument')) {
	      // For cases like 'first argument'
	      msg += `${name} `;
	    } else {
	      const type = StringPrototypeIncludes(name, '.') ? 'property' : 'argument';
	      msg += `"${name}" ${type} `;
	    }
	    msg += 'must be ';

	    const types = [];
	    const instances = [];
	    const other = [];

	    for (const value of expected) {
	      assert(typeof value === 'string',
	             'All expected entries have to be of type string');
	      if (ArrayPrototypeIncludes(kTypes, value)) {
	        ArrayPrototypePush(types, StringPrototypeToLowerCase(value));
	      } else if (RegExpPrototypeTest(classRegExp, value)) {
	        ArrayPrototypePush(instances, value);
	      } else {
	        assert(value !== 'object',
	               'The value "object" should be written as "Object"');
	        ArrayPrototypePush(other, value);
	      }
	    }

	    // Special handle `object` in case other instances are allowed to outline
	    // the differences between each other.
	    if (instances.length > 0) {
	      const pos = ArrayPrototypeIndexOf(types, 'object');
	      if (pos !== -1) {
	        ArrayPrototypeSplice(types, pos, 1);
	        ArrayPrototypePush(instances, 'Object');
	      }
	    }

	    if (types.length > 0) {
	      if (types.length > 2) {
	        const last = ArrayPrototypePop(types);
	        msg += `one of type ${ArrayPrototypeJoin(types, ', ')}, or ${last}`;
	      } else if (types.length === 2) {
	        msg += `one of type ${types[0]} or ${types[1]}`;
	      } else {
	        msg += `of type ${types[0]}`;
	      }
	      if (instances.length > 0 || other.length > 0)
	        msg += ' or ';
	    }

	    if (instances.length > 0) {
	      if (instances.length > 2) {
	        const last = ArrayPrototypePop(instances);
	        msg +=
	          `an instance of ${ArrayPrototypeJoin(instances, ', ')}, or ${last}`;
	      } else {
	        msg += `an instance of ${instances[0]}`;
	        if (instances.length === 2) {
	          msg += ` or ${instances[1]}`;
	        }
	      }
	      if (other.length > 0)
	        msg += ' or ';
	    }

	    if (other.length > 0) {
	      if (other.length > 2) {
	        const last = ArrayPrototypePop(other);
	        msg += `one of ${ArrayPrototypeJoin(other, ', ')}, or ${last}`;
	      } else if (other.length === 2) {
	        msg += `one of ${other[0]} or ${other[1]}`;
	      } else {
	        if (StringPrototypeToLowerCase(other[0]) !== other[0])
	          msg += 'an ';
	        msg += `${other[0]}`;
	      }
	    }

	    if (actual == null) {
	      msg += `. Received ${actual}`;
	    } else if (typeof actual === 'function' && actual.name) {
	      msg += `. Received function ${actual.name}`;
	    } else if (typeof actual === 'object') {
	      if (actual.constructor && actual.constructor.name) {
	        msg += `. Received an instance of ${actual.constructor.name}`;
	      } else {
	        const inspected = lazyInternalUtilInspect()
	          .inspect(actual, { depth: -1 });
	        msg += `. Received ${inspected}`;
	      }
	    } else {
	      let inspected = lazyInternalUtilInspect()
	        .inspect(actual, { colors: false });
	      if (inspected.length > 25)
	        inspected = `${StringPrototypeSlice(inspected, 0, 25)}...`;
	      msg += `. Received type ${typeof actual} (${inspected})`;
	    }
	    return msg;
	  }, TypeError);
	return errors$1;
}

const { getConstructorName } = util$1$1;

// From https://mathiasbynens.be/notes/globalthis
/* c8 ignore start */ // only needed for node 10
(function() {
  if (typeof globalThis === 'object') return;
  Object.defineProperty(Object.prototype, '__magic__', {
    get: function() {
      return this;
    },
    configurable: true,
  });
  // eslint-disable-next-line no-undef
  __magic__.globalThis = __magic__;
  delete Object.prototype.__magic__;
}());
/* c8 ignore stop */

function constructorNamed(val, ...name) {
  // Pass in names rather than types, in case SharedArrayBuffer (e.g.) isn't
  // in your browser
  for (const n of name) {
    const typ = globalThis[n];
    if (typ) {
      if (val instanceof typ) {
        return true;
      }
    }
  }
  // instanceOf doesn't work across vm boundaries, so check the whole
  // inheritance chain
  while (val) {
    if (typeof val !== 'object') {
      return false;
    }
    if (name.indexOf(getConstructorName(val)) >= 0) {
      return true;
    }
    val = Object.getPrototypeOf(val);
  }
  return false;
}

function checkBox(cls) {
  return (val) => {
    if (!constructorNamed(val, cls.name)) {
      return false;
    }
    try {
      cls.prototype.valueOf.call(val);
    } catch {
      return false;
    }
    return true;
  };
}

const isStringObject = checkBox(String);
const isNumberObject = checkBox(Number);
const isBooleanObject = checkBox(Boolean);
const isBigIntObject = checkBox(BigInt);
const isSymbolObject = checkBox(Symbol);

var types = {
  isAsyncFunction(val) {
    return (typeof val === 'function') &&
      Function.prototype.toString.call(val).startsWith('async');
  },
  isGeneratorFunction(val) {
    return (typeof val === 'function') &&
      Function.prototype.toString.call(val).match(/^(async\s+)?function *\*/);
  },
  isAnyArrayBuffer(val) {
    return constructorNamed(val, 'ArrayBuffer', 'SharedArrayBuffer');
  },
  isArrayBuffer(val) {
    return constructorNamed(val, 'ArrayBuffer');
  },
  isArgumentsObject(val) {
    const cond = (val !== null) &&
      (typeof val === 'object') &&
      !Array.isArray(val) &&
      (typeof val.length === 'number') &&
      (val.length === (val.length | 0)) &&
      (val.length >= 0);
    if (cond) {
      const prop = Object.getOwnPropertyDescriptor(val, 'callee');
      return prop && !prop.enumerable;
    }
    return false;
  },
  isBoxedPrimitive(val) {
    return isNumberObject(val) ||
      isStringObject(val) ||
      isBooleanObject(val) ||
      isBigIntObject(val) ||
      isSymbolObject(val);
  },
  isDataView(val) {
    return constructorNamed(val, 'DataView');
  },
  isExternal(val) {
    return (typeof val === 'object') &&
      (Object.isFrozen(val)) &&
      (Object.getPrototypeOf(val) == null);
  },
  isMap(val) {
    if (!constructorNamed(val, 'Map')) {
      return false;
    }
    try {
      val.has();
    } catch {
      return false;
    }
    return true;
  },
  isMapIterator(val) {
    return Object.prototype.toString.call(Object.getPrototypeOf(val)) ===
      '[object Map Iterator]';
  },
  isModuleNamespaceObject(val) {
    // TODO: this is weak and easily faked
    return val &&
      (typeof val === 'object') &&
      (val[Symbol.toStringTag] === 'Module');
  },
  isNativeError(val) {
    return (val instanceof Error) && constructorNamed(
      val,
      'Error',
      'EvalError',
      'RangeError',
      'ReferenceError',
      'SyntaxError',
      'TypeError',
      'URIError',
      'AggregateError');
  },
  isPromise(val) {
    return constructorNamed(val, 'Promise');
  },
  isSet(val) {
    if (!constructorNamed(val, 'Set')) {
      return false;
    }
    try {
      val.has();
    } catch {
      return false;
    }
    return true;
  },
  isSetIterator(val) {
    return Object.prototype.toString.call(Object.getPrototypeOf(val)) ===
      '[object Set Iterator]';
  },
  isWeakMap(val) {
    return constructorNamed(val, 'WeakMap');
  },
  isWeakSet(val) {
    return constructorNamed(val, 'WeakSet');
  },
  isRegExp(val) {
    return constructorNamed(val, 'RegExp');
  },
  isDate(val) {
    if (constructorNamed(val, 'Date')) {
      try {
        Date.prototype.getTime.call(val); // Throws for pseudo-dates
        return true;
      } catch {
        // Ignored
      }
    }
    return false;
  },
  isTypedArray(val) {
    return constructorNamed(
      val,
      'Int8Array',
      'Uint8Array',
      'Uint8ClampedArray',
      'Int16Array',
      'Uint16Array',
      'Int32Array',
      'Uint32Array',
      'Float32Array',
      'Float64Array',
      'BigInt64Array',
      'BigUint64Array',
    );
  },
  isStringObject,
  isNumberObject,
  isBooleanObject,
  isBigIntObject};

var realm = {};

// This is a snapshot from node 18.11.0
const builtinModules = [
  '_http_agent',
  '_http_client',
  '_http_common',
  '_http_incoming',
  '_http_outgoing',
  '_http_server',
  '_stream_duplex',
  '_stream_passthrough',
  '_stream_readable',
  '_stream_transform',
  '_stream_wrap',
  '_stream_writable',
  '_tls_common',
  '_tls_wrap',
  'assert',
  'assert/strict',
  'async_hooks',
  'buffer',
  'child_process',
  'cluster',
  'console',
  'constants',
  'crypto',
  'dgram',
  'diagnostics_channel',
  'dns',
  'dns/promises',
  'domain',
  'events',
  'fs',
  'fs/promises',
  'http',
  'http2',
  'https',
  'inspector',
  'module',
  'Module',
  'net',
  'os',
  'path',
  'path/posix',
  'path/win32',
  'perf_hooks',
  'process',
  'punycode',
  'querystring',
  'readline',
  'readline/promises',
  'repl',
  'stream',
  'stream/consumers',
  'stream/promises',
  'stream/web',
  'string_decoder',
  'sys',
  'timers',
  'timers/promises',
  'tls',
  'trace_events',
  'tty',
  'url',
  'util',
  'util/types',
  'v8',
  'vm',
  'wasi',
  'worker_threads',
  'zlib',
];

realm.BuiltinModule = {
  exists(s) {
    return s.startsWith('internal/') || builtinModules.indexOf(s) !== -1;
  },
};

var validators$1;
var hasRequiredValidators$1;

function requireValidators$1 () {
	if (hasRequiredValidators$1) return validators$1;
	hasRequiredValidators$1 = 1;

	const {
	  ArrayIsArray,
	} = primordialsExports;

	const {
	  hideStackFrames,
	  codes: {
	    ERR_INVALID_ARG_TYPE,
	  },
	} = requireErrors$2();

	/**
	 * @param {unknown} value
	 * @param {string} name
	 * @param {{
	 *   allowArray?: boolean,
	 *   allowFunction?: boolean,
	 *   nullable?: boolean
	 * }} [options]
	 */
	const validateObject = hideStackFrames(
	  (value, name, options) => {
	    const useDefaultOptions = options == null;
	    const allowArray = useDefaultOptions ? false : options.allowArray;
	    const allowFunction = useDefaultOptions ? false : options.allowFunction;
	    const nullable = useDefaultOptions ? false : options.nullable;
	    if ((!nullable && value === null) ||
	        (!allowArray && ArrayIsArray(value)) ||
	        (typeof value !== 'object' && (
	          !allowFunction || typeof value !== 'function'
	        ))) {
	      throw new ERR_INVALID_ARG_TYPE(name, 'Object', value);
	    }
	  });

	function validateString(value, name) {
	  if (typeof value !== 'string')
	    throw new ERR_INVALID_ARG_TYPE(name, 'string', value);
	}

	validators$1 = {
	  validateObject,
	  validateString,
	};
	return validators$1;
}

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;

	constants$1 = {
	  // Non-alphabetic chars.
	  CHAR_DOT: 46, /* . */
	  CHAR_FORWARD_SLASH: 47, /* / */
	  CHAR_BACKWARD_SLASH: 92, /* \ */
	};
	return constants$1;
}

var path;
var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;

	const {
	  StringPrototypeCharCodeAt,
	  StringPrototypeLastIndexOf,
	  StringPrototypeSlice,
	} = primordialsExports;

	const {
	  CHAR_DOT,
	  CHAR_FORWARD_SLASH,
	} = requireConstants$1();
	const {
	  validateString,
	} = requireValidators$1();

	function posixCwd() {
	  return '/'; // Fake for the web case
	}

	function isPosixPathSeparator(code) {
	  return code === CHAR_FORWARD_SLASH;
	}

	// Resolves . and .. elements in a path with directory names
	function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
	  let res = '';
	  let lastSegmentLength = 0;
	  let lastSlash = -1;
	  let dots = 0;
	  let code = 0;
	  for (let i = 0; i <= path.length; ++i) {
	    if (i < path.length)
	      code = StringPrototypeCharCodeAt(path, i);
	    else if (isPathSeparator(code))
	      break;
	    else
	      code = CHAR_FORWARD_SLASH;

	    if (isPathSeparator(code)) {
	      if (lastSlash === i - 1 || dots === 1) ; else if (dots === 2) {
	        if (res.length < 2 || lastSegmentLength !== 2 ||
	            StringPrototypeCharCodeAt(res, res.length - 1) !== CHAR_DOT ||
	            StringPrototypeCharCodeAt(res, res.length - 2) !== CHAR_DOT) {
	          if (res.length > 2) {
	            const lastSlashIndex = StringPrototypeLastIndexOf(res, separator);
	            if (lastSlashIndex === -1) {
	              res = '';
	              lastSegmentLength = 0;
	            } else {
	              res = StringPrototypeSlice(res, 0, lastSlashIndex);
	              lastSegmentLength =
	                res.length - 1 - StringPrototypeLastIndexOf(res, separator);
	            }
	            lastSlash = i;
	            dots = 0;
	            continue;
	          } else if (res.length !== 0) {
	            res = '';
	            lastSegmentLength = 0;
	            lastSlash = i;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          res += res.length > 0 ? `${separator}..` : '..';
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (res.length > 0)
	          res += `${separator}${StringPrototypeSlice(path, lastSlash + 1, i)}`;
	        else
	          res = StringPrototypeSlice(path, lastSlash + 1, i);
	        lastSegmentLength = i - lastSlash - 1;
	      }
	      lastSlash = i;
	      dots = 0;
	    } else if (code === CHAR_DOT && dots !== -1) {
	      ++dots;
	    } else {
	      dots = -1;
	    }
	  }
	  return res;
	}

	function resolve(...args) {
	  let resolvedPath = '';
	  let resolvedAbsolute = false;

	  for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    const path = i >= 0 ? args[i] : posixCwd();

	    validateString(path, 'path');

	    // Skip empty entries
	    if (path.length === 0) {
	      continue;
	    }

	    resolvedPath = `${path}/${resolvedPath}`;
	    resolvedAbsolute =
	      StringPrototypeCharCodeAt(path, 0) === CHAR_FORWARD_SLASH;
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',
	                                 isPosixPathSeparator);

	  if (resolvedAbsolute) {
	    return `/${resolvedPath}`;
	  }
	  return resolvedPath.length > 0 ? resolvedPath : '.';
	}

	path = {
	  resolve,
	};
	return path;
}

var url$1;
var hasRequiredUrl$1;

function requireUrl$1 () {
	if (hasRequiredUrl$1) return url$1;
	hasRequiredUrl$1 = 1;

	// The main use case is browsers, and I rarely test on Windows, so all of the
	// Windows-specific stuff is removed.

	const {
	  StringPrototypeCharCodeAt,
	  StringPrototypeIncludes,
	  StringPrototypeReplace,
	} = primordialsExports;

	const {
	  CHAR_FORWARD_SLASH,
	} = requireConstants$1();
	const path = requirePath();

	const percentRegEx = /%/g;
	const backslashRegEx = /\\/g;
	const newlineRegEx = /\n/g;
	const carriageReturnRegEx = /\r/g;
	const tabRegEx = /\t/g;

	function encodePathChars(filepath) {
	  if (StringPrototypeIncludes(filepath, '%'))
	    filepath = StringPrototypeReplace(filepath, percentRegEx, '%25');
	  // In posix, backslash is a valid character in paths:
	  if (StringPrototypeIncludes(filepath, '\\'))
	    filepath = StringPrototypeReplace(filepath, backslashRegEx, '%5C');
	  if (StringPrototypeIncludes(filepath, '\n'))
	    filepath = StringPrototypeReplace(filepath, newlineRegEx, '%0A');
	  if (StringPrototypeIncludes(filepath, '\r'))
	    filepath = StringPrototypeReplace(filepath, carriageReturnRegEx, '%0D');
	  if (StringPrototypeIncludes(filepath, '\t'))
	    filepath = StringPrototypeReplace(filepath, tabRegEx, '%09');
	  return filepath;
	}

	function pathToFileURL(filepath) {
	  const outURL = new URL('file://');

	  let resolved = path.resolve(filepath);
	  // path.resolve strips trailing slashes so we must add them back
	  const filePathLast = StringPrototypeCharCodeAt(filepath,
	                                                 filepath.length - 1);
	  if ((filePathLast === CHAR_FORWARD_SLASH) &&
	      resolved[resolved.length - 1] !== path.sep)
	    resolved += '/';
	  outURL.pathname = encodePathChars(resolved);

	  return outURL;
	}

	url$1 = {
	  pathToFileURL,
	};
	return url$1;
}

var buffer = {};

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;

	class Buffer {
	  hexSlice(start = 0, end) {
	    return Array.prototype.map.call(
	      this.slice(start, end),
	      (x) => ('00' + x.toString(16)).slice(-2))
	      .join('');
	  }
	}

	buffer.Buffer = Buffer;
	return buffer;
}

var inspect_1;
var hasRequiredInspect$1;

function requireInspect$1 () {
	if (hasRequiredInspect$1) return inspect_1;
	hasRequiredInspect$1 = 1;

	const primordials = primordialsExports;
	const {
	  internalBinding,
	  Array,
	  ArrayIsArray,
	  ArrayPrototypeFilter,
	  ArrayPrototypeForEach,
	  ArrayPrototypeIncludes,
	  ArrayPrototypeIndexOf,
	  ArrayPrototypeJoin,
	  ArrayPrototypeMap,
	  ArrayPrototypePop,
	  ArrayPrototypePush,
	  ArrayPrototypePushApply,
	  ArrayPrototypeSlice,
	  ArrayPrototypeSplice,
	  ArrayPrototypeSort,
	  ArrayPrototypeUnshift,
	  BigIntPrototypeValueOf,
	  BooleanPrototypeValueOf,
	  DatePrototypeGetTime,
	  DatePrototypeToISOString,
	  DatePrototypeToString,
	  ErrorPrototypeToString,
	  FunctionPrototypeBind,
	  FunctionPrototypeCall,
	  FunctionPrototypeToString,
	  JSONStringify,
	  MapPrototypeGetSize,
	  MapPrototypeEntries,
	  MathFloor,
	  MathMax,
	  MathMin,
	  MathRound,
	  MathSqrt,
	  MathTrunc,
	  Number,
	  NumberIsFinite,
	  NumberIsNaN,
	  NumberParseFloat,
	  NumberParseInt,
	  NumberPrototypeToString,
	  NumberPrototypeValueOf,
	  Object,
	  ObjectAssign,
	  ObjectDefineProperty,
	  ObjectGetOwnPropertyDescriptor,
	  ObjectGetOwnPropertyNames,
	  ObjectGetOwnPropertySymbols,
	  ObjectGetPrototypeOf,
	  ObjectIs,
	  ObjectKeys,
	  ObjectPrototypeHasOwnProperty,
	  ObjectPrototypePropertyIsEnumerable,
	  ObjectSeal,
	  ObjectSetPrototypeOf,
	  ReflectApply,
	  ReflectOwnKeys,
	  RegExp,
	  RegExpPrototypeExec,
	  RegExpPrototypeSymbolReplace,
	  RegExpPrototypeSymbolSplit,
	  RegExpPrototypeToString,
	  SafeStringIterator,
	  SafeMap,
	  SafeSet,
	  SetPrototypeGetSize,
	  SetPrototypeValues,
	  String,
	  StringPrototypeCharCodeAt,
	  StringPrototypeCodePointAt,
	  StringPrototypeIncludes,
	  StringPrototypeIndexOf,
	  StringPrototypeLastIndexOf,
	  StringPrototypeNormalize,
	  StringPrototypePadEnd,
	  StringPrototypePadStart,
	  StringPrototypeRepeat,
	  StringPrototypeReplaceAll,
	  StringPrototypeSlice,
	  StringPrototypeSplit,
	  StringPrototypeEndsWith,
	  StringPrototypeStartsWith,
	  StringPrototypeToLowerCase,
	  StringPrototypeTrim,
	  StringPrototypeValueOf,
	  SymbolPrototypeToString,
	  SymbolPrototypeValueOf,
	  SymbolIterator,
	  SymbolToStringTag,
	  TypedArrayPrototypeGetLength,
	  TypedArrayPrototypeGetSymbolToStringTag,
	  Uint8Array,
	  globalThis,
	  uncurryThis,
	} = primordials;

	const {
	  constants: {
	    ALL_PROPERTIES,
	    ONLY_ENUMERABLE,
	    kPending,
	    kRejected,
	  },
	  getOwnNonIndexProperties,
	  getPromiseDetails,
	  getProxyDetails,
	  previewEntries,
	  getConstructorName: internalGetConstructorName,
	  getExternalValue,
	  Proxy,
	} = util$1$1;

	const {
	  customInspectSymbol,
	  isError,
	  join,
	  removeColors,
	} = util$4;

	const {
	  isStackOverflowError,
	} = requireErrors$2();

	const {
	  isAsyncFunction,
	  isGeneratorFunction,
	  isAnyArrayBuffer,
	  isArrayBuffer,
	  isArgumentsObject,
	  isBoxedPrimitive,
	  isDataView,
	  isExternal,
	  isMap,
	  isMapIterator,
	  isModuleNamespaceObject,
	  isNativeError,
	  isPromise,
	  isSet,
	  isSetIterator,
	  isWeakMap,
	  isWeakSet,
	  isRegExp,
	  isDate,
	  isTypedArray,
	  isStringObject,
	  isNumberObject,
	  isBooleanObject,
	  isBigIntObject,
	} = types;

	const assert = assert_1;

	const { BuiltinModule } = realm;
	const {
	  validateObject,
	  validateString,
	} = requireValidators$1();

	let hexSlice;
	let internalUrl;

	function pathToFileUrlHref(filepath) {
	  // Maintain node 14 compat
	  // internalUrl ??= require('./internal/url');
	  internalUrl = (internalUrl == null) ? requireUrl$1() : internalUrl;
	  return internalUrl.pathToFileURL(filepath).href;
	}

	const builtInObjects = new SafeSet(
	  ArrayPrototypeFilter(
	    ObjectGetOwnPropertyNames(globalThis),
	    (e) => RegExpPrototypeExec(/^[A-Z][a-zA-Z0-9]+$/, e) !== null,
	  ),
	);

	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
	const isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;

	// These options must stay in sync with `getUserOptions`. So if any option will
	// be added or removed, `getUserOptions` must also be updated accordingly.
	const inspectDefaultOptions = ObjectSeal({
	  showHidden: false,
	  depth: 2,
	  colors: false,
	  customInspect: true,
	  showProxy: false,
	  maxArrayLength: 100,
	  maxStringLength: 10000,
	  breakLength: 80,
	  compact: 3,
	  sorted: false,
	  getters: false,
	  numericSeparator: false,
	});

	const kObjectType = 0;
	const kArrayType = 1;
	const kArrayExtrasType = 2;

	/* eslint-disable no-control-regex */
	// Work-arounds for Safari not implementing negative look-behinds.
	// Remove all of this once Safari 16.4 is rolled out "enough".
	let strEscapeSequencesRegExp,
	  strEscapeSequencesReplacer,
	  strEscapeSequencesRegExpSingle,
	  strEscapeSequencesReplacerSingle,
	  extractedSplitNewLines;
	try {
	  // Change from regex literals to RegExp constructors to avoid unrecoverable
	  // syntax error at load time.
	  strEscapeSequencesRegExp =
	    // eslint-disable-next-line max-len
	    new RegExp('[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]');
	  strEscapeSequencesReplacer =
	    new RegExp(
	      // eslint-disable-next-line max-len
	      '[\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]',
	      'g',
	    );
	  strEscapeSequencesRegExpSingle =
	    // eslint-disable-next-line max-len
	    new RegExp('[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]');
	  strEscapeSequencesReplacerSingle =
	    // eslint-disable-next-line max-len
	    new RegExp('[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]', 'g');
	  const extractedNewLineRe = new RegExp('(?<=\\n)');
	  extractedSplitNewLines = (value) => RegExpPrototypeSymbolSplit(extractedNewLineRe, value);
	  /* c8 ignore start */
	  // CI doesn't run in an elderly runtime
	} catch {
	  // These are from a previous version of node,
	  // see commit 76372607a6743cc75eae50ca58657c9e8a654428
	  // dated 2021-12-06
	  strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
	  strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
	  strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
	  strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
	  extractedSplitNewLines = (value) => {
	    const lines = RegExpPrototypeSymbolSplit(/\n/, value);
	    const last = ArrayPrototypePop(lines);
	    const nlLines = ArrayPrototypeMap(lines, (line) => line + '\n');
	    if (last !== '') {
	      nlLines.push(last);
	    }
	    return nlLines;
	  };
	}
	/* c8 ignore stop */
	/* eslint-enable no-control-regex */

	const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
	const numberRegExp = /^(0|[1-9][0-9]*)$/;

	const coreModuleRegExp = /^ {4}at (?:[^/\\(]+ \(|)node:(.+):\d+:\d+\)?$/;
	const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;

	const classRegExp = /^(\s+[^(]*?)\s*{/;
	// eslint-disable-next-line node-core/no-unescaped-regexp-dot
	const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;

	const kMinLineLength = 16;

	// Constants to map the iterator state.
	const kWeak = 0;
	const kIterator = 1;
	const kMapEntries = 2;

	// Escaped control characters (plus the single quote and the backslash). Use
	// empty strings to fill up unused entries.
	const meta = [
	  '\\x00', '\\x01', '\\x02', '\\x03', '\\x04', '\\x05', '\\x06', '\\x07', // x07
	  '\\b', '\\t', '\\n', '\\x0B', '\\f', '\\r', '\\x0E', '\\x0F',           // x0F
	  '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16', '\\x17', // x17
	  '\\x18', '\\x19', '\\x1A', '\\x1B', '\\x1C', '\\x1D', '\\x1E', '\\x1F', // x1F
	  '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '',      // x2F
	  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x3F
	  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x4F
	  '', '', '', '', '', '', '', '', '', '', '', '', '\\\\', '', '', '',     // x5F
	  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',         // x6F
	  '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\x7F',    // x7F
	  '\\x80', '\\x81', '\\x82', '\\x83', '\\x84', '\\x85', '\\x86', '\\x87', // x87
	  '\\x88', '\\x89', '\\x8A', '\\x8B', '\\x8C', '\\x8D', '\\x8E', '\\x8F', // x8F
	  '\\x90', '\\x91', '\\x92', '\\x93', '\\x94', '\\x95', '\\x96', '\\x97', // x97
	  '\\x98', '\\x99', '\\x9A', '\\x9B', '\\x9C', '\\x9D', '\\x9E', '\\x9F', // x9F
	];

	// Regex used for ansi escape code splitting
	// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js
	// License: MIT, authors: @sindresorhus, Qix-, arjunmehta and LitoMore
	// Matches all ansi escape code sequences in a string
	const ansiPattern = '[\\u001B\\u009B][[\\]()#;?]*' +
	  '(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*' +
	  '|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)' +
	  '|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))';
	const ansi = new RegExp(ansiPattern, 'g');

	let getStringWidth;

	function getUserOptions(ctx, isCrossContext) {
	  const ret = {
	    stylize: ctx.stylize,
	    showHidden: ctx.showHidden,
	    depth: ctx.depth,
	    colors: ctx.colors,
	    customInspect: ctx.customInspect,
	    showProxy: ctx.showProxy,
	    maxArrayLength: ctx.maxArrayLength,
	    maxStringLength: ctx.maxStringLength,
	    breakLength: ctx.breakLength,
	    compact: ctx.compact,
	    sorted: ctx.sorted,
	    getters: ctx.getters,
	    numericSeparator: ctx.numericSeparator,
	    ...ctx.userOptions,
	  };

	  // Typically, the target value will be an instance of `Object`. If that is
	  // *not* the case, the object may come from another vm.Context, and we want
	  // to avoid passing it objects from this Context in that case, so we remove
	  // the prototype from the returned object itself + the `stylize()` function,
	  // and remove all other non-primitives, including non-primitive user options.
	  if (isCrossContext) {
	    ObjectSetPrototypeOf(ret, null);
	    for (const key of ObjectKeys(ret)) {
	      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&
	          ret[key] !== null) {
	        delete ret[key];
	      }
	    }
	    ret.stylize = ObjectSetPrototypeOf((value, flavour) => {
	      let stylized;
	      try {
	        stylized = `${ctx.stylize(value, flavour)}`;
	      } catch {
	        // Continue regardless of error.
	      }

	      if (typeof stylized !== 'string') return value;
	      // `stylized` is a string as it should be, which is safe to pass along.
	      return stylized;
	    }, null);
	  }

	  return ret;
	}

	/**
	 * Echos the value of any input. Tries to print the value out
	 * in the best way possible given the different types.
	 * @param {any} value The value to print out.
	 * @param {object} opts Optional options object that alters the output.
	 */
	/* Legacy: value, showHidden, depth, colors */
	function inspect(value, opts) {
	  // Default options
	  const ctx = {
	    budget: {},
	    indentationLvl: 0,
	    seen: [],
	    currentDepth: 0,
	    stylize: stylizeNoColor,
	    showHidden: inspectDefaultOptions.showHidden,
	    depth: inspectDefaultOptions.depth,
	    colors: inspectDefaultOptions.colors,
	    customInspect: inspectDefaultOptions.customInspect,
	    showProxy: inspectDefaultOptions.showProxy,
	    maxArrayLength: inspectDefaultOptions.maxArrayLength,
	    maxStringLength: inspectDefaultOptions.maxStringLength,
	    breakLength: inspectDefaultOptions.breakLength,
	    compact: inspectDefaultOptions.compact,
	    sorted: inspectDefaultOptions.sorted,
	    getters: inspectDefaultOptions.getters,
	    numericSeparator: inspectDefaultOptions.numericSeparator,
	  };
	  if (arguments.length > 1) {
	    // Legacy...
	    if (arguments.length > 2) {
	      if (arguments[2] !== undefined) {
	        ctx.depth = arguments[2];
	      }
	      if (arguments.length > 3 && arguments[3] !== undefined) {
	        ctx.colors = arguments[3];
	      }
	    }
	    // Set user-specified options
	    if (typeof opts === 'boolean') {
	      ctx.showHidden = opts;
	    } else if (opts) {
	      const optKeys = ObjectKeys(opts);
	      for (let i = 0; i < optKeys.length; ++i) {
	        const key = optKeys[i];
	        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
	        // this function public or add a new API with a similar or better
	        // functionality.
	        if (
	          ObjectPrototypeHasOwnProperty(inspectDefaultOptions, key) ||
	          key === 'stylize') {
	          ctx[key] = opts[key];
	        } else if (ctx.userOptions === undefined) {
	          // This is required to pass through the actual user input.
	          ctx.userOptions = opts;
	        }
	      }
	    }
	  }
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
	  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
	  return formatValue(ctx, value, 0);
	}
	inspect.custom = customInspectSymbol;

	ObjectDefineProperty(inspect, 'defaultOptions', {
	  __proto__: null,
	  get() {
	    return inspectDefaultOptions;
	  },
	  set(options) {
	    validateObject(options, 'options');
	    return ObjectAssign(inspectDefaultOptions, options);
	  },
	});

	// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	// Each color consists of an array with the color code as first entry and the
	// reset code as second entry.
	const defaultFG = 39;
	const defaultBG = 49;
	inspect.colors = {
	  __proto__: null,
	  reset: [0, 0],
	  bold: [1, 22],
	  dim: [2, 22], // Alias: faint
	  italic: [3, 23],
	  underline: [4, 24],
	  blink: [5, 25],
	  // Swap foreground and background colors
	  inverse: [7, 27], // Alias: swapcolors, swapColors
	  hidden: [8, 28], // Alias: conceal
	  strikethrough: [9, 29], // Alias: strikeThrough, crossedout, crossedOut
	  doubleunderline: [21, 24], // Alias: doubleUnderline
	  black: [30, defaultFG],
	  red: [31, defaultFG],
	  green: [32, defaultFG],
	  yellow: [33, defaultFG],
	  blue: [34, defaultFG],
	  magenta: [35, defaultFG],
	  cyan: [36, defaultFG],
	  white: [37, defaultFG],
	  bgBlack: [40, defaultBG],
	  bgRed: [41, defaultBG],
	  bgGreen: [42, defaultBG],
	  bgYellow: [43, defaultBG],
	  bgBlue: [44, defaultBG],
	  bgMagenta: [45, defaultBG],
	  bgCyan: [46, defaultBG],
	  bgWhite: [47, defaultBG],
	  framed: [51, 54],
	  overlined: [53, 55],
	  gray: [90, defaultFG], // Alias: grey, blackBright
	  redBright: [91, defaultFG],
	  greenBright: [92, defaultFG],
	  yellowBright: [93, defaultFG],
	  blueBright: [94, defaultFG],
	  magentaBright: [95, defaultFG],
	  cyanBright: [96, defaultFG],
	  whiteBright: [97, defaultFG],
	  bgGray: [100, defaultBG], // Alias: bgGrey, bgBlackBright
	  bgRedBright: [101, defaultBG],
	  bgGreenBright: [102, defaultBG],
	  bgYellowBright: [103, defaultBG],
	  bgBlueBright: [104, defaultBG],
	  bgMagentaBright: [105, defaultBG],
	  bgCyanBright: [106, defaultBG],
	  bgWhiteBright: [107, defaultBG],
	};

	function defineColorAlias(target, alias) {
	  ObjectDefineProperty(inspect.colors, alias, {
	    __proto__: null,
	    get() {
	      return this[target];
	    },
	    set(value) {
	      this[target] = value;
	    },
	    configurable: true,
	    enumerable: false,
	  });
	}

	defineColorAlias('gray', 'grey');
	defineColorAlias('gray', 'blackBright');
	defineColorAlias('bgGray', 'bgGrey');
	defineColorAlias('bgGray', 'bgBlackBright');
	defineColorAlias('dim', 'faint');
	defineColorAlias('strikethrough', 'crossedout');
	defineColorAlias('strikethrough', 'strikeThrough');
	defineColorAlias('strikethrough', 'crossedOut');
	defineColorAlias('hidden', 'conceal');
	defineColorAlias('inverse', 'swapColors');
	defineColorAlias('inverse', 'swapcolors');
	defineColorAlias('doubleunderline', 'doubleUnderline');

	// TODO(BridgeAR): Add function style support for more complex styles.
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = ObjectAssign({ __proto__: null }, {
	  special: 'cyan',
	  number: 'yellow',
	  bigint: 'yellow',
	  boolean: 'yellow',
	  undefined: 'grey',
	  null: 'bold',
	  string: 'green',
	  symbol: 'green',
	  date: 'magenta',
	  // "name": intentionally not styling
	  // TODO(BridgeAR): Highlight regular expressions properly.
	  regexp: 'red',
	  module: 'underline',
	});

	function addQuotes(str, quotes) {
	  if (quotes === -1) {
	    return `"${str}"`;
	  }
	  if (quotes === -2) {
	    return `\`${str}\``;
	  }
	  return `'${str}'`;
	}

	function escapeFn(str) {
	  const charCode = StringPrototypeCharCodeAt(str);
	  return meta.length > charCode ? meta[charCode] : `\\u${NumberPrototypeToString(charCode, 16)}`;
	}

	// Escape control characters, single quotes and the backslash.
	// This is similar to JSON stringify escaping.
	function strEscape(str) {
	  let escapeTest = strEscapeSequencesRegExp;
	  let escapeReplace = strEscapeSequencesReplacer;
	  let singleQuote = 39;

	  // Check for double quotes. If not present, do not escape single quotes and
	  // instead wrap the text in double quotes. If double quotes exist, check for
	  // backticks. If they do not exist, use those as fallback instead of the
	  // double quotes.
	  if (StringPrototypeIncludes(str, "'")) {
	    // This invalidates the charCode and therefore can not be matched for
	    // anymore.
	    if (!StringPrototypeIncludes(str, '"')) {
	      singleQuote = -1;
	    } else if (!StringPrototypeIncludes(str, '`') &&
	               !StringPrototypeIncludes(str, '${')) {
	      singleQuote = -2;
	    }
	    if (singleQuote !== 39) {
	      escapeTest = strEscapeSequencesRegExpSingle;
	      escapeReplace = strEscapeSequencesReplacerSingle;
	    }
	  }

	  // Some magic numbers that worked out fine while benchmarking with v8 6.0
	  if (str.length < 5000 && RegExpPrototypeExec(escapeTest, str) === null)
	    return addQuotes(str, singleQuote);
	  if (str.length > 100) {
	    str = RegExpPrototypeSymbolReplace(escapeReplace, str, escapeFn);
	    return addQuotes(str, singleQuote);
	  }

	  let result = '';
	  let last = 0;
	  for (let i = 0; i < str.length; i++) {
	    const point = StringPrototypeCharCodeAt(str, i);
	    if (point === singleQuote ||
	        point === 92 ||
	        point < 32 ||
	        (point > 126 && point < 160)) {
	      if (last === i) {
	        result += meta[point];
	      } else {
	        result += `${StringPrototypeSlice(str, last, i)}${meta[point]}`;
	      }
	      last = i + 1;
	    } else if (point >= 0xd800 && point <= 0xdfff) {
	      if (point <= 0xdbff && i + 1 < str.length) {
	        const point = StringPrototypeCharCodeAt(str, i + 1);
	        if (point >= 0xdc00 && point <= 0xdfff) {
	          i++;
	          continue;
	        }
	      }
	      result += `${StringPrototypeSlice(str, last, i)}\\u${NumberPrototypeToString(point, 16)}`;
	      last = i + 1;
	    }
	  }

	  if (last !== str.length) {
	    result += StringPrototypeSlice(str, last);
	  }
	  return addQuotes(result, singleQuote);
	}

	function stylizeWithColor(str, styleType) {
	  const style = inspect.styles[styleType];
	  if (style !== undefined) {
	    const color = inspect.colors[style];
	    if (color !== undefined)
	      return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
	  }
	  return str;
	}

	function stylizeNoColor(str) {
	  return str;
	}

	// Return a new empty array to push in the results of the default formatter.
	function getEmptyFormatArray() {
	  return [];
	}

	function isInstanceof(object, proto) {
	  try {
	    return object instanceof proto;
	  } catch {
	    return false;
	  }
	}

	function getConstructorName(obj, ctx, recurseTimes, protoProps) {
	  let firstProto;
	  const tmp = obj;
	  while (obj || isUndetectableObject(obj)) {
	    const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');
	    if (descriptor !== undefined &&
	        typeof descriptor.value === 'function' &&
	        descriptor.value.name !== '' &&
	        isInstanceof(tmp, descriptor.value)) {
	      if (protoProps !== undefined &&
	         (firstProto !== obj ||
	         !builtInObjects.has(descriptor.value.name))) {
	        addPrototypeProperties(
	          ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
	      }
	      return String(descriptor.value.name);
	    }

	    obj = ObjectGetPrototypeOf(obj);
	    if (firstProto === undefined) {
	      firstProto = obj;
	    }
	  }

	  if (firstProto === null) {
	    return null;
	  }

	  const res = internalGetConstructorName(tmp);

	  if (recurseTimes > ctx.depth && ctx.depth !== null) {
	    return `${res} <Complex prototype>`;
	  }

	  const protoConstr = getConstructorName(
	    firstProto, ctx, recurseTimes + 1, protoProps);

	  if (protoConstr === null) {
	    return `${res} <${inspect(firstProto, {
	      ...ctx,
	      customInspect: false,
	      depth: -1,
	    })}>`;
	  }

	  return `${res} <${protoConstr}>`;
	}

	// This function has the side effect of adding prototype properties to the
	// `output` argument (which is an array). This is intended to highlight user
	// defined prototype properties.
	function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
	  let depth = 0;
	  let keys;
	  let keySet;
	  do {
	    if (depth !== 0 || main === obj) {
	      obj = ObjectGetPrototypeOf(obj);
	      // Stop as soon as a null prototype is encountered.
	      if (obj === null) {
	        return;
	      }
	      // Stop as soon as a built-in object type is detected.
	      const descriptor = ObjectGetOwnPropertyDescriptor(obj, 'constructor');
	      if (descriptor !== undefined &&
	          typeof descriptor.value === 'function' &&
	          builtInObjects.has(descriptor.value.name)) {
	        return;
	      }
	    }

	    if (depth === 0) {
	      keySet = new SafeSet();
	    } else {
	      ArrayPrototypeForEach(keys, (key) => keySet.add(key));
	    }
	    // Get all own property names and symbols.
	    keys = ReflectOwnKeys(obj);
	    ArrayPrototypePush(ctx.seen, main);
	    for (const key of keys) {
	      // Ignore the `constructor` property and keys that exist on layers above.
	      if (key === 'constructor' ||
	          ObjectPrototypeHasOwnProperty(main, key) ||
	          (depth !== 0 && keySet.has(key))) {
	        continue;
	      }
	      const desc = ObjectGetOwnPropertyDescriptor(obj, key);
	      if (typeof desc.value === 'function') {
	        continue;
	      }
	      const value = formatProperty(
	        ctx, obj, recurseTimes, key, kObjectType, desc, main);
	      if (ctx.colors) {
	        // Faint!
	        ArrayPrototypePush(output, `\u001b[2m${value}\u001b[22m`);
	      } else {
	        ArrayPrototypePush(output, value);
	      }
	    }
	    ArrayPrototypePop(ctx.seen);
	  // Limit the inspection to up to three prototype layers. Using `recurseTimes`
	  // is not a good choice here, because it's as if the properties are declared
	  // on the current object from the users perspective.
	  } while (++depth !== 3);
	}

	function getPrefix(constructor, tag, fallback, size = '') {
	  if (constructor === null) {
	    if (tag !== '' && fallback !== tag) {
	      return `[${fallback}${size}: null prototype] [${tag}] `;
	    }
	    return `[${fallback}${size}: null prototype] `;
	  }

	  if (tag !== '' && constructor !== tag) {
	    return `${constructor}${size} [${tag}] `;
	  }
	  return `${constructor}${size} `;
	}

	// Look up the keys of the object.
	function getKeys(value, showHidden) {
	  let keys;
	  const symbols = ObjectGetOwnPropertySymbols(value);
	  if (showHidden) {
	    keys = ObjectGetOwnPropertyNames(value);
	    if (symbols.length !== 0)
	      ArrayPrototypePushApply(keys, symbols);
	  } else {
	    // This might throw if `value` is a Module Namespace Object from an
	    // unevaluated module, but we don't want to perform the actual type
	    // check because it's expensive.
	    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
	    // and modify this logic as needed.
	    try {
	      keys = ObjectKeys(value);
	    } catch (err) {
	      assert(isNativeError(err) && err.name === 'ReferenceError' &&
	             isModuleNamespaceObject(value));
	      keys = ObjectGetOwnPropertyNames(value);
	    }
	    if (symbols.length !== 0) {
	      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value, key);
	      ArrayPrototypePushApply(keys, ArrayPrototypeFilter(symbols, filter));
	    }
	  }
	  return keys;
	}

	function getCtxStyle(value, constructor, tag) {
	  let fallback = '';
	  if (constructor === null) {
	    fallback = internalGetConstructorName(value);
	    if (fallback === tag) {
	      fallback = 'Object';
	    }
	  }
	  return getPrefix(constructor, tag, fallback);
	}

	function formatProxy(ctx, proxy, recurseTimes) {
	  if (recurseTimes > ctx.depth && ctx.depth !== null) {
	    return ctx.stylize('Proxy [Array]', 'special');
	  }
	  recurseTimes += 1;
	  ctx.indentationLvl += 2;
	  const res = [
	    formatValue(ctx, proxy[0], recurseTimes),
	    formatValue(ctx, proxy[1], recurseTimes),
	  ];
	  ctx.indentationLvl -= 2;
	  return reduceToSingleString(
	    ctx, res, '', ['Proxy [', ']'], kArrayExtrasType, recurseTimes);
	}

	// Note: using `formatValue` directly requires the indentation level to be
	// corrected by setting `ctx.indentationLvL += diff` and then to decrease the
	// value afterwards again.
	function formatValue(ctx, value, recurseTimes, typedArray) {
	  // Primitive types cannot have properties.
	  if (typeof value !== 'object' &&
	      typeof value !== 'function' &&
	      !isUndetectableObject(value)) {
	    return formatPrimitive(ctx.stylize, value, ctx);
	  }
	  if (value === null) {
	    return ctx.stylize('null', 'null');
	  }

	  // Memorize the context for custom inspection on proxies.
	  const context = value;
	  // Always check for proxies to prevent side effects and to prevent triggering
	  // any proxy handlers.
	  const proxy = getProxyDetails(value, !!ctx.showProxy);
	  if (proxy !== undefined) {
	    if (proxy === null || proxy[0] === null) {
	      return ctx.stylize('<Revoked Proxy>', 'special');
	    }
	    if (ctx.showProxy) {
	      return formatProxy(ctx, proxy, recurseTimes);
	    }
	    value = proxy;
	  }

	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it.
	  if (ctx.customInspect) {
	    const maybeCustom = value[customInspectSymbol];
	    if (typeof maybeCustom === 'function' &&
	        // Filter out the util module, its inspect function is special.
	        maybeCustom !== inspect &&
	        // Also filter out any prototype objects using the circular check.
	        !(value.constructor && value.constructor.prototype === value)) {
	      // This makes sure the recurseTimes are reported as before while using
	      // a counter internally.
	      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
	      const isCrossContext =
	        proxy !== undefined || !(context instanceof Object);
	      const ret = FunctionPrototypeCall(
	        maybeCustom,
	        context,
	        depth,
	        getUserOptions(ctx, isCrossContext),
	        inspect,
	      );
	      // If the custom inspection method returned `this`, don't go into
	      // infinite recursion.
	      if (ret !== context) {
	        if (typeof ret !== 'string') {
	          return formatValue(ctx, ret, recurseTimes);
	        }
	        return StringPrototypeReplaceAll(ret, '\n', `\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`);
	      }
	    }
	  }

	  // Using an array here is actually better for the average case than using
	  // a Set. `seen` will only check for the depth and will never grow too large.
	  if (ctx.seen.includes(value)) {
	    let index = 1;
	    if (ctx.circular === undefined) {
	      ctx.circular = new SafeMap();
	      ctx.circular.set(value, index);
	    } else {
	      index = ctx.circular.get(value);
	      if (index === undefined) {
	        index = ctx.circular.size + 1;
	        ctx.circular.set(value, index);
	      }
	    }
	    return ctx.stylize(`[Circular *${index}]`, 'special');
	  }

	  return formatRaw(ctx, value, recurseTimes, typedArray);
	}

	function formatRaw(ctx, value, recurseTimes, typedArray) {
	  let keys;
	  let protoProps;
	  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
	    protoProps = [];
	  }

	  const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
	  // Reset the variable to check for this later on.
	  if (protoProps !== undefined && protoProps.length === 0) {
	    protoProps = undefined;
	  }

	  let tag = value[SymbolToStringTag];
	  // Only list the tag in case it's non-enumerable / not an own property.
	  // Otherwise we'd print this twice.
	  if (typeof tag !== 'string' ||
	      (tag !== '' &&
	      (ctx.showHidden ?
	        ObjectPrototypeHasOwnProperty :
	        ObjectPrototypePropertyIsEnumerable)(
	        value, SymbolToStringTag,
	      ))) {
	    tag = '';
	  }
	  let base = '';
	  let formatter = getEmptyFormatArray;
	  let braces;
	  let noIterator = true;
	  let i = 0;
	  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;

	  let extrasType = kObjectType;

	  // Iterators and the rest are split to reduce checks.
	  // We have to check all values in case the constructor is set to null.
	  // Otherwise it would not possible to identify all types properly.
	  if (SymbolIterator in value || constructor === null) {
	    noIterator = false;
	    if (ArrayIsArray(value)) {
	      // Only set the constructor for non ordinary ("Array [...]") arrays.
	      const prefix = (constructor !== 'Array' || tag !== '') ?
	        getPrefix(constructor, tag, 'Array', `(${value.length})`) :
	        '';
	      keys = getOwnNonIndexProperties(value, filter);
	      braces = [`${prefix}[`, ']'];
	      if (value.length === 0 && keys.length === 0 && protoProps === undefined)
	        return `${braces[0]}]`;
	      extrasType = kArrayExtrasType;
	      formatter = formatArray;
	    } else if (isSet(value)) {
	      const size = SetPrototypeGetSize(value);
	      const prefix = getPrefix(constructor, tag, 'Set', `(${size})`);
	      keys = getKeys(value, ctx.showHidden);
	      formatter = constructor !== null ?
	        FunctionPrototypeBind(formatSet, null, value) :
	        FunctionPrototypeBind(formatSet, null, SetPrototypeValues(value));
	      if (size === 0 && keys.length === 0 && protoProps === undefined)
	        return `${prefix}{}`;
	      braces = [`${prefix}{`, '}'];
	    } else if (isMap(value)) {
	      const size = MapPrototypeGetSize(value);
	      const prefix = getPrefix(constructor, tag, 'Map', `(${size})`);
	      keys = getKeys(value, ctx.showHidden);
	      formatter = constructor !== null ?
	        FunctionPrototypeBind(formatMap, null, value) :
	        FunctionPrototypeBind(formatMap, null, MapPrototypeEntries(value));
	      if (size === 0 && keys.length === 0 && protoProps === undefined)
	        return `${prefix}{}`;
	      braces = [`${prefix}{`, '}'];
	    } else if (isTypedArray(value)) {
	      keys = getOwnNonIndexProperties(value, filter);
	      let bound = value;
	      let fallback = '';
	      if (constructor === null) {
	        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);
	        // Reconstruct the array information.
	        bound = new primordials[fallback](value);
	      }
	      const size = TypedArrayPrototypeGetLength(value);
	      const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
	      braces = [`${prefix}[`, ']'];
	      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)
	        return `${braces[0]}]`;
	      // Special handle the value. The original value is required below. The
	      // bound function is required to reconstruct missing information.
	      formatter = FunctionPrototypeBind(formatTypedArray, null, bound, size);
	      extrasType = kArrayExtrasType;
	    } else if (isMapIterator(value)) {
	      keys = getKeys(value, ctx.showHidden);
	      braces = getIteratorBraces('Map', tag);
	      // Add braces to the formatter parameters.
	      formatter = FunctionPrototypeBind(formatIterator, null, braces);
	    } else if (isSetIterator(value)) {
	      keys = getKeys(value, ctx.showHidden);
	      braces = getIteratorBraces('Set', tag);
	      // Add braces to the formatter parameters.
	      formatter = FunctionPrototypeBind(formatIterator, null, braces);
	    } else {
	      noIterator = true;
	    }
	  }
	  if (noIterator) {
	    keys = getKeys(value, ctx.showHidden);
	    braces = ['{', '}'];
	    if (constructor === 'Object') {
	      if (isArgumentsObject(value)) {
	        braces[0] = '[Arguments] {';
	      } else if (tag !== '') {
	        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;
	      }
	      if (keys.length === 0 && protoProps === undefined) {
	        return `${braces[0]}}`;
	      }
	    } else if (typeof value === 'function') {
	      base = getFunctionBase(value, constructor, tag);
	      if (keys.length === 0 && protoProps === undefined)
	        return ctx.stylize(base, 'special');
	    } else if (isRegExp(value)) {
	      // Make RegExps say that they are RegExps
	      base = RegExpPrototypeToString(
	        constructor !== null ? value : new RegExp(value),
	      );
	      const prefix = getPrefix(constructor, tag, 'RegExp');
	      if (prefix !== 'RegExp ')
	        base = `${prefix}${base}`;
	      if ((keys.length === 0 && protoProps === undefined) ||
	          (recurseTimes > ctx.depth && ctx.depth !== null)) {
	        return ctx.stylize(base, 'regexp');
	      }
	    } else if (isDate(value)) {
	      // Make dates with properties first say the date
	      base = NumberIsNaN(DatePrototypeGetTime(value)) ?
	        DatePrototypeToString(value) :
	        DatePrototypeToISOString(value);
	      const prefix = getPrefix(constructor, tag, 'Date');
	      if (prefix !== 'Date ')
	        base = `${prefix}${base}`;
	      if (keys.length === 0 && protoProps === undefined) {
	        return ctx.stylize(base, 'date');
	      }
	    } else if (isError(value)) {
	      base = formatError(value, constructor, tag, ctx, keys);
	      if (keys.length === 0 && protoProps === undefined)
	        return base;
	    } else if (isAnyArrayBuffer(value)) {
	      // Fast path for ArrayBuffer and SharedArrayBuffer.
	      // Can't do the same for DataView because it has a non-primitive
	      // .buffer property that we need to recurse for.
	      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :
	        'SharedArrayBuffer';
	      const prefix = getPrefix(constructor, tag, arrayType);
	      if (typedArray === undefined) {
	        formatter = formatArrayBuffer;
	      } else if (keys.length === 0 && protoProps === undefined) {
	        return prefix +
	              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength, false)} }`;
	      }
	      braces[0] = `${prefix}{`;
	      ArrayPrototypeUnshift(keys, 'byteLength');
	    } else if (isDataView(value)) {
	      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;
	      // .buffer goes last, it's not a primitive like the others.
	      ArrayPrototypeUnshift(keys, 'byteLength', 'byteOffset', 'buffer');
	    } else if (isPromise(value)) {
	      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;
	      formatter = formatPromise;
	    } else if (isWeakSet(value)) {
	      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;
	      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
	    } else if (isWeakMap(value)) {
	      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;
	      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
	    } else if (isModuleNamespaceObject(value)) {
	      braces[0] = `${getPrefix(constructor, tag, 'Module')}{`;
	      // Special handle keys for namespace objects.
	      formatter = formatNamespaceObject.bind(null, keys);
	    } else if (isBoxedPrimitive(value)) {
	      base = getBoxedBase(value, ctx, keys, constructor, tag);
	      if (keys.length === 0 && protoProps === undefined) {
	        return base;
	      }
	    } else {
	      if (keys.length === 0 && protoProps === undefined) {
	        if (isExternal(value)) {
	          const address = getExternalValue(value).toString(16);
	          return ctx.stylize(`[External: ${address}]`, 'special');
	        }
	        return `${getCtxStyle(value, constructor, tag)}{}`;
	      }
	      braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
	    }
	  }

	  if (recurseTimes > ctx.depth && ctx.depth !== null) {
	    let constructorName = StringPrototypeSlice(getCtxStyle(value, constructor, tag), 0, -1);
	    if (constructor !== null)
	      constructorName = `[${constructorName}]`;
	    return ctx.stylize(constructorName, 'special');
	  }
	  recurseTimes += 1;

	  ctx.seen.push(value);
	  ctx.currentDepth = recurseTimes;
	  let output;
	  const indentationLvl = ctx.indentationLvl;
	  try {
	    output = formatter(ctx, value, recurseTimes);
	    for (i = 0; i < keys.length; i++) {
	      ArrayPrototypePush(
	        output,
	        formatProperty(ctx, value, recurseTimes, keys[i], extrasType),
	      );
	    }
	    if (protoProps !== undefined) {
	      ArrayPrototypePushApply(output, protoProps);
	    }
	  } catch (err) {
	    const constructorName = StringPrototypeSlice(getCtxStyle(value, constructor, tag), 0, -1);
	    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
	  }
	  if (ctx.circular !== undefined) {
	    const index = ctx.circular.get(value);
	    if (index !== undefined) {
	      const reference = ctx.stylize(`<ref *${index}>`, 'special');
	      // Add reference always to the very beginning of the output.
	      if (ctx.compact !== true) {
	        base = base === '' ? reference : `${reference} ${base}`;
	      } else {
	        braces[0] = `${reference} ${braces[0]}`;
	      }
	    }
	  }
	  ctx.seen.pop();

	  if (ctx.sorted) {
	    const comparator = ctx.sorted === true ? undefined : ctx.sorted;
	    if (extrasType === kObjectType) {
	      ArrayPrototypeSort(output, comparator);
	    } else if (keys.length > 1) {
	      const sorted = ArrayPrototypeSort(ArrayPrototypeSlice(output, output.length - keys.length), comparator);
	      ArrayPrototypeUnshift(sorted, output, output.length - keys.length, keys.length);
	      ReflectApply(ArrayPrototypeSplice, null, sorted);
	    }
	  }

	  const res = reduceToSingleString(
	    ctx, output, base, braces, extrasType, recurseTimes, value);
	  const budget = ctx.budget[ctx.indentationLvl] || 0;
	  const newLength = budget + res.length;
	  ctx.budget[ctx.indentationLvl] = newLength;
	  // If any indentationLvl exceeds this limit, limit further inspecting to the
	  // minimum. Otherwise the recursive algorithm might continue inspecting the
	  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
	  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
	  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
	  // This limit also makes sure that huge objects don't block the event loop
	  // significantly.
	  if (newLength > 2 ** 27) {
	    ctx.depth = -1;
	  }
	  return res;
	}

	function getIteratorBraces(type, tag) {
	  if (tag !== `${type} Iterator`) {
	    if (tag !== '')
	      tag += '] [';
	    tag += `${type} Iterator`;
	  }
	  return [`[${tag}] {`, '}'];
	}

	function getBoxedBase(value, ctx, keys, constructor, tag) {
	  let fn;
	  let type;
	  if (isNumberObject(value)) {
	    fn = NumberPrototypeValueOf;
	    type = 'Number';
	  } else if (isStringObject(value)) {
	    fn = StringPrototypeValueOf;
	    type = 'String';
	    // For boxed Strings, we have to remove the 0-n indexed entries,
	    // since they just noisy up the output and are redundant
	    // Make boxed primitive Strings look like such
	    keys.splice(0, value.length);
	  } else if (isBooleanObject(value)) {
	    fn = BooleanPrototypeValueOf;
	    type = 'Boolean';
	  } else if (isBigIntObject(value)) {
	    fn = BigIntPrototypeValueOf;
	    type = 'BigInt';
	  } else {
	    fn = SymbolPrototypeValueOf;
	    type = 'Symbol';
	  }
	  let base = `[${type}`;
	  if (type !== constructor) {
	    if (constructor === null) {
	      base += ' (null prototype)';
	    } else {
	      base += ` (${constructor})`;
	    }
	  }
	  base += `: ${formatPrimitive(stylizeNoColor, fn(value), ctx)}]`;
	  if (tag !== '' && tag !== constructor) {
	    base += ` [${tag}]`;
	  }
	  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)
	    return base;
	  return ctx.stylize(base, StringPrototypeToLowerCase(type));
	}

	function getClassBase(value, constructor, tag) {
	  const hasName = ObjectPrototypeHasOwnProperty(value, 'name');
	  const name = (hasName && value.name) || '(anonymous)';
	  let base = `class ${name}`;
	  if (constructor !== 'Function' && constructor !== null) {
	    base += ` [${constructor}]`;
	  }
	  if (tag !== '' && constructor !== tag) {
	    base += ` [${tag}]`;
	  }
	  if (constructor !== null) {
	    const superName = ObjectGetPrototypeOf(value).name;
	    if (superName) {
	      base += ` extends ${superName}`;
	    }
	  } else {
	    base += ' extends [null prototype]';
	  }
	  return `[${base}]`;
	}

	function getFunctionBase(value, constructor, tag) {
	  const stringified = FunctionPrototypeToString(value);
	  if (StringPrototypeStartsWith(stringified, 'class') && StringPrototypeEndsWith(stringified, '}')) {
	    const slice = StringPrototypeSlice(stringified, 5, -1);
	    const bracketIndex = StringPrototypeIndexOf(slice, '{');
	    if (bracketIndex !== -1 &&
	        (!StringPrototypeIncludes(StringPrototypeSlice(slice, 0, bracketIndex), '(') ||
	        // Slow path to guarantee that it's indeed a class.
	        RegExpPrototypeExec(classRegExp, RegExpPrototypeSymbolReplace(stripCommentsRegExp, slice)) !== null)
	    ) {
	      return getClassBase(value, constructor, tag);
	    }
	  }
	  let type = 'Function';
	  if (isGeneratorFunction(value)) {
	    type = `Generator${type}`;
	  }
	  if (isAsyncFunction(value)) {
	    type = `Async${type}`;
	  }
	  let base = `[${type}`;
	  if (constructor === null) {
	    base += ' (null prototype)';
	  }
	  if (value.name === '') {
	    base += ' (anonymous)';
	  } else {
	    base += `: ${value.name}`;
	  }
	  base += ']';
	  if (constructor !== type && constructor !== null) {
	    base += ` ${constructor}`;
	  }
	  if (tag !== '' && constructor !== tag) {
	    base += ` [${tag}]`;
	  }
	  return base;
	}

	function identicalSequenceRange(a, b) {
	  for (let i = 0; i < a.length - 3; i++) {
	    // Find the first entry of b that matches the current entry of a.
	    const pos = b.indexOf(a[i]);
	    if (pos !== -1) {
	      const rest = b.length - pos;
	      if (rest > 3) {
	        let len = 1;
	        const maxLen = MathMin(a.length - i, rest);
	        // Count the number of consecutive entries.
	        while (maxLen > len && a[i + len] === b[pos + len]) {
	          len++;
	        }
	        if (len > 3) {
	          return { len, offset: i };
	        }
	      }
	    }
	  }

	  return { len: 0, offset: 0 };
	}

	function getStackString(error) {
	  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);
	}

	function getStackFrames(ctx, err, stack) {
	  const frames = StringPrototypeSplit(stack, '\n');

	  let cause;
	  try {
	    ({ cause } = err);
	  } catch {
	    // If 'cause' is a getter that throws, ignore it.
	  }

	  // Remove stack frames identical to frames in cause.
	  if (cause != null && isError(cause)) {
	    const causeStack = getStackString(cause);
	    const causeStackStart = StringPrototypeIndexOf(causeStack, '\n    at');
	    if (causeStackStart !== -1) {
	      const causeFrames = StringPrototypeSplit(StringPrototypeSlice(causeStack, causeStackStart + 1), '\n');
	      const { len, offset } = identicalSequenceRange(frames, causeFrames);
	      if (len > 0) {
	        const skipped = len - 2;
	        const msg = `    ... ${skipped} lines matching cause stack trace ...`;
	        frames.splice(offset + 1, skipped, ctx.stylize(msg, 'undefined'));
	      }
	    }
	  }
	  return frames;
	}

	function improveStack(stack, constructor, name, tag) {
	  // A stack trace may contain arbitrary data. Only manipulate the output
	  // for "regular errors" (errors that "look normal") for now.
	  let len = name.length;

	  if (constructor === null ||
	      (StringPrototypeEndsWith(name, 'Error') &&
	      StringPrototypeStartsWith(stack, name) &&
	      (stack.length === len || stack[len] === ':' || stack[len] === '\n'))) {
	    let fallback = 'Error';
	    if (constructor === null) {
	      const start = RegExpPrototypeExec(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/, stack) ||
	      RegExpPrototypeExec(/^([a-z_A-Z0-9-]*Error)$/, stack);
	      fallback = (start && start[1]) || '';
	      len = fallback.length;
	      fallback = fallback || 'Error';
	    }
	    const prefix = StringPrototypeSlice(getPrefix(constructor, tag, fallback), 0, -1);
	    if (name !== prefix) {
	      if (StringPrototypeIncludes(prefix, name)) {
	        if (len === 0) {
	          stack = `${prefix}: ${stack}`;
	        } else {
	          stack = `${prefix}${StringPrototypeSlice(stack, len)}`;
	        }
	      } else {
	        stack = `${prefix} [${name}]${StringPrototypeSlice(stack, len)}`;
	      }
	    }
	  }
	  return stack;
	}

	function removeDuplicateErrorKeys(ctx, keys, err, stack) {
	  if (!ctx.showHidden && keys.length !== 0) {
	    for (const name of ['name', 'message', 'stack']) {
	      const index = ArrayPrototypeIndexOf(keys, name);
	      // Only hide the property in case it's part of the original stack
	      if (index !== -1 && StringPrototypeIncludes(stack, err[name])) {
	        ArrayPrototypeSplice(keys, index, 1);
	      }
	    }
	  }
	}

	function markNodeModules(ctx, line) {
	  let tempLine = '';
	  let nodeModule;
	  let pos = 0;
	  while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {
	    // '/node_modules/'.length === 14
	    tempLine += StringPrototypeSlice(line, pos, nodeModule.index + 14);
	    tempLine += ctx.stylize(nodeModule[1], 'module');
	    pos = nodeModule.index + nodeModule[0].length;
	  }
	  if (pos !== 0) {
	    line = tempLine + StringPrototypeSlice(line, pos);
	  }
	  return line;
	}

	function markCwd(ctx, line, workingDirectory) {
	  let cwdStartPos = StringPrototypeIndexOf(line, workingDirectory);
	  let tempLine = '';
	  let cwdLength = workingDirectory.length;
	  if (cwdStartPos !== -1) {
	    if (StringPrototypeSlice(line, cwdStartPos - 7, cwdStartPos) === 'file://') {
	      cwdLength += 7;
	      cwdStartPos -= 7;
	    }
	    const start = line[cwdStartPos - 1] === '(' ? cwdStartPos - 1 : cwdStartPos;
	    const end = start !== cwdStartPos && StringPrototypeEndsWith(line, ')') ? -1 : line.length;
	    const workingDirectoryEndPos = cwdStartPos + cwdLength + 1;
	    const cwdSlice = StringPrototypeSlice(line, start, workingDirectoryEndPos);

	    tempLine += StringPrototypeSlice(line, 0, start);
	    tempLine += ctx.stylize(cwdSlice, 'undefined');
	    tempLine += StringPrototypeSlice(line, workingDirectoryEndPos, end);
	    if (end === -1) {
	      tempLine += ctx.stylize(')', 'undefined');
	    }
	  } else {
	    tempLine += line;
	  }
	  return tempLine;
	}

	function safeGetCWD() {
	  let workingDirectory;
	  try {
	    workingDirectory = process$1.cwd();
	  } catch {
	    return;
	  }
	  return workingDirectory;
	}

	function formatError(err, constructor, tag, ctx, keys) {
	  const name = err.name != null ? String(err.name) : 'Error';
	  let stack = getStackString(err);

	  removeDuplicateErrorKeys(ctx, keys, err, stack);

	  if ('cause' in err &&
	      (keys.length === 0 || !ArrayPrototypeIncludes(keys, 'cause'))) {
	    ArrayPrototypePush(keys, 'cause');
	  }

	  // Print errors aggregated into AggregateError
	  if (ArrayIsArray(err.errors) &&
	      (keys.length === 0 || !ArrayPrototypeIncludes(keys, 'errors'))) {
	    ArrayPrototypePush(keys, 'errors');
	  }

	  stack = improveStack(stack, constructor, name, tag);

	  // Ignore the error message if it's contained in the stack.
	  let pos = (err.message && StringPrototypeIndexOf(stack, err.message)) || -1;
	  if (pos !== -1)
	    pos += err.message.length;
	  // Wrap the error in brackets in case it has no stack trace.
	  const stackStart = StringPrototypeIndexOf(stack, '\n    at', pos);
	  if (stackStart === -1) {
	    stack = `[${stack}]`;
	  } else {
	    let newStack = StringPrototypeSlice(stack, 0, stackStart);
	    const stackFramePart = StringPrototypeSlice(stack, stackStart + 1);
	    const lines = getStackFrames(ctx, err, stackFramePart);
	    if (ctx.colors) {
	      // Highlight userland code and node modules.
	      const workingDirectory = safeGetCWD();
	      let esmWorkingDirectory;
	      for (let line of lines) {
	        const core = RegExpPrototypeExec(coreModuleRegExp, line);
	        if (core !== null && BuiltinModule.exists(core[1])) {
	          newStack += `\n${ctx.stylize(line, 'undefined')}`;
	        } else {
	          newStack += '\n';

	          line = markNodeModules(ctx, line);
	          if (workingDirectory !== undefined) {
	            let newLine = markCwd(ctx, line, workingDirectory);
	            if (newLine === line) {
	              // Maintain node 14 compat
	              // esmWorkingDirectory ??= pathToFileUrlHref(workingDirectory);
	              esmWorkingDirectory =
	                (esmWorkingDirectory == null) ? pathToFileUrlHref(workingDirectory) : esmWorkingDirectory;
	              newLine = markCwd(ctx, line, esmWorkingDirectory);
	            }
	            line = newLine;
	          }

	          newStack += line;
	        }
	      }
	    } else {
	      newStack += `\n${ArrayPrototypeJoin(lines, '\n')}`;
	    }
	    stack = newStack;
	  }
	  // The message and the stack have to be indented as well!
	  if (ctx.indentationLvl !== 0) {
	    const indentation = StringPrototypeRepeat(' ', ctx.indentationLvl);
	    stack = StringPrototypeReplaceAll(stack, '\n', `\n${indentation}`);
	  }
	  return stack;
	}

	function groupArrayElements(ctx, output, value) {
	  let totalLength = 0;
	  let maxLength = 0;
	  let i = 0;
	  let outputLength = output.length;
	  if (ctx.maxArrayLength < output.length) {
	    // This makes sure the "... n more items" part is not taken into account.
	    outputLength--;
	  }
	  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.
	  const dataLen = new Array(outputLength);
	  // Calculate the total length of all output entries and the individual max
	  // entries length of all output entries. We have to remove colors first,
	  // otherwise the length would not be calculated properly.
	  for (; i < outputLength; i++) {
	    const len = getStringWidth(output[i], ctx.colors);
	    dataLen[i] = len;
	    totalLength += len + separatorSpace;
	    if (maxLength < len)
	      maxLength = len;
	  }
	  // Add two to `maxLength` as we add a single whitespace character plus a comma
	  // in-between two entries.
	  const actualMax = maxLength + separatorSpace;
	  // Check if at least three entries fit next to each other and prevent grouping
	  // of arrays that contains entries of very different length (i.e., if a single
	  // entry is longer than 1/5 of all other entries combined). Otherwise the
	  // space in-between small entries would be enormous.
	  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&
	      (totalLength / actualMax > 5 || maxLength <= 6)) {

	    const approxCharHeights = 2.5;
	    const averageBias = MathSqrt(actualMax - totalLength / output.length);
	    const biasedMax = MathMax(actualMax - 3 - averageBias, 1);
	    // Dynamically check how many columns seem possible.
	    const columns = MathMin(
	      // Ideally a square should be drawn. We expect a character to be about 2.5
	      // times as high as wide. This is the area formula to calculate a square
	      // which contains n rectangles of size `actualMax * approxCharHeights`.
	      // Divide that by `actualMax` to receive the correct number of columns.
	      // The added bias increases the columns for short entries.
	      MathRound(
	        MathSqrt(
	          approxCharHeights * biasedMax * outputLength,
	        ) / biasedMax,
	      ),
	      // Do not exceed the breakLength.
	      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax),
	      // Limit array grouping for small `compact` modes as the user requested
	      // minimal grouping.
	      ctx.compact * 4,
	      // Limit the columns to a maximum of fifteen.
	      15,
	    );
	    // Return with the original output if no grouping should happen.
	    if (columns <= 1) {
	      return output;
	    }
	    const tmp = [];
	    const maxLineLength = [];
	    for (let i = 0; i < columns; i++) {
	      let lineMaxLength = 0;
	      for (let j = i; j < output.length; j += columns) {
	        if (dataLen[j] > lineMaxLength)
	          lineMaxLength = dataLen[j];
	      }
	      lineMaxLength += separatorSpace;
	      maxLineLength[i] = lineMaxLength;
	    }
	    let order = StringPrototypePadStart;
	    if (value !== undefined) {
	      for (let i = 0; i < output.length; i++) {
	        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {
	          order = StringPrototypePadEnd;
	          break;
	        }
	      }
	    }
	    // Each iteration creates a single line of grouped entries.
	    for (let i = 0; i < outputLength; i += columns) {
	      // The last lines may contain less entries than columns.
	      const max = MathMin(i + columns, outputLength);
	      let str = '';
	      let j = i;
	      for (; j < max - 1; j++) {
	        // Calculate extra color padding in case it's active. This has to be
	        // done line by line as some lines might contain more colors than
	        // others.
	        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
	        str += order(`${output[j]}, `, padding, ' ');
	      }
	      if (order === StringPrototypePadStart) {
	        const padding = maxLineLength[j - i] +
	                        output[j].length -
	                        dataLen[j] -
	                        separatorSpace;
	        str += StringPrototypePadStart(output[j], padding, ' ');
	      } else {
	        str += output[j];
	      }
	      ArrayPrototypePush(tmp, str);
	    }
	    if (ctx.maxArrayLength < output.length) {
	      ArrayPrototypePush(tmp, output[outputLength]);
	    }
	    output = tmp;
	  }
	  return output;
	}

	function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
	  if (isStackOverflowError(err)) {
	    ctx.seen.pop();
	    ctx.indentationLvl = indentationLvl;
	    return ctx.stylize(
	      `[${constructorName}: Inspection interrupted ` +
	        'prematurely. Maximum call stack size exceeded.]',
	      'special',
	    );
	  }
	  assert.fail(err.stack);
	}

	function addNumericSeparator(integerString) {
	  let result = '';
	  let i = integerString.length;
	  const start = StringPrototypeStartsWith(integerString, '-') ? 1 : 0;
	  for (; i >= start + 4; i -= 3) {
	    result = `_${StringPrototypeSlice(integerString, i - 3, i)}${result}`;
	  }
	  return i === integerString.length ?
	    integerString :
	    `${StringPrototypeSlice(integerString, 0, i)}${result}`;
	}

	function addNumericSeparatorEnd(integerString) {
	  let result = '';
	  let i = 0;
	  for (; i < integerString.length - 3; i += 3) {
	    result += `${StringPrototypeSlice(integerString, i, i + 3)}_`;
	  }
	  return i === 0 ?
	    integerString :
	    `${result}${StringPrototypeSlice(integerString, i)}`;
	}

	const remainingText = (remaining) => `... ${remaining} more item${remaining > 1 ? 's' : ''}`;

	function formatNumber(fn, number, numericSeparator) {
	  if (!numericSeparator) {
	    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.
	    if (ObjectIs(number, -0)) {
	      return fn('-0', 'number');
	    }
	    return fn(`${number}`, 'number');
	  }
	  const integer = MathTrunc(number);
	  const string = String(integer);
	  if (integer === number) {
	    if (!NumberIsFinite(number) || StringPrototypeIncludes(string, 'e')) {
	      return fn(string, 'number');
	    }
	    return fn(`${addNumericSeparator(string)}`, 'number');
	  }
	  if (NumberIsNaN(number)) {
	    return fn(string, 'number');
	  }
	  return fn(`${
	    addNumericSeparator(string)
	  }.${
	    addNumericSeparatorEnd(
	      StringPrototypeSlice(String(number), string.length + 1),
	    )
	  }`, 'number');
	}

	function formatBigInt(fn, bigint, numericSeparator) {
	  const string = String(bigint);
	  if (!numericSeparator) {
	    return fn(`${string}n`, 'bigint');
	  }
	  return fn(`${addNumericSeparator(string)}n`, 'bigint');
	}

	function formatPrimitive(fn, value, ctx) {
	  if (typeof value === 'string') {
	    let trailer = '';
	    if (value.length > ctx.maxStringLength) {
	      const remaining = value.length - ctx.maxStringLength;
	      value = StringPrototypeSlice(value, 0, ctx.maxStringLength);
	      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;
	    }
	    if (ctx.compact !== true &&
	        // We do not support handling unicode characters width with
	        // the readline getStringWidth function as there are
	        // performance implications.
	        value.length > kMinLineLength &&
	        value.length > ctx.breakLength - ctx.indentationLvl - 4) {
	      return ArrayPrototypeJoin(
	        ArrayPrototypeMap(
	          extractedSplitNewLines(value),
	          (line) => fn(strEscape(line), 'string'),
	        ),
	        ` +\n${StringPrototypeRepeat(' ', ctx.indentationLvl + 2)}`,
	      ) + trailer;
	    }
	    return fn(strEscape(value), 'string') + trailer;
	  }
	  if (typeof value === 'number')
	    return formatNumber(fn, value, ctx.numericSeparator);
	  if (typeof value === 'bigint')
	    return formatBigInt(fn, value, ctx.numericSeparator);
	  if (typeof value === 'boolean')
	    return fn(`${value}`, 'boolean');
	  if (typeof value === 'undefined')
	    return fn('undefined', 'undefined');
	  // es6 symbol primitive
	  return fn(SymbolPrototypeToString(value), 'symbol');
	}

	function formatNamespaceObject(keys, ctx, value, recurseTimes) {
	  const output = new Array(keys.length);
	  for (let i = 0; i < keys.length; i++) {
	    try {
	      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],
	                                 kObjectType);
	    } catch (err) {
	      assert(isNativeError(err) && err.name === 'ReferenceError');
	      // Use the existing functionality. This makes sure the indentation and
	      // line breaks are always correct. Otherwise it is very difficult to keep
	      // this aligned, even though this is a hacky way of dealing with this.
	      const tmp = { [keys[i]]: '' };
	      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
	      const pos = StringPrototypeLastIndexOf(output[i], ' ');
	      // We have to find the last whitespace and have to replace that value as
	      // it will be visualized as a regular string.
	      output[i] = StringPrototypeSlice(output[i], 0, pos + 1) +
	                  ctx.stylize('<uninitialized>', 'special');
	    }
	  }
	  // Reset the keys to an empty array. This prevents duplicated inspection.
	  keys.length = 0;
	  return output;
	}

	// The array is sparse and/or has extra keys
	function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
	  const keys = ObjectKeys(value);
	  let index = i;
	  for (; i < keys.length && output.length < maxLength; i++) {
	    const key = keys[i];
	    const tmp = +key;
	    // Arrays can only have up to 2^32 - 1 entries
	    if (tmp > 2 ** 32 - 2) {
	      break;
	    }
	    if (`${index}` !== key) {
	      if (RegExpPrototypeExec(numberRegExp, key) === null) {
	        break;
	      }
	      const emptyItems = tmp - index;
	      const ending = emptyItems > 1 ? 's' : '';
	      const message = `<${emptyItems} empty item${ending}>`;
	      ArrayPrototypePush(output, ctx.stylize(message, 'undefined'));
	      index = tmp;
	      if (output.length === maxLength) {
	        break;
	      }
	    }
	    ArrayPrototypePush(output, formatProperty(ctx, value, recurseTimes, key, kArrayType));
	    index++;
	  }
	  const remaining = value.length - index;
	  if (output.length !== maxLength) {
	    if (remaining > 0) {
	      const ending = remaining > 1 ? 's' : '';
	      const message = `<${remaining} empty item${ending}>`;
	      ArrayPrototypePush(output, ctx.stylize(message, 'undefined'));
	    }
	  } else if (remaining > 0) {
	    ArrayPrototypePush(output, remainingText(remaining));
	  }
	  return output;
	}

	function formatArrayBuffer(ctx, value) {
	  let buffer;
	  try {
	    buffer = new Uint8Array(value);
	  } catch {
	    return [ctx.stylize('(detached)', 'special')];
	  }
	  if (hexSlice === undefined)
	    hexSlice = uncurryThis(requireBuffer().Buffer.prototype.hexSlice);
	  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(
	    /(.{2})/g,
	    hexSlice(buffer, 0, MathMin(ctx.maxArrayLength, buffer.length)),
	    '$1 ',
	  ));
	  const remaining = buffer.length - ctx.maxArrayLength;
	  if (remaining > 0)
	    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
	  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];
	}

	function formatArray(ctx, value, recurseTimes) {
	  const valLen = value.length;
	  const len = MathMin(MathMax(0, ctx.maxArrayLength), valLen);

	  const remaining = valLen - len;
	  const output = [];
	  for (let i = 0; i < len; i++) {
	    // Special handle sparse arrays.
	    if (!ObjectPrototypeHasOwnProperty(value, i)) {
	      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
	    }
	    ArrayPrototypePush(output, formatProperty(ctx, value, recurseTimes, i, kArrayType));
	  }
	  if (remaining > 0) {
	    ArrayPrototypePush(output, remainingText(remaining));
	  }
	  return output;
	}

	function formatTypedArray(value, length, ctx, ignored, recurseTimes) {
	  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);
	  const remaining = value.length - maxLength;
	  const output = new Array(maxLength);
	  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?
	    formatNumber :
	    formatBigInt;
	  for (let i = 0; i < maxLength; ++i) {
	    output[i] = elementFormatter(ctx.stylize, value[i], ctx.numericSeparator);
	  }
	  if (remaining > 0) {
	    output[maxLength] = remainingText(remaining);
	  }
	  if (ctx.showHidden) {
	    // .buffer goes last, it's not a primitive like the others.
	    // All besides `BYTES_PER_ELEMENT` are actually getters.
	    ctx.indentationLvl += 2;
	    for (const key of [
	      'BYTES_PER_ELEMENT',
	      'length',
	      'byteLength',
	      'byteOffset',
	      'buffer',
	    ]) {
	      const str = formatValue(ctx, value[key], recurseTimes, true);
	      ArrayPrototypePush(output, `[${key}]: ${str}`);
	    }
	    ctx.indentationLvl -= 2;
	  }
	  return output;
	}

	function formatSet(value, ctx, ignored, recurseTimes) {
	  const length = value.size;
	  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);
	  const remaining = length - maxLength;
	  const output = [];
	  ctx.indentationLvl += 2;
	  let i = 0;
	  for (const v of value) {
	    if (i >= maxLength) break;
	    ArrayPrototypePush(output, formatValue(ctx, v, recurseTimes));
	    i++;
	  }
	  if (remaining > 0) {
	    ArrayPrototypePush(output, remainingText(remaining));
	  }
	  ctx.indentationLvl -= 2;
	  return output;
	}

	function formatMap(value, ctx, ignored, recurseTimes) {
	  const length = value.size;
	  const maxLength = MathMin(MathMax(0, ctx.maxArrayLength), length);
	  const remaining = length - maxLength;
	  const output = [];
	  ctx.indentationLvl += 2;
	  let i = 0;
	  for (const { 0: k, 1: v } of value) {
	    if (i >= maxLength) break;
	    ArrayPrototypePush(
	      output,
	      `${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`,
	    );
	    i++;
	  }
	  if (remaining > 0) {
	    ArrayPrototypePush(output, remainingText(remaining));
	  }
	  ctx.indentationLvl -= 2;
	  return output;
	}

	function formatSetIterInner(ctx, recurseTimes, entries, state) {
	  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);
	  const maxLength = MathMin(maxArrayLength, entries.length);
	  const output = new Array(maxLength);
	  ctx.indentationLvl += 2;
	  for (let i = 0; i < maxLength; i++) {
	    output[i] = formatValue(ctx, entries[i], recurseTimes);
	  }
	  ctx.indentationLvl -= 2;
	  if (state === kWeak && !ctx.sorted) {
	    // Sort all entries to have a halfway reliable output (if more entries than
	    // retrieved ones exist, we can not reliably return the same output) if the
	    // output is not sorted anyway.
	    ArrayPrototypeSort(output);
	  }
	  const remaining = entries.length - maxLength;
	  if (remaining > 0) {
	    ArrayPrototypePush(output, remainingText(remaining));
	  }
	  return output;
	}

	function formatMapIterInner(ctx, recurseTimes, entries, state) {
	  const maxArrayLength = MathMax(ctx.maxArrayLength, 0);
	  // Entries exist as [key1, val1, key2, val2, ...]
	  const len = entries.length / 2;
	  const remaining = len - maxArrayLength;
	  const maxLength = MathMin(maxArrayLength, len);
	  const output = new Array(maxLength);
	  let i = 0;
	  ctx.indentationLvl += 2;
	  if (state === kWeak) {
	    for (; i < maxLength; i++) {
	      const pos = i * 2;
	      output[i] =
	        `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
	    }
	    // Sort all entries to have a halfway reliable output (if more entries than
	    // retrieved ones exist, we can not reliably return the same output) if the
	    // output is not sorted anyway.
	    if (!ctx.sorted)
	      ArrayPrototypeSort(output);
	  } else {
	    for (; i < maxLength; i++) {
	      const pos = i * 2;
	      const res = [
	        formatValue(ctx, entries[pos], recurseTimes),
	        formatValue(ctx, entries[pos + 1], recurseTimes),
	      ];
	      output[i] = reduceToSingleString(
	        ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
	    }
	  }
	  ctx.indentationLvl -= 2;
	  if (remaining > 0) {
	    ArrayPrototypePush(output, remainingText(remaining));
	  }
	  return output;
	}

	function formatWeakCollection(ctx) {
	  return [ctx.stylize('<items unknown>', 'special')];
	}

	function formatWeakSet(ctx, value, recurseTimes) {
	  const entries = previewEntries(value);
	  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);
	}

	function formatWeakMap(ctx, value, recurseTimes) {
	  const entries = previewEntries(value);
	  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);
	}

	function formatIterator(braces, ctx, value, recurseTimes) {
	  const { 0: entries, 1: isKeyValue } = previewEntries(value, true);
	  if (isKeyValue) {
	    // Mark entry iterators as such.
	    braces[0] = RegExpPrototypeSymbolReplace(/ Iterator] {$/, braces[0], ' Entries] {');
	    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
	  }

	  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
	}

	function formatPromise(ctx, value, recurseTimes) {
	  let output;
	  const { 0: state, 1: result } = getPromiseDetails(value);
	  if (state === kPending) {
	    output = [ctx.stylize('<pending>', 'special')];
	  } else {
	    ctx.indentationLvl += 2;
	    const str = formatValue(ctx, result, recurseTimes);
	    ctx.indentationLvl -= 2;
	    output = [
	      state === kRejected ?
	        `${ctx.stylize('<rejected>', 'special')} ${str}` :
	        str,
	    ];
	  }
	  return output;
	}

	function formatProperty(ctx, value, recurseTimes, key, type, desc,
	                        original = value) {
	  let name, str;
	  let extra = ' ';
	  desc = desc || ObjectGetOwnPropertyDescriptor(value, key) ||
	    { value: value[key], enumerable: true };
	  if (desc.value !== undefined) {
	    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;
	    ctx.indentationLvl += diff;
	    str = formatValue(ctx, desc.value, recurseTimes);
	    if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
	      extra = `\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`;
	    }
	    ctx.indentationLvl -= diff;
	  } else if (desc.get !== undefined) {
	    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
	    const s = ctx.stylize;
	    const sp = 'special';
	    if (ctx.getters && (ctx.getters === true ||
	          (ctx.getters === 'get' && desc.set === undefined) ||
	          (ctx.getters === 'set' && desc.set !== undefined))) {
	      try {
	        const tmp = FunctionPrototypeCall(desc.get, original);
	        ctx.indentationLvl += 2;
	        if (tmp === null) {
	          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;
	        } else if (typeof tmp === 'object') {
	          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
	        } else {
	          const primitive = formatPrimitive(s, tmp, ctx);
	          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;
	        }
	        ctx.indentationLvl -= 2;
	      } catch (err) {
	        const message = `<Inspection threw (${err.message})>`;
	        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;
	      }
	    } else {
	      str = ctx.stylize(`[${label}]`, sp);
	    }
	  } else if (desc.set !== undefined) {
	    str = ctx.stylize('[Setter]', 'special');
	  } else {
	    str = ctx.stylize('undefined', 'undefined');
	  }
	  if (type === kArrayType) {
	    return str;
	  }
	  if (typeof key === 'symbol') {
	    const tmp = RegExpPrototypeSymbolReplace(
	      strEscapeSequencesReplacer,
	      SymbolPrototypeToString(key),
	      escapeFn,
	    );
	    name = `[${ctx.stylize(tmp, 'symbol')}]`;
	  } else if (key === '__proto__') {
	    name = "['__proto__']";
	  } else if (desc.enumerable === false) {
	    const tmp = RegExpPrototypeSymbolReplace(
	      strEscapeSequencesReplacer,
	      key,
	      escapeFn,
	    );
	    name = `[${tmp}]`;
	  } else if (RegExpPrototypeExec(keyStrRegExp, key) !== null) {
	    name = ctx.stylize(key, 'name');
	  } else {
	    name = ctx.stylize(strEscape(key), 'string');
	  }
	  return `${name}:${extra}${str}`;
	}

	function isBelowBreakLength(ctx, output, start, base) {
	  // Each entry is separated by at least a comma. Thus, we start with a total
	  // length of at least `output.length`. In addition, some cases have a
	  // whitespace in-between each other that is added to the total as well.
	  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth
	  // function. Check the performance overhead and make it an opt-in in case it's
	  // significant.
	  let totalLength = output.length + start;
	  if (totalLength + output.length > ctx.breakLength)
	    return false;
	  for (let i = 0; i < output.length; i++) {
	    if (ctx.colors) {
	      totalLength += removeColors(output[i]).length;
	    } else {
	      totalLength += output[i].length;
	    }
	    if (totalLength > ctx.breakLength) {
	      return false;
	    }
	  }
	  // Do not line up properties on the same line if `base` contains line breaks.
	  return base === '' || !StringPrototypeIncludes(base, '\n');
	}

	function reduceToSingleString(
	  ctx, output, base, braces, extrasType, recurseTimes, value) {
	  if (ctx.compact !== true) {
	    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
	      // Memorize the original output length. In case the output is grouped,
	      // prevent lining up the entries on a single line.
	      const entries = output.length;
	      // Group array elements together if the array contains at least six
	      // separate entries.
	      if (extrasType === kArrayExtrasType && entries > 6) {
	        output = groupArrayElements(ctx, output, value);
	      }
	      // `ctx.currentDepth` is set to the most inner depth of the currently
	      // inspected object part while `recurseTimes` is the actual current depth
	      // that is inspected.
	      //
	      // Example:
	      //
	      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
	      //
	      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
	      // depth of 1.
	      //
	      // Consolidate all entries of the local most inner depth up to
	      // `ctx.compact`, as long as the properties are smaller than
	      // `ctx.breakLength`.
	      if (ctx.currentDepth - recurseTimes < ctx.compact &&
	          entries === output.length) {
	        // Line up all entries on a single line in case the entries do not
	        // exceed `breakLength`. Add 10 as constant to start next to all other
	        // factors that may reduce `breakLength`.
	        const start = output.length + ctx.indentationLvl +
	                      braces[0].length + base.length + 10;
	        if (isBelowBreakLength(ctx, output, start, base)) {
	          const joinedOutput = join(output, ', ');
	          if (!StringPrototypeIncludes(joinedOutput, '\n')) {
	            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +
	              ` ${braces[1]}`;
	          }
	        }
	      }
	    }
	    // Line up each entry on an individual line.
	    const indentation = `\n${StringPrototypeRepeat(' ', ctx.indentationLvl)}`;
	    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +
	      `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
	  }
	  // Line up all entries on a single line in case the entries do not exceed
	  // `breakLength`.
	  if (isBelowBreakLength(ctx, output, 0, base)) {
	    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` +
	      braces[1];
	  }
	  const indentation = StringPrototypeRepeat(' ', ctx.indentationLvl);
	  // If the opening "brace" is too large, like in the case of "Set {",
	  // we need to force the first item to be on the next line or the
	  // items will not line up correctly.
	  const ln = base === '' && braces[0].length === 1 ?
	    ' ' : `${base ? ` ${base}` : ''}\n${indentation}  `;
	  // Line up each entry on an individual line.
	  return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;
	}

	function hasBuiltInToString(value) {
	  // Prevent triggering proxy traps.
	  const getFullProxy = false;
	  const proxyTarget = getProxyDetails(value, getFullProxy);
	  if (proxyTarget !== undefined) {
	    if (proxyTarget === null) {
	      return true;
	    }
	    value = proxyTarget;
	  }

	  // Count objects that have no `toString` function as built-in.
	  if (typeof value.toString !== 'function') {
	    return true;
	  }

	  // The object has a own `toString` property. Thus it's not not a built-in one.
	  if (ObjectPrototypeHasOwnProperty(value, 'toString')) {
	    return false;
	  }

	  // Find the object that has the `toString` property as own property in the
	  // prototype chain.
	  let pointer = value;
	  do {
	    pointer = ObjectGetPrototypeOf(pointer);
	  } while (!ObjectPrototypeHasOwnProperty(pointer, 'toString'));

	  // Check closer if the object is a built-in.
	  const descriptor = ObjectGetOwnPropertyDescriptor(pointer, 'constructor');
	  return descriptor !== undefined &&
	    typeof descriptor.value === 'function' &&
	    builtInObjects.has(descriptor.value.name);
	}

	const firstErrorLine = (error) => StringPrototypeSplit(error.message, '\n', 1)[0];
	let CIRCULAR_ERROR_MESSAGE;
	function tryStringify(arg) {
	  try {
	    return JSONStringify(arg);
	  } catch (err) {
	    // Populate the circular error message lazily
	    if (!CIRCULAR_ERROR_MESSAGE) {
	      try {
	        const a = {};
	        a.a = a;
	        JSONStringify(a);
	      } catch (circularError) {
	        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);
	      }
	    }
	    if (err.name === 'TypeError' &&
	        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
	      return '[Circular]';
	    }
	    throw err;
	  }
	}

	function format(...args) {
	  return formatWithOptionsInternal(undefined, args);
	}

	function formatWithOptions(inspectOptions, ...args) {
	  validateObject(inspectOptions, 'inspectOptions', { allowArray: true });
	  return formatWithOptionsInternal(inspectOptions, args);
	}

	function formatNumberNoColor(number, options) {
	  return formatNumber(
	    stylizeNoColor,
	    number,
	    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator,
	  );
	}

	function formatBigIntNoColor(bigint, options) {
	  return formatBigInt(
	    stylizeNoColor,
	    bigint,
	    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator,
	  );
	}

	function formatWithOptionsInternal(inspectOptions, args) {
	  const first = args[0];
	  let a = 0;
	  let str = '';
	  let join = '';

	  if (typeof first === 'string') {
	    if (args.length === 1) {
	      return first;
	    }
	    let tempStr;
	    let lastPos = 0;

	    for (let i = 0; i < first.length - 1; i++) {
	      if (StringPrototypeCharCodeAt(first, i) === 37) { // '%'
	        const nextChar = StringPrototypeCharCodeAt(first, ++i);
	        if (a + 1 !== args.length) {
	          switch (nextChar) {
	            case 115: { // 's'
	              const tempArg = args[++a];
	              if (typeof tempArg === 'number') {
	                tempStr = formatNumberNoColor(tempArg, inspectOptions);
	              } else if (typeof tempArg === 'bigint') {
	                tempStr = formatBigIntNoColor(tempArg, inspectOptions);
	              } else if (typeof tempArg !== 'object' ||
	                         tempArg === null ||
	                         !hasBuiltInToString(tempArg)) {
	                tempStr = String(tempArg);
	              } else {
	                tempStr = inspect(tempArg, {
	                  ...inspectOptions,
	                  compact: 3,
	                  colors: false,
	                  depth: 0,
	                });
	              }
	              break;
	            }
	            case 106: // 'j'
	              tempStr = tryStringify(args[++a]);
	              break;
	            case 100: { // 'd'
	              const tempNum = args[++a];
	              if (typeof tempNum === 'bigint') {
	                tempStr = formatBigIntNoColor(tempNum, inspectOptions);
	              } else if (typeof tempNum === 'symbol') {
	                tempStr = 'NaN';
	              } else {
	                tempStr = formatNumberNoColor(Number(tempNum), inspectOptions);
	              }
	              break;
	            }
	            case 79: // 'O'
	              tempStr = inspect(args[++a], inspectOptions);
	              break;
	            case 111: // 'o'
	              tempStr = inspect(args[++a], {
	                ...inspectOptions,
	                showHidden: true,
	                showProxy: true,
	                depth: 4,
	              });
	              break;
	            case 105: { // 'i'
	              const tempInteger = args[++a];
	              if (typeof tempInteger === 'bigint') {
	                tempStr = formatBigIntNoColor(tempInteger, inspectOptions);
	              } else if (typeof tempInteger === 'symbol') {
	                tempStr = 'NaN';
	              } else {
	                tempStr = formatNumberNoColor(
	                  NumberParseInt(tempInteger), inspectOptions);
	              }
	              break;
	            }
	            case 102: { // 'f'
	              const tempFloat = args[++a];
	              if (typeof tempFloat === 'symbol') {
	                tempStr = 'NaN';
	              } else {
	                tempStr = formatNumberNoColor(
	                  NumberParseFloat(tempFloat), inspectOptions);
	              }
	              break;
	            }
	            case 99: // 'c'
	              a += 1;
	              tempStr = '';
	              break;
	            case 37: // '%'
	              str += StringPrototypeSlice(first, lastPos, i);
	              lastPos = i + 1;
	              continue;
	            default: // Any other character is not a correct placeholder
	              continue;
	          }
	          if (lastPos !== i - 1) {
	            str += StringPrototypeSlice(first, lastPos, i - 1);
	          }
	          str += tempStr;
	          lastPos = i + 1;
	        } else if (nextChar === 37) {
	          str += StringPrototypeSlice(first, lastPos, i);
	          lastPos = i + 1;
	        }
	      }
	    }
	    if (lastPos !== 0) {
	      a++;
	      join = ' ';
	      if (lastPos < first.length) {
	        str += StringPrototypeSlice(first, lastPos);
	      }
	    }
	  }

	  while (a < args.length) {
	    const value = args[a];
	    str += join;
	    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
	    join = ' ';
	    a++;
	  }
	  return str;
	}

	function isZeroWidthCodePoint(code) {
	  return code <= 0x1F || // C0 control codes
	    (code >= 0x7F && code <= 0x9F) || // C1 control codes
	    (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks
	    (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters
	    // Combining Diacritical Marks for Symbols
	    (code >= 0x20D0 && code <= 0x20FF) ||
	    (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors
	    (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks
	    (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors
	}

	/* c8 ignore start */
	if (internalBinding('config').hasIntl) {
	  assert(false);
	  // Can't use node internals
	  // const icu = internalBinding('icu');
	  // // icu.getStringWidth(string, ambiguousAsFullWidth, expandEmojiSequence)
	  // // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;
	  // // TODO(BridgeAR): Expose the options to the user. That is probably the
	  // // best thing possible at the moment, since it's difficult to know what
	  // // the receiving end supports.
	  // getStringWidth = function getStringWidth(str, removeControlChars = true) {
	  //   let width = 0;

	  //   if (removeControlChars) {
	  //     str = stripVTControlCharacters(str);
	  //   }
	  //   for (let i = 0; i < str.length; i++) {
	  //     // Try to avoid calling into C++ by first handling the ASCII portion of
	  //     // the string. If it is fully ASCII, we skip the C++ part.
	  //     const code = str.charCodeAt(i);
	  //     if (code >= 127) {
	  //       width += icu.getStringWidth(StringPrototypeNormalize(StringPrototypeSlice(str, i), 'NFC'));
	  //       break;
	  //     }
	  //     width += code >= 32 ? 1 : 0;
	  //   }
	  //   return width;
	  // };
	  /* c8 ignore stop */
	} else {
	  /**
	   * Returns the number of columns required to display the given string.
	   */
	  getStringWidth = function getStringWidth(str, removeControlChars = true) {
	    let width = 0;

	    if (removeControlChars)
	      str = stripVTControlCharacters(str);
	    str = StringPrototypeNormalize(str, 'NFC');
	    for (const char of new SafeStringIterator(str)) {
	      const code = StringPrototypeCodePointAt(char, 0);
	      if (isFullWidthCodePoint(code)) {
	        width += 2;
	      } else if (!isZeroWidthCodePoint(code)) {
	        width++;
	      }
	    }

	    return width;
	  };

	  /**
	   * Returns true if the character represented by a given
	   * Unicode code point is full-width. Otherwise returns false.
	   */
	  const isFullWidthCodePoint = (code) => {
	    // Code points are partially derived from:
	    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt
	    return code >= 0x1100 && (
	      code <= 0x115f ||  // Hangul Jamo
	      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET
	      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET
	      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
	      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||
	      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
	      (code >= 0x3250 && code <= 0x4dbf) ||
	      // CJK Unified Ideographs .. Yi Radicals
	      (code >= 0x4e00 && code <= 0xa4c6) ||
	      // Hangul Jamo Extended-A
	      (code >= 0xa960 && code <= 0xa97c) ||
	      // Hangul Syllables
	      (code >= 0xac00 && code <= 0xd7a3) ||
	      // CJK Compatibility Ideographs
	      (code >= 0xf900 && code <= 0xfaff) ||
	      // Vertical Forms
	      (code >= 0xfe10 && code <= 0xfe19) ||
	      // CJK Compatibility Forms .. Small Form Variants
	      (code >= 0xfe30 && code <= 0xfe6b) ||
	      // Halfwidth and Fullwidth Forms
	      (code >= 0xff01 && code <= 0xff60) ||
	      (code >= 0xffe0 && code <= 0xffe6) ||
	      // Kana Supplement
	      (code >= 0x1b000 && code <= 0x1b001) ||
	      // Enclosed Ideographic Supplement
	      (code >= 0x1f200 && code <= 0x1f251) ||
	      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff
	      // Emoticons 0x1f600 - 0x1f64f
	      (code >= 0x1f300 && code <= 0x1f64f) ||
	      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
	      (code >= 0x20000 && code <= 0x3fffd)
	    );
	  };

	}

	/**
	 * Remove all VT control characters. Use to estimate displayed string width.
	 */
	function stripVTControlCharacters(str) {
	  validateString(str, 'str');
	  return RegExpPrototypeSymbolReplace(ansi, str, '');
	}

	const entities = {
	  34: '&quot;',
	  38: '&amp;',
	  39: '&apos;',
	  60: '&lt;',
	  62: '&gt;',
	  160: '&nbsp;',
	};

	function escapeHTML(str) {
	  return str.replace(
	    // eslint-disable-next-line no-control-regex
	    /[\u0000-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u00FF]/g,
	    (c) => {
	      const code = String(c.charCodeAt(0));
	      const ent = entities[code];
	      return ent || ('&#' + code + ';');
	    },
	  );
	}

	inspect_1 = {
	  identicalSequenceRange,
	  inspect,
	  inspectDefaultOptions,
	  format,
	  formatWithOptions,
	  getStringWidth,
	  stripVTControlCharacters,
	  isZeroWidthCodePoint,
	  stylizeWithColor,
	  stylizeWithHTML(str, styleType) {
	    const style = inspect.styles[styleType];
	    if (style !== undefined) {
	      return `<span style="color:${style};">${escapeHTML(str)}</span>`;
	    }
	    return escapeHTML(str);
	  },
	  Proxy,
	};
	return inspect_1;
}

var inspectExports = requireInspect$1();
var inspect$2 = /*@__PURE__*/getDefaultExportFromCjs(inspectExports);

const {
  // The commented out things are not visible from normal node's util.
  // identicalSequenceRange,
  inspect: inspect$1,
  // inspectDefaultOptions,
  format,
  formatWithOptions,
  // getStringWidth,
  stripVTControlCharacters,
  // isZeroWidthCodePoint,
  stylizeWithColor,
  stylizeWithHTML,
  Proxy: Proxy$1,
} = inspect$2;

function isBuffer(arg) {
  return (
    arg &&
    typeof arg === 'object' &&
    typeof arg.copy === 'function' &&
    typeof arg.fill === 'function' &&
    typeof arg.readUInt8 === 'function'
  )
}

// borrow from https://github.com/isaacs/inherits
function inherits(ctor, superCtor) {
  if (superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
  }
}

var util$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	format: format,
	inherits: inherits,
	inspect: inspect$1,
	isBuffer: isBuffer
});

var require$$13 = /*@__PURE__*/getAugmentedNamespace(util$3);

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$2;
	hasRequiredErrors$1 = 1;
	(function (exports) {
		// The whole point behind this internal module is to allow Node.js to no
		// longer be forced to treat every error message change as a semver-major
		// change. The NodeError classes here all expose a `code` property whose
		// value statically and permanently identifies the error. While the error
		// message may change, the code should not.
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AssertionError = exports.RangeError = exports.TypeError = exports.Error = void 0;
		exports.message = message;
		exports.E = E;
		const assert = requireAssert();
		const util = require$$13;
		const kCode = typeof Symbol === 'undefined' ? '_kCode' : Symbol('code');
		const messages = {}; // new Map();
		function makeNodeError(Base) {
		    return class NodeError extends Base {
		        constructor(key, ...args) {
		            super(message(key, args));
		            this.code = key;
		            this[kCode] = key;
		            this.name = `${super.name} [${this[kCode]}]`;
		        }
		    };
		}
		const g = typeof globalThis !== 'undefined' ? globalThis : commonjsGlobal$1;
		class AssertionError extends g.Error {
		    constructor(options) {
		        if (typeof options !== 'object' || options === null) {
		            throw new exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');
		        }
		        if (options.message) {
		            super(options.message);
		        }
		        else {
		            super(`${util.inspect(options.actual).slice(0, 128)} ` +
		                `${options.operator} ${util.inspect(options.expected).slice(0, 128)}`);
		        }
		        this.generatedMessage = !options.message;
		        this.name = 'AssertionError [ERR_ASSERTION]';
		        this.code = 'ERR_ASSERTION';
		        this.actual = options.actual;
		        this.expected = options.expected;
		        this.operator = options.operator;
		        exports.Error.captureStackTrace(this, options.stackStartFunction);
		    }
		}
		exports.AssertionError = AssertionError;
		function message(key, args) {
		    assert.strictEqual(typeof key, 'string');
		    // const msg = messages.get(key);
		    const msg = messages[key];
		    assert(msg, `An invalid error message key was used: ${key}.`);
		    let fmt;
		    if (typeof msg === 'function') {
		        fmt = msg;
		    }
		    else {
		        fmt = util.format;
		        if (args === undefined || args.length === 0)
		            return msg;
		        args.unshift(msg);
		    }
		    return String(fmt.apply(null, args));
		}
		// Utility function for registering the error codes. Only used here. Exported
		// *only* to allow for testing.
		function E(sym, val) {
		    messages[sym] = typeof val === 'function' ? val : String(val);
		}
		exports.Error = makeNodeError(g.Error);
		exports.TypeError = makeNodeError(g.TypeError);
		exports.RangeError = makeNodeError(g.RangeError);
		// To declare an error message, use the E(sym, val) function above. The sym
		// must be an upper case string. The val can be either a function or a string.
		// The return value of the function must be a string.
		// Examples:
		// E('EXAMPLE_KEY1', 'This is the error value');
		// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);
		//
		// Once an error code has been assigned, the code itself MUST NOT change and
		// any given error code must never be reused to identify a different error.
		//
		// Any error code added here should also be added to the documentation
		//
		// Note: Please try to keep these in alphabetical order
		E('ERR_ARG_NOT_ITERABLE', '%s must be iterable');
		E('ERR_ASSERTION', '%s');
		E('ERR_BUFFER_OUT_OF_BOUNDS', bufferOutOfBounds);
		E('ERR_CHILD_CLOSED_BEFORE_REPLY', 'Child closed before reply received');
		E('ERR_CONSOLE_WRITABLE_STREAM', 'Console expects a writable stream instance for %s');
		E('ERR_CPU_USAGE', 'Unable to obtain cpu usage %s');
		E('ERR_DNS_SET_SERVERS_FAILED', (err, servers) => `c-ares failed to set servers: "${err}" [${servers}]`);
		E('ERR_FALSY_VALUE_REJECTION', 'Promise was rejected with falsy value');
		E('ERR_ENCODING_NOT_SUPPORTED', enc => `The "${enc}" encoding is not supported`);
		E('ERR_ENCODING_INVALID_ENCODED_DATA', enc => `The encoded data was not valid for encoding ${enc}`);
		E('ERR_HTTP_HEADERS_SENT', 'Cannot render headers after they are sent to the client');
		E('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s');
		E('ERR_HTTP_TRAILER_INVALID', 'Trailers are invalid with this transfer encoding');
		E('ERR_INDEX_OUT_OF_RANGE', 'Index out of range');
		E('ERR_INVALID_ARG_TYPE', invalidArgType);
		E('ERR_INVALID_ARRAY_LENGTH', (name, len, actual) => {
		    assert.strictEqual(typeof actual, 'number');
		    return `The array "${name}" (length ${actual}) must be of length ${len}.`;
		});
		E('ERR_INVALID_BUFFER_SIZE', 'Buffer size must be a multiple of %s');
		E('ERR_INVALID_CALLBACK', 'Callback must be a function');
		E('ERR_INVALID_CHAR', 'Invalid character in %s');
		E('ERR_INVALID_CURSOR_POS', 'Cannot set cursor row without setting its column');
		E('ERR_INVALID_FD', '"fd" must be a positive integer: %s');
		E('ERR_INVALID_FILE_URL_HOST', 'File URL host must be "localhost" or empty on %s');
		E('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');
		E('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');
		E('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s');
		E('ERR_INVALID_OPT_VALUE', (name, value) => {
		    return `The value "${String(value)}" is invalid for option "${name}"`;
		});
		E('ERR_INVALID_OPT_VALUE_ENCODING', value => `The value "${String(value)}" is invalid for option "encoding"`);
		E('ERR_INVALID_REPL_EVAL_CONFIG', 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
		E('ERR_INVALID_SYNC_FORK_INPUT', 'Asynchronous forks do not support Buffer, Uint8Array or string input: %s');
		E('ERR_INVALID_THIS', 'Value of "this" must be of type %s');
		E('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');
		E('ERR_INVALID_URL', 'Invalid URL: %s');
		E('ERR_INVALID_URL_SCHEME', expected => `The URL must be ${oneOf(expected, 'scheme')}`);
		E('ERR_IPC_CHANNEL_CLOSED', 'Channel closed');
		E('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');
		E('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');
		E('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');
		E('ERR_MISSING_ARGS', missingArgs);
		E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
		E('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function');
		E('ERR_NAPI_CONS_PROTOTYPE_OBJECT', 'Constructor.prototype must be an object');
		E('ERR_NO_CRYPTO', 'Node.js is not compiled with OpenSSL crypto support');
		E('ERR_NO_LONGER_SUPPORTED', '%s is no longer supported');
		E('ERR_PARSE_HISTORY_DATA', 'Could not parse history data in %s');
		E('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');
		E('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');
		E('ERR_SOCKET_BAD_TYPE', 'Bad socket type specified. Valid types are: udp4, udp6');
		E('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');
		E('ERR_SOCKET_CLOSED', 'Socket is closed');
		E('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');
		E('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');
		E('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');
		E('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode');
		E('ERR_TLS_CERT_ALTNAME_INVALID', "Hostname/IP does not match certificate's altnames: %s");
		E('ERR_TLS_DH_PARAM_SIZE', size => `DH parameter size ${size} is less than 2048`);
		E('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout');
		E('ERR_TLS_RENEGOTIATION_FAILED', 'Failed to renegotiate');
		E('ERR_TLS_REQUIRED_SERVER_NAME', '"servername" is required parameter for Server.addContext');
		E('ERR_TLS_SESSION_ATTACK', 'TSL session renegotiation attack detected');
		E('ERR_TRANSFORM_ALREADY_TRANSFORMING', 'Calling transform done when still transforming');
		E('ERR_TRANSFORM_WITH_LENGTH_0', 'Calling transform done when writableState.length != 0');
		E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s');
		E('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s');
		E('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');
		E('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');
		E('ERR_V8BREAKITERATOR', 'Full ICU data not installed. ' + 'See https://github.com/nodejs/node/wiki/Intl');
		function invalidArgType(name, expected, actual) {
		    assert(name, 'name is required');
		    // determiner: 'must be' or 'must not be'
		    let determiner;
		    if (expected.includes('not ')) {
		        determiner = 'must not be';
		        expected = expected.split('not ')[1];
		    }
		    else {
		        determiner = 'must be';
		    }
		    let msg;
		    if (Array.isArray(name)) {
		        const names = name.map(val => `"${val}"`).join(', ');
		        msg = `The ${names} arguments ${determiner} ${oneOf(expected, 'type')}`;
		    }
		    else if (name.includes(' argument')) {
		        // for the case like 'first argument'
		        msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
		    }
		    else {
		        const type = name.includes('.') ? 'property' : 'argument';
		        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
		    }
		    // if actual value received, output it
		    if (arguments.length >= 3) {
		        msg += `. Received type ${actual !== null ? typeof actual : 'null'}`;
		    }
		    return msg;
		}
		function missingArgs(...args) {
		    assert(args.length > 0, 'At least one arg needs to be specified');
		    let msg = 'The ';
		    const len = args.length;
		    args = args.map(a => `"${a}"`);
		    switch (len) {
		        case 1:
		            msg += `${args[0]} argument`;
		            break;
		        case 2:
		            msg += `${args[0]} and ${args[1]} arguments`;
		            break;
		        default:
		            msg += args.slice(0, len - 1).join(', ');
		            msg += `, and ${args[len - 1]} arguments`;
		            break;
		    }
		    return `${msg} must be specified`;
		}
		function oneOf(expected, thing) {
		    assert(expected, 'expected is required');
		    assert(typeof thing === 'string', 'thing is required');
		    if (Array.isArray(expected)) {
		        const len = expected.length;
		        assert(len > 0, 'At least one expected value needs to be specified');
		        // tslint:disable-next-line
		        expected = expected.map(i => String(i));
		        if (len > 2) {
		            return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
		        }
		        else if (len === 2) {
		            return `one of ${thing} ${expected[0]} or ${expected[1]}`;
		        }
		        else {
		            return `of ${thing} ${expected[0]}`;
		        }
		    }
		    else {
		        return `of ${thing} ${String(expected)}`;
		    }
		}
		function bufferOutOfBounds(name, isWriting) {
		    if (isWriting) {
		        return 'Attempt to write outside buffer bounds';
		    }
		    else {
		        return `"${name}" is outside of buffer bounds`;
		    }
		}
		
	} (errors$2));
	return errors$2;
}

var hasRequiredEncoding;

function requireEncoding () {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.ENCODING_UTF8 = void 0;
		exports.assertEncoding = assertEncoding;
		exports.strToEncoding = strToEncoding;
		const buffer_1 = requireBuffer$1();
		const errors = requireErrors$1();
		exports.ENCODING_UTF8 = 'utf8';
		function assertEncoding(encoding) {
		    if (encoding && !buffer_1.Buffer.isEncoding(encoding))
		        throw new errors.TypeError('ERR_INVALID_OPT_VALUE_ENCODING', encoding);
		}
		function strToEncoding(str, encoding) {
		    if (!encoding || encoding === exports.ENCODING_UTF8)
		        return str; // UTF-8
		    if (encoding === 'buffer')
		        return new buffer_1.Buffer(str); // `buffer` encoding
		    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding
		}
		
	} (encoding));
	return encoding;
}

var hasRequiredDirent;

function requireDirent () {
	if (hasRequiredDirent) return Dirent;
	hasRequiredDirent = 1;
	Object.defineProperty(Dirent, "__esModule", { value: true });
	Dirent.Dirent = void 0;
	const constants_1 = requireConstants$2();
	const encoding_1 = requireEncoding();
	const { S_IFMT, S_IFDIR, S_IFREG, S_IFBLK, S_IFCHR, S_IFLNK, S_IFIFO, S_IFSOCK } = constants_1.constants;
	/**
	 * A directory entry, like `fs.Dirent`.
	 */
	let Dirent$1 = class Dirent {
	    constructor() {
	        this.name = '';
	        this.path = '';
	        this.parentPath = '';
	        this.mode = 0;
	    }
	    static build(link, encoding) {
	        const dirent = new Dirent();
	        const { mode } = link.getNode();
	        dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
	        dirent.mode = mode;
	        dirent.path = link.getParentPath();
	        dirent.parentPath = dirent.path;
	        return dirent;
	    }
	    _checkModeProperty(property) {
	        return (this.mode & S_IFMT) === property;
	    }
	    isDirectory() {
	        return this._checkModeProperty(S_IFDIR);
	    }
	    isFile() {
	        return this._checkModeProperty(S_IFREG);
	    }
	    isBlockDevice() {
	        return this._checkModeProperty(S_IFBLK);
	    }
	    isCharacterDevice() {
	        return this._checkModeProperty(S_IFCHR);
	    }
	    isSymbolicLink() {
	        return this._checkModeProperty(S_IFLNK);
	    }
	    isFIFO() {
	        return this._checkModeProperty(S_IFIFO);
	    }
	    isSocket() {
	        return this._checkModeProperty(S_IFSOCK);
	    }
	};
	Dirent.Dirent = Dirent$1;
	Dirent.default = Dirent$1;
	
	return Dirent;
}

var volume = {};

var pathBrowserify;
var hasRequiredPathBrowserify;

function requirePathBrowserify () {
	if (hasRequiredPathBrowserify) return pathBrowserify;
	hasRequiredPathBrowserify = 1;

	function assertPath(path) {
	  if (typeof path !== 'string') {
	    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
	  }
	}

	// Resolves . and .. elements in a path with directory names
	function normalizeStringPosix(path, allowAboveRoot) {
	  var res = '';
	  var lastSegmentLength = 0;
	  var lastSlash = -1;
	  var dots = 0;
	  var code;
	  for (var i = 0; i <= path.length; ++i) {
	    if (i < path.length)
	      code = path.charCodeAt(i);
	    else if (code === 47 /*/*/)
	      break;
	    else
	      code = 47 /*/*/;
	    if (code === 47 /*/*/) {
	      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
	        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
	          if (res.length > 2) {
	            var lastSlashIndex = res.lastIndexOf('/');
	            if (lastSlashIndex !== res.length - 1) {
	              if (lastSlashIndex === -1) {
	                res = '';
	                lastSegmentLength = 0;
	              } else {
	                res = res.slice(0, lastSlashIndex);
	                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
	              }
	              lastSlash = i;
	              dots = 0;
	              continue;
	            }
	          } else if (res.length === 2 || res.length === 1) {
	            res = '';
	            lastSegmentLength = 0;
	            lastSlash = i;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          if (res.length > 0)
	            res += '/..';
	          else
	            res = '..';
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (res.length > 0)
	          res += '/' + path.slice(lastSlash + 1, i);
	        else
	          res = path.slice(lastSlash + 1, i);
	        lastSegmentLength = i - lastSlash - 1;
	      }
	      lastSlash = i;
	      dots = 0;
	    } else if (code === 46 /*.*/ && dots !== -1) {
	      ++dots;
	    } else {
	      dots = -1;
	    }
	  }
	  return res;
	}

	function _format(sep, pathObject) {
	  var dir = pathObject.dir || pathObject.root;
	  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
	  if (!dir) {
	    return base;
	  }
	  if (dir === pathObject.root) {
	    return dir + base;
	  }
	  return dir + sep + base;
	}

	var posix = {
	  // path.resolve([from ...], to)
	  resolve: function resolve() {
	    var resolvedPath = '';
	    var resolvedAbsolute = false;
	    var cwd;

	    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	      var path;
	      if (i >= 0)
	        path = arguments[i];
	      else {
	        if (cwd === undefined)
	          cwd = process$1.cwd();
	        path = cwd;
	      }

	      assertPath(path);

	      // Skip empty entries
	      if (path.length === 0) {
	        continue;
	      }

	      resolvedPath = path + '/' + resolvedPath;
	      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
	    }

	    // At this point the path should be resolved to a full absolute path, but
	    // handle relative paths to be safe (might happen when process.cwd() fails)

	    // Normalize the path
	    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

	    if (resolvedAbsolute) {
	      if (resolvedPath.length > 0)
	        return '/' + resolvedPath;
	      else
	        return '/';
	    } else if (resolvedPath.length > 0) {
	      return resolvedPath;
	    } else {
	      return '.';
	    }
	  },

	  normalize: function normalize(path) {
	    assertPath(path);

	    if (path.length === 0) return '.';

	    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
	    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

	    // Normalize the path
	    path = normalizeStringPosix(path, !isAbsolute);

	    if (path.length === 0 && !isAbsolute) path = '.';
	    if (path.length > 0 && trailingSeparator) path += '/';

	    if (isAbsolute) return '/' + path;
	    return path;
	  },

	  isAbsolute: function isAbsolute(path) {
	    assertPath(path);
	    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
	  },

	  join: function join() {
	    if (arguments.length === 0)
	      return '.';
	    var joined;
	    for (var i = 0; i < arguments.length; ++i) {
	      var arg = arguments[i];
	      assertPath(arg);
	      if (arg.length > 0) {
	        if (joined === undefined)
	          joined = arg;
	        else
	          joined += '/' + arg;
	      }
	    }
	    if (joined === undefined)
	      return '.';
	    return posix.normalize(joined);
	  },

	  relative: function relative(from, to) {
	    assertPath(from);
	    assertPath(to);

	    if (from === to) return '';

	    from = posix.resolve(from);
	    to = posix.resolve(to);

	    if (from === to) return '';

	    // Trim any leading backslashes
	    var fromStart = 1;
	    for (; fromStart < from.length; ++fromStart) {
	      if (from.charCodeAt(fromStart) !== 47 /*/*/)
	        break;
	    }
	    var fromEnd = from.length;
	    var fromLen = fromEnd - fromStart;

	    // Trim any leading backslashes
	    var toStart = 1;
	    for (; toStart < to.length; ++toStart) {
	      if (to.charCodeAt(toStart) !== 47 /*/*/)
	        break;
	    }
	    var toEnd = to.length;
	    var toLen = toEnd - toStart;

	    // Compare paths to find the longest common path from root
	    var length = fromLen < toLen ? fromLen : toLen;
	    var lastCommonSep = -1;
	    var i = 0;
	    for (; i <= length; ++i) {
	      if (i === length) {
	        if (toLen > length) {
	          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
	            // We get here if `from` is the exact base path for `to`.
	            // For example: from='/foo/bar'; to='/foo/bar/baz'
	            return to.slice(toStart + i + 1);
	          } else if (i === 0) {
	            // We get here if `from` is the root
	            // For example: from='/'; to='/foo'
	            return to.slice(toStart + i);
	          }
	        } else if (fromLen > length) {
	          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
	            // We get here if `to` is the exact base path for `from`.
	            // For example: from='/foo/bar/baz'; to='/foo/bar'
	            lastCommonSep = i;
	          } else if (i === 0) {
	            // We get here if `to` is the root.
	            // For example: from='/foo'; to='/'
	            lastCommonSep = 0;
	          }
	        }
	        break;
	      }
	      var fromCode = from.charCodeAt(fromStart + i);
	      var toCode = to.charCodeAt(toStart + i);
	      if (fromCode !== toCode)
	        break;
	      else if (fromCode === 47 /*/*/)
	        lastCommonSep = i;
	    }

	    var out = '';
	    // Generate the relative path based on the path difference between `to`
	    // and `from`
	    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
	      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
	        if (out.length === 0)
	          out += '..';
	        else
	          out += '/..';
	      }
	    }

	    // Lastly, append the rest of the destination (`to`) path that comes after
	    // the common path parts
	    if (out.length > 0)
	      return out + to.slice(toStart + lastCommonSep);
	    else {
	      toStart += lastCommonSep;
	      if (to.charCodeAt(toStart) === 47 /*/*/)
	        ++toStart;
	      return to.slice(toStart);
	    }
	  },

	  _makeLong: function _makeLong(path) {
	    return path;
	  },

	  dirname: function dirname(path) {
	    assertPath(path);
	    if (path.length === 0) return '.';
	    var code = path.charCodeAt(0);
	    var hasRoot = code === 47 /*/*/;
	    var end = -1;
	    var matchedSlash = true;
	    for (var i = path.length - 1; i >= 1; --i) {
	      code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          if (!matchedSlash) {
	            end = i;
	            break;
	          }
	        } else {
	        // We saw the first non-path separator
	        matchedSlash = false;
	      }
	    }

	    if (end === -1) return hasRoot ? '/' : '.';
	    if (hasRoot && end === 1) return '//';
	    return path.slice(0, end);
	  },

	  basename: function basename(path, ext) {
	    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
	    assertPath(path);

	    var start = 0;
	    var end = -1;
	    var matchedSlash = true;
	    var i;

	    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
	      if (ext.length === path.length && ext === path) return '';
	      var extIdx = ext.length - 1;
	      var firstNonSlashEnd = -1;
	      for (i = path.length - 1; i >= 0; --i) {
	        var code = path.charCodeAt(i);
	        if (code === 47 /*/*/) {
	            // If we reached a path separator that was not part of a set of path
	            // separators at the end of the string, stop now
	            if (!matchedSlash) {
	              start = i + 1;
	              break;
	            }
	          } else {
	          if (firstNonSlashEnd === -1) {
	            // We saw the first non-path separator, remember this index in case
	            // we need it if the extension ends up not matching
	            matchedSlash = false;
	            firstNonSlashEnd = i + 1;
	          }
	          if (extIdx >= 0) {
	            // Try to match the explicit extension
	            if (code === ext.charCodeAt(extIdx)) {
	              if (--extIdx === -1) {
	                // We matched the extension, so mark this as the end of our path
	                // component
	                end = i;
	              }
	            } else {
	              // Extension does not match, so our result is the entire path
	              // component
	              extIdx = -1;
	              end = firstNonSlashEnd;
	            }
	          }
	        }
	      }

	      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
	      return path.slice(start, end);
	    } else {
	      for (i = path.length - 1; i >= 0; --i) {
	        if (path.charCodeAt(i) === 47 /*/*/) {
	            // If we reached a path separator that was not part of a set of path
	            // separators at the end of the string, stop now
	            if (!matchedSlash) {
	              start = i + 1;
	              break;
	            }
	          } else if (end === -1) {
	          // We saw the first non-path separator, mark this as the end of our
	          // path component
	          matchedSlash = false;
	          end = i + 1;
	        }
	      }

	      if (end === -1) return '';
	      return path.slice(start, end);
	    }
	  },

	  extname: function extname(path) {
	    assertPath(path);
	    var startDot = -1;
	    var startPart = 0;
	    var end = -1;
	    var matchedSlash = true;
	    // Track the state of characters (if any) we see before our first dot and
	    // after any path separator we find
	    var preDotState = 0;
	    for (var i = path.length - 1; i >= 0; --i) {
	      var code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          // If we reached a path separator that was not part of a set of path
	          // separators at the end of the string, stop now
	          if (!matchedSlash) {
	            startPart = i + 1;
	            break;
	          }
	          continue;
	        }
	      if (end === -1) {
	        // We saw the first non-path separator, mark this as the end of our
	        // extension
	        matchedSlash = false;
	        end = i + 1;
	      }
	      if (code === 46 /*.*/) {
	          // If this is our first dot, mark it as the start of our extension
	          if (startDot === -1)
	            startDot = i;
	          else if (preDotState !== 1)
	            preDotState = 1;
	      } else if (startDot !== -1) {
	        // We saw a non-dot and non-path separator before our dot, so we should
	        // have a good chance at having a non-empty extension
	        preDotState = -1;
	      }
	    }

	    if (startDot === -1 || end === -1 ||
	        // We saw a non-dot character immediately before the dot
	        preDotState === 0 ||
	        // The (right-most) trimmed path component is exactly '..'
	        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	      return '';
	    }
	    return path.slice(startDot, end);
	  },

	  format: function format(pathObject) {
	    if (pathObject === null || typeof pathObject !== 'object') {
	      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
	    }
	    return _format('/', pathObject);
	  },

	  parse: function parse(path) {
	    assertPath(path);

	    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
	    if (path.length === 0) return ret;
	    var code = path.charCodeAt(0);
	    var isAbsolute = code === 47 /*/*/;
	    var start;
	    if (isAbsolute) {
	      ret.root = '/';
	      start = 1;
	    } else {
	      start = 0;
	    }
	    var startDot = -1;
	    var startPart = 0;
	    var end = -1;
	    var matchedSlash = true;
	    var i = path.length - 1;

	    // Track the state of characters (if any) we see before our first dot and
	    // after any path separator we find
	    var preDotState = 0;

	    // Get non-dir info
	    for (; i >= start; --i) {
	      code = path.charCodeAt(i);
	      if (code === 47 /*/*/) {
	          // If we reached a path separator that was not part of a set of path
	          // separators at the end of the string, stop now
	          if (!matchedSlash) {
	            startPart = i + 1;
	            break;
	          }
	          continue;
	        }
	      if (end === -1) {
	        // We saw the first non-path separator, mark this as the end of our
	        // extension
	        matchedSlash = false;
	        end = i + 1;
	      }
	      if (code === 46 /*.*/) {
	          // If this is our first dot, mark it as the start of our extension
	          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
	        } else if (startDot !== -1) {
	        // We saw a non-dot and non-path separator before our dot, so we should
	        // have a good chance at having a non-empty extension
	        preDotState = -1;
	      }
	    }

	    if (startDot === -1 || end === -1 ||
	    // We saw a non-dot character immediately before the dot
	    preDotState === 0 ||
	    // The (right-most) trimmed path component is exactly '..'
	    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	      if (end !== -1) {
	        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
	      }
	    } else {
	      if (startPart === 0 && isAbsolute) {
	        ret.name = path.slice(1, startDot);
	        ret.base = path.slice(1, end);
	      } else {
	        ret.name = path.slice(startPart, startDot);
	        ret.base = path.slice(startPart, end);
	      }
	      ret.ext = path.slice(startDot, end);
	    }

	    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

	    return ret;
	  },

	  sep: '/',
	  delimiter: ':',
	  win32: null,
	  posix: null
	};

	posix.posix = posix;

	pathBrowserify = posix;
	return pathBrowserify;
}

var node = {};

var process = {};

var hasRequiredProcess;

function requireProcess () {
	if (hasRequiredProcess) return process;
	hasRequiredProcess = 1;
	// Here we mock the undefined `process` variable in case we are not in Node's environment.
	Object.defineProperty(process, "__esModule", { value: true });
	process.createProcess = createProcess;
	/**
	 * Looks to return a `process` object, if one is available.
	 *
	 * The undefined `process` is returned if defined;
	 * otherwise `require('process')` is attempted.
	 *
	 * If that fails, `undefined` is returned.
	 *
	 * @return {IProcess | undefined}
	 */
	const maybeReturnProcess = () => {
	    if (typeof process$1 !== 'undefined') {
	        return process$1;
	    }
	    try {
	        return requireBrowser$2();
	    }
	    catch (_a) {
	        return undefined;
	    }
	};
	function createProcess() {
	    const p = maybeReturnProcess() || {};
	    if (!p.cwd)
	        p.cwd = () => '/';
	    if (!p.emitWarning)
	        p.emitWarning = (message, type) => {
	            // tslint:disable-next-line:no-console
	            console.warn(`${type}${type ? ': ' : ''}${message}`);
	        };
	    if (!p.env)
	        p.env = {};
	    return p;
	}
	process.default = createProcess();
	
	return process;
}

var events = {exports: {}};

var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events.exports;
	hasRequiredEvents = 1;

	var R = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply = R && typeof R.apply === 'function'
	  ? R.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys;
	if (R && typeof R.ownKeys === 'function') {
	  ReflectOwnKeys = R.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}
	events.exports = EventEmitter;
	events.exports.once = once;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners = 10;

	function checkListener(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners = arg;
	  }
	});

	EventEmitter.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners(this);
	};

	EventEmitter.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning(w);
	    }
	  }

	  return target;
	}

	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function onceWrapper() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  checkListener(listener);
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener(listener);
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

	EventEmitter.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}

	EventEmitter.prototype.listeners = function listeners(type) {
	  return _listeners(this, type, true);
	};

	EventEmitter.prototype.rawListeners = function rawListeners(type) {
	  return _listeners(this, type, false);
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};

	function arrayClone(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}
	return events.exports;
}

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.File = exports.Link = exports.Node = exports.SEP = void 0;
		const process_1 = requireProcess();
		const buffer_1 = requireBuffer$1();
		const constants_1 = requireConstants$2();
		const events_1 = requireEvents();
		const Stats_1 = requireStats();
		const { S_IFMT, S_IFDIR, S_IFREG, S_IFLNK, S_IFCHR, O_APPEND } = constants_1.constants;
		const getuid = () => { var _a, _b; return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0; };
		const getgid = () => { var _a, _b; return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0; };
		exports.SEP = '/';
		/**
		 * Node in a file system (like i-node, v-node).
		 */
		class Node extends events_1.EventEmitter {
		    constructor(ino, mode = 0o666) {
		        super();
		        // User ID and group ID.
		        this._uid = getuid();
		        this._gid = getgid();
		        this._atime = new Date();
		        this._mtime = new Date();
		        this._ctime = new Date();
		        this.rdev = 0;
		        // Number of hard links pointing at this Node.
		        this._nlink = 1;
		        this.mode = mode;
		        this.ino = ino;
		    }
		    set ctime(ctime) {
		        this._ctime = ctime;
		    }
		    get ctime() {
		        return this._ctime;
		    }
		    set uid(uid) {
		        this._uid = uid;
		        this.ctime = new Date();
		    }
		    get uid() {
		        return this._uid;
		    }
		    set gid(gid) {
		        this._gid = gid;
		        this.ctime = new Date();
		    }
		    get gid() {
		        return this._gid;
		    }
		    set atime(atime) {
		        this._atime = atime;
		        this.ctime = new Date();
		    }
		    get atime() {
		        return this._atime;
		    }
		    set mtime(mtime) {
		        this._mtime = mtime;
		        this.ctime = new Date();
		    }
		    get mtime() {
		        return this._mtime;
		    }
		    get perm() {
		        return this.mode & ~S_IFMT;
		    }
		    set perm(perm) {
		        this.mode = (this.mode & S_IFMT) | (perm & ~S_IFMT);
		        this.ctime = new Date();
		    }
		    set nlink(nlink) {
		        this._nlink = nlink;
		        this.ctime = new Date();
		    }
		    get nlink() {
		        return this._nlink;
		    }
		    getString(encoding = 'utf8') {
		        this.atime = new Date();
		        return this.getBuffer().toString(encoding);
		    }
		    setString(str) {
		        // this.setBuffer(bufferFrom(str, 'utf8'));
		        this.buf = (0, buffer_1.bufferFrom)(str, 'utf8');
		        this.touch();
		    }
		    getBuffer() {
		        this.atime = new Date();
		        if (!this.buf)
		            this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
		        return (0, buffer_1.bufferFrom)(this.buf); // Return a copy.
		    }
		    setBuffer(buf) {
		        this.buf = (0, buffer_1.bufferFrom)(buf); // Creates a copy of data.
		        this.touch();
		    }
		    getSize() {
		        return this.buf ? this.buf.length : 0;
		    }
		    setModeProperty(property) {
		        this.mode = property;
		    }
		    isFile() {
		        return (this.mode & S_IFMT) === S_IFREG;
		    }
		    isDirectory() {
		        return (this.mode & S_IFMT) === S_IFDIR;
		    }
		    isSymlink() {
		        // return !!this.symlink;
		        return (this.mode & S_IFMT) === S_IFLNK;
		    }
		    isCharacterDevice() {
		        return (this.mode & S_IFMT) === S_IFCHR;
		    }
		    makeSymlink(symlink) {
		        this.mode = S_IFLNK | 0o666;
		        this.symlink = symlink;
		    }
		    write(buf, off = 0, len = buf.length, pos = 0) {
		        if (!this.buf)
		            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
		        if (pos + len > this.buf.length) {
		            const newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
		            this.buf.copy(newBuf, 0, 0, this.buf.length);
		            this.buf = newBuf;
		        }
		        buf.copy(this.buf, pos, off, off + len);
		        this.touch();
		        return len;
		    }
		    // Returns the number of bytes read.
		    read(buf, off = 0, len = buf.byteLength, pos = 0) {
		        this.atime = new Date();
		        if (!this.buf)
		            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
		        let actualLen = len;
		        if (actualLen > buf.byteLength) {
		            actualLen = buf.byteLength;
		        }
		        if (actualLen + pos > this.buf.length) {
		            actualLen = this.buf.length - pos;
		        }
		        const buf2 = buf instanceof buffer_1.Buffer ? buf : buffer_1.Buffer.from(buf.buffer);
		        this.buf.copy(buf2, off, pos, pos + actualLen);
		        return actualLen;
		    }
		    truncate(len = 0) {
		        if (!len)
		            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
		        else {
		            if (!this.buf)
		                this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
		            if (len <= this.buf.length) {
		                this.buf = this.buf.slice(0, len);
		            }
		            else {
		                const buf = (0, buffer_1.bufferAllocUnsafe)(len);
		                this.buf.copy(buf);
		                buf.fill(0, this.buf.length);
		                this.buf = buf;
		            }
		        }
		        this.touch();
		    }
		    chmod(perm) {
		        this.mode = (this.mode & S_IFMT) | (perm & ~S_IFMT);
		        this.touch();
		    }
		    chown(uid, gid) {
		        this.uid = uid;
		        this.gid = gid;
		        this.touch();
		    }
		    touch() {
		        this.mtime = new Date();
		        this.emit('change', this);
		    }
		    canRead(uid = getuid(), gid = getgid()) {
		        if (this.perm & 4 /* S.IROTH */) {
		            return true;
		        }
		        if (gid === this.gid) {
		            if (this.perm & 32 /* S.IRGRP */) {
		                return true;
		            }
		        }
		        if (uid === this.uid) {
		            if (this.perm & 256 /* S.IRUSR */) {
		                return true;
		            }
		        }
		        return false;
		    }
		    canWrite(uid = getuid(), gid = getgid()) {
		        if (this.perm & 2 /* S.IWOTH */) {
		            return true;
		        }
		        if (gid === this.gid) {
		            if (this.perm & 16 /* S.IWGRP */) {
		                return true;
		            }
		        }
		        if (uid === this.uid) {
		            if (this.perm & 128 /* S.IWUSR */) {
		                return true;
		            }
		        }
		        return false;
		    }
		    canExecute(uid = getuid(), gid = getgid()) {
		        if (this.perm & 1 /* S.IXOTH */) {
		            return true;
		        }
		        if (gid === this.gid) {
		            if (this.perm & 8 /* S.IXGRP */) {
		                return true;
		            }
		        }
		        if (uid === this.uid) {
		            if (this.perm & 64 /* S.IXUSR */) {
		                return true;
		            }
		        }
		        return false;
		    }
		    del() {
		        this.emit('delete', this);
		    }
		    toJSON() {
		        return {
		            ino: this.ino,
		            uid: this.uid,
		            gid: this.gid,
		            atime: this.atime.getTime(),
		            mtime: this.mtime.getTime(),
		            ctime: this.ctime.getTime(),
		            perm: this.perm,
		            mode: this.mode,
		            nlink: this.nlink,
		            symlink: this.symlink,
		            data: this.getString(),
		        };
		    }
		}
		exports.Node = Node;
		/**
		 * Represents a hard link that points to an i-node `node`.
		 */
		class Link extends events_1.EventEmitter {
		    get steps() {
		        return this._steps;
		    }
		    // Recursively sync children steps, e.g. in case of dir rename
		    set steps(val) {
		        this._steps = val;
		        for (const [child, link] of this.children.entries()) {
		            if (child === '.' || child === '..') {
		                continue;
		            }
		            link === null || link === void 0 ? void 0 : link.syncSteps();
		        }
		    }
		    constructor(vol, parent, name) {
		        super();
		        this.children = new Map();
		        // Path to this node as Array: ['usr', 'bin', 'node'].
		        this._steps = [];
		        // "i-node" number of the node.
		        this.ino = 0;
		        // Number of children.
		        this.length = 0;
		        this.vol = vol;
		        this.parent = parent;
		        this.name = name;
		        this.syncSteps();
		    }
		    setNode(node) {
		        this.node = node;
		        this.ino = node.ino;
		    }
		    getNode() {
		        return this.node;
		    }
		    createChild(name, node = this.vol.createNode(S_IFREG | 0o666)) {
		        const link = new Link(this.vol, this, name);
		        link.setNode(node);
		        if (node.isDirectory()) {
		            link.children.set('.', link);
		            link.getNode().nlink++;
		        }
		        this.setChild(name, link);
		        return link;
		    }
		    setChild(name, link = new Link(this.vol, this, name)) {
		        this.children.set(name, link);
		        link.parent = this;
		        this.length++;
		        const node = link.getNode();
		        if (node.isDirectory()) {
		            link.children.set('..', this);
		            this.getNode().nlink++;
		        }
		        this.getNode().mtime = new Date();
		        this.emit('child:add', link, this);
		        return link;
		    }
		    deleteChild(link) {
		        const node = link.getNode();
		        if (node.isDirectory()) {
		            link.children.delete('..');
		            this.getNode().nlink--;
		        }
		        this.children.delete(link.getName());
		        this.length--;
		        this.getNode().mtime = new Date();
		        this.emit('child:delete', link, this);
		    }
		    getChild(name) {
		        this.getNode().mtime = new Date();
		        return this.children.get(name);
		    }
		    getPath() {
		        return this.steps.join(exports.SEP);
		    }
		    getParentPath() {
		        return this.steps.slice(0, -1).join(exports.SEP);
		    }
		    getName() {
		        return this.steps[this.steps.length - 1];
		    }
		    // del() {
		    //     const parent = this.parent;
		    //     if(parent) {
		    //         parent.deleteChild(link);
		    //     }
		    //     this.parent = null;
		    //     this.vol = null;
		    // }
		    toJSON() {
		        return {
		            steps: this.steps,
		            ino: this.ino,
		            children: Array.from(this.children.keys()),
		        };
		    }
		    syncSteps() {
		        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
		    }
		}
		exports.Link = Link;
		/**
		 * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.
		 */
		class File {
		    /**
		     * Open a Link-Node pair. `node` is provided separately as that might be a different node
		     * rather the one `link` points to, because it might be a symlink.
		     * @param link
		     * @param node
		     * @param flags
		     * @param fd
		     */
		    constructor(link, node, flags, fd) {
		        this.link = link;
		        this.node = node;
		        this.flags = flags;
		        this.fd = fd;
		        this.position = 0;
		        if (this.flags & O_APPEND)
		            this.position = this.getSize();
		    }
		    getString(encoding = 'utf8') {
		        return this.node.getString();
		    }
		    setString(str) {
		        this.node.setString(str);
		    }
		    getBuffer() {
		        return this.node.getBuffer();
		    }
		    setBuffer(buf) {
		        this.node.setBuffer(buf);
		    }
		    getSize() {
		        return this.node.getSize();
		    }
		    truncate(len) {
		        this.node.truncate(len);
		    }
		    seekTo(position) {
		        this.position = position;
		    }
		    stats() {
		        return Stats_1.default.build(this.node);
		    }
		    write(buf, offset = 0, length = buf.length, position) {
		        if (typeof position !== 'number')
		            position = this.position;
		        const bytes = this.node.write(buf, offset, length, position);
		        this.position = position + bytes;
		        return bytes;
		    }
		    read(buf, offset = 0, length = buf.byteLength, position) {
		        if (typeof position !== 'number')
		            position = this.position;
		        const bytes = this.node.read(buf, offset, length, position);
		        this.position = position + bytes;
		        return bytes;
		    }
		    chmod(perm) {
		        this.node.chmod(perm);
		    }
		    chown(uid, gid) {
		        this.node.chown(uid, gid);
		    }
		}
		exports.File = File;
		
	} (node));
	return node;
}

var queueMicrotask$1 = {};

var hasRequiredQueueMicrotask;

function requireQueueMicrotask () {
	if (hasRequiredQueueMicrotask) return queueMicrotask$1;
	hasRequiredQueueMicrotask = 1;
	Object.defineProperty(queueMicrotask$1, "__esModule", { value: true });
	queueMicrotask$1.default = typeof queueMicrotask === 'function' ? queueMicrotask : (cb => Promise.resolve()
	    .then(() => cb())
	    .catch(() => { }));
	
	return queueMicrotask$1;
}

var setTimeoutUnref = {};

var hasRequiredSetTimeoutUnref;

function requireSetTimeoutUnref () {
	if (hasRequiredSetTimeoutUnref) return setTimeoutUnref;
	hasRequiredSetTimeoutUnref = 1;
	Object.defineProperty(setTimeoutUnref, "__esModule", { value: true });
	/**
	 * `setTimeoutUnref` is just like `setTimeout`,
	 * only in Node's environment it will "unref" its macro task.
	 */
	function setTimeoutUnref$1(callback, time, args) {
	    const ref = setTimeout.apply(typeof globalThis !== 'undefined' ? globalThis : commonjsGlobal$1, arguments);
	    if (ref && typeof ref === 'object' && typeof ref.unref === 'function')
	        ref.unref();
	    return ref;
	}
	setTimeoutUnref.default = setTimeoutUnref$1;
	
	return setTimeoutUnref;
}

var browser$1 = {exports: {}};

var stream = {exports: {}};

var primordials;
var hasRequiredPrimordials;

function requirePrimordials () {
	if (hasRequiredPrimordials) return primordials;
	hasRequiredPrimordials = 1;

	/*
	  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at

	  https://github.com/nodejs/node/blob/main/lib/internal/per_context/primordials.js

	  Don't try to replace with the original file and keep it up to date with the upstream file.
	*/

	// This is a simplified version of AggregateError
	class AggregateError extends Error {
	  constructor(errors) {
	    if (!Array.isArray(errors)) {
	      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)
	    }
	    let message = '';
	    for (let i = 0; i < errors.length; i++) {
	      message += `    ${errors[i].stack}\n`;
	    }
	    super(message);
	    this.name = 'AggregateError';
	    this.errors = errors;
	  }
	}
	primordials = {
	  AggregateError,
	  ArrayIsArray(self) {
	    return Array.isArray(self)
	  },
	  ArrayPrototypeIncludes(self, el) {
	    return self.includes(el)
	  },
	  ArrayPrototypeIndexOf(self, el) {
	    return self.indexOf(el)
	  },
	  ArrayPrototypeJoin(self, sep) {
	    return self.join(sep)
	  },
	  ArrayPrototypeMap(self, fn) {
	    return self.map(fn)
	  },
	  ArrayPrototypePop(self, el) {
	    return self.pop(el)
	  },
	  ArrayPrototypePush(self, el) {
	    return self.push(el)
	  },
	  ArrayPrototypeSlice(self, start, end) {
	    return self.slice(start, end)
	  },
	  Error,
	  FunctionPrototypeCall(fn, thisArgs, ...args) {
	    return fn.call(thisArgs, ...args)
	  },
	  FunctionPrototypeSymbolHasInstance(self, instance) {
	    return Function.prototype[Symbol.hasInstance].call(self, instance)
	  },
	  MathFloor: Math.floor,
	  Number,
	  NumberIsInteger: Number.isInteger,
	  NumberIsNaN: Number.isNaN,
	  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
	  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
	  NumberParseInt: Number.parseInt,
	  ObjectDefineProperties(self, props) {
	    return Object.defineProperties(self, props)
	  },
	  ObjectDefineProperty(self, name, prop) {
	    return Object.defineProperty(self, name, prop)
	  },
	  ObjectGetOwnPropertyDescriptor(self, name) {
	    return Object.getOwnPropertyDescriptor(self, name)
	  },
	  ObjectKeys(obj) {
	    return Object.keys(obj)
	  },
	  ObjectSetPrototypeOf(target, proto) {
	    return Object.setPrototypeOf(target, proto)
	  },
	  Promise,
	  PromisePrototypeCatch(self, fn) {
	    return self.catch(fn)
	  },
	  PromisePrototypeThen(self, thenFn, catchFn) {
	    return self.then(thenFn, catchFn)
	  },
	  PromiseReject(err) {
	    return Promise.reject(err)
	  },
	  PromiseResolve(val) {
	    return Promise.resolve(val)
	  },
	  ReflectApply: Reflect.apply,
	  RegExpPrototypeTest(self, value) {
	    return self.test(value)
	  },
	  SafeSet: Set,
	  String,
	  StringPrototypeSlice(self, start, end) {
	    return self.slice(start, end)
	  },
	  StringPrototypeToLowerCase(self) {
	    return self.toLowerCase()
	  },
	  StringPrototypeToUpperCase(self) {
	    return self.toUpperCase()
	  },
	  StringPrototypeTrim(self) {
	    return self.trim()
	  },
	  Symbol,
	  SymbolFor: Symbol.for,
	  SymbolAsyncIterator: Symbol.asyncIterator,
	  SymbolHasInstance: Symbol.hasInstance,
	  SymbolIterator: Symbol.iterator,
	  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),
	  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),
	  TypedArrayPrototypeSet(self, buf, len) {
	    return self.set(buf, len)
	  },
	  Boolean,
	  Uint8Array
	};
	return primordials;
}

var util$2 = {exports: {}};

var inspect;
var hasRequiredInspect;

function requireInspect () {
	if (hasRequiredInspect) return inspect;
	hasRequiredInspect = 1;

	/*
	  This file is a reduced and adapted version of the main lib/internal/util/inspect.js file defined at

	  https://github.com/nodejs/node/blob/main/lib/internal/util/inspect.js

	  Don't try to replace with the original file and keep it up to date with the upstream file.
	*/
	inspect = {
	  format(format, ...args) {
	    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args
	    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {
	      const replacement = args.shift();
	      if (type === 'f') {
	        return replacement.toFixed(6)
	      } else if (type === 'j') {
	        return JSON.stringify(replacement)
	      } else if (type === 's' && typeof replacement === 'object') {
	        const ctor = replacement.constructor !== Object ? replacement.constructor.name : '';
	        return `${ctor} {}`.trim()
	      } else {
	        return replacement.toString()
	      }
	    })
	  },
	  inspect(value) {
	    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options
	    switch (typeof value) {
	      case 'string':
	        if (value.includes("'")) {
	          if (!value.includes('"')) {
	            return `"${value}"`
	          } else if (!value.includes('`') && !value.includes('${')) {
	            return `\`${value}\``
	          }
	        }
	        return `'${value}'`
	      case 'number':
	        if (isNaN(value)) {
	          return 'NaN'
	        } else if (Object.is(value, -0)) {
	          return String(value)
	        }
	        return value
	      case 'bigint':
	        return `${String(value)}n`
	      case 'boolean':
	      case 'undefined':
	        return String(value)
	      case 'object':
	        return '{}'
	    }
	  }
	};
	return inspect;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	const { format, inspect } = requireInspect();
	const { AggregateError: CustomAggregateError } = requirePrimordials();

	/*
	  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at

	  https://github.com/nodejs/node/blob/main/lib/internal/errors.js

	  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)
	  with the upstream file.
	*/

	const AggregateError = globalThis.AggregateError || CustomAggregateError;
	const kIsNodeError = Symbol('kIsNodeError');
	const kTypes = [
	  'string',
	  'function',
	  'number',
	  'object',
	  // Accept 'Function' and 'Object' as alternative to the lower cased version.
	  'Function',
	  'Object',
	  'boolean',
	  'bigint',
	  'symbol'
	];
	const classRegExp = /^([A-Z][a-z0-9]*)+$/;
	const nodeInternalPrefix = '__node_internal_';
	const codes = {};
	function assert(value, message) {
	  if (!value) {
	    throw new codes.ERR_INTERNAL_ASSERTION(message)
	  }
	}

	// Only use this for integers! Decimal numbers do not work with this function.
	function addNumericalSeparator(val) {
	  let res = '';
	  let i = val.length;
	  const start = val[0] === '-' ? 1 : 0;
	  for (; i >= start + 4; i -= 3) {
	    res = `_${val.slice(i - 3, i)}${res}`;
	  }
	  return `${val.slice(0, i)}${res}`
	}
	function getMessage(key, msg, args) {
	  if (typeof msg === 'function') {
	    assert(
	      msg.length <= args.length,
	      // Default options do not count.
	      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
	    );
	    return msg(...args)
	  }
	  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
	  assert(
	    expectedLength === args.length,
	    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
	  );
	  if (args.length === 0) {
	    return msg
	  }
	  return format(msg, ...args)
	}
	function E(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }
	  class NodeError extends Base {
	    constructor(...args) {
	      super(getMessage(code, message, args));
	    }
	    toString() {
	      return `${this.name} [${code}]: ${this.message}`
	    }
	  }
	  Object.defineProperties(NodeError.prototype, {
	    name: {
	      value: Base.name,
	      writable: true,
	      enumerable: false,
	      configurable: true
	    },
	    toString: {
	      value() {
	        return `${this.name} [${code}]: ${this.message}`
	      },
	      writable: true,
	      enumerable: false,
	      configurable: true
	    }
	  });
	  NodeError.prototype.code = code;
	  NodeError.prototype[kIsNodeError] = true;
	  codes[code] = NodeError;
	}
	function hideStackFrames(fn) {
	  // We rename the functions that will be hidden to cut off the stacktrace
	  // at the outermost one
	  const hidden = nodeInternalPrefix + fn.name;
	  Object.defineProperty(fn, 'name', {
	    value: hidden
	  });
	  return fn
	}
	function aggregateTwoErrors(innerError, outerError) {
	  if (innerError && outerError && innerError !== outerError) {
	    if (Array.isArray(outerError.errors)) {
	      // If `outerError` is already an `AggregateError`.
	      outerError.errors.push(innerError);
	      return outerError
	    }
	    const err = new AggregateError([outerError, innerError], outerError.message);
	    err.code = outerError.code;
	    return err
	  }
	  return innerError || outerError
	}
	class AbortError extends Error {
	  constructor(message = 'The operation was aborted', options = undefined) {
	    if (options !== undefined && typeof options !== 'object') {
	      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)
	    }
	    super(message, options);
	    this.code = 'ABORT_ERR';
	    this.name = 'AbortError';
	  }
	}
	E('ERR_ASSERTION', '%s', Error);
	E(
	  'ERR_INVALID_ARG_TYPE',
	  (name, expected, actual) => {
	    assert(typeof name === 'string', "'name' must be a string");
	    if (!Array.isArray(expected)) {
	      expected = [expected];
	    }
	    let msg = 'The ';
	    if (name.endsWith(' argument')) {
	      // For cases like 'first argument'
	      msg += `${name} `;
	    } else {
	      msg += `"${name}" ${name.includes('.') ? 'property' : 'argument'} `;
	    }
	    msg += 'must be ';
	    const types = [];
	    const instances = [];
	    const other = [];
	    for (const value of expected) {
	      assert(typeof value === 'string', 'All expected entries have to be of type string');
	      if (kTypes.includes(value)) {
	        types.push(value.toLowerCase());
	      } else if (classRegExp.test(value)) {
	        instances.push(value);
	      } else {
	        assert(value !== 'object', 'The value "object" should be written as "Object"');
	        other.push(value);
	      }
	    }

	    // Special handle `object` in case other instances are allowed to outline
	    // the differences between each other.
	    if (instances.length > 0) {
	      const pos = types.indexOf('object');
	      if (pos !== -1) {
	        types.splice(types, pos, 1);
	        instances.push('Object');
	      }
	    }
	    if (types.length > 0) {
	      switch (types.length) {
	        case 1:
	          msg += `of type ${types[0]}`;
	          break
	        case 2:
	          msg += `one of type ${types[0]} or ${types[1]}`;
	          break
	        default: {
	          const last = types.pop();
	          msg += `one of type ${types.join(', ')}, or ${last}`;
	        }
	      }
	      if (instances.length > 0 || other.length > 0) {
	        msg += ' or ';
	      }
	    }
	    if (instances.length > 0) {
	      switch (instances.length) {
	        case 1:
	          msg += `an instance of ${instances[0]}`;
	          break
	        case 2:
	          msg += `an instance of ${instances[0]} or ${instances[1]}`;
	          break
	        default: {
	          const last = instances.pop();
	          msg += `an instance of ${instances.join(', ')}, or ${last}`;
	        }
	      }
	      if (other.length > 0) {
	        msg += ' or ';
	      }
	    }
	    switch (other.length) {
	      case 0:
	        break
	      case 1:
	        if (other[0].toLowerCase() !== other[0]) {
	          msg += 'an ';
	        }
	        msg += `${other[0]}`;
	        break
	      case 2:
	        msg += `one of ${other[0]} or ${other[1]}`;
	        break
	      default: {
	        const last = other.pop();
	        msg += `one of ${other.join(', ')}, or ${last}`;
	      }
	    }
	    if (actual == null) {
	      msg += `. Received ${actual}`;
	    } else if (typeof actual === 'function' && actual.name) {
	      msg += `. Received function ${actual.name}`;
	    } else if (typeof actual === 'object') {
	      var _actual$constructor;
	      if (
	        (_actual$constructor = actual.constructor) !== null &&
	        _actual$constructor !== undefined &&
	        _actual$constructor.name
	      ) {
	        msg += `. Received an instance of ${actual.constructor.name}`;
	      } else {
	        const inspected = inspect(actual, {
	          depth: -1
	        });
	        msg += `. Received ${inspected}`;
	      }
	    } else {
	      let inspected = inspect(actual, {
	        colors: false
	      });
	      if (inspected.length > 25) {
	        inspected = `${inspected.slice(0, 25)}...`;
	      }
	      msg += `. Received type ${typeof actual} (${inspected})`;
	    }
	    return msg
	  },
	  TypeError
	);
	E(
	  'ERR_INVALID_ARG_VALUE',
	  (name, value, reason = 'is invalid') => {
	    let inspected = inspect(value);
	    if (inspected.length > 128) {
	      inspected = inspected.slice(0, 128) + '...';
	    }
	    const type = name.includes('.') ? 'property' : 'argument';
	    return `The ${type} '${name}' ${reason}. Received ${inspected}`
	  },
	  TypeError
	);
	E(
	  'ERR_INVALID_RETURN_VALUE',
	  (input, name, value) => {
	    var _value$constructor;
	    const type =
	      value !== null &&
	      value !== undefined &&
	      (_value$constructor = value.constructor) !== null &&
	      _value$constructor !== undefined &&
	      _value$constructor.name
	        ? `instance of ${value.constructor.name}`
	        : `type ${typeof value}`;
	    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`
	  },
	  TypeError
	);
	E(
	  'ERR_MISSING_ARGS',
	  (...args) => {
	    assert(args.length > 0, 'At least one arg needs to be specified');
	    let msg;
	    const len = args.length;
	    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(' or ');
	    switch (len) {
	      case 1:
	        msg += `The ${args[0]} argument`;
	        break
	      case 2:
	        msg += `The ${args[0]} and ${args[1]} arguments`;
	        break
	      default:
	        {
	          const last = args.pop();
	          msg += `The ${args.join(', ')}, and ${last} arguments`;
	        }
	        break
	    }
	    return `${msg} must be specified`
	  },
	  TypeError
	);
	E(
	  'ERR_OUT_OF_RANGE',
	  (str, range, input) => {
	    assert(range, 'Missing "range" argument');
	    let received;
	    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
	      received = addNumericalSeparator(String(input));
	    } else if (typeof input === 'bigint') {
	      received = String(input);
	      const limit = BigInt(2) ** BigInt(32);
	      if (input > limit || input < -limit) {
	        received = addNumericalSeparator(received);
	      }
	      received += 'n';
	    } else {
	      received = inspect(input);
	    }
	    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`
	  },
	  RangeError
	);
	E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);
	E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);
	E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error);
	E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);
	E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);
	E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);
	E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);
	E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error);
	E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);
	E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);
	errors = {
	  AbortError,
	  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
	  hideStackFrames,
	  codes
	};
	return errors;
}

var browser = {exports: {}};

/*globals self, window */

var hasRequiredBrowser$1;

function requireBrowser$1 () {
	if (hasRequiredBrowser$1) return browser.exports;
	hasRequiredBrowser$1 = 1;

	/*eslint-disable @mysticatea/prettier */
	const { AbortController, AbortSignal } =
	    typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    /* otherwise */ undefined;
	/*eslint-enable @mysticatea/prettier */

	browser.exports = AbortController;
	browser.exports.AbortSignal = AbortSignal;
	browser.exports.default = AbortController;
	return browser.exports;
}

var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2.exports;
	hasRequiredUtil$2 = 1;
	(function (module) {

		const bufferModule = require$$0$2;
		const { format, inspect } = requireInspect();
		const {
		  codes: { ERR_INVALID_ARG_TYPE }
		} = requireErrors();
		const { kResistStopPropagation, AggregateError, SymbolDispose } = requirePrimordials();
		const AbortSignal = globalThis.AbortSignal || requireBrowser$1().AbortSignal;
		const AbortController = globalThis.AbortController || requireBrowser$1().AbortController;
		const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
		const Blob = globalThis.Blob || bufferModule.Blob;
		/* eslint-disable indent */
		const isBlob =
		  typeof Blob !== 'undefined'
		    ? function isBlob(b) {
		        // eslint-disable-next-line indent
		        return b instanceof Blob
		      }
		    : function isBlob(b) {
		        return false
		      };
		/* eslint-enable indent */

		const validateAbortSignal = (signal, name) => {
		  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
		    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
		  }
		};
		const validateFunction = (value, name) => {
		  if (typeof value !== 'function') {
		    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
		  }
		};
		module.exports = {
		  AggregateError,
		  kEmptyObject: Object.freeze({}),
		  once(callback) {
		    let called = false;
		    return function (...args) {
		      if (called) {
		        return
		      }
		      called = true;
		      callback.apply(this, args);
		    }
		  },
		  createDeferredPromise: function () {
		    let resolve;
		    let reject;

		    // eslint-disable-next-line promise/param-names
		    const promise = new Promise((res, rej) => {
		      resolve = res;
		      reject = rej;
		    });
		    return {
		      promise,
		      resolve,
		      reject
		    }
		  },
		  promisify(fn) {
		    return new Promise((resolve, reject) => {
		      fn((err, ...args) => {
		        if (err) {
		          return reject(err)
		        }
		        return resolve(...args)
		      });
		    })
		  },
		  debuglog() {
		    return function () {}
		  },
		  format,
		  inspect,
		  types: {
		    isAsyncFunction(fn) {
		      return fn instanceof AsyncFunction
		    },
		    isArrayBufferView(arr) {
		      return ArrayBuffer.isView(arr)
		    }
		  },
		  isBlob,
		  deprecate(fn, message) {
		    return fn
		  },
		  addAbortListener:
		    requireEvents().addAbortListener ||
		    function addAbortListener(signal, listener) {
		      if (signal === undefined) {
		        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)
		      }
		      validateAbortSignal(signal, 'signal');
		      validateFunction(listener, 'listener');
		      let removeEventListener;
		      if (signal.aborted) {
		        queueMicrotask(() => listener());
		      } else {
		        signal.addEventListener('abort', listener, {
		          __proto__: null,
		          once: true,
		          [kResistStopPropagation]: true
		        });
		        removeEventListener = () => {
		          signal.removeEventListener('abort', listener);
		        };
		      }
		      return {
		        __proto__: null,
		        [SymbolDispose]() {
		          var _removeEventListener
		          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined
		            ? undefined
		            : _removeEventListener();
		        }
		      }
		    },
		  AbortSignalAny:
		    AbortSignal.any ||
		    function AbortSignalAny(signals) {
		      // Fast path if there is only one signal.
		      if (signals.length === 1) {
		        return signals[0]
		      }
		      const ac = new AbortController();
		      const abort = () => ac.abort();
		      signals.forEach((signal) => {
		        validateAbortSignal(signal, 'signals');
		        signal.addEventListener('abort', abort, {
		          once: true
		        });
		      });
		      ac.signal.addEventListener(
		        'abort',
		        () => {
		          signals.forEach((signal) => signal.removeEventListener('abort', abort));
		        },
		        {
		          once: true
		        }
		      );
		      return ac.signal
		    }
		};
		module.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom'); 
	} (util$2));
	return util$2.exports;
}

var operators = {};

/* eslint jsdoc/require-jsdoc: "error" */

var validators;
var hasRequiredValidators;

function requireValidators () {
	if (hasRequiredValidators) return validators;
	hasRequiredValidators = 1;

	const {
	  ArrayIsArray,
	  ArrayPrototypeIncludes,
	  ArrayPrototypeJoin,
	  ArrayPrototypeMap,
	  NumberIsInteger,
	  NumberIsNaN,
	  NumberMAX_SAFE_INTEGER,
	  NumberMIN_SAFE_INTEGER,
	  NumberParseInt,
	  ObjectPrototypeHasOwnProperty,
	  RegExpPrototypeExec,
	  String,
	  StringPrototypeToUpperCase,
	  StringPrototypeTrim
	} = requirePrimordials();
	const {
	  hideStackFrames,
	  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
	} = requireErrors();
	const { normalizeEncoding } = requireUtil$2();
	const { isAsyncFunction, isArrayBufferView } = requireUtil$2().types;
	const signals = {};

	/**
	 * @param {*} value
	 * @returns {boolean}
	 */
	function isInt32(value) {
	  return value === (value | 0)
	}

	/**
	 * @param {*} value
	 * @returns {boolean}
	 */
	function isUint32(value) {
	  return value === value >>> 0
	}
	const octalReg = /^[0-7]+$/;
	const modeDesc = 'must be a 32-bit unsigned integer or an octal string';

	/**
	 * Parse and validate values that will be converted into mode_t (the S_*
	 * constants). Only valid numbers and octal strings are allowed. They could be
	 * converted to 32-bit unsigned integers or non-negative signed integers in the
	 * C++ land, but any value higher than 0o777 will result in platform-specific
	 * behaviors.
	 * @param {*} value Values to be validated
	 * @param {string} name Name of the argument
	 * @param {number} [def] If specified, will be returned for invalid values
	 * @returns {number}
	 */
	function parseFileMode(value, name, def) {
	  if (typeof value === 'undefined') {
	    value = def;
	  }
	  if (typeof value === 'string') {
	    if (RegExpPrototypeExec(octalReg, value) === null) {
	      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)
	    }
	    value = NumberParseInt(value, 8);
	  }
	  validateUint32(value, name);
	  return value
	}

	/**
	 * @callback validateInteger
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [min]
	 * @param {number} [max]
	 * @returns {asserts value is number}
	 */

	/** @type {validateInteger} */
	const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
	  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
	  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
	});

	/**
	 * @callback validateInt32
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [min]
	 * @param {number} [max]
	 * @returns {asserts value is number}
	 */

	/** @type {validateInt32} */
	const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
	  // The defaults for min and max correspond to the limits of 32-bit integers.
	  if (typeof value !== 'number') {
	    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  }
	  if (!NumberIsInteger(value)) {
	    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
	  }
	  if (value < min || value > max) {
	    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
	  }
	});

	/**
	 * @callback validateUint32
	 * @param {*} value
	 * @param {string} name
	 * @param {number|boolean} [positive=false]
	 * @returns {asserts value is number}
	 */

	/** @type {validateUint32} */
	const validateUint32 = hideStackFrames((value, name, positive = false) => {
	  if (typeof value !== 'number') {
	    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  }
	  if (!NumberIsInteger(value)) {
	    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
	  }
	  const min = positive ? 1 : 0;
	  // 2 ** 32 === 4294967296
	  const max = 4294967295;
	  if (value < min || value > max) {
	    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
	  }
	});

	/**
	 * @callback validateString
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is string}
	 */

	/** @type {validateString} */
	function validateString(value, name) {
	  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)
	}

	/**
	 * @callback validateNumber
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [min]
	 * @param {number} [max]
	 * @returns {asserts value is number}
	 */

	/** @type {validateNumber} */
	function validateNumber(value, name, min = undefined, max) {
	  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  if (
	    (min != null && value < min) ||
	    (max != null && value > max) ||
	    ((min != null || max != null) && NumberIsNaN(value))
	  ) {
	    throw new ERR_OUT_OF_RANGE(
	      name,
	      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
	      value
	    )
	  }
	}

	/**
	 * @callback validateOneOf
	 * @template T
	 * @param {T} value
	 * @param {string} name
	 * @param {T[]} oneOf
	 */

	/** @type {validateOneOf} */
	const validateOneOf = hideStackFrames((value, name, oneOf) => {
	  if (!ArrayPrototypeIncludes(oneOf, value)) {
	    const allowed = ArrayPrototypeJoin(
	      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),
	      ', '
	    );
	    const reason = 'must be one of: ' + allowed;
	    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
	  }
	});

	/**
	 * @callback validateBoolean
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is boolean}
	 */

	/** @type {validateBoolean} */
	function validateBoolean(value, name) {
	  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)
	}

	/**
	 * @param {any} options
	 * @param {string} key
	 * @param {boolean} defaultValue
	 * @returns {boolean}
	 */
	function getOwnPropertyValueOrDefault(options, key, defaultValue) {
	  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]
	}

	/**
	 * @callback validateObject
	 * @param {*} value
	 * @param {string} name
	 * @param {{
	 *   allowArray?: boolean,
	 *   allowFunction?: boolean,
	 *   nullable?: boolean
	 * }} [options]
	 */

	/** @type {validateObject} */
	const validateObject = hideStackFrames((value, name, options = null) => {
	  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false);
	  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false);
	  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false);
	  if (
	    (!nullable && value === null) ||
	    (!allowArray && ArrayIsArray(value)) ||
	    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))
	  ) {
	    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)
	  }
	});

	/**
	 * @callback validateDictionary - We are using the Web IDL Standard definition
	 *                                of "dictionary" here, which means any value
	 *                                whose Type is either Undefined, Null, or
	 *                                Object (which includes functions).
	 * @param {*} value
	 * @param {string} name
	 * @see https://webidl.spec.whatwg.org/#es-dictionary
	 * @see https://tc39.es/ecma262/#table-typeof-operator-results
	 */

	/** @type {validateDictionary} */
	const validateDictionary = hideStackFrames((value, name) => {
	  if (value != null && typeof value !== 'object' && typeof value !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)
	  }
	});

	/**
	 * @callback validateArray
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [minLength]
	 * @returns {asserts value is any[]}
	 */

	/** @type {validateArray} */
	const validateArray = hideStackFrames((value, name, minLength = 0) => {
	  if (!ArrayIsArray(value)) {
	    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)
	  }
	  if (value.length < minLength) {
	    const reason = `must be longer than ${minLength}`;
	    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
	  }
	});

	/**
	 * @callback validateStringArray
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is string[]}
	 */

	/** @type {validateStringArray} */
	function validateStringArray(value, name) {
	  validateArray(value, name);
	  for (let i = 0; i < value.length; i++) {
	    validateString(value[i], `${name}[${i}]`);
	  }
	}

	/**
	 * @callback validateBooleanArray
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is boolean[]}
	 */

	/** @type {validateBooleanArray} */
	function validateBooleanArray(value, name) {
	  validateArray(value, name);
	  for (let i = 0; i < value.length; i++) {
	    validateBoolean(value[i], `${name}[${i}]`);
	  }
	}

	/**
	 * @callback validateAbortSignalArray
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is AbortSignal[]}
	 */

	/** @type {validateAbortSignalArray} */
	function validateAbortSignalArray(value, name) {
	  validateArray(value, name);
	  for (let i = 0; i < value.length; i++) {
	    const signal = value[i];
	    const indexedName = `${name}[${i}]`;
	    if (signal == null) {
	      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)
	    }
	    validateAbortSignal(signal, indexedName);
	  }
	}

	/**
	 * @param {*} signal
	 * @param {string} [name='signal']
	 * @returns {asserts signal is keyof signals}
	 */
	function validateSignalName(signal, name = 'signal') {
	  validateString(signal, name);
	  if (signals[signal] === undefined) {
	    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
	      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')
	    }
	    throw new ERR_UNKNOWN_SIGNAL(signal)
	  }
	}

	/**
	 * @callback validateBuffer
	 * @param {*} buffer
	 * @param {string} [name='buffer']
	 * @returns {asserts buffer is ArrayBufferView}
	 */

	/** @type {validateBuffer} */
	const validateBuffer = hideStackFrames((buffer, name = 'buffer') => {
	  if (!isArrayBufferView(buffer)) {
	    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)
	  }
	});

	/**
	 * @param {string} data
	 * @param {string} encoding
	 */
	function validateEncoding(data, encoding) {
	  const normalizedEncoding = normalizeEncoding(encoding);
	  const length = data.length;
	  if (normalizedEncoding === 'hex' && length % 2 !== 0) {
	    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)
	  }
	}

	/**
	 * Check that the port number is not NaN when coerced to a number,
	 * is an integer and that it falls within the legal range of port numbers.
	 * @param {*} port
	 * @param {string} [name='Port']
	 * @param {boolean} [allowZero=true]
	 * @returns {number}
	 */
	function validatePort(port, name = 'Port', allowZero = true) {
	  if (
	    (typeof port !== 'number' && typeof port !== 'string') ||
	    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||
	    +port !== +port >>> 0 ||
	    port > 0xffff ||
	    (port === 0 && !allowZero)
	  ) {
	    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)
	  }
	  return port | 0
	}

	/**
	 * @callback validateAbortSignal
	 * @param {*} signal
	 * @param {string} name
	 */

	/** @type {validateAbortSignal} */
	const validateAbortSignal = hideStackFrames((signal, name) => {
	  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
	    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
	  }
	});

	/**
	 * @callback validateFunction
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is Function}
	 */

	/** @type {validateFunction} */
	const validateFunction = hideStackFrames((value, name) => {
	  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
	});

	/**
	 * @callback validatePlainFunction
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is Function}
	 */

	/** @type {validatePlainFunction} */
	const validatePlainFunction = hideStackFrames((value, name) => {
	  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
	});

	/**
	 * @callback validateUndefined
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is undefined}
	 */

	/** @type {validateUndefined} */
	const validateUndefined = hideStackFrames((value, name) => {
	  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)
	});

	/**
	 * @template T
	 * @param {T} value
	 * @param {string} name
	 * @param {T[]} union
	 */
	function validateUnion(value, name, union) {
	  if (!ArrayPrototypeIncludes(union, value)) {
	    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)
	  }
	}

	/*
	  The rules for the Link header field are described here:
	  https://www.rfc-editor.org/rfc/rfc8288.html#section-3

	  This regex validates any string surrounded by angle brackets
	  (not necessarily a valid URI reference) followed by zero or more
	  link-params separated by semicolons.
	*/
	const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;

	/**
	 * @param {any} value
	 * @param {string} name
	 */
	function validateLinkHeaderFormat(value, name) {
	  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {
	    throw new ERR_INVALID_ARG_VALUE(
	      name,
	      value,
	      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
	    )
	  }
	}

	/**
	 * @param {any} hints
	 * @return {string}
	 */
	function validateLinkHeaderValue(hints) {
	  if (typeof hints === 'string') {
	    validateLinkHeaderFormat(hints, 'hints');
	    return hints
	  } else if (ArrayIsArray(hints)) {
	    const hintsLength = hints.length;
	    let result = '';
	    if (hintsLength === 0) {
	      return result
	    }
	    for (let i = 0; i < hintsLength; i++) {
	      const link = hints[i];
	      validateLinkHeaderFormat(link, 'hints');
	      result += link;
	      if (i !== hintsLength - 1) {
	        result += ', ';
	      }
	    }
	    return result
	  }
	  throw new ERR_INVALID_ARG_VALUE(
	    'hints',
	    hints,
	    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
	  )
	}
	validators = {
	  isInt32,
	  isUint32,
	  parseFileMode,
	  validateArray,
	  validateStringArray,
	  validateBooleanArray,
	  validateAbortSignalArray,
	  validateBoolean,
	  validateBuffer,
	  validateDictionary,
	  validateEncoding,
	  validateFunction,
	  validateInt32,
	  validateInteger,
	  validateNumber,
	  validateObject,
	  validateOneOf,
	  validatePlainFunction,
	  validatePort,
	  validateSignalName,
	  validateString,
	  validateUint32,
	  validateUndefined,
	  validateUnion,
	  validateAbortSignal,
	  validateLinkHeaderValue
	};
	return validators;
}

var endOfStream = {exports: {}};

var utils$1;
var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;

	const { SymbolAsyncIterator, SymbolIterator, SymbolFor } = requirePrimordials();

	// We need to use SymbolFor to make these globally available
	// for interopt with readable-stream, i.e. readable-stream
	// and node core needs to be able to read/write private state
	// from each other for proper interoperability.
	const kIsDestroyed = SymbolFor('nodejs.stream.destroyed');
	const kIsErrored = SymbolFor('nodejs.stream.errored');
	const kIsReadable = SymbolFor('nodejs.stream.readable');
	const kIsWritable = SymbolFor('nodejs.stream.writable');
	const kIsDisturbed = SymbolFor('nodejs.stream.disturbed');
	const kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise');
	const kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction');
	function isReadableNodeStream(obj, strict = false) {
	  var _obj$_readableState;
	  return !!(
	    (
	      obj &&
	      typeof obj.pipe === 'function' &&
	      typeof obj.on === 'function' &&
	      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&
	      (!obj._writableState ||
	        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined
	          ? undefined
	          : _obj$_readableState.readable) !== false) &&
	      // Duplex
	      (!obj._writableState || obj._readableState)
	    ) // Writable has .pipe.
	  )
	}
	function isWritableNodeStream(obj) {
	  var _obj$_writableState;
	  return !!(
	    (
	      obj &&
	      typeof obj.write === 'function' &&
	      typeof obj.on === 'function' &&
	      (!obj._readableState ||
	        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined
	          ? undefined
	          : _obj$_writableState.writable) !== false)
	    ) // Duplex
	  )
	}
	function isDuplexNodeStream(obj) {
	  return !!(
	    obj &&
	    typeof obj.pipe === 'function' &&
	    obj._readableState &&
	    typeof obj.on === 'function' &&
	    typeof obj.write === 'function'
	  )
	}
	function isNodeStream(obj) {
	  return (
	    obj &&
	    (obj._readableState ||
	      obj._writableState ||
	      (typeof obj.write === 'function' && typeof obj.on === 'function') ||
	      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))
	  )
	}
	function isReadableStream(obj) {
	  return !!(
	    obj &&
	    !isNodeStream(obj) &&
	    typeof obj.pipeThrough === 'function' &&
	    typeof obj.getReader === 'function' &&
	    typeof obj.cancel === 'function'
	  )
	}
	function isWritableStream(obj) {
	  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')
	}
	function isTransformStream(obj) {
	  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')
	}
	function isWebStream(obj) {
	  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)
	}
	function isIterable(obj, isAsync) {
	  if (obj == null) return false
	  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'
	  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'
	  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'
	}
	function isDestroyed(stream) {
	  if (!isNodeStream(stream)) return null
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  const state = wState || rState;
	  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))
	}

	// Have been end():d.
	function isWritableEnded(stream) {
	  if (!isWritableNodeStream(stream)) return null
	  if (stream.writableEnded === true) return true
	  const wState = stream._writableState;
	  if (wState !== null && wState !== undefined && wState.errored) return false
	  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null
	  return wState.ended
	}

	// Have emitted 'finish'.
	function isWritableFinished(stream, strict) {
	  if (!isWritableNodeStream(stream)) return null
	  if (stream.writableFinished === true) return true
	  const wState = stream._writableState;
	  if (wState !== null && wState !== undefined && wState.errored) return false
	  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null
	  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))
	}

	// Have been push(null):d.
	function isReadableEnded(stream) {
	  if (!isReadableNodeStream(stream)) return null
	  if (stream.readableEnded === true) return true
	  const rState = stream._readableState;
	  if (!rState || rState.errored) return false
	  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null
	  return rState.ended
	}

	// Have emitted 'end'.
	function isReadableFinished(stream, strict) {
	  if (!isReadableNodeStream(stream)) return null
	  const rState = stream._readableState;
	  if (rState !== null && rState !== undefined && rState.errored) return false
	  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null
	  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))
	}
	function isReadable(stream) {
	  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]
	  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null
	  if (isDestroyed(stream)) return false
	  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)
	}
	function isWritable(stream) {
	  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]
	  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null
	  if (isDestroyed(stream)) return false
	  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)
	}
	function isFinished(stream, opts) {
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (isDestroyed(stream)) {
	    return true
	  }
	  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
	    return false
	  }
	  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
	    return false
	  }
	  return true
	}
	function isWritableErrored(stream) {
	  var _stream$_writableStat, _stream$_writableStat2;
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (stream.writableErrored) {
	    return stream.writableErrored
	  }
	  return (_stream$_writableStat =
	    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined
	      ? undefined
	      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined
	    ? _stream$_writableStat
	    : null
	}
	function isReadableErrored(stream) {
	  var _stream$_readableStat, _stream$_readableStat2;
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (stream.readableErrored) {
	    return stream.readableErrored
	  }
	  return (_stream$_readableStat =
	    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined
	      ? undefined
	      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined
	    ? _stream$_readableStat
	    : null
	}
	function isClosed(stream) {
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (typeof stream.closed === 'boolean') {
	    return stream.closed
	  }
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  if (
	    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||
	    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'
	  ) {
	    return (
	      (wState === null || wState === undefined ? undefined : wState.closed) ||
	      (rState === null || rState === undefined ? undefined : rState.closed)
	    )
	  }
	  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {
	    return stream._closed
	  }
	  return null
	}
	function isOutgoingMessage(stream) {
	  return (
	    typeof stream._closed === 'boolean' &&
	    typeof stream._defaultKeepAlive === 'boolean' &&
	    typeof stream._removedConnection === 'boolean' &&
	    typeof stream._removedContLen === 'boolean'
	  )
	}
	function isServerResponse(stream) {
	  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)
	}
	function isServerRequest(stream) {
	  var _stream$req;
	  return (
	    typeof stream._consuming === 'boolean' &&
	    typeof stream._dumped === 'boolean' &&
	    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===
	      undefined
	  )
	}
	function willEmitClose(stream) {
	  if (!isNodeStream(stream)) return null
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  const state = wState || rState;
	  return (
	    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)
	  )
	}
	function isDisturbed(stream) {
	  var _stream$kIsDisturbed;
	  return !!(
	    stream &&
	    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined
	      ? _stream$kIsDisturbed
	      : stream.readableDidRead || stream.readableAborted)
	  )
	}
	function isErrored(stream) {
	  var _ref,
	    _ref2,
	    _ref3,
	    _ref4,
	    _ref5,
	    _stream$kIsErrored,
	    _stream$_readableStat3,
	    _stream$_writableStat3,
	    _stream$_readableStat4,
	    _stream$_writableStat4;
	  return !!(
	    stream &&
	    ((_ref =
	      (_ref2 =
	        (_ref3 =
	          (_ref4 =
	            (_ref5 =
	              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined
	                ? _stream$kIsErrored
	                : stream.readableErrored) !== null && _ref5 !== undefined
	              ? _ref5
	              : stream.writableErrored) !== null && _ref4 !== undefined
	            ? _ref4
	            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined
	            ? undefined
	            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined
	          ? _ref3
	          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined
	          ? undefined
	          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined
	        ? _ref2
	        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined
	        ? undefined
	        : _stream$_readableStat4.errored) !== null && _ref !== undefined
	      ? _ref
	      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined
	      ? undefined
	      : _stream$_writableStat4.errored)
	  )
	}
	utils$1 = {
	  isDestroyed,
	  kIsDestroyed,
	  isDisturbed,
	  kIsDisturbed,
	  isErrored,
	  kIsErrored,
	  isReadable,
	  kIsReadable,
	  kIsClosedPromise,
	  kControllerErrorFunction,
	  kIsWritable,
	  isClosed,
	  isDuplexNodeStream,
	  isFinished,
	  isIterable,
	  isReadableNodeStream,
	  isReadableStream,
	  isReadableEnded,
	  isReadableFinished,
	  isReadableErrored,
	  isNodeStream,
	  isWebStream,
	  isWritable,
	  isWritableNodeStream,
	  isWritableStream,
	  isWritableEnded,
	  isWritableFinished,
	  isWritableErrored,
	  isServerRequest,
	  isServerResponse,
	  willEmitClose,
	  isTransformStream
	};
	return utils$1;
}

var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream.exports;
	hasRequiredEndOfStream = 1;

	/* replacement start */

	const process = requireBrowser$2();

	/* replacement end */

	const { AbortError, codes } = requireErrors();
	const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
	const { kEmptyObject, once } = requireUtil$2();
	const { validateAbortSignal, validateFunction, validateObject, validateBoolean } = requireValidators();
	const { Promise, PromisePrototypeThen, SymbolDispose } = requirePrimordials();
	const {
	  isClosed,
	  isReadable,
	  isReadableNodeStream,
	  isReadableStream,
	  isReadableFinished,
	  isReadableErrored,
	  isWritable,
	  isWritableNodeStream,
	  isWritableStream,
	  isWritableFinished,
	  isWritableErrored,
	  isNodeStream,
	  willEmitClose: _willEmitClose,
	  kIsClosedPromise
	} = requireUtils$1();
	let addAbortListener;
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function'
	}
	const nop = () => {};
	function eos(stream, options, callback) {
	  var _options$readable, _options$writable;
	  if (arguments.length === 2) {
	    callback = options;
	    options = kEmptyObject;
	  } else if (options == null) {
	    options = kEmptyObject;
	  } else {
	    validateObject(options, 'options');
	  }
	  validateFunction(callback, 'callback');
	  validateAbortSignal(options.signal, 'options.signal');
	  callback = once(callback);
	  if (isReadableStream(stream) || isWritableStream(stream)) {
	    return eosWeb(stream, options, callback)
	  }
	  if (!isNodeStream(stream)) {
	    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
	  }
	  const readable =
	    (_options$readable = options.readable) !== null && _options$readable !== undefined
	      ? _options$readable
	      : isReadableNodeStream(stream);
	  const writable =
	    (_options$writable = options.writable) !== null && _options$writable !== undefined
	      ? _options$writable
	      : isWritableNodeStream(stream);
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  const onlegacyfinish = () => {
	    if (!stream.writable) {
	      onfinish();
	    }
	  };

	  // TODO (ronag): Improve soft detection to include core modules and
	  // common ecosystem modules that do properly emit 'close' but fail
	  // this generic check.
	  let willEmitClose =
	    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
	  let writableFinished = isWritableFinished(stream, false);
	  const onfinish = () => {
	    writableFinished = true;
	    // Stream should not be destroyed here. If it is that
	    // means that user space is doing something differently and
	    // we cannot trust willEmitClose.
	    if (stream.destroyed) {
	      willEmitClose = false;
	    }
	    if (willEmitClose && (!stream.readable || readable)) {
	      return
	    }
	    if (!readable || readableFinished) {
	      callback.call(stream);
	    }
	  };
	  let readableFinished = isReadableFinished(stream, false);
	  const onend = () => {
	    readableFinished = true;
	    // Stream should not be destroyed here. If it is that
	    // means that user space is doing something differently and
	    // we cannot trust willEmitClose.
	    if (stream.destroyed) {
	      willEmitClose = false;
	    }
	    if (willEmitClose && (!stream.writable || writable)) {
	      return
	    }
	    if (!writable || writableFinished) {
	      callback.call(stream);
	    }
	  };
	  const onerror = (err) => {
	    callback.call(stream, err);
	  };
	  let closed = isClosed(stream);
	  const onclose = () => {
	    closed = true;
	    const errored = isWritableErrored(stream) || isReadableErrored(stream);
	    if (errored && typeof errored !== 'boolean') {
	      return callback.call(stream, errored)
	    }
	    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
	      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
	    }
	    if (writable && !writableFinished) {
	      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
	    }
	    callback.call(stream);
	  };
	  const onclosed = () => {
	    closed = true;
	    const errored = isWritableErrored(stream) || isReadableErrored(stream);
	    if (errored && typeof errored !== 'boolean') {
	      return callback.call(stream, errored)
	    }
	    callback.call(stream);
	  };
	  const onrequest = () => {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    if (!willEmitClose) {
	      stream.on('abort', onclose);
	    }
	    if (stream.req) {
	      onrequest();
	    } else {
	      stream.on('request', onrequest);
	    }
	  } else if (writable && !wState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }

	  // Not all streams will emit 'close' after 'aborted'.
	  if (!willEmitClose && typeof stream.aborted === 'boolean') {
	    stream.on('aborted', onclose);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (options.error !== false) {
	    stream.on('error', onerror);
	  }
	  stream.on('close', onclose);
	  if (closed) {
	    process.nextTick(onclose);
	  } else if (
	    (wState !== null && wState !== undefined && wState.errorEmitted) ||
	    (rState !== null && rState !== undefined && rState.errorEmitted)
	  ) {
	    if (!willEmitClose) {
	      process.nextTick(onclosed);
	    }
	  } else if (
	    !readable &&
	    (!willEmitClose || isReadable(stream)) &&
	    (writableFinished || isWritable(stream) === false)
	  ) {
	    process.nextTick(onclosed);
	  } else if (
	    !writable &&
	    (!willEmitClose || isWritable(stream)) &&
	    (readableFinished || isReadable(stream) === false)
	  ) {
	    process.nextTick(onclosed);
	  } else if (rState && stream.req && stream.aborted) {
	    process.nextTick(onclosed);
	  }
	  const cleanup = () => {
	    callback = nop;
	    stream.removeListener('aborted', onclose);
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	  if (options.signal && !closed) {
	    const abort = () => {
	      // Keep it because cleanup removes it.
	      const endCallback = callback;
	      cleanup();
	      endCallback.call(
	        stream,
	        new AbortError(undefined, {
	          cause: options.signal.reason
	        })
	      );
	    };
	    if (options.signal.aborted) {
	      process.nextTick(abort);
	    } else {
	      addAbortListener = addAbortListener || requireUtil$2().addAbortListener;
	      const disposable = addAbortListener(options.signal, abort);
	      const originalCallback = callback;
	      callback = once((...args) => {
	        disposable[SymbolDispose]();
	        originalCallback.apply(stream, args);
	      });
	    }
	  }
	  return cleanup
	}
	function eosWeb(stream, options, callback) {
	  let isAborted = false;
	  let abort = nop;
	  if (options.signal) {
	    abort = () => {
	      isAborted = true;
	      callback.call(
	        stream,
	        new AbortError(undefined, {
	          cause: options.signal.reason
	        })
	      );
	    };
	    if (options.signal.aborted) {
	      process.nextTick(abort);
	    } else {
	      addAbortListener = addAbortListener || requireUtil$2().addAbortListener;
	      const disposable = addAbortListener(options.signal, abort);
	      const originalCallback = callback;
	      callback = once((...args) => {
	        disposable[SymbolDispose]();
	        originalCallback.apply(stream, args);
	      });
	    }
	  }
	  const resolverFn = (...args) => {
	    if (!isAborted) {
	      process.nextTick(() => callback.apply(stream, args));
	    }
	  };
	  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
	  return nop
	}
	function finished(stream, opts) {
	  var _opts;
	  let autoCleanup = false;
	  if (opts === null) {
	    opts = kEmptyObject;
	  }
	  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
	    validateBoolean(opts.cleanup, 'cleanup');
	    autoCleanup = opts.cleanup;
	  }
	  return new Promise((resolve, reject) => {
	    const cleanup = eos(stream, opts, (err) => {
	      if (autoCleanup) {
	        cleanup();
	      }
	      if (err) {
	        reject(err);
	      } else {
	        resolve();
	      }
	    });
	  })
	}
	endOfStream.exports = eos;
	endOfStream.exports.finished = finished;
	return endOfStream.exports;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	/* replacement start */

	const process = requireBrowser$2();

	/* replacement end */

	const {
	  aggregateTwoErrors,
	  codes: { ERR_MULTIPLE_CALLBACK },
	  AbortError
	} = requireErrors();
	const { Symbol } = requirePrimordials();
	const { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = requireUtils$1();
	const kDestroy = Symbol('kDestroy');
	const kConstruct = Symbol('kConstruct');
	function checkError(err, w, r) {
	  if (err) {
	    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
	    err.stack; // eslint-disable-line no-unused-expressions

	    if (w && !w.errored) {
	      w.errored = err;
	    }
	    if (r && !r.errored) {
	      r.errored = err;
	    }
	  }
	}

	// Backwards compat. cb() is undocumented and unused in core but
	// unfortunately might be used by modules.
	function destroy(err, cb) {
	  const r = this._readableState;
	  const w = this._writableState;
	  // With duplex streams we use the writable side for state.
	  const s = w || r;
	  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
	    if (typeof cb === 'function') {
	      cb();
	    }
	    return this
	  }

	  // We set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks
	  checkError(err, w, r);
	  if (w) {
	    w.destroyed = true;
	  }
	  if (r) {
	    r.destroyed = true;
	  }

	  // If still constructing then defer calling _destroy.
	  if (!s.constructed) {
	    this.once(kDestroy, function (er) {
	      _destroy(this, aggregateTwoErrors(er, err), cb);
	    });
	  } else {
	    _destroy(this, err, cb);
	  }
	  return this
	}
	function _destroy(self, err, cb) {
	  let called = false;
	  function onDestroy(err) {
	    if (called) {
	      return
	    }
	    called = true;
	    const r = self._readableState;
	    const w = self._writableState;
	    checkError(err, w, r);
	    if (w) {
	      w.closed = true;
	    }
	    if (r) {
	      r.closed = true;
	    }
	    if (typeof cb === 'function') {
	      cb(err);
	    }
	    if (err) {
	      process.nextTick(emitErrorCloseNT, self, err);
	    } else {
	      process.nextTick(emitCloseNT, self);
	    }
	  }
	  try {
	    self._destroy(err || null, onDestroy);
	  } catch (err) {
	    onDestroy(err);
	  }
	}
	function emitErrorCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  const r = self._readableState;
	  const w = self._writableState;
	  if (w) {
	    w.closeEmitted = true;
	  }
	  if (r) {
	    r.closeEmitted = true;
	  }
	  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {
	    self.emit('close');
	  }
	}
	function emitErrorNT(self, err) {
	  const r = self._readableState;
	  const w = self._writableState;
	  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {
	    return
	  }
	  if (w) {
	    w.errorEmitted = true;
	  }
	  if (r) {
	    r.errorEmitted = true;
	  }
	  self.emit('error', err);
	}
	function undestroy() {
	  const r = this._readableState;
	  const w = this._writableState;
	  if (r) {
	    r.constructed = true;
	    r.closed = false;
	    r.closeEmitted = false;
	    r.destroyed = false;
	    r.errored = null;
	    r.errorEmitted = false;
	    r.reading = false;
	    r.ended = r.readable === false;
	    r.endEmitted = r.readable === false;
	  }
	  if (w) {
	    w.constructed = true;
	    w.destroyed = false;
	    w.closed = false;
	    w.closeEmitted = false;
	    w.errored = null;
	    w.errorEmitted = false;
	    w.finalCalled = false;
	    w.prefinished = false;
	    w.ended = w.writable === false;
	    w.ending = w.writable === false;
	    w.finished = w.writable === false;
	  }
	}
	function errorOrDestroy(stream, err, sync) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  const r = stream._readableState;
	  const w = stream._writableState;
	  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
	    return this
	  }
	  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))
	    stream.destroy(err);
	  else if (err) {
	    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
	    err.stack; // eslint-disable-line no-unused-expressions

	    if (w && !w.errored) {
	      w.errored = err;
	    }
	    if (r && !r.errored) {
	      r.errored = err;
	    }
	    if (sync) {
	      process.nextTick(emitErrorNT, stream, err);
	    } else {
	      emitErrorNT(stream, err);
	    }
	  }
	}
	function construct(stream, cb) {
	  if (typeof stream._construct !== 'function') {
	    return
	  }
	  const r = stream._readableState;
	  const w = stream._writableState;
	  if (r) {
	    r.constructed = false;
	  }
	  if (w) {
	    w.constructed = false;
	  }
	  stream.once(kConstruct, cb);
	  if (stream.listenerCount(kConstruct) > 1) {
	    // Duplex
	    return
	  }
	  process.nextTick(constructNT, stream);
	}
	function constructNT(stream) {
	  let called = false;
	  function onConstruct(err) {
	    if (called) {
	      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK());
	      return
	    }
	    called = true;
	    const r = stream._readableState;
	    const w = stream._writableState;
	    const s = w || r;
	    if (r) {
	      r.constructed = true;
	    }
	    if (w) {
	      w.constructed = true;
	    }
	    if (s.destroyed) {
	      stream.emit(kDestroy, err);
	    } else if (err) {
	      errorOrDestroy(stream, err, true);
	    } else {
	      process.nextTick(emitConstructNT, stream);
	    }
	  }
	  try {
	    stream._construct((err) => {
	      process.nextTick(onConstruct, err);
	    });
	  } catch (err) {
	    process.nextTick(onConstruct, err);
	  }
	}
	function emitConstructNT(stream) {
	  stream.emit(kConstruct);
	}
	function isRequest(stream) {
	  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'
	}
	function emitCloseLegacy(stream) {
	  stream.emit('close');
	}
	function emitErrorCloseLegacy(stream, err) {
	  stream.emit('error', err);
	  process.nextTick(emitCloseLegacy, stream);
	}

	// Normalize destroy for legacy.
	function destroyer(stream, err) {
	  if (!stream || isDestroyed(stream)) {
	    return
	  }
	  if (!err && !isFinished(stream)) {
	    err = new AbortError();
	  }

	  // TODO: Remove isRequest branches.
	  if (isServerRequest(stream)) {
	    stream.socket = null;
	    stream.destroy(err);
	  } else if (isRequest(stream)) {
	    stream.abort();
	  } else if (isRequest(stream.req)) {
	    stream.req.abort();
	  } else if (typeof stream.destroy === 'function') {
	    stream.destroy(err);
	  } else if (typeof stream.close === 'function') {
	    // TODO: Don't lose err?
	    stream.close();
	  } else if (err) {
	    process.nextTick(emitErrorCloseLegacy, stream, err);
	  } else {
	    process.nextTick(emitCloseLegacy, stream);
	  }
	  if (!stream.destroyed) {
	    stream[kIsDestroyed] = true;
	  }
	}
	destroy_1 = {
	  construct,
	  destroyer,
	  destroy,
	  undestroy,
	  errorOrDestroy
	};
	return destroy_1;
}

var legacy;
var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;

	const { ArrayIsArray, ObjectSetPrototypeOf } = requirePrimordials();
	const { EventEmitter: EE } = requireEvents();
	function Stream(opts) {
	  EE.call(this, opts);
	}
	ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
	ObjectSetPrototypeOf(Stream, EE);
	Stream.prototype.pipe = function (dest, options) {
	  const source = this;
	  function ondata(chunk) {
	    if (dest.writable && dest.write(chunk) === false && source.pause) {
	      source.pause();
	    }
	  }
	  source.on('data', ondata);
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	  let didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return
	    didOnEnd = true;
	    dest.end();
	  }
	  function onclose() {
	    if (didOnEnd) return
	    didOnEnd = true;
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // Don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      this.emit('error', er);
	    }
	  }
	  prependListener(source, 'error', onerror);
	  prependListener(dest, 'error', onerror);

	  // Remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	    dest.removeListener('close', cleanup);
	  }
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	  dest.on('close', cleanup);
	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest
	};
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
	  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
	  else emitter._events[event] = [fn, emitter._events[event]];
	}
	legacy = {
	  Stream,
	  prependListener
	};
	return legacy;
}

var addAbortSignal = {exports: {}};

var hasRequiredAddAbortSignal;

function requireAddAbortSignal () {
	if (hasRequiredAddAbortSignal) return addAbortSignal.exports;
	hasRequiredAddAbortSignal = 1;
	(function (module) {

		const { SymbolDispose } = requirePrimordials();
		const { AbortError, codes } = requireErrors();
		const { isNodeStream, isWebStream, kControllerErrorFunction } = requireUtils$1();
		const eos = requireEndOfStream();
		const { ERR_INVALID_ARG_TYPE } = codes;
		let addAbortListener;

		// This method is inlined here for readable-stream
		// It also does not allow for signal to not exist on the stream
		// https://github.com/nodejs/node/pull/36061#discussion_r533718029
		const validateAbortSignal = (signal, name) => {
		  if (typeof signal !== 'object' || !('aborted' in signal)) {
		    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
		  }
		};
		module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
		  validateAbortSignal(signal, 'signal');
		  if (!isNodeStream(stream) && !isWebStream(stream)) {
		    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
		  }
		  return module.exports.addAbortSignalNoValidate(signal, stream)
		};
		module.exports.addAbortSignalNoValidate = function (signal, stream) {
		  if (typeof signal !== 'object' || !('aborted' in signal)) {
		    return stream
		  }
		  const onAbort = isNodeStream(stream)
		    ? () => {
		        stream.destroy(
		          new AbortError(undefined, {
		            cause: signal.reason
		          })
		        );
		      }
		    : () => {
		        stream[kControllerErrorFunction](
		          new AbortError(undefined, {
		            cause: signal.reason
		          })
		        );
		      };
		  if (signal.aborted) {
		    onAbort();
		  } else {
		    addAbortListener = addAbortListener || requireUtil$2().addAbortListener;
		    const disposable = addAbortListener(signal, onAbort);
		    eos(stream, disposable[SymbolDispose]);
		  }
		  return stream
		}; 
	} (addAbortSignal));
	return addAbortSignal.exports;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = requirePrimordials();
	const { Buffer } = require$$0$2;
	const { inspect } = requireUtil$2();
	buffer_list = class BufferList {
	  constructor() {
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  push(v) {
	    const entry = {
	      data: v,
	      next: null
	    };
	    if (this.length > 0) this.tail.next = entry;
	    else this.head = entry;
	    this.tail = entry;
	    ++this.length;
	  }
	  unshift(v) {
	    const entry = {
	      data: v,
	      next: this.head
	    };
	    if (this.length === 0) this.tail = entry;
	    this.head = entry;
	    ++this.length;
	  }
	  shift() {
	    if (this.length === 0) return
	    const ret = this.head.data;
	    if (this.length === 1) this.head = this.tail = null;
	    else this.head = this.head.next;
	    --this.length;
	    return ret
	  }
	  clear() {
	    this.head = this.tail = null;
	    this.length = 0;
	  }
	  join(s) {
	    if (this.length === 0) return ''
	    let p = this.head;
	    let ret = '' + p.data;
	    while ((p = p.next) !== null) ret += s + p.data;
	    return ret
	  }
	  concat(n) {
	    if (this.length === 0) return Buffer.alloc(0)
	    const ret = Buffer.allocUnsafe(n >>> 0);
	    let p = this.head;
	    let i = 0;
	    while (p) {
	      TypedArrayPrototypeSet(ret, p.data, i);
	      i += p.data.length;
	      p = p.next;
	    }
	    return ret
	  }

	  // Consumes a specified amount of bytes or characters from the buffered data.
	  consume(n, hasStrings) {
	    const data = this.head.data;
	    if (n < data.length) {
	      // `slice` is the same for buffers and strings.
	      const slice = data.slice(0, n);
	      this.head.data = data.slice(n);
	      return slice
	    }
	    if (n === data.length) {
	      // First chunk is a perfect match.
	      return this.shift()
	    }
	    // Result spans more than one buffer.
	    return hasStrings ? this._getString(n) : this._getBuffer(n)
	  }
	  first() {
	    return this.head.data
	  }
	  *[SymbolIterator]() {
	    for (let p = this.head; p; p = p.next) {
	      yield p.data;
	    }
	  }

	  // Consumes a specified amount of characters from the buffered data.
	  _getString(n) {
	    let ret = '';
	    let p = this.head;
	    let c = 0;
	    do {
	      const str = p.data;
	      if (n > str.length) {
	        ret += str;
	        n -= str.length;
	      } else {
	        if (n === str.length) {
	          ret += str;
	          ++c;
	          if (p.next) this.head = p.next;
	          else this.head = this.tail = null;
	        } else {
	          ret += StringPrototypeSlice(str, 0, n);
	          this.head = p;
	          p.data = StringPrototypeSlice(str, n);
	        }
	        break
	      }
	      ++c;
	    } while ((p = p.next) !== null)
	    this.length -= c;
	    return ret
	  }

	  // Consumes a specified amount of bytes from the buffered data.
	  _getBuffer(n) {
	    const ret = Buffer.allocUnsafe(n);
	    const retLen = n;
	    let p = this.head;
	    let c = 0;
	    do {
	      const buf = p.data;
	      if (n > buf.length) {
	        TypedArrayPrototypeSet(ret, buf, retLen - n);
	        n -= buf.length;
	      } else {
	        if (n === buf.length) {
	          TypedArrayPrototypeSet(ret, buf, retLen - n);
	          ++c;
	          if (p.next) this.head = p.next;
	          else this.head = this.tail = null;
	        } else {
	          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
	          this.head = p;
	          p.data = buf.slice(n);
	        }
	        break
	      }
	      ++c;
	    } while ((p = p.next) !== null)
	    this.length -= c;
	    return ret
	  }

	  // Make sure the linked list only shows the minimal necessary information.
	  [Symbol.for('nodejs.util.inspect.custom')](_, options) {
	    return inspect(this, {
	      ...options,
	      // Only inspect one level.
	      depth: 0,
	      // It should not recurse.
	      customInspect: false
	    })
	  }
	};
	return buffer_list;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	const { MathFloor, NumberIsInteger } = requirePrimordials();
	const { validateInteger } = requireValidators();
	const { ERR_INVALID_ARG_VALUE } = requireErrors().codes;
	let defaultHighWaterMarkBytes = 16 * 1024;
	let defaultHighWaterMarkObjectMode = 16;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null
	}
	function getDefaultHighWaterMark(objectMode) {
	  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes
	}
	function setDefaultHighWaterMark(objectMode, value) {
	  validateInteger(value, 'value', 0);
	  if (objectMode) {
	    defaultHighWaterMarkObjectMode = value;
	  } else {
	    defaultHighWaterMarkBytes = value;
	  }
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!NumberIsInteger(hwm) || hwm < 0) {
	      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';
	      throw new ERR_INVALID_ARG_VALUE(name, hwm)
	    }
	    return MathFloor(hwm)
	  }

	  // Default value
	  return getDefaultHighWaterMark(state.objectMode)
	}
	state = {
	  getHighWaterMark,
	  getDefaultHighWaterMark,
	  setDefaultHighWaterMark
	};
	return state;
}

var string_decoder = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$2;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var from_1;
var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from_1;
	hasRequiredFrom = 1;

	/* replacement start */

	const process = requireBrowser$2();

	/* replacement end */

	const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = requirePrimordials();
	const { Buffer } = require$$0$2;
	const { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = requireErrors().codes;
	function from(Readable, iterable, opts) {
	  let iterator;
	  if (typeof iterable === 'string' || iterable instanceof Buffer) {
	    return new Readable({
	      objectMode: true,
	      ...opts,
	      read() {
	        this.push(iterable);
	        this.push(null);
	      }
	    })
	  }
	  let isAsync;
	  if (iterable && iterable[SymbolAsyncIterator]) {
	    isAsync = true;
	    iterator = iterable[SymbolAsyncIterator]();
	  } else if (iterable && iterable[SymbolIterator]) {
	    isAsync = false;
	    iterator = iterable[SymbolIterator]();
	  } else {
	    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)
	  }
	  const readable = new Readable({
	    objectMode: true,
	    highWaterMark: 1,
	    // TODO(ronag): What options should be allowed?
	    ...opts
	  });

	  // Flag to protect against _read
	  // being called before last iteration completion.
	  let reading = false;
	  readable._read = function () {
	    if (!reading) {
	      reading = true;
	      next();
	    }
	  };
	  readable._destroy = function (error, cb) {
	    PromisePrototypeThen(
	      close(error),
	      () => process.nextTick(cb, error),
	      // nextTick is here in case cb throws
	      (e) => process.nextTick(cb, e || error)
	    );
	  };
	  async function close(error) {
	    const hadError = error !== undefined && error !== null;
	    const hasThrow = typeof iterator.throw === 'function';
	    if (hadError && hasThrow) {
	      const { value, done } = await iterator.throw(error);
	      await value;
	      if (done) {
	        return
	      }
	    }
	    if (typeof iterator.return === 'function') {
	      const { value } = await iterator.return();
	      await value;
	    }
	  }
	  async function next() {
	    for (;;) {
	      try {
	        const { value, done } = isAsync ? await iterator.next() : iterator.next();
	        if (done) {
	          readable.push(null);
	        } else {
	          const res = value && typeof value.then === 'function' ? await value : value;
	          if (res === null) {
	            reading = false;
	            throw new ERR_STREAM_NULL_VALUES()
	          } else if (readable.push(res)) {
	            continue
	          } else {
	            reading = false;
	          }
	        }
	      } catch (err) {
	        readable.destroy(err);
	      }
	      break
	    }
	  }
	  return readable
	}
	from_1 = from;
	return from_1;
}

var readable;
var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable;
	hasRequiredReadable = 1;

	/* replacement start */

	const process = requireBrowser$2();

	/* replacement end */

	const {
	  ArrayPrototypeIndexOf,
	  NumberIsInteger,
	  NumberIsNaN,
	  NumberParseInt,
	  ObjectDefineProperties,
	  ObjectKeys,
	  ObjectSetPrototypeOf,
	  Promise,
	  SafeSet,
	  SymbolAsyncDispose,
	  SymbolAsyncIterator,
	  Symbol
	} = requirePrimordials();
	readable = Readable;
	Readable.ReadableState = ReadableState;
	const { EventEmitter: EE } = requireEvents();
	const { Stream, prependListener } = requireLegacy();
	const { Buffer } = require$$0$2;
	const { addAbortSignal } = requireAddAbortSignal();
	const eos = requireEndOfStream();
	let debug = requireUtil$2().debuglog('stream', (fn) => {
	  debug = fn;
	});
	const BufferList = requireBuffer_list();
	const destroyImpl = requireDestroy();
	const { getHighWaterMark, getDefaultHighWaterMark } = requireState();
	const {
	  aggregateTwoErrors,
	  codes: {
	    ERR_INVALID_ARG_TYPE,
	    ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_OUT_OF_RANGE,
	    ERR_STREAM_PUSH_AFTER_EOF,
	    ERR_STREAM_UNSHIFT_AFTER_END_EVENT
	  },
	  AbortError
	} = requireErrors();
	const { validateObject } = requireValidators();
	const kPaused = Symbol('kPaused');
	const { StringDecoder } = requireString_decoder();
	const from = requireFrom();
	ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
	ObjectSetPrototypeOf(Readable, Stream);
	const nop = () => {};
	const { errorOrDestroy } = destroyImpl;
	const kObjectMode = 1 << 0;
	const kEnded = 1 << 1;
	const kEndEmitted = 1 << 2;
	const kReading = 1 << 3;
	const kConstructed = 1 << 4;
	const kSync = 1 << 5;
	const kNeedReadable = 1 << 6;
	const kEmittedReadable = 1 << 7;
	const kReadableListening = 1 << 8;
	const kResumeScheduled = 1 << 9;
	const kErrorEmitted = 1 << 10;
	const kEmitClose = 1 << 11;
	const kAutoDestroy = 1 << 12;
	const kDestroyed = 1 << 13;
	const kClosed = 1 << 14;
	const kCloseEmitted = 1 << 15;
	const kMultiAwaitDrain = 1 << 16;
	const kReadingMore = 1 << 17;
	const kDataEmitted = 1 << 18;

	// TODO(benjamingr) it is likely slower to do it this way than with free functions
	function makeBitMapDescriptor(bit) {
	  return {
	    enumerable: false,
	    get() {
	      return (this.state & bit) !== 0
	    },
	    set(value) {
	      if (value) this.state |= bit;
	      else this.state &= ~bit;
	    }
	  }
	}
	ObjectDefineProperties(ReadableState.prototype, {
	  objectMode: makeBitMapDescriptor(kObjectMode),
	  ended: makeBitMapDescriptor(kEnded),
	  endEmitted: makeBitMapDescriptor(kEndEmitted),
	  reading: makeBitMapDescriptor(kReading),
	  // Stream is still being constructed and cannot be
	  // destroyed until construction finished or failed.
	  // Async construction is opt in, therefore we start as
	  // constructed.
	  constructed: makeBitMapDescriptor(kConstructed),
	  // A flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  sync: makeBitMapDescriptor(kSync),
	  // Whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  needReadable: makeBitMapDescriptor(kNeedReadable),
	  emittedReadable: makeBitMapDescriptor(kEmittedReadable),
	  readableListening: makeBitMapDescriptor(kReadableListening),
	  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
	  // True if the error was already emitted and should not be thrown again.
	  errorEmitted: makeBitMapDescriptor(kErrorEmitted),
	  emitClose: makeBitMapDescriptor(kEmitClose),
	  autoDestroy: makeBitMapDescriptor(kAutoDestroy),
	  // Has it been destroyed.
	  destroyed: makeBitMapDescriptor(kDestroyed),
	  // Indicates whether the stream has finished destroying.
	  closed: makeBitMapDescriptor(kClosed),
	  // True if close has been emitted or would have been emitted
	  // depending on emitClose.
	  closeEmitted: makeBitMapDescriptor(kCloseEmitted),
	  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
	  // If true, a maybeReadMore has been scheduled.
	  readingMore: makeBitMapDescriptor(kReadingMore),
	  dataEmitted: makeBitMapDescriptor(kDataEmitted)
	});
	function ReadableState(options, stream, isDuplex) {
	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof requireDuplex();

	  // Bit map field to store ReadableState more effciently with 1 bit per field
	  // instead of a V8 slot per field.
	  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
	  // Object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away.
	  if (options && options.objectMode) this.state |= kObjectMode;
	  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;

	  // The point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = options
	    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)
	    : getDefaultHighWaterMark(false);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift().
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = [];
	  this.flowing = null;
	  this[kPaused] = null;

	  // Should close be emitted on destroy. Defaults to true.
	  if (options && options.emitClose === false) this.state &= -2049;

	  // Should .destroy() be called after 'end' (and potentially 'finish').
	  if (options && options.autoDestroy === false) this.state &= -4097;

	  // Indicates whether the stream has errored. When true no further
	  // _read calls, 'data' or 'readable' events should occur. This is needed
	  // since when autoDestroy is disabled we need a way to tell whether the
	  // stream has failed.
	  this.errored = null;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';

	  // Ref the piped dest which we need a drain event on it
	  // type: null | Writable | Set<Writable>.
	  this.awaitDrainWriters = null;
	  this.decoder = null;
	  this.encoding = null;
	  if (options && options.encoding) {
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  if (!(this instanceof Readable)) return new Readable(options)

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5.
	  const isDuplex = this instanceof requireDuplex();
	  this._readableState = new ReadableState(options, this, isDuplex);
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.construct === 'function') this._construct = options.construct;
	    if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
	  }
	  Stream.call(this, options);
	  destroyImpl.construct(this, () => {
	    if (this._readableState.needReadable) {
	      maybeReadMore(this, this._readableState);
	    }
	  });
	}
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	Readable.prototype[EE.captureRejectionSymbol] = function (err) {
	  this.destroy(err);
	};
	Readable.prototype[SymbolAsyncDispose] = function () {
	  let error;
	  if (!this.destroyed) {
	    error = this.readableEnded ? null : new AbortError();
	    this.destroy(error);
	  }
	  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  return readableAddChunk(this, chunk, encoding, false)
	};

	// Unshift should *always* be something directly out of read().
	Readable.prototype.unshift = function (chunk, encoding) {
	  return readableAddChunk(this, chunk, encoding, true)
	};
	function readableAddChunk(stream, chunk, encoding, addToFront) {
	  debug('readableAddChunk', chunk);
	  const state = stream._readableState;
	  let err;
	  if ((state.state & kObjectMode) === 0) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (state.encoding !== encoding) {
	        if (addToFront && state.encoding) {
	          // When unshifting, if state.encoding is set, we have to save
	          // the string in the BufferList with the state encoding.
	          chunk = Buffer.from(chunk, encoding).toString(state.encoding);
	        } else {
	          chunk = Buffer.from(chunk, encoding);
	          encoding = '';
	        }
	      }
	    } else if (chunk instanceof Buffer) {
	      encoding = '';
	    } else if (Stream._isUint8Array(chunk)) {
	      chunk = Stream._uint8ArrayToBuffer(chunk);
	      encoding = '';
	    } else if (chunk != null) {
	      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	    }
	  }
	  if (err) {
	    errorOrDestroy(stream, err);
	  } else if (chunk === null) {
	    state.state &= -9;
	    onEofChunk(stream, state);
	  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {
	    if (addToFront) {
	      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
	      else if (state.destroyed || state.errored) return false
	      else addChunk(stream, state, chunk, true);
	    } else if (state.ended) {
	      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	    } else if (state.destroyed || state.errored) {
	      return false
	    } else {
	      state.state &= -9;
	      if (state.decoder && !encoding) {
	        chunk = state.decoder.write(chunk);
	        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
	        else maybeReadMore(stream, state);
	      } else {
	        addChunk(stream, state, chunk, false);
	      }
	    }
	  } else if (!addToFront) {
	    state.state &= -9;
	    maybeReadMore(stream, state);
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0)
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {
	    // Use the guard to avoid creating `Set()` repeatedly
	    // when we have multiple pipes.
	    if ((state.state & kMultiAwaitDrain) !== 0) {
	      state.awaitDrainWriters.clear();
	    } else {
	      state.awaitDrainWriters = null;
	    }
	    state.dataEmitted = true;
	    stream.emit('data', chunk);
	  } else {
	    // Update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);
	    else state.buffer.push(chunk);
	    if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	Readable.prototype.isPaused = function () {
	  const state = this._readableState;
	  return state[kPaused] === true || state.flowing === false
	};

	// Backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  const decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8.
	  this._readableState.encoding = this._readableState.decoder.encoding;
	  const buffer = this._readableState.buffer;
	  // Iterate over current buffer to convert already stored Buffers:
	  let content = '';
	  for (const data of buffer) {
	    content += decoder.write(data);
	  }
	  buffer.clear();
	  if (content !== '') buffer.push(content);
	  this._readableState.length = content.length;
	  return this
	};

	// Don't raise the hwm > 1GB.
	const MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n > MAX_HWM) {
	    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts.
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || (state.length === 0 && state.ended)) return 0
	  if ((state.state & kObjectMode) !== 0) return 1
	  if (NumberIsNaN(n)) {
	    // Only flow one buffer at a time.
	    if (state.flowing && state.length) return state.buffer.first().length
	    return state.length
	  }
	  if (n <= state.length) return n
	  return state.ended ? state.length : 0
	}

	// You can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
	  // in this scenario, so we are doing it manually.
	  if (n === undefined) {
	    n = NaN;
	  } else if (!NumberIsInteger(n)) {
	    n = NumberParseInt(n, 10);
	  }
	  const state = this._readableState;
	  const nOrig = n;

	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n !== 0) state.state &= -129;

	  // If we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (
	    n === 0 &&
	    state.needReadable &&
	    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)
	  ) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);
	    else emitReadable(this);
	    return null
	  }
	  n = howMuchToRead(n, state);

	  // If we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  let doRead = (state.state & kNeedReadable) !== 0;
	  debug('need readable', doRead);

	  // If we currently have less than the highWaterMark, then also read some.
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // However, if we've ended, then there's no point, if we're already
	  // reading, then it's unnecessary, if we're constructing we have to wait,
	  // and if we're destroyed or errored, then it's not allowed,
	  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
	    doRead = false;
	    debug('reading, ended or constructing', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.state |= kReading | kSync;
	    // If the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.state |= kNeedReadable;

	    // Call internal read method
	    try {
	      this._read(state.highWaterMark);
	    } catch (err) {
	      errorOrDestroy(this, err);
	    }
	    state.state &= -33;

	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  let ret;
	  if (n > 0) ret = fromList(n, state);
	  else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    if (state.multiAwaitDrain) {
	      state.awaitDrainWriters.clear();
	    } else {
	      state.awaitDrainWriters = null;
	    }
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
	    state.dataEmitted = true;
	    this.emit('data', ret);
	  }
	  return ret
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return
	  if (state.decoder) {
	    const chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // If we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call.
	    emitReadable(stream);
	  } else {
	    // Emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    state.emittedReadable = true;
	    // We have to emit readable now that we are EOF. Modules
	    // in the ecosystem (e.g. dicer) rely on this event being sync.
	    emitReadable_(stream);
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  const state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  const state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if:
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// At this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore && state.constructed) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (
	    !state.reading &&
	    !state.ended &&
	    (state.length < state.highWaterMark || (state.flowing && state.length === 0))
	  ) {
	    const len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // Didn't get any data, stop spinning.
	      break
	  }
	  state.readingMore = false;
	}

	// Abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  const src = this;
	  const state = this._readableState;
	  if (state.pipes.length === 1) {
	    if (!state.multiAwaitDrain) {
	      state.multiAwaitDrain = true;
	      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
	    }
	  }
	  state.pipes.push(dest);
	  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts);
	  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  const endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);
	  else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	  let ondrain;
	  let cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // Cleanup event handlers once the pipe is broken.
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    if (ondrain) {
	      dest.removeListener('drain', ondrain);
	    }
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // If the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  function pause() {
	    // If the user unpiped during `dest.write()`, it is possible
	    // to get stuck in a permanently paused state if that write
	    // also returned false.
	    // => Check whether `dest` is still a piping destination.
	    if (!cleanedUp) {
	      if (state.pipes.length === 1 && state.pipes[0] === dest) {
	        debug('false write response, pause', 0);
	        state.awaitDrainWriters = dest;
	        state.multiAwaitDrain = false;
	      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
	        debug('false write response, pause', state.awaitDrainWriters.size);
	        state.awaitDrainWriters.add(dest);
	      }
	      src.pause();
	    }
	    if (!ondrain) {
	      // When the dest drains, it reduces the awaitDrain counter
	      // on the source.  This would be more elegant with a .once()
	      // handler in flow(), but adding and removing repeatedly is
	      // too slow.
	      ondrain = pipeOnDrain(src, dest);
	      dest.on('drain', ondrain);
	    }
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    const ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      pause();
	    }
	  }

	  // If the dest has an error, then stop piping into it.
	  // However, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (dest.listenerCount('error') === 0) {
	      const s = dest._writableState || dest._readableState;
	      if (s && !s.errorEmitted) {
	        // User incorrectly emitted 'error' directly on the stream.
	        errorOrDestroy(dest, er);
	      } else {
	        dest.emit('error', er);
	      }
	    }
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // Tell the dest that it's being piped to.
	  dest.emit('pipe', src);

	  // Start the flow if it hasn't been started already.

	  if (dest.writableNeedDrain === true) {
	    pause();
	  } else if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest
	};
	function pipeOnDrain(src, dest) {
	  return function pipeOnDrainFunctionResult() {
	    const state = src._readableState;

	    // `ondrain` will call directly,
	    // `this` maybe not a reference to dest,
	    // so we use the real dest here.
	    if (state.awaitDrainWriters === dest) {
	      debug('pipeOnDrain', 1);
	      state.awaitDrainWriters = null;
	    } else if (state.multiAwaitDrain) {
	      debug('pipeOnDrain', state.awaitDrainWriters.size);
	      state.awaitDrainWriters.delete(dest);
	    }
	    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {
	      src.resume();
	    }
	  }
	}
	Readable.prototype.unpipe = function (dest) {
	  const state = this._readableState;
	  const unpipeInfo = {
	    hasUnpiped: false
	  };

	  // If we're not piping anywhere, then do nothing.
	  if (state.pipes.length === 0) return this
	  if (!dest) {
	    // remove all.
	    const dests = state.pipes;
	    state.pipes = [];
	    this.pause();
	    for (let i = 0; i < dests.length; i++)
	      dests[i].emit('unpipe', this, {
	        hasUnpiped: false
	      });
	    return this
	  }

	  // Try to find the right one.
	  const index = ArrayPrototypeIndexOf(state.pipes, dest);
	  if (index === -1) return this
	  state.pipes.splice(index, 1);
	  if (state.pipes.length === 0) this.pause();
	  dest.emit('unpipe', this, unpipeInfo);
	  return this
	};

	// Set up data events if they are asked for
	// Ensure readable listeners eventually get something.
	Readable.prototype.on = function (ev, fn) {
	  const res = Stream.prototype.on.call(this, ev, fn);
	  const state = this._readableState;
	  if (ev === 'data') {
	    // Update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused.
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  const res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res
	};
	Readable.prototype.off = Readable.prototype.removeListener;
	Readable.prototype.removeAllListeners = function (ev) {
	  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res
	};
	function updateReadableListening(self) {
	  const state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && state[kPaused] === false) {
	    // Flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // Crude way to check if we should resume.
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  } else if (!state.readableListening) {
	    state.flowing = null;
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  const state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // We flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume().
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state[kPaused] = false;
	  return this
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState[kPaused] = true;
	  return this
	};
	function flow(stream) {
	  const state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// Wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  let paused = false;

	  // TODO (ronag): Should this.destroy(err) emit
	  // 'error' on the wrapped stream? Would require
	  // a static factory method, e.g. Readable.wrap(stream).

	  stream.on('data', (chunk) => {
	    if (!this.push(chunk) && stream.pause) {
	      paused = true;
	      stream.pause();
	    }
	  });
	  stream.on('end', () => {
	    this.push(null);
	  });
	  stream.on('error', (err) => {
	    errorOrDestroy(this, err);
	  });
	  stream.on('close', () => {
	    this.destroy();
	  });
	  stream.on('destroy', () => {
	    this.destroy();
	  });
	  this._read = () => {
	    if (paused && stream.resume) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  // Proxy all the other methods. Important when wrapping filters and duplexes.
	  const streamKeys = ObjectKeys(stream);
	  for (let j = 1; j < streamKeys.length; j++) {
	    const i = streamKeys[j];
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = stream[i].bind(stream);
	    }
	  }
	  return this
	};
	Readable.prototype[SymbolAsyncIterator] = function () {
	  return streamToAsyncIterator(this)
	};
	Readable.prototype.iterator = function (options) {
	  if (options !== undefined) {
	    validateObject(options, 'options');
	  }
	  return streamToAsyncIterator(this, options)
	};
	function streamToAsyncIterator(stream, options) {
	  if (typeof stream.read !== 'function') {
	    stream = Readable.wrap(stream, {
	      objectMode: true
	    });
	  }
	  const iter = createAsyncIterator(stream, options);
	  iter.stream = stream;
	  return iter
	}
	async function* createAsyncIterator(stream, options) {
	  let callback = nop;
	  function next(resolve) {
	    if (this === stream) {
	      callback();
	      callback = nop;
	    } else {
	      callback = resolve;
	    }
	  }
	  stream.on('readable', next);
	  let error;
	  const cleanup = eos(
	    stream,
	    {
	      writable: false
	    },
	    (err) => {
	      error = err ? aggregateTwoErrors(error, err) : null;
	      callback();
	      callback = nop;
	    }
	  );
	  try {
	    while (true) {
	      const chunk = stream.destroyed ? null : stream.read();
	      if (chunk !== null) {
	        yield chunk;
	      } else if (error) {
	        throw error
	      } else if (error === null) {
	        return
	      } else {
	        await new Promise(next);
	      }
	    }
	  } catch (err) {
	    error = aggregateTwoErrors(error, err);
	    throw error
	  } finally {
	    if (
	      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&
	      (error === undefined || stream._readableState.autoDestroy)
	    ) {
	      destroyImpl.destroyer(stream, null);
	    } else {
	      stream.off('readable', next);
	      cleanup();
	    }
	  }
	}

	// Making it explicit these properties are not enumerable
	// because otherwise some prototype manipulation in
	// userland will fail.
	ObjectDefineProperties(Readable.prototype, {
	  readable: {
	    __proto__: null,
	    get() {
	      const r = this._readableState;
	      // r.readable === false means that this is part of a Duplex stream
	      // where the readable side was disabled upon construction.
	      // Compat. The user might manually disable readable side through
	      // deprecated setter.
	      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted
	    },
	    set(val) {
	      // Backwards compat.
	      if (this._readableState) {
	        this._readableState.readable = !!val;
	      }
	    }
	  },
	  readableDidRead: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState.dataEmitted
	    }
	  },
	  readableAborted: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return !!(
	        this._readableState.readable !== false &&
	        (this._readableState.destroyed || this._readableState.errored) &&
	        !this._readableState.endEmitted
	      )
	    }
	  },
	  readableHighWaterMark: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState.highWaterMark
	    }
	  },
	  readableBuffer: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState && this._readableState.buffer
	    }
	  },
	  readableFlowing: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState.flowing
	    },
	    set: function (state) {
	      if (this._readableState) {
	        this._readableState.flowing = state;
	      }
	    }
	  },
	  readableLength: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState.length
	    }
	  },
	  readableObjectMode: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.objectMode : false
	    }
	  },
	  readableEncoding: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.encoding : null
	    }
	  },
	  errored: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.errored : null
	    }
	  },
	  closed: {
	    __proto__: null,
	    get() {
	      return this._readableState ? this._readableState.closed : false
	    }
	  },
	  destroyed: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.destroyed : false
	    },
	    set(value) {
	      // We ignore the value if the stream
	      // has not been initialized yet.
	      if (!this._readableState) {
	        return
	      }

	      // Backward compatibility, the user is explicitly
	      // managing destroyed.
	      this._readableState.destroyed = value;
	    }
	  },
	  readableEnded: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.endEmitted : false
	    }
	  }
	});
	ObjectDefineProperties(ReadableState.prototype, {
	  // Legacy getter for `pipesCount`.
	  pipesCount: {
	    __proto__: null,
	    get() {
	      return this.pipes.length
	    }
	  },
	  // Legacy property for `paused`.
	  paused: {
	    __proto__: null,
	    get() {
	      return this[kPaused] !== false
	    },
	    set(value) {
	      this[kPaused] = !!value;
	    }
	  }
	});

	// Exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered.
	  if (state.length === 0) return null
	  let ret;
	  if (state.objectMode) ret = state.buffer.shift();
	  else if (!n || n >= state.length) {
	    // Read it all, truncate the list.
	    if (state.decoder) ret = state.buffer.join('');
	    else if (state.buffer.length === 1) ret = state.buffer.first();
	    else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list.
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret
	}
	function endReadable(stream) {
	  const state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.emit('end');
	    if (stream.writable && stream.allowHalfOpen === false) {
	      process.nextTick(endWritableNT, stream);
	    } else if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well.
	      const wState = stream._writableState;
	      const autoDestroy =
	        !wState ||
	        (wState.autoDestroy &&
	          // We don't expect the writable to ever 'finish'
	          // if writable is explicitly set to false.
	          (wState.finished || wState.writable === false));
	      if (autoDestroy) {
	        stream.destroy();
	      }
	    }
	  }
	}
	function endWritableNT(stream) {
	  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
	  if (writable) {
	    stream.end();
	  }
	}
	Readable.from = function (iterable, opts) {
	  return from(Readable, iterable, opts)
	};
	let webStreamsAdapters;

	// Lazy to avoid circular references
	function lazyWebStreams() {
	  if (webStreamsAdapters === undefined) webStreamsAdapters = {};
	  return webStreamsAdapters
	}
	Readable.fromWeb = function (readableStream, options) {
	  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)
	};
	Readable.toWeb = function (streamReadable, options) {
	  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)
	};
	Readable.wrap = function (src, options) {
	  var _ref, _src$readableObjectMo;
	  return new Readable({
	    objectMode:
	      (_ref =
	        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined
	          ? _src$readableObjectMo
	          : src.objectMode) !== null && _ref !== undefined
	        ? _ref
	        : true,
	    ...options,
	    destroy(err, callback) {
	      destroyImpl.destroyer(src, err);
	      callback(err);
	    }
	  }).wrap(src)
	};
	return readable;
}

var writable;
var hasRequiredWritable;

function requireWritable () {
	if (hasRequiredWritable) return writable;
	hasRequiredWritable = 1;

	/* replacement start */

	const process = requireBrowser$2();

	/* replacement end */

	const {
	  ArrayPrototypeSlice,
	  Error,
	  FunctionPrototypeSymbolHasInstance,
	  ObjectDefineProperty,
	  ObjectDefineProperties,
	  ObjectSetPrototypeOf,
	  StringPrototypeToLowerCase,
	  Symbol,
	  SymbolHasInstance
	} = requirePrimordials();
	writable = Writable;
	Writable.WritableState = WritableState;
	const { EventEmitter: EE } = requireEvents();
	const Stream = requireLegacy().Stream;
	const { Buffer } = require$$0$2;
	const destroyImpl = requireDestroy();
	const { addAbortSignal } = requireAddAbortSignal();
	const { getHighWaterMark, getDefaultHighWaterMark } = requireState();
	const {
	  ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED,
	  ERR_STREAM_ALREADY_FINISHED,
	  ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING
	} = requireErrors().codes;
	const { errorOrDestroy } = destroyImpl;
	ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
	ObjectSetPrototypeOf(Writable, Stream);
	function nop() {}
	const kOnFinished = Symbol('kOnFinished');
	function WritableState(options, stream, isDuplex) {
	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof requireDuplex();

	  // Object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!(options && options.objectMode);
	  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);

	  // The point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write().
	  this.highWaterMark = options
	    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)
	    : getDefaultHighWaterMark(false);

	  // if _final has been called.
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // At the start of calling end()
	  this.ending = false;
	  // When end() has been called, and returned.
	  this.ended = false;
	  // When 'finish' is emitted.
	  this.finished = false;

	  // Has it been destroyed
	  this.destroyed = false;

	  // Should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  const noDecode = !!(options && options.decodeStrings === false);
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';

	  // Not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // A flag to see when we're in the middle of a write.
	  this.writing = false;

	  // When true all writes will be buffered until .uncork() call.
	  this.corked = 0;

	  // A flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // A flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // The callback that's passed to _write(chunk, cb).
	  this.onwrite = onwrite.bind(undefined, stream);

	  // The callback that the user supplies to write(chunk, encoding, cb).
	  this.writecb = null;

	  // The amount that is being written when _write is called.
	  this.writelen = 0;

	  // Storage for data passed to the afterWrite() callback in case of
	  // synchronous _write() completion.
	  this.afterWriteTickInfo = null;
	  resetBuffer(this);

	  // Number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted.
	  this.pendingcb = 0;

	  // Stream is still being constructed and cannot be
	  // destroyed until construction finished or failed.
	  // Async construction is opt in, therefore we start as
	  // constructed.
	  this.constructed = true;

	  // Emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams.
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again.
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = !options || options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end').
	  this.autoDestroy = !options || options.autoDestroy !== false;

	  // Indicates whether the stream has errored. When true all write() calls
	  // should return false. This is needed since when autoDestroy
	  // is disabled we need a way to tell whether the stream has failed.
	  this.errored = null;

	  // Indicates whether the stream has finished destroying.
	  this.closed = false;

	  // True if close has been emitted or would have been emitted
	  // depending on emitClose.
	  this.closeEmitted = false;
	  this[kOnFinished] = [];
	}
	function resetBuffer(state) {
	  state.buffered = [];
	  state.bufferedIndex = 0;
	  state.allBuffers = true;
	  state.allNoop = true;
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)
	};
	ObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {
	  __proto__: null,
	  get() {
	    return this.buffered.length - this.bufferedIndex
	  }
	});
	function Writable(options) {
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5.
	  const isDuplex = this instanceof requireDuplex();
	  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)
	  this._writableState = new WritableState(options, this, isDuplex);
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	    if (typeof options.construct === 'function') this._construct = options.construct;
	    if (options.signal) addAbortSignal(options.signal, this);
	  }
	  Stream.call(this, options);
	  destroyImpl.construct(this, () => {
	    const state = this._writableState;
	    if (!state.writing) {
	      clearBuffer(this, state);
	    }
	    finishMaybe(this, state);
	  });
	}
	ObjectDefineProperty(Writable, SymbolHasInstance, {
	  __proto__: null,
	  value: function (object) {
	    if (FunctionPrototypeSymbolHasInstance(this, object)) return true
	    if (this !== Writable) return false
	    return object && object._writableState instanceof WritableState
	  }
	});

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function _write(stream, chunk, encoding, cb) {
	  const state = stream._writableState;
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = state.defaultEncoding;
	  } else {
	    if (!encoding) encoding = state.defaultEncoding;
	    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
	    if (typeof cb !== 'function') cb = nop;
	  }
	  if (chunk === null) {
	    throw new ERR_STREAM_NULL_VALUES()
	  } else if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      if (state.decodeStrings !== false) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = 'buffer';
	      }
	    } else if (chunk instanceof Buffer) {
	      encoding = 'buffer';
	    } else if (Stream._isUint8Array(chunk)) {
	      chunk = Stream._uint8ArrayToBuffer(chunk);
	      encoding = 'buffer';
	    } else {
	      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
	    }
	  }
	  let err;
	  if (state.ending) {
	    err = new ERR_STREAM_WRITE_AFTER_END();
	  } else if (state.destroyed) {
	    err = new ERR_STREAM_DESTROYED('write');
	  }
	  if (err) {
	    process.nextTick(cb, err);
	    errorOrDestroy(stream, err, true);
	    return err
	  }
	  state.pendingcb++;
	  return writeOrBuffer(stream, state, chunk, encoding, cb)
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  return _write(this, chunk, encoding, cb) === true
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  const state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding);
	  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
	  this._writableState.defaultEncoding = encoding;
	  return this
	};

	// If we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, callback) {
	  const len = state.objectMode ? 1 : chunk.length;
	  state.length += len;

	  // stream._write resets state.length
	  const ret = state.length < state.highWaterMark;
	  // We must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked || state.errored || !state.constructed) {
	    state.buffered.push({
	      chunk,
	      encoding,
	      callback
	    });
	    if (state.allBuffers && encoding !== 'buffer') {
	      state.allBuffers = false;
	    }
	    if (state.allNoop && callback !== nop) {
	      state.allNoop = false;
	    }
	  } else {
	    state.writelen = len;
	    state.writecb = callback;
	    state.writing = true;
	    state.sync = true;
	    stream._write(chunk, encoding, state.onwrite);
	    state.sync = false;
	  }

	  // Return false if errored or destroyed in order to break
	  // any synchronous while(stream.write(data)) loops.
	  return ret && !state.errored && !state.destroyed
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));
	  else if (writev) stream._writev(chunk, state.onwrite);
	  else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, er, cb) {
	  --state.pendingcb;
	  cb(er);
	  // Ensure callbacks are invoked even when autoDestroy is
	  // not enabled. Passing `er` here doesn't make sense since
	  // it's related to one specific write, not to the buffered
	  // writes.
	  errorBuffer(state);
	  // This can emit error, but error must always follow cb.
	  errorOrDestroy(stream, er);
	}
	function onwrite(stream, er) {
	  const state = stream._writableState;
	  const sync = state.sync;
	  const cb = state.writecb;
	  if (typeof cb !== 'function') {
	    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
	    return
	  }
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	  if (er) {
	    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
	    er.stack; // eslint-disable-line no-unused-expressions

	    if (!state.errored) {
	      state.errored = er;
	    }

	    // In case of duplex streams we need to notify the readable side of the
	    // error.
	    if (stream._readableState && !stream._readableState.errored) {
	      stream._readableState.errored = er;
	    }
	    if (sync) {
	      process.nextTick(onwriteError, stream, state, er, cb);
	    } else {
	      onwriteError(stream, state, er, cb);
	    }
	  } else {
	    if (state.buffered.length > state.bufferedIndex) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      // It is a common case that the callback passed to .write() is always
	      // the same. In that case, we do not schedule a new nextTick(), but
	      // rather just increase a counter, to improve performance and avoid
	      // memory allocations.
	      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
	        state.afterWriteTickInfo.count++;
	      } else {
	        state.afterWriteTickInfo = {
	          count: 1,
	          cb,
	          stream,
	          state
	        };
	        process.nextTick(afterWriteTick, state.afterWriteTickInfo);
	      }
	    } else {
	      afterWrite(stream, state, 1, cb);
	    }
	  }
	}
	function afterWriteTick({ stream, state, count, cb }) {
	  state.afterWriteTickInfo = null;
	  return afterWrite(stream, state, count, cb)
	}
	function afterWrite(stream, state, count, cb) {
	  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
	  if (needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	  while (count-- > 0) {
	    state.pendingcb--;
	    cb();
	  }
	  if (state.destroyed) {
	    errorBuffer(state);
	  }
	  finishMaybe(stream, state);
	}

	// If there's something in the buffer waiting, then invoke callbacks.
	function errorBuffer(state) {
	  if (state.writing) {
	    return
	  }
	  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
	    var _state$errored;
	    const { chunk, callback } = state.buffered[n];
	    const len = state.objectMode ? 1 : chunk.length;
	    state.length -= len;
	    callback(
	      (_state$errored = state.errored) !== null && _state$errored !== undefined
	        ? _state$errored
	        : new ERR_STREAM_DESTROYED('write')
	    );
	  }
	  const onfinishCallbacks = state[kOnFinished].splice(0);
	  for (let i = 0; i < onfinishCallbacks.length; i++) {
	    var _state$errored2;
	    onfinishCallbacks[i](
	      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined
	        ? _state$errored2
	        : new ERR_STREAM_DESTROYED('end')
	    );
	  }
	  resetBuffer(state);
	}

	// If there's something in the buffer waiting, then process it.
	function clearBuffer(stream, state) {
	  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
	    return
	  }
	  const { buffered, bufferedIndex, objectMode } = state;
	  const bufferedLength = buffered.length - bufferedIndex;
	  if (!bufferedLength) {
	    return
	  }
	  let i = bufferedIndex;
	  state.bufferProcessing = true;
	  if (bufferedLength > 1 && stream._writev) {
	    state.pendingcb -= bufferedLength - 1;
	    const callback = state.allNoop
	      ? nop
	      : (err) => {
	          for (let n = i; n < buffered.length; ++n) {
	            buffered[n].callback(err);
	          }
	        };
	    // Make a copy of `buffered` if it's going to be used by `callback` above,
	    // since `doWrite` will mutate the array.
	    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
	    chunks.allBuffers = state.allBuffers;
	    doWrite(stream, state, true, state.length, chunks, '', callback);
	    resetBuffer(state);
	  } else {
	    do {
	      const { chunk, encoding, callback } = buffered[i];
	      buffered[i++] = null;
	      const len = objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, callback);
	    } while (i < buffered.length && !state.writing)
	    if (i === buffered.length) {
	      resetBuffer(state);
	    } else if (i > 256) {
	      buffered.splice(0, i);
	      state.bufferedIndex = 0;
	    } else {
	      state.bufferedIndex = i;
	    }
	  }
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  if (this._writev) {
	    this._writev(
	      [
	        {
	          chunk,
	          encoding
	        }
	      ],
	      cb
	    );
	  } else {
	    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')
	  }
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  const state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  let err;
	  if (chunk !== null && chunk !== undefined) {
	    const ret = _write(this, chunk, encoding);
	    if (ret instanceof Error) {
	      err = ret;
	    }
	  }

	  // .end() fully uncorks.
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	  if (err) ; else if (!state.errored && !state.ending) {
	    // This is forgiving in terms of unnecessary calls to end() and can hide
	    // logic errors. However, usually such errors are harmless and causing a
	    // hard error can be disproportionately destructive. It is not always
	    // trivial for the user to determine whether end() needs to be called
	    // or not.

	    state.ending = true;
	    finishMaybe(this, state, true);
	    state.ended = true;
	  } else if (state.finished) {
	    err = new ERR_STREAM_ALREADY_FINISHED('end');
	  } else if (state.destroyed) {
	    err = new ERR_STREAM_DESTROYED('end');
	  }
	  if (typeof cb === 'function') {
	    if (err || state.finished) {
	      process.nextTick(cb, err);
	    } else {
	      state[kOnFinished].push(cb);
	    }
	  }
	  return this
	};
	function needFinish(state) {
	  return (
	    state.ending &&
	    !state.destroyed &&
	    state.constructed &&
	    state.length === 0 &&
	    !state.errored &&
	    state.buffered.length === 0 &&
	    !state.finished &&
	    !state.writing &&
	    !state.errorEmitted &&
	    !state.closeEmitted
	  )
	}
	function callFinal(stream, state) {
	  let called = false;
	  function onFinish(err) {
	    if (called) {
	      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
	      return
	    }
	    called = true;
	    state.pendingcb--;
	    if (err) {
	      const onfinishCallbacks = state[kOnFinished].splice(0);
	      for (let i = 0; i < onfinishCallbacks.length; i++) {
	        onfinishCallbacks[i](err);
	      }
	      errorOrDestroy(stream, err, state.sync);
	    } else if (needFinish(state)) {
	      state.prefinished = true;
	      stream.emit('prefinish');
	      // Backwards compat. Don't check state.sync here.
	      // Some streams assume 'finish' will be emitted
	      // asynchronously relative to _final callback.
	      state.pendingcb++;
	      process.nextTick(finish, stream, state);
	    }
	  }
	  state.sync = true;
	  state.pendingcb++;
	  try {
	    stream._final(onFinish);
	  } catch (err) {
	    onFinish(err);
	  }
	  state.sync = false;
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.finalCalled = true;
	      callFinal(stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state, sync) {
	  if (needFinish(state)) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      if (sync) {
	        state.pendingcb++;
	        process.nextTick(
	          (stream, state) => {
	            if (needFinish(state)) {
	              finish(stream, state);
	            } else {
	              state.pendingcb--;
	            }
	          },
	          stream,
	          state
	        );
	      } else if (needFinish(state)) {
	        state.pendingcb++;
	        finish(stream, state);
	      }
	    }
	  }
	}
	function finish(stream, state) {
	  state.pendingcb--;
	  state.finished = true;
	  const onfinishCallbacks = state[kOnFinished].splice(0);
	  for (let i = 0; i < onfinishCallbacks.length; i++) {
	    onfinishCallbacks[i]();
	  }
	  stream.emit('finish');
	  if (state.autoDestroy) {
	    // In case of duplex streams we need a way to detect
	    // if the readable side is ready for autoDestroy as well.
	    const rState = stream._readableState;
	    const autoDestroy =
	      !rState ||
	      (rState.autoDestroy &&
	        // We don't expect the readable to ever 'end'
	        // if readable is explicitly set to false.
	        (rState.endEmitted || rState.readable === false));
	    if (autoDestroy) {
	      stream.destroy();
	    }
	  }
	}
	ObjectDefineProperties(Writable.prototype, {
	  closed: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.closed : false
	    }
	  },
	  destroyed: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.destroyed : false
	    },
	    set(value) {
	      // Backward compatibility, the user is explicitly managing destroyed.
	      if (this._writableState) {
	        this._writableState.destroyed = value;
	      }
	    }
	  },
	  writable: {
	    __proto__: null,
	    get() {
	      const w = this._writableState;
	      // w.writable === false means that this is part of a Duplex stream
	      // where the writable side was disabled upon construction.
	      // Compat. The user might manually disable writable side through
	      // deprecated setter.
	      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended
	    },
	    set(val) {
	      // Backwards compatible.
	      if (this._writableState) {
	        this._writableState.writable = !!val;
	      }
	    }
	  },
	  writableFinished: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.finished : false
	    }
	  },
	  writableObjectMode: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.objectMode : false
	    }
	  },
	  writableBuffer: {
	    __proto__: null,
	    get() {
	      return this._writableState && this._writableState.getBuffer()
	    }
	  },
	  writableEnded: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.ending : false
	    }
	  },
	  writableNeedDrain: {
	    __proto__: null,
	    get() {
	      const wState = this._writableState;
	      if (!wState) return false
	      return !wState.destroyed && !wState.ending && wState.needDrain
	    }
	  },
	  writableHighWaterMark: {
	    __proto__: null,
	    get() {
	      return this._writableState && this._writableState.highWaterMark
	    }
	  },
	  writableCorked: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.corked : 0
	    }
	  },
	  writableLength: {
	    __proto__: null,
	    get() {
	      return this._writableState && this._writableState.length
	    }
	  },
	  errored: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._writableState ? this._writableState.errored : null
	    }
	  },
	  writableAborted: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return !!(
	        this._writableState.writable !== false &&
	        (this._writableState.destroyed || this._writableState.errored) &&
	        !this._writableState.finished
	      )
	    }
	  }
	});
	const destroy = destroyImpl.destroy;
	Writable.prototype.destroy = function (err, cb) {
	  const state = this._writableState;

	  // Invoke pending callbacks.
	  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
	    process.nextTick(errorBuffer, state);
	  }
	  destroy.call(this, err, cb);
	  return this
	};
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	Writable.prototype[EE.captureRejectionSymbol] = function (err) {
	  this.destroy(err);
	};
	let webStreamsAdapters;

	// Lazy to avoid circular references
	function lazyWebStreams() {
	  if (webStreamsAdapters === undefined) webStreamsAdapters = {};
	  return webStreamsAdapters
	}
	Writable.fromWeb = function (writableStream, options) {
	  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)
	};
	Writable.toWeb = function (streamWritable) {
	  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)
	};
	return writable;
}

/* replacement start */

var duplexify;
var hasRequiredDuplexify;

function requireDuplexify () {
	if (hasRequiredDuplexify) return duplexify;
	hasRequiredDuplexify = 1;
	const process = requireBrowser$2()

	/* replacement end */

	;	const bufferModule = require$$0$2;
	const {
	  isReadable,
	  isWritable,
	  isIterable,
	  isNodeStream,
	  isReadableNodeStream,
	  isWritableNodeStream,
	  isDuplexNodeStream,
	  isReadableStream,
	  isWritableStream
	} = requireUtils$1();
	const eos = requireEndOfStream();
	const {
	  AbortError,
	  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
	} = requireErrors();
	const { destroyer } = requireDestroy();
	const Duplex = requireDuplex();
	const Readable = requireReadable();
	const Writable = requireWritable();
	const { createDeferredPromise } = requireUtil$2();
	const from = requireFrom();
	const Blob = globalThis.Blob || bufferModule.Blob;
	const isBlob =
	  typeof Blob !== 'undefined'
	    ? function isBlob(b) {
	        return b instanceof Blob
	      }
	    : function isBlob(b) {
	        return false
	      };
	const AbortController = globalThis.AbortController || requireBrowser$1().AbortController;
	const { FunctionPrototypeCall } = requirePrimordials();

	// This is needed for pre node 17.
	class Duplexify extends Duplex {
	  constructor(options) {
	    super(options);

	    // https://github.com/nodejs/node/pull/34385

	    if ((options === null || options === undefined ? undefined : options.readable) === false) {
	      this._readableState.readable = false;
	      this._readableState.ended = true;
	      this._readableState.endEmitted = true;
	    }
	    if ((options === null || options === undefined ? undefined : options.writable) === false) {
	      this._writableState.writable = false;
	      this._writableState.ending = true;
	      this._writableState.ended = true;
	      this._writableState.finished = true;
	    }
	  }
	}
	duplexify = function duplexify(body, name) {
	  if (isDuplexNodeStream(body)) {
	    return body
	  }
	  if (isReadableNodeStream(body)) {
	    return _duplexify({
	      readable: body
	    })
	  }
	  if (isWritableNodeStream(body)) {
	    return _duplexify({
	      writable: body
	    })
	  }
	  if (isNodeStream(body)) {
	    return _duplexify({
	      writable: false,
	      readable: false
	    })
	  }
	  if (isReadableStream(body)) {
	    return _duplexify({
	      readable: Readable.fromWeb(body)
	    })
	  }
	  if (isWritableStream(body)) {
	    return _duplexify({
	      writable: Writable.fromWeb(body)
	    })
	  }
	  if (typeof body === 'function') {
	    const { value, write, final, destroy } = fromAsyncGen(body);
	    if (isIterable(value)) {
	      return from(Duplexify, value, {
	        // TODO (ronag): highWaterMark?
	        objectMode: true,
	        write,
	        final,
	        destroy
	      })
	    }
	    const then = value === null || value === undefined ? undefined : value.then;
	    if (typeof then === 'function') {
	      let d;
	      const promise = FunctionPrototypeCall(
	        then,
	        value,
	        (val) => {
	          if (val != null) {
	            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)
	          }
	        },
	        (err) => {
	          destroyer(d, err);
	        }
	      );
	      return (d = new Duplexify({
	        // TODO (ronag): highWaterMark?
	        objectMode: true,
	        readable: false,
	        write,
	        final(cb) {
	          final(async () => {
	            try {
	              await promise;
	              process.nextTick(cb, null);
	            } catch (err) {
	              process.nextTick(cb, err);
	            }
	          });
	        },
	        destroy
	      }))
	    }
	    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)
	  }
	  if (isBlob(body)) {
	    return duplexify(body.arrayBuffer())
	  }
	  if (isIterable(body)) {
	    return from(Duplexify, body, {
	      // TODO (ronag): highWaterMark?
	      objectMode: true,
	      writable: false
	    })
	  }
	  if (
	    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&
	    isWritableStream(body === null || body === undefined ? undefined : body.writable)
	  ) {
	    return Duplexify.fromWeb(body)
	  }
	  if (
	    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||
	    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'
	  ) {
	    const readable =
	      body !== null && body !== undefined && body.readable
	        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)
	          ? body === null || body === undefined
	            ? undefined
	            : body.readable
	          : duplexify(body.readable)
	        : undefined;
	    const writable =
	      body !== null && body !== undefined && body.writable
	        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)
	          ? body === null || body === undefined
	            ? undefined
	            : body.writable
	          : duplexify(body.writable)
	        : undefined;
	    return _duplexify({
	      readable,
	      writable
	    })
	  }
	  const then = body === null || body === undefined ? undefined : body.then;
	  if (typeof then === 'function') {
	    let d;
	    FunctionPrototypeCall(
	      then,
	      body,
	      (val) => {
	        if (val != null) {
	          d.push(val);
	        }
	        d.push(null);
	      },
	      (err) => {
	        destroyer(d, err);
	      }
	    );
	    return (d = new Duplexify({
	      objectMode: true,
	      writable: false,
	      read() {}
	    }))
	  }
	  throw new ERR_INVALID_ARG_TYPE(
	    name,
	    [
	      'Blob',
	      'ReadableStream',
	      'WritableStream',
	      'Stream',
	      'Iterable',
	      'AsyncIterable',
	      'Function',
	      '{ readable, writable } pair',
	      'Promise'
	    ],
	    body
	  )
	};
	function fromAsyncGen(fn) {
	  let { promise, resolve } = createDeferredPromise();
	  const ac = new AbortController();
	  const signal = ac.signal;
	  const value = fn(
	    (async function* () {
	      while (true) {
	        const _promise = promise;
	        promise = null;
	        const { chunk, done, cb } = await _promise;
	        process.nextTick(cb);
	        if (done) return
	        if (signal.aborted)
	          throw new AbortError(undefined, {
	            cause: signal.reason
	          })
	        ;({ promise, resolve } = createDeferredPromise());
	        yield chunk;
	      }
	    })(),
	    {
	      signal
	    }
	  );
	  return {
	    value,
	    write(chunk, encoding, cb) {
	      const _resolve = resolve;
	      resolve = null;
	      _resolve({
	        chunk,
	        done: false,
	        cb
	      });
	    },
	    final(cb) {
	      const _resolve = resolve;
	      resolve = null;
	      _resolve({
	        done: true,
	        cb
	      });
	    },
	    destroy(err, cb) {
	      ac.abort();
	      cb(err);
	    }
	  }
	}
	function _duplexify(pair) {
	  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable;
	  const w = pair.writable;
	  let readable = !!isReadable(r);
	  let writable = !!isWritable(w);
	  let ondrain;
	  let onfinish;
	  let onreadable;
	  let onclose;
	  let d;
	  function onfinished(err) {
	    const cb = onclose;
	    onclose = null;
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      d.destroy(err);
	    }
	  }

	  // TODO(ronag): Avoid double buffering.
	  // Implement Writable/Readable/Duplex traits.
	  // See, https://github.com/nodejs/node/pull/33515.
	  d = new Duplexify({
	    // TODO (ronag): highWaterMark?
	    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
	    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
	    readable,
	    writable
	  });
	  if (writable) {
	    eos(w, (err) => {
	      writable = false;
	      if (err) {
	        destroyer(r, err);
	      }
	      onfinished(err);
	    });
	    d._write = function (chunk, encoding, callback) {
	      if (w.write(chunk, encoding)) {
	        callback();
	      } else {
	        ondrain = callback;
	      }
	    };
	    d._final = function (callback) {
	      w.end();
	      onfinish = callback;
	    };
	    w.on('drain', function () {
	      if (ondrain) {
	        const cb = ondrain;
	        ondrain = null;
	        cb();
	      }
	    });
	    w.on('finish', function () {
	      if (onfinish) {
	        const cb = onfinish;
	        onfinish = null;
	        cb();
	      }
	    });
	  }
	  if (readable) {
	    eos(r, (err) => {
	      readable = false;
	      if (err) {
	        destroyer(r, err);
	      }
	      onfinished(err);
	    });
	    r.on('readable', function () {
	      if (onreadable) {
	        const cb = onreadable;
	        onreadable = null;
	        cb();
	      }
	    });
	    r.on('end', function () {
	      d.push(null);
	    });
	    d._read = function () {
	      while (true) {
	        const buf = r.read();
	        if (buf === null) {
	          onreadable = d._read;
	          return
	        }
	        if (!d.push(buf)) {
	          return
	        }
	      }
	    };
	  }
	  d._destroy = function (err, callback) {
	    if (!err && onclose !== null) {
	      err = new AbortError();
	    }
	    onreadable = null;
	    ondrain = null;
	    onfinish = null;
	    if (onclose === null) {
	      callback(err);
	    } else {
	      onclose = callback;
	      destroyer(w, err);
	      destroyer(r, err);
	    }
	  };
	  return d
	}
	return duplexify;
}

var duplex;
var hasRequiredDuplex;

function requireDuplex () {
	if (hasRequiredDuplex) return duplex;
	hasRequiredDuplex = 1;

	const {
	  ObjectDefineProperties,
	  ObjectGetOwnPropertyDescriptor,
	  ObjectKeys,
	  ObjectSetPrototypeOf
	} = requirePrimordials();
	duplex = Duplex;
	const Readable = requireReadable();
	const Writable = requireWritable();
	ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
	ObjectSetPrototypeOf(Duplex, Readable);
	{
	  const keys = ObjectKeys(Writable.prototype);
	  // Allow the keys array to be GC'ed.
	  for (let i = 0; i < keys.length; i++) {
	    const method = keys[i];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options)
	  Readable.call(this, options);
	  Writable.call(this, options);
	  if (options) {
	    this.allowHalfOpen = options.allowHalfOpen !== false;
	    if (options.readable === false) {
	      this._readableState.readable = false;
	      this._readableState.ended = true;
	      this._readableState.endEmitted = true;
	    }
	    if (options.writable === false) {
	      this._writableState.writable = false;
	      this._writableState.ending = true;
	      this._writableState.ended = true;
	      this._writableState.finished = true;
	    }
	  } else {
	    this.allowHalfOpen = true;
	  }
	}
	ObjectDefineProperties(Duplex.prototype, {
	  writable: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')
	  },
	  writableHighWaterMark: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')
	  },
	  writableObjectMode: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')
	  },
	  writableBuffer: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')
	  },
	  writableLength: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')
	  },
	  writableFinished: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')
	  },
	  writableCorked: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')
	  },
	  writableEnded: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')
	  },
	  writableNeedDrain: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')
	  },
	  destroyed: {
	    __proto__: null,
	    get() {
	      if (this._readableState === undefined || this._writableState === undefined) {
	        return false
	      }
	      return this._readableState.destroyed && this._writableState.destroyed
	    },
	    set(value) {
	      // Backward compatibility, the user is explicitly
	      // managing destroyed.
	      if (this._readableState && this._writableState) {
	        this._readableState.destroyed = value;
	        this._writableState.destroyed = value;
	      }
	    }
	  }
	});
	let webStreamsAdapters;

	// Lazy to avoid circular references
	function lazyWebStreams() {
	  if (webStreamsAdapters === undefined) webStreamsAdapters = {};
	  return webStreamsAdapters
	}
	Duplex.fromWeb = function (pair, options) {
	  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)
	};
	Duplex.toWeb = function (duplex) {
	  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)
	};
	let duplexify;
	Duplex.from = function (body) {
	  if (!duplexify) {
	    duplexify = requireDuplexify();
	  }
	  return duplexify(body, 'body')
	};
	return duplex;
}

var transform;
var hasRequiredTransform;

function requireTransform () {
	if (hasRequiredTransform) return transform;
	hasRequiredTransform = 1;

	const { ObjectSetPrototypeOf, Symbol } = requirePrimordials();
	transform = Transform;
	const { ERR_METHOD_NOT_IMPLEMENTED } = requireErrors().codes;
	const Duplex = requireDuplex();
	const { getHighWaterMark } = requireState();
	ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
	ObjectSetPrototypeOf(Transform, Duplex);
	const kCallback = Symbol('kCallback');
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options)

	  // TODO (ronag): This should preferably always be
	  // applied but would be semver-major. Or even better;
	  // make Transform a Readable with the Writable interface.
	  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null;
	  if (readableHighWaterMark === 0) {
	    // A Duplex will buffer both on the writable and readable side while
	    // a Transform just wants to buffer hwm number of elements. To avoid
	    // buffering twice we disable buffering on the writable side.
	    options = {
	      ...options,
	      highWaterMark: null,
	      readableHighWaterMark,
	      // TODO (ronag): 0 is not optimal since we have
	      // a "bug" where we check needDrain before calling _write and not after.
	      // Refs: https://github.com/nodejs/node/pull/32887
	      // Refs: https://github.com/nodejs/node/pull/35941
	      writableHighWaterMark: options.writableHighWaterMark || 0
	    };
	  }
	  Duplex.call(this, options);

	  // We have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  this[kCallback] = null;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  // Backwards compat. Some Transform streams incorrectly implement _final
	  // instead of or in addition to _flush. By using 'prefinish' instead of
	  // implementing _final we continue supporting this unfortunate use case.
	  this.on('prefinish', prefinish);
	}
	function final(cb) {
	  if (typeof this._flush === 'function' && !this.destroyed) {
	    this._flush((er, data) => {
	      if (er) {
	        if (cb) {
	          cb(er);
	        } else {
	          this.destroy(er);
	        }
	        return
	      }
	      if (data != null) {
	        this.push(data);
	      }
	      this.push(null);
	      if (cb) {
	        cb();
	      }
	    });
	  } else {
	    this.push(null);
	    if (cb) {
	      cb();
	    }
	  }
	}
	function prefinish() {
	  if (this._final !== final) {
	    final.call(this);
	  }
	}
	Transform.prototype._final = final;
	Transform.prototype._transform = function (chunk, encoding, callback) {
	  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')
	};
	Transform.prototype._write = function (chunk, encoding, callback) {
	  const rState = this._readableState;
	  const wState = this._writableState;
	  const length = rState.length;
	  this._transform(chunk, encoding, (err, val) => {
	    if (err) {
	      callback(err);
	      return
	    }
	    if (val != null) {
	      this.push(val);
	    }
	    if (
	      wState.ended ||
	      // Backwards compat.
	      length === rState.length ||
	      // Backwards compat.
	      rState.length < rState.highWaterMark
	    ) {
	      callback();
	    } else {
	      this[kCallback] = callback;
	    }
	  });
	};
	Transform.prototype._read = function () {
	  if (this[kCallback]) {
	    const callback = this[kCallback];
	    this[kCallback] = null;
	    callback();
	  }
	};
	return transform;
}

var passthrough;
var hasRequiredPassthrough;

function requirePassthrough () {
	if (hasRequiredPassthrough) return passthrough;
	hasRequiredPassthrough = 1;

	const { ObjectSetPrototypeOf } = requirePrimordials();
	passthrough = PassThrough;
	const Transform = requireTransform();
	ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
	ObjectSetPrototypeOf(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options)
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return passthrough;
}

/* replacement start */

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;
	const process = requireBrowser$2()

	/* replacement end */
	// Ported from https://github.com/mafintosh/pump with
	// permission from the author, Mathias Buus (@mafintosh).

	;	const { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = requirePrimordials();
	const eos = requireEndOfStream();
	const { once } = requireUtil$2();
	const destroyImpl = requireDestroy();
	const Duplex = requireDuplex();
	const {
	  aggregateTwoErrors,
	  codes: {
	    ERR_INVALID_ARG_TYPE,
	    ERR_INVALID_RETURN_VALUE,
	    ERR_MISSING_ARGS,
	    ERR_STREAM_DESTROYED,
	    ERR_STREAM_PREMATURE_CLOSE
	  },
	  AbortError
	} = requireErrors();
	const { validateFunction, validateAbortSignal } = requireValidators();
	const {
	  isIterable,
	  isReadable,
	  isReadableNodeStream,
	  isNodeStream,
	  isTransformStream,
	  isWebStream,
	  isReadableStream,
	  isReadableFinished
	} = requireUtils$1();
	const AbortController = globalThis.AbortController || requireBrowser$1().AbortController;
	let PassThrough;
	let Readable;
	let addAbortListener;
	function destroyer(stream, reading, writing) {
	  let finished = false;
	  stream.on('close', () => {
	    finished = true;
	  });
	  const cleanup = eos(
	    stream,
	    {
	      readable: reading,
	      writable: writing
	    },
	    (err) => {
	      finished = !err;
	    }
	  );
	  return {
	    destroy: (err) => {
	      if (finished) return
	      finished = true;
	      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));
	    },
	    cleanup
	  }
	}
	function popCallback(streams) {
	  // Streams should never be an empty array. It should always contain at least
	  // a single stream. Therefore optimize for the average case instead of
	  // checking for length === 0 as well.
	  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');
	  return streams.pop()
	}
	function makeAsyncIterable(val) {
	  if (isIterable(val)) {
	    return val
	  } else if (isReadableNodeStream(val)) {
	    // Legacy streams are not Iterable.
	    return fromReadable(val)
	  }
	  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)
	}
	async function* fromReadable(val) {
	  if (!Readable) {
	    Readable = requireReadable();
	  }
	  yield* Readable.prototype[SymbolAsyncIterator].call(val);
	}
	async function pumpToNode(iterable, writable, finish, { end }) {
	  let error;
	  let onresolve = null;
	  const resume = (err) => {
	    if (err) {
	      error = err;
	    }
	    if (onresolve) {
	      const callback = onresolve;
	      onresolve = null;
	      callback();
	    }
	  };
	  const wait = () =>
	    new Promise((resolve, reject) => {
	      if (error) {
	        reject(error);
	      } else {
	        onresolve = () => {
	          if (error) {
	            reject(error);
	          } else {
	            resolve();
	          }
	        };
	      }
	    });
	  writable.on('drain', resume);
	  const cleanup = eos(
	    writable,
	    {
	      readable: false
	    },
	    resume
	  );
	  try {
	    if (writable.writableNeedDrain) {
	      await wait();
	    }
	    for await (const chunk of iterable) {
	      if (!writable.write(chunk)) {
	        await wait();
	      }
	    }
	    if (end) {
	      writable.end();
	      await wait();
	    }
	    finish();
	  } catch (err) {
	    finish(error !== err ? aggregateTwoErrors(error, err) : err);
	  } finally {
	    cleanup();
	    writable.off('drain', resume);
	  }
	}
	async function pumpToWeb(readable, writable, finish, { end }) {
	  if (isTransformStream(writable)) {
	    writable = writable.writable;
	  }
	  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure
	  const writer = writable.getWriter();
	  try {
	    for await (const chunk of readable) {
	      await writer.ready;
	      writer.write(chunk).catch(() => {});
	    }
	    await writer.ready;
	    if (end) {
	      await writer.close();
	    }
	    finish();
	  } catch (err) {
	    try {
	      await writer.abort(err);
	      finish(err);
	    } catch (err) {
	      finish(err);
	    }
	  }
	}
	function pipeline(...streams) {
	  return pipelineImpl(streams, once(popCallback(streams)))
	}
	function pipelineImpl(streams, callback, opts) {
	  if (streams.length === 1 && ArrayIsArray(streams[0])) {
	    streams = streams[0];
	  }
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams')
	  }
	  const ac = new AbortController();
	  const signal = ac.signal;
	  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;

	  // Need to cleanup event listeners if last stream is readable
	  // https://github.com/nodejs/node/issues/35452
	  const lastStreamCleanup = [];
	  validateAbortSignal(outerSignal, 'options.signal');
	  function abort() {
	    finishImpl(new AbortError());
	  }
	  addAbortListener = addAbortListener || requireUtil$2().addAbortListener;
	  let disposable;
	  if (outerSignal) {
	    disposable = addAbortListener(outerSignal, abort);
	  }
	  let error;
	  let value;
	  const destroys = [];
	  let finishCount = 0;
	  function finish(err) {
	    finishImpl(err, --finishCount === 0);
	  }
	  function finishImpl(err, final) {
	    var _disposable;
	    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
	      error = err;
	    }
	    if (!error && !final) {
	      return
	    }
	    while (destroys.length) {
	      destroys.shift()(error);
	    }
(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]();
	    ac.abort();
	    if (final) {
	      if (!error) {
	        lastStreamCleanup.forEach((fn) => fn());
	      }
	      process.nextTick(callback, error, value);
	    }
	  }
	  let ret;
	  for (let i = 0; i < streams.length; i++) {
	    const stream = streams[i];
	    const reading = i < streams.length - 1;
	    const writing = i > 0;
	    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;
	    const isLastStream = i === streams.length - 1;
	    if (isNodeStream(stream)) {
	      if (end) {
	        const { destroy, cleanup } = destroyer(stream, reading, writing);
	        destroys.push(destroy);
	        if (isReadable(stream) && isLastStream) {
	          lastStreamCleanup.push(cleanup);
	        }
	      }

	      // Catch stream errors that occur after pipe/pump has completed.
	      function onError(err) {
	        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	          finish(err);
	        }
	      }
	      stream.on('error', onError);
	      if (isReadable(stream) && isLastStream) {
	        lastStreamCleanup.push(() => {
	          stream.removeListener('error', onError);
	        });
	      }
	    }
	    if (i === 0) {
	      if (typeof stream === 'function') {
	        ret = stream({
	          signal
	        });
	        if (!isIterable(ret)) {
	          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)
	        }
	      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
	        ret = stream;
	      } else {
	        ret = Duplex.from(stream);
	      }
	    } else if (typeof stream === 'function') {
	      if (isTransformStream(ret)) {
	        var _ret;
	        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
	      } else {
	        ret = makeAsyncIterable(ret);
	      }
	      ret = stream(ret, {
	        signal
	      });
	      if (reading) {
	        if (!isIterable(ret, true)) {
	          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)
	        }
	      } else {
	        var _ret2;
	        if (!PassThrough) {
	          PassThrough = requirePassthrough();
	        }

	        // If the last argument to pipeline is not a stream
	        // we must create a proxy stream so that pipeline(...)
	        // always returns a stream which can be further
	        // composed through `.pipe(stream)`.

	        const pt = new PassThrough({
	          objectMode: true
	        });

	        // Handle Promises/A+ spec, `then` could be a getter that throws on
	        // second use.
	        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
	        if (typeof then === 'function') {
	          finishCount++;
	          then.call(
	            ret,
	            (val) => {
	              value = val;
	              if (val != null) {
	                pt.write(val);
	              }
	              if (end) {
	                pt.end();
	              }
	              process.nextTick(finish);
	            },
	            (err) => {
	              pt.destroy(err);
	              process.nextTick(finish, err);
	            }
	          );
	        } else if (isIterable(ret, true)) {
	          finishCount++;
	          pumpToNode(ret, pt, finish, {
	            end
	          });
	        } else if (isReadableStream(ret) || isTransformStream(ret)) {
	          const toRead = ret.readable || ret;
	          finishCount++;
	          pumpToNode(toRead, pt, finish, {
	            end
	          });
	        } else {
	          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)
	        }
	        ret = pt;
	        const { destroy, cleanup } = destroyer(ret, false, true);
	        destroys.push(destroy);
	        if (isLastStream) {
	          lastStreamCleanup.push(cleanup);
	        }
	      }
	    } else if (isNodeStream(stream)) {
	      if (isReadableNodeStream(ret)) {
	        finishCount += 2;
	        const cleanup = pipe(ret, stream, finish, {
	          end
	        });
	        if (isReadable(stream) && isLastStream) {
	          lastStreamCleanup.push(cleanup);
	        }
	      } else if (isTransformStream(ret) || isReadableStream(ret)) {
	        const toRead = ret.readable || ret;
	        finishCount++;
	        pumpToNode(toRead, stream, finish, {
	          end
	        });
	      } else if (isIterable(ret)) {
	        finishCount++;
	        pumpToNode(ret, stream, finish, {
	          end
	        });
	      } else {
	        throw new ERR_INVALID_ARG_TYPE(
	          'val',
	          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
	          ret
	        )
	      }
	      ret = stream;
	    } else if (isWebStream(stream)) {
	      if (isReadableNodeStream(ret)) {
	        finishCount++;
	        pumpToWeb(makeAsyncIterable(ret), stream, finish, {
	          end
	        });
	      } else if (isReadableStream(ret) || isIterable(ret)) {
	        finishCount++;
	        pumpToWeb(ret, stream, finish, {
	          end
	        });
	      } else if (isTransformStream(ret)) {
	        finishCount++;
	        pumpToWeb(ret.readable, stream, finish, {
	          end
	        });
	      } else {
	        throw new ERR_INVALID_ARG_TYPE(
	          'val',
	          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
	          ret
	        )
	      }
	      ret = stream;
	    } else {
	      ret = Duplex.from(stream);
	    }
	  }
	  if (
	    (signal !== null && signal !== undefined && signal.aborted) ||
	    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
	  ) {
	    process.nextTick(abort);
	  }
	  return ret
	}
	function pipe(src, dst, finish, { end }) {
	  let ended = false;
	  dst.on('close', () => {
	    if (!ended) {
	      // Finish if the destination closes before the source has completed.
	      finish(new ERR_STREAM_PREMATURE_CLOSE());
	    }
	  });
	  src.pipe(dst, {
	    end: false
	  }); // If end is true we already will have a listener to end dst.

	  if (end) {
	    // Compat. Before node v10.12.0 stdio used to throw an error so
	    // pipe() did/does not end() stdio destinations.
	    // Now they allow it but "secretly" don't close the underlying fd.

	    function endFn() {
	      ended = true;
	      dst.end();
	    }
	    if (isReadableFinished(src)) {
	      // End the destination if the source has already ended.
	      process.nextTick(endFn);
	    } else {
	      src.once('end', endFn);
	    }
	  } else {
	    finish();
	  }
	  eos(
	    src,
	    {
	      readable: true,
	      writable: false
	    },
	    (err) => {
	      const rState = src._readableState;
	      if (
	        err &&
	        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
	        rState &&
	        rState.ended &&
	        !rState.errored &&
	        !rState.errorEmitted
	      ) {
	        // Some readable streams will emit 'close' before 'end'. However, since
	        // this is on the readable side 'end' should still be emitted if the
	        // stream has been ended and no error emitted. This should be allowed in
	        // favor of backwards compatibility. Since the stream is piped to a
	        // destination this should not result in any observable difference.
	        // We don't need to check if this is a writable premature close since
	        // eos will only fail with premature close on the reading side for
	        // duplex streams.
	        src.once('end', finish).once('error', finish);
	      } else {
	        finish(err);
	      }
	    }
	  );
	  return eos(
	    dst,
	    {
	      readable: false,
	      writable: true
	    },
	    finish
	  )
	}
	pipeline_1 = {
	  pipelineImpl,
	  pipeline
	};
	return pipeline_1;
}

var compose;
var hasRequiredCompose;

function requireCompose () {
	if (hasRequiredCompose) return compose;
	hasRequiredCompose = 1;

	const { pipeline } = requirePipeline();
	const Duplex = requireDuplex();
	const { destroyer } = requireDestroy();
	const {
	  isNodeStream,
	  isReadable,
	  isWritable,
	  isWebStream,
	  isTransformStream,
	  isWritableStream,
	  isReadableStream
	} = requireUtils$1();
	const {
	  AbortError,
	  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
	} = requireErrors();
	const eos = requireEndOfStream();
	compose = function compose(...streams) {
	  if (streams.length === 0) {
	    throw new ERR_MISSING_ARGS('streams')
	  }
	  if (streams.length === 1) {
	    return Duplex.from(streams[0])
	  }
	  const orgStreams = [...streams];
	  if (typeof streams[0] === 'function') {
	    streams[0] = Duplex.from(streams[0]);
	  }
	  if (typeof streams[streams.length - 1] === 'function') {
	    const idx = streams.length - 1;
	    streams[idx] = Duplex.from(streams[idx]);
	  }
	  for (let n = 0; n < streams.length; ++n) {
	    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
	      // TODO(ronag): Add checks for non streams.
	      continue
	    }
	    if (
	      n < streams.length - 1 &&
	      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))
	    ) {
	      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')
	    }
	    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
	      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')
	    }
	  }
	  let ondrain;
	  let onfinish;
	  let onreadable;
	  let onclose;
	  let d;
	  function onfinished(err) {
	    const cb = onclose;
	    onclose = null;
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      d.destroy(err);
	    } else if (!readable && !writable) {
	      d.destroy();
	    }
	  }
	  const head = streams[0];
	  const tail = pipeline(streams, onfinished);
	  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
	  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));

	  // TODO(ronag): Avoid double buffering.
	  // Implement Writable/Readable/Duplex traits.
	  // See, https://github.com/nodejs/node/pull/33515.
	  d = new Duplex({
	    // TODO (ronag): highWaterMark?
	    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
	    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
	    writable,
	    readable
	  });
	  if (writable) {
	    if (isNodeStream(head)) {
	      d._write = function (chunk, encoding, callback) {
	        if (head.write(chunk, encoding)) {
	          callback();
	        } else {
	          ondrain = callback;
	        }
	      };
	      d._final = function (callback) {
	        head.end();
	        onfinish = callback;
	      };
	      head.on('drain', function () {
	        if (ondrain) {
	          const cb = ondrain;
	          ondrain = null;
	          cb();
	        }
	      });
	    } else if (isWebStream(head)) {
	      const writable = isTransformStream(head) ? head.writable : head;
	      const writer = writable.getWriter();
	      d._write = async function (chunk, encoding, callback) {
	        try {
	          await writer.ready;
	          writer.write(chunk).catch(() => {});
	          callback();
	        } catch (err) {
	          callback(err);
	        }
	      };
	      d._final = async function (callback) {
	        try {
	          await writer.ready;
	          writer.close().catch(() => {});
	          onfinish = callback;
	        } catch (err) {
	          callback(err);
	        }
	      };
	    }
	    const toRead = isTransformStream(tail) ? tail.readable : tail;
	    eos(toRead, () => {
	      if (onfinish) {
	        const cb = onfinish;
	        onfinish = null;
	        cb();
	      }
	    });
	  }
	  if (readable) {
	    if (isNodeStream(tail)) {
	      tail.on('readable', function () {
	        if (onreadable) {
	          const cb = onreadable;
	          onreadable = null;
	          cb();
	        }
	      });
	      tail.on('end', function () {
	        d.push(null);
	      });
	      d._read = function () {
	        while (true) {
	          const buf = tail.read();
	          if (buf === null) {
	            onreadable = d._read;
	            return
	          }
	          if (!d.push(buf)) {
	            return
	          }
	        }
	      };
	    } else if (isWebStream(tail)) {
	      const readable = isTransformStream(tail) ? tail.readable : tail;
	      const reader = readable.getReader();
	      d._read = async function () {
	        while (true) {
	          try {
	            const { value, done } = await reader.read();
	            if (!d.push(value)) {
	              return
	            }
	            if (done) {
	              d.push(null);
	              return
	            }
	          } catch {
	            return
	          }
	        }
	      };
	    }
	  }
	  d._destroy = function (err, callback) {
	    if (!err && onclose !== null) {
	      err = new AbortError();
	    }
	    onreadable = null;
	    ondrain = null;
	    onfinish = null;
	    if (onclose === null) {
	      callback(err);
	    } else {
	      onclose = callback;
	      if (isNodeStream(tail)) {
	        destroyer(tail, err);
	      }
	    }
	  };
	  return d
	};
	return compose;
}

var hasRequiredOperators;

function requireOperators () {
	if (hasRequiredOperators) return operators;
	hasRequiredOperators = 1;

	const AbortController = globalThis.AbortController || requireBrowser$1().AbortController;
	const {
	  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
	  AbortError
	} = requireErrors();
	const { validateAbortSignal, validateInteger, validateObject } = requireValidators();
	const kWeakHandler = requirePrimordials().Symbol('kWeak');
	const kResistStopPropagation = requirePrimordials().Symbol('kResistStopPropagation');
	const { finished } = requireEndOfStream();
	const staticCompose = requireCompose();
	const { addAbortSignalNoValidate } = requireAddAbortSignal();
	const { isWritable, isNodeStream } = requireUtils$1();
	const { deprecate } = requireUtil$2();
	const {
	  ArrayPrototypePush,
	  Boolean,
	  MathFloor,
	  Number,
	  NumberIsNaN,
	  Promise,
	  PromiseReject,
	  PromiseResolve,
	  PromisePrototypeThen,
	  Symbol
	} = requirePrimordials();
	const kEmpty = Symbol('kEmpty');
	const kEof = Symbol('kEof');
	function compose(stream, options) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  if (isNodeStream(stream) && !isWritable(stream)) {
	    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')
	  }
	  const composedStream = staticCompose(this, stream);
	  if (options !== null && options !== undefined && options.signal) {
	    // Not validating as we already validated before
	    addAbortSignalNoValidate(options.signal, composedStream);
	  }
	  return composedStream
	}
	function map(fn, options) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  let concurrency = 1;
	  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
	    concurrency = MathFloor(options.concurrency);
	  }
	  let highWaterMark = concurrency - 1;
	  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
	    highWaterMark = MathFloor(options.highWaterMark);
	  }
	  validateInteger(concurrency, 'options.concurrency', 1);
	  validateInteger(highWaterMark, 'options.highWaterMark', 0);
	  highWaterMark += concurrency;
	  return async function* map() {
	    const signal = requireUtil$2().AbortSignalAny(
	      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)
	    );
	    const stream = this;
	    const queue = [];
	    const signalOpt = {
	      signal
	    };
	    let next;
	    let resume;
	    let done = false;
	    let cnt = 0;
	    function onCatch() {
	      done = true;
	      afterItemProcessed();
	    }
	    function afterItemProcessed() {
	      cnt -= 1;
	      maybeResume();
	    }
	    function maybeResume() {
	      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
	        resume();
	        resume = null;
	      }
	    }
	    async function pump() {
	      try {
	        for await (let val of stream) {
	          if (done) {
	            return
	          }
	          if (signal.aborted) {
	            throw new AbortError()
	          }
	          try {
	            val = fn(val, signalOpt);
	            if (val === kEmpty) {
	              continue
	            }
	            val = PromiseResolve(val);
	          } catch (err) {
	            val = PromiseReject(err);
	          }
	          cnt += 1;
	          PromisePrototypeThen(val, afterItemProcessed, onCatch);
	          queue.push(val);
	          if (next) {
	            next();
	            next = null;
	          }
	          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
	            await new Promise((resolve) => {
	              resume = resolve;
	            });
	          }
	        }
	        queue.push(kEof);
	      } catch (err) {
	        const val = PromiseReject(err);
	        PromisePrototypeThen(val, afterItemProcessed, onCatch);
	        queue.push(val);
	      } finally {
	        done = true;
	        if (next) {
	          next();
	          next = null;
	        }
	      }
	    }
	    pump();
	    try {
	      while (true) {
	        while (queue.length > 0) {
	          const val = await queue[0];
	          if (val === kEof) {
	            return
	          }
	          if (signal.aborted) {
	            throw new AbortError()
	          }
	          if (val !== kEmpty) {
	            yield val;
	          }
	          queue.shift();
	          maybeResume();
	        }
	        await new Promise((resolve) => {
	          next = resolve;
	        });
	      }
	    } finally {
	      done = true;
	      if (resume) {
	        resume();
	        resume = null;
	      }
	    }
	  }.call(this)
	}
	function asIndexedPairs(options = undefined) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  return async function* asIndexedPairs() {
	    let index = 0;
	    for await (const val of this) {
	      var _options$signal;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal = options.signal) !== null &&
	        _options$signal !== undefined &&
	        _options$signal.aborted
	      ) {
	        throw new AbortError({
	          cause: options.signal.reason
	        })
	      }
	      yield [index++, val];
	    }
	  }.call(this)
	}
	async function some(fn, options = undefined) {
	  for await (const unused of filter.call(this, fn, options)) {
	    return true
	  }
	  return false
	}
	async function every(fn, options = undefined) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws
	  return !(await some.call(
	    this,
	    async (...args) => {
	      return !(await fn(...args))
	    },
	    options
	  ))
	}
	async function find(fn, options) {
	  for await (const result of filter.call(this, fn, options)) {
	    return result
	  }
	  return undefined
	}
	async function forEach(fn, options) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  async function forEachFn(value, options) {
	    await fn(value, options);
	    return kEmpty
	  }
	  // eslint-disable-next-line no-unused-vars
	  for await (const unused of map.call(this, forEachFn, options));
	}
	function filter(fn, options) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  async function filterFn(value, options) {
	    if (await fn(value, options)) {
	      return value
	    }
	    return kEmpty
	  }
	  return map.call(this, filterFn, options)
	}

	// Specific to provide better error to reduce since the argument is only
	// missing if the stream has no items in it - but the code is still appropriate
	class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
	  constructor() {
	    super('reduce');
	    this.message = 'Reduce of an empty stream requires an initial value';
	  }
	}
	async function reduce(reducer, initialValue, options) {
	  var _options$signal2;
	  if (typeof reducer !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)
	  }
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  let hasInitialValue = arguments.length > 1;
	  if (
	    options !== null &&
	    options !== undefined &&
	    (_options$signal2 = options.signal) !== null &&
	    _options$signal2 !== undefined &&
	    _options$signal2.aborted
	  ) {
	    const err = new AbortError(undefined, {
	      cause: options.signal.reason
	    });
	    this.once('error', () => {}); // The error is already propagated
	    await finished(this.destroy(err));
	    throw err
	  }
	  const ac = new AbortController();
	  const signal = ac.signal;
	  if (options !== null && options !== undefined && options.signal) {
	    const opts = {
	      once: true,
	      [kWeakHandler]: this,
	      [kResistStopPropagation]: true
	    };
	    options.signal.addEventListener('abort', () => ac.abort(), opts);
	  }
	  let gotAnyItemFromStream = false;
	  try {
	    for await (const value of this) {
	      var _options$signal3;
	      gotAnyItemFromStream = true;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal3 = options.signal) !== null &&
	        _options$signal3 !== undefined &&
	        _options$signal3.aborted
	      ) {
	        throw new AbortError()
	      }
	      if (!hasInitialValue) {
	        initialValue = value;
	        hasInitialValue = true;
	      } else {
	        initialValue = await reducer(initialValue, value, {
	          signal
	        });
	      }
	    }
	    if (!gotAnyItemFromStream && !hasInitialValue) {
	      throw new ReduceAwareErrMissingArgs()
	    }
	  } finally {
	    ac.abort();
	  }
	  return initialValue
	}
	async function toArray(options) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  const result = [];
	  for await (const val of this) {
	    var _options$signal4;
	    if (
	      options !== null &&
	      options !== undefined &&
	      (_options$signal4 = options.signal) !== null &&
	      _options$signal4 !== undefined &&
	      _options$signal4.aborted
	    ) {
	      throw new AbortError(undefined, {
	        cause: options.signal.reason
	      })
	    }
	    ArrayPrototypePush(result, val);
	  }
	  return result
	}
	function flatMap(fn, options) {
	  const values = map.call(this, fn, options);
	  return async function* flatMap() {
	    for await (const val of values) {
	      yield* val;
	    }
	  }.call(this)
	}
	function toIntegerOrInfinity(number) {
	  // We coerce here to align with the spec
	  // https://github.com/tc39/proposal-iterator-helpers/issues/169
	  number = Number(number);
	  if (NumberIsNaN(number)) {
	    return 0
	  }
	  if (number < 0) {
	    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)
	  }
	  return number
	}
	function drop(number, options = undefined) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  number = toIntegerOrInfinity(number);
	  return async function* drop() {
	    var _options$signal5;
	    if (
	      options !== null &&
	      options !== undefined &&
	      (_options$signal5 = options.signal) !== null &&
	      _options$signal5 !== undefined &&
	      _options$signal5.aborted
	    ) {
	      throw new AbortError()
	    }
	    for await (const val of this) {
	      var _options$signal6;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal6 = options.signal) !== null &&
	        _options$signal6 !== undefined &&
	        _options$signal6.aborted
	      ) {
	        throw new AbortError()
	      }
	      if (number-- <= 0) {
	        yield val;
	      }
	    }
	  }.call(this)
	}
	function take(number, options = undefined) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  number = toIntegerOrInfinity(number);
	  return async function* take() {
	    var _options$signal7;
	    if (
	      options !== null &&
	      options !== undefined &&
	      (_options$signal7 = options.signal) !== null &&
	      _options$signal7 !== undefined &&
	      _options$signal7.aborted
	    ) {
	      throw new AbortError()
	    }
	    for await (const val of this) {
	      var _options$signal8;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal8 = options.signal) !== null &&
	        _options$signal8 !== undefined &&
	        _options$signal8.aborted
	      ) {
	        throw new AbortError()
	      }
	      if (number-- > 0) {
	        yield val;
	      }

	      // Don't get another item from iterator in case we reached the end
	      if (number <= 0) {
	        return
	      }
	    }
	  }.call(this)
	}
	operators.streamReturningOperators = {
	  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),
	  drop,
	  filter,
	  flatMap,
	  map,
	  take,
	  compose
	};
	operators.promiseReturningOperators = {
	  every,
	  forEach,
	  reduce,
	  toArray,
	  some,
	  find
	};
	return operators;
}

var promises;
var hasRequiredPromises;

function requirePromises () {
	if (hasRequiredPromises) return promises;
	hasRequiredPromises = 1;

	const { ArrayPrototypePop, Promise } = requirePrimordials();
	const { isIterable, isNodeStream, isWebStream } = requireUtils$1();
	const { pipelineImpl: pl } = requirePipeline();
	const { finished } = requireEndOfStream();
	requireStream();
	function pipeline(...streams) {
	  return new Promise((resolve, reject) => {
	    let signal;
	    let end;
	    const lastArg = streams[streams.length - 1];
	    if (
	      lastArg &&
	      typeof lastArg === 'object' &&
	      !isNodeStream(lastArg) &&
	      !isIterable(lastArg) &&
	      !isWebStream(lastArg)
	    ) {
	      const options = ArrayPrototypePop(streams);
	      signal = options.signal;
	      end = options.end;
	    }
	    pl(
	      streams,
	      (err, value) => {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(value);
	        }
	      },
	      {
	        signal,
	        end
	      }
	    );
	  })
	}
	promises = {
	  finished,
	  pipeline
	};
	return promises;
}

var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream.exports;
	hasRequiredStream = 1;

	/* replacement start */

	const { Buffer } = require$$0$2;

	/* replacement end */

	const { ObjectDefineProperty, ObjectKeys, ReflectApply } = requirePrimordials();
	const {
	  promisify: { custom: customPromisify }
	} = requireUtil$2();
	const { streamReturningOperators, promiseReturningOperators } = requireOperators();
	const {
	  codes: { ERR_ILLEGAL_CONSTRUCTOR }
	} = requireErrors();
	const compose = requireCompose();
	const { setDefaultHighWaterMark, getDefaultHighWaterMark } = requireState();
	const { pipeline } = requirePipeline();
	const { destroyer } = requireDestroy();
	const eos = requireEndOfStream();
	const promises = requirePromises();
	const utils = requireUtils$1();
	const Stream = (stream.exports = requireLegacy().Stream);
	Stream.isDestroyed = utils.isDestroyed;
	Stream.isDisturbed = utils.isDisturbed;
	Stream.isErrored = utils.isErrored;
	Stream.isReadable = utils.isReadable;
	Stream.isWritable = utils.isWritable;
	Stream.Readable = requireReadable();
	for (const key of ObjectKeys(streamReturningOperators)) {
	  const op = streamReturningOperators[key];
	  function fn(...args) {
	    if (new.target) {
	      throw ERR_ILLEGAL_CONSTRUCTOR()
	    }
	    return Stream.Readable.from(ReflectApply(op, this, args))
	  }
	  ObjectDefineProperty(fn, 'name', {
	    __proto__: null,
	    value: op.name
	  });
	  ObjectDefineProperty(fn, 'length', {
	    __proto__: null,
	    value: op.length
	  });
	  ObjectDefineProperty(Stream.Readable.prototype, key, {
	    __proto__: null,
	    value: fn,
	    enumerable: false,
	    configurable: true,
	    writable: true
	  });
	}
	for (const key of ObjectKeys(promiseReturningOperators)) {
	  const op = promiseReturningOperators[key];
	  function fn(...args) {
	    if (new.target) {
	      throw ERR_ILLEGAL_CONSTRUCTOR()
	    }
	    return ReflectApply(op, this, args)
	  }
	  ObjectDefineProperty(fn, 'name', {
	    __proto__: null,
	    value: op.name
	  });
	  ObjectDefineProperty(fn, 'length', {
	    __proto__: null,
	    value: op.length
	  });
	  ObjectDefineProperty(Stream.Readable.prototype, key, {
	    __proto__: null,
	    value: fn,
	    enumerable: false,
	    configurable: true,
	    writable: true
	  });
	}
	Stream.Writable = requireWritable();
	Stream.Duplex = requireDuplex();
	Stream.Transform = requireTransform();
	Stream.PassThrough = requirePassthrough();
	Stream.pipeline = pipeline;
	const { addAbortSignal } = requireAddAbortSignal();
	Stream.addAbortSignal = addAbortSignal;
	Stream.finished = eos;
	Stream.destroy = destroyer;
	Stream.compose = compose;
	Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
	Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
	ObjectDefineProperty(Stream, 'promises', {
	  __proto__: null,
	  configurable: true,
	  enumerable: true,
	  get() {
	    return promises
	  }
	});
	ObjectDefineProperty(pipeline, customPromisify, {
	  __proto__: null,
	  enumerable: true,
	  get() {
	    return promises.pipeline
	  }
	});
	ObjectDefineProperty(eos, customPromisify, {
	  __proto__: null,
	  enumerable: true,
	  get() {
	    return promises.finished
	  }
	});

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	Stream._isUint8Array = function isUint8Array(value) {
	  return value instanceof Uint8Array
	};
	Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
	};
	return stream.exports;
}

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser$1.exports;
	hasRequiredBrowser = 1;
	(function (module) {

		const CustomStream = requireStream();
		const promises = requirePromises();
		const originalDestroy = CustomStream.Readable.destroy;
		module.exports = CustomStream.Readable;

		// Explicit export naming is needed for ESM
		module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
		module.exports._isUint8Array = CustomStream._isUint8Array;
		module.exports.isDisturbed = CustomStream.isDisturbed;
		module.exports.isErrored = CustomStream.isErrored;
		module.exports.isReadable = CustomStream.isReadable;
		module.exports.Readable = CustomStream.Readable;
		module.exports.Writable = CustomStream.Writable;
		module.exports.Duplex = CustomStream.Duplex;
		module.exports.Transform = CustomStream.Transform;
		module.exports.PassThrough = CustomStream.PassThrough;
		module.exports.addAbortSignal = CustomStream.addAbortSignal;
		module.exports.finished = CustomStream.finished;
		module.exports.destroy = CustomStream.destroy;
		module.exports.destroy = originalDestroy;
		module.exports.pipeline = CustomStream.pipeline;
		module.exports.compose = CustomStream.compose;
		Object.defineProperty(CustomStream, 'promises', {
		  configurable: true,
		  enumerable: true,
		  get() {
		    return promises
		  }
		});
		module.exports.Stream = CustomStream.Stream;

		// Allow default importing
		module.exports.default = module.exports; 
	} (browser$1));
	return browser$1.exports;
}

var FileHandle = {};

var util$1 = {};

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.FLAGS = constants.ERRSTR = void 0;
	const constants_1 = requireConstants$2();
	constants.ERRSTR = {
	    PATH_STR: 'path must be a string, Buffer, or Uint8Array',
	    // FD:             'file descriptor must be a unsigned 32-bit integer',
	    FD: 'fd must be a file descriptor',
	    MODE_INT: 'mode must be an int',
	    CB: 'callback must be a function',
	    UID: 'uid must be an unsigned int',
	    GID: 'gid must be an unsigned int',
	    LEN: 'len must be an integer',
	    ATIME: 'atime must be an integer',
	    MTIME: 'mtime must be an integer',
	    PREFIX: 'filename prefix is required',
	    BUFFER: 'buffer must be an instance of Buffer or StaticBuffer',
	    OFFSET: 'offset must be an integer',
	    LENGTH: 'length must be an integer',
	    POSITION: 'position must be an integer',
	};
	const { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_SYNC } = constants_1.constants;
	// List of file `flags` as defined by Node.
	var FLAGS;
	(function (FLAGS) {
	    // Open file for reading. An exception occurs if the file does not exist.
	    FLAGS[FLAGS["r"] = O_RDONLY] = "r";
	    // Open file for reading and writing. An exception occurs if the file does not exist.
	    FLAGS[FLAGS["r+"] = O_RDWR] = "r+";
	    // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.
	    FLAGS[FLAGS["rs"] = O_RDONLY | O_SYNC] = "rs";
	    FLAGS[FLAGS["sr"] = FLAGS.rs] = "sr";
	    // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.
	    FLAGS[FLAGS["rs+"] = O_RDWR | O_SYNC] = "rs+";
	    FLAGS[FLAGS["sr+"] = FLAGS['rs+']] = "sr+";
	    // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
	    FLAGS[FLAGS["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
	    // Like 'w' but fails if path exists.
	    FLAGS[FLAGS["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
	    FLAGS[FLAGS["xw"] = FLAGS.wx] = "xw";
	    // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
	    FLAGS[FLAGS["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
	    // Like 'w+' but fails if path exists.
	    FLAGS[FLAGS["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
	    FLAGS[FLAGS["xw+"] = FLAGS['wx+']] = "xw+";
	    // Open file for appending. The file is created if it does not exist.
	    FLAGS[FLAGS["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
	    // Like 'a' but fails if path exists.
	    FLAGS[FLAGS["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
	    FLAGS[FLAGS["xa"] = FLAGS.ax] = "xa";
	    // Open file for reading and appending. The file is created if it does not exist.
	    FLAGS[FLAGS["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
	    // Like 'a+' but fails if path exists.
	    FLAGS[FLAGS["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
	    FLAGS[FLAGS["xa+"] = FLAGS['ax+']] = "xa+";
	})(FLAGS || (constants.FLAGS = FLAGS = {}));
	
	return constants;
}

var url = {};

var punycode$1 = {exports: {}};

/*! https://mths.be/punycode v1.4.1 by @mathias */
var punycode = punycode$1.exports;

var hasRequiredPunycode;

function requirePunycode () {
	if (hasRequiredPunycode) return punycode$1.exports;
	hasRequiredPunycode = 1;
	(function (module, exports) {
(function(root) {

			/** Detect free variables */
			var freeExports = exports &&
				!exports.nodeType && exports;
			var freeModule = module &&
				!module.nodeType && module;
			var freeGlobal = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1;
			if (
				freeGlobal.undefined === freeGlobal ||
				freeGlobal.window === freeGlobal ||
				freeGlobal.self === freeGlobal
			) {
				root = freeGlobal;
			}

			/**
			 * The `punycode` object.
			 * @name punycode
			 * @type Object
			 */
			var punycode,

			/** Highest positive signed 32-bit float value */
			maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

			/** Bootstring parameters */
			base = 36,
			tMin = 1,
			tMax = 26,
			skew = 38,
			damp = 700,
			initialBias = 72,
			initialN = 128, // 0x80
			delimiter = '-', // '\x2D'

			/** Regular expressions */
			regexPunycode = /^xn--/,
			regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
			regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

			/** Error messages */
			errors = {
				'overflow': 'Overflow: input needs wider integers to process',
				'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
				'invalid-input': 'Invalid input'
			},

			/** Convenience shortcuts */
			baseMinusTMin = base - tMin,
			floor = Math.floor,
			stringFromCharCode = String.fromCharCode,

			/** Temporary variable */
			key;

			/*--------------------------------------------------------------------------*/

			/**
			 * A generic error utility function.
			 * @private
			 * @param {String} type The error type.
			 * @returns {Error} Throws a `RangeError` with the applicable error message.
			 */
			function error(type) {
				throw new RangeError(errors[type]);
			}

			/**
			 * A generic `Array#map` utility function.
			 * @private
			 * @param {Array} array The array to iterate over.
			 * @param {Function} callback The function that gets called for every array
			 * item.
			 * @returns {Array} A new array of values returned by the callback function.
			 */
			function map(array, fn) {
				var length = array.length;
				var result = [];
				while (length--) {
					result[length] = fn(array[length]);
				}
				return result;
			}

			/**
			 * A simple `Array#map`-like wrapper to work with domain name strings or email
			 * addresses.
			 * @private
			 * @param {String} domain The domain name or email address.
			 * @param {Function} callback The function that gets called for every
			 * character.
			 * @returns {Array} A new string of characters returned by the callback
			 * function.
			 */
			function mapDomain(string, fn) {
				var parts = string.split('@');
				var result = '';
				if (parts.length > 1) {
					// In email addresses, only the domain name should be punycoded. Leave
					// the local part (i.e. everything up to `@`) intact.
					result = parts[0] + '@';
					string = parts[1];
				}
				// Avoid `split(regex)` for IE8 compatibility. See #17.
				string = string.replace(regexSeparators, '\x2E');
				var labels = string.split('.');
				var encoded = map(labels, fn).join('.');
				return result + encoded;
			}

			/**
			 * Creates an array containing the numeric code points of each Unicode
			 * character in the string. While JavaScript uses UCS-2 internally,
			 * this function will convert a pair of surrogate halves (each of which
			 * UCS-2 exposes as separate characters) into a single code point,
			 * matching UTF-16.
			 * @see `punycode.ucs2.encode`
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode.ucs2
			 * @name decode
			 * @param {String} string The Unicode input string (UCS-2).
			 * @returns {Array} The new array of code points.
			 */
			function ucs2decode(string) {
				var output = [],
				    counter = 0,
				    length = string.length,
				    value,
				    extra;
				while (counter < length) {
					value = string.charCodeAt(counter++);
					if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
						// high surrogate, and there is a next character
						extra = string.charCodeAt(counter++);
						if ((extra & 0xFC00) == 0xDC00) { // low surrogate
							output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
						} else {
							// unmatched surrogate; only append this code unit, in case the next
							// code unit is the high surrogate of a surrogate pair
							output.push(value);
							counter--;
						}
					} else {
						output.push(value);
					}
				}
				return output;
			}

			/**
			 * Creates a string based on an array of numeric code points.
			 * @see `punycode.ucs2.decode`
			 * @memberOf punycode.ucs2
			 * @name encode
			 * @param {Array} codePoints The array of numeric code points.
			 * @returns {String} The new Unicode string (UCS-2).
			 */
			function ucs2encode(array) {
				return map(array, function(value) {
					var output = '';
					if (value > 0xFFFF) {
						value -= 0x10000;
						output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
						value = 0xDC00 | value & 0x3FF;
					}
					output += stringFromCharCode(value);
					return output;
				}).join('');
			}

			/**
			 * Converts a basic code point into a digit/integer.
			 * @see `digitToBasic()`
			 * @private
			 * @param {Number} codePoint The basic numeric code point value.
			 * @returns {Number} The numeric value of a basic code point (for use in
			 * representing integers) in the range `0` to `base - 1`, or `base` if
			 * the code point does not represent a value.
			 */
			function basicToDigit(codePoint) {
				if (codePoint - 48 < 10) {
					return codePoint - 22;
				}
				if (codePoint - 65 < 26) {
					return codePoint - 65;
				}
				if (codePoint - 97 < 26) {
					return codePoint - 97;
				}
				return base;
			}

			/**
			 * Converts a digit/integer into a basic code point.
			 * @see `basicToDigit()`
			 * @private
			 * @param {Number} digit The numeric value of a basic code point.
			 * @returns {Number} The basic code point whose value (when used for
			 * representing integers) is `digit`, which needs to be in the range
			 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
			 * used; else, the lowercase form is used. The behavior is undefined
			 * if `flag` is non-zero and `digit` has no uppercase form.
			 */
			function digitToBasic(digit, flag) {
				//  0..25 map to ASCII a..z or A..Z
				// 26..35 map to ASCII 0..9
				return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
			}

			/**
			 * Bias adaptation function as per section 3.4 of RFC 3492.
			 * https://tools.ietf.org/html/rfc3492#section-3.4
			 * @private
			 */
			function adapt(delta, numPoints, firstTime) {
				var k = 0;
				delta = firstTime ? floor(delta / damp) : delta >> 1;
				delta += floor(delta / numPoints);
				for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
					delta = floor(delta / baseMinusTMin);
				}
				return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
			}

			/**
			 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
			 * symbols.
			 * @memberOf punycode
			 * @param {String} input The Punycode string of ASCII-only symbols.
			 * @returns {String} The resulting string of Unicode symbols.
			 */
			function decode(input) {
				// Don't use UCS-2
				var output = [],
				    inputLength = input.length,
				    out,
				    i = 0,
				    n = initialN,
				    bias = initialBias,
				    basic,
				    j,
				    index,
				    oldi,
				    w,
				    k,
				    digit,
				    t,
				    /** Cached calculation results */
				    baseMinusT;

				// Handle the basic code points: let `basic` be the number of input code
				// points before the last delimiter, or `0` if there is none, then copy
				// the first basic code points to the output.

				basic = input.lastIndexOf(delimiter);
				if (basic < 0) {
					basic = 0;
				}

				for (j = 0; j < basic; ++j) {
					// if it's not a basic code point
					if (input.charCodeAt(j) >= 0x80) {
						error('not-basic');
					}
					output.push(input.charCodeAt(j));
				}

				// Main decoding loop: start just after the last delimiter if any basic code
				// points were copied; start at the beginning otherwise.

				for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

					// `index` is the index of the next character to be consumed.
					// Decode a generalized variable-length integer into `delta`,
					// which gets added to `i`. The overflow checking is easier
					// if we increase `i` as we go, then subtract off its starting
					// value at the end to obtain `delta`.
					for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

						if (index >= inputLength) {
							error('invalid-input');
						}

						digit = basicToDigit(input.charCodeAt(index++));

						if (digit >= base || digit > floor((maxInt - i) / w)) {
							error('overflow');
						}

						i += digit * w;
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

						if (digit < t) {
							break;
						}

						baseMinusT = base - t;
						if (w > floor(maxInt / baseMinusT)) {
							error('overflow');
						}

						w *= baseMinusT;

					}

					out = output.length + 1;
					bias = adapt(i - oldi, out, oldi == 0);

					// `i` was supposed to wrap around from `out` to `0`,
					// incrementing `n` each time, so we'll fix that now:
					if (floor(i / out) > maxInt - n) {
						error('overflow');
					}

					n += floor(i / out);
					i %= out;

					// Insert `n` at position `i` of the output
					output.splice(i++, 0, n);

				}

				return ucs2encode(output);
			}

			/**
			 * Converts a string of Unicode symbols (e.g. a domain name label) to a
			 * Punycode string of ASCII-only symbols.
			 * @memberOf punycode
			 * @param {String} input The string of Unicode symbols.
			 * @returns {String} The resulting Punycode string of ASCII-only symbols.
			 */
			function encode(input) {
				var n,
				    delta,
				    handledCPCount,
				    basicLength,
				    bias,
				    j,
				    m,
				    q,
				    k,
				    t,
				    currentValue,
				    output = [],
				    /** `inputLength` will hold the number of code points in `input`. */
				    inputLength,
				    /** Cached calculation results */
				    handledCPCountPlusOne,
				    baseMinusT,
				    qMinusT;

				// Convert the input in UCS-2 to Unicode
				input = ucs2decode(input);

				// Cache the length
				inputLength = input.length;

				// Initialize the state
				n = initialN;
				delta = 0;
				bias = initialBias;

				// Handle the basic code points
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue < 0x80) {
						output.push(stringFromCharCode(currentValue));
					}
				}

				handledCPCount = basicLength = output.length;

				// `handledCPCount` is the number of code points that have been handled;
				// `basicLength` is the number of basic code points.

				// Finish the basic string - if it is not empty - with a delimiter
				if (basicLength) {
					output.push(delimiter);
				}

				// Main encoding loop:
				while (handledCPCount < inputLength) {

					// All non-basic code points < n have been handled already. Find the next
					// larger one:
					for (m = maxInt, j = 0; j < inputLength; ++j) {
						currentValue = input[j];
						if (currentValue >= n && currentValue < m) {
							m = currentValue;
						}
					}

					// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
					// but guard against overflow
					handledCPCountPlusOne = handledCPCount + 1;
					if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
						error('overflow');
					}

					delta += (m - n) * handledCPCountPlusOne;
					n = m;

					for (j = 0; j < inputLength; ++j) {
						currentValue = input[j];

						if (currentValue < n && ++delta > maxInt) {
							error('overflow');
						}

						if (currentValue == n) {
							// Represent delta as a generalized variable-length integer
							for (q = delta, k = base; /* no condition */; k += base) {
								t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
								if (q < t) {
									break;
								}
								qMinusT = q - t;
								baseMinusT = base - t;
								output.push(
									stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
								);
								q = floor(qMinusT / baseMinusT);
							}

							output.push(stringFromCharCode(digitToBasic(q, 0)));
							bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
							delta = 0;
							++handledCPCount;
						}
					}

					++delta;
					++n;

				}
				return output.join('');
			}

			/**
			 * Converts a Punycode string representing a domain name or an email address
			 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
			 * it doesn't matter if you call it on a string that has already been
			 * converted to Unicode.
			 * @memberOf punycode
			 * @param {String} input The Punycoded domain name or email address to
			 * convert to Unicode.
			 * @returns {String} The Unicode representation of the given Punycode
			 * string.
			 */
			function toUnicode(input) {
				return mapDomain(input, function(string) {
					return regexPunycode.test(string)
						? decode(string.slice(4).toLowerCase())
						: string;
				});
			}

			/**
			 * Converts a Unicode string representing a domain name or an email address to
			 * Punycode. Only the non-ASCII parts of the domain name will be converted,
			 * i.e. it doesn't matter if you call it with a domain that's already in
			 * ASCII.
			 * @memberOf punycode
			 * @param {String} input The domain name or email address to convert, as a
			 * Unicode string.
			 * @returns {String} The Punycode representation of the given domain name or
			 * email address.
			 */
			function toASCII(input) {
				return mapDomain(input, function(string) {
					return regexNonASCII.test(string)
						? 'xn--' + encode(string)
						: string;
				});
			}

			/*--------------------------------------------------------------------------*/

			/** Define the public API */
			punycode = {
				/**
				 * A string representing the current Punycode.js version number.
				 * @memberOf punycode
				 * @type String
				 */
				'version': '1.4.1',
				/**
				 * An object of methods to convert from JavaScript's internal character
				 * representation (UCS-2) to Unicode code points, and back.
				 * @see <https://mathiasbynens.be/notes/javascript-encoding>
				 * @memberOf punycode
				 * @type Object
				 */
				'ucs2': {
					'decode': ucs2decode,
					'encode': ucs2encode
				},
				'decode': decode,
				'encode': encode,
				'toASCII': toASCII,
				'toUnicode': toUnicode
			};

			/** Expose `punycode` */
			// Some AMD build optimizers, like r.js, check for specific condition patterns
			// like the following:
			if (freeExports && freeModule) {
				if (module.exports == freeExports) {
					// in Node.js, io.js, or RingoJS v0.8.0+
					freeModule.exports = punycode;
				} else {
					// in Narwhal or RingoJS v0.7.0-
					for (key in punycode) {
						punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
					}
				}
			} else {
				// in Rhino or a web browser
				root.punycode = punycode;
			}

		}(punycode)); 
	} (punycode$1, punycode$1.exports));
	return punycode$1.exports;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	/** @type {import('./type')} */
	type = TypeError;
	return type;
}

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	default: _nodeResolve_empty
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

var objectInspect;
var hasRequiredObjectInspect;

function requireObjectInspect () {
	if (hasRequiredObjectInspect) return objectInspect;
	hasRequiredObjectInspect = 1;
	var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
	var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
	var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
	var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
	var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
	var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
	// ie, `has-tostringtag/shams
	var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
	    ? Symbol.toStringTag
	    : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;

	var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
	    [].__proto__ === Array.prototype // eslint-disable-line no-proto
	        ? function (O) {
	            return O.__proto__; // eslint-disable-line no-proto
	        }
	        : null
	);

	function addNumericSeparator(num, str) {
	    if (
	        num === Infinity
	        || num === -Infinity
	        || num !== num
	        || (num && num > -1e3 && num < 1000)
	        || $test.call(/e/, str)
	    ) {
	        return str;
	    }
	    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
	    if (typeof num === 'number') {
	        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
	        if (int !== num) {
	            var intStr = String(int);
	            var dec = $slice.call(str, intStr.length + 1);
	            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
	        }
	    }
	    return $replace.call(str, sepRegex, '$&_');
	}

	var utilInspect = require$$0$1;
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

	var quotes = {
	    __proto__: null,
	    'double': '"',
	    single: "'"
	};
	var quoteREs = {
	    __proto__: null,
	    'double': /(["\\])/g,
	    single: /(['\\])/g
	};

	objectInspect = function inspect_(obj, options, depth, seen) {
	    var opts = options || {};

	    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {
	        throw new TypeError('option "quoteStyle" must be "single" or "double"');
	    }
	    if (
	        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
	            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
	            : opts.maxStringLength !== null
	        )
	    ) {
	        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
	    }
	    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
	    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
	        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
	    }

	    if (
	        has(opts, 'indent')
	        && opts.indent !== null
	        && opts.indent !== '\t'
	        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
	    ) {
	        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
	    }
	    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
	        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
	    }
	    var numericSeparator = opts.numericSeparator;

	    if (typeof obj === 'undefined') {
	        return 'undefined';
	    }
	    if (obj === null) {
	        return 'null';
	    }
	    if (typeof obj === 'boolean') {
	        return obj ? 'true' : 'false';
	    }

	    if (typeof obj === 'string') {
	        return inspectString(obj, opts);
	    }
	    if (typeof obj === 'number') {
	        if (obj === 0) {
	            return Infinity / obj > 0 ? '0' : '-0';
	        }
	        var str = String(obj);
	        return numericSeparator ? addNumericSeparator(obj, str) : str;
	    }
	    if (typeof obj === 'bigint') {
	        var bigIntStr = String(obj) + 'n';
	        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
	    }

	    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
	    if (typeof depth === 'undefined') { depth = 0; }
	    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
	        return isArray(obj) ? '[Array]' : '[Object]';
	    }

	    var indent = getIndent(opts, depth);

	    if (typeof seen === 'undefined') {
	        seen = [];
	    } else if (indexOf(seen, obj) >= 0) {
	        return '[Circular]';
	    }

	    function inspect(value, from, noIndent) {
	        if (from) {
	            seen = $arrSlice.call(seen);
	            seen.push(from);
	        }
	        if (noIndent) {
	            var newOpts = {
	                depth: opts.depth
	            };
	            if (has(opts, 'quoteStyle')) {
	                newOpts.quoteStyle = opts.quoteStyle;
	            }
	            return inspect_(value, newOpts, depth + 1, seen);
	        }
	        return inspect_(value, opts, depth + 1, seen);
	    }

	    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
	        var name = nameOf(obj);
	        var keys = arrObjKeys(obj, inspect);
	        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
	    }
	    if (isSymbol(obj)) {
	        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
	        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
	    }
	    if (isElement(obj)) {
	        var s = '<' + $toLowerCase.call(String(obj.nodeName));
	        var attrs = obj.attributes || [];
	        for (var i = 0; i < attrs.length; i++) {
	            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
	        }
	        s += '>';
	        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
	        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
	        return s;
	    }
	    if (isArray(obj)) {
	        if (obj.length === 0) { return '[]'; }
	        var xs = arrObjKeys(obj, inspect);
	        if (indent && !singleLineValues(xs)) {
	            return '[' + indentedJoin(xs, indent) + ']';
	        }
	        return '[ ' + $join.call(xs, ', ') + ' ]';
	    }
	    if (isError(obj)) {
	        var parts = arrObjKeys(obj, inspect);
	        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
	            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
	        }
	        if (parts.length === 0) { return '[' + String(obj) + ']'; }
	        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
	    }
	    if (typeof obj === 'object' && customInspect) {
	        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
	            return utilInspect(obj, { depth: maxDepth - depth });
	        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
	            return obj.inspect();
	        }
	    }
	    if (isMap(obj)) {
	        var mapParts = [];
	        if (mapForEach) {
	            mapForEach.call(obj, function (value, key) {
	                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
	            });
	        }
	        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
	    }
	    if (isSet(obj)) {
	        var setParts = [];
	        if (setForEach) {
	            setForEach.call(obj, function (value) {
	                setParts.push(inspect(value, obj));
	            });
	        }
	        return collectionOf('Set', setSize.call(obj), setParts, indent);
	    }
	    if (isWeakMap(obj)) {
	        return weakCollectionOf('WeakMap');
	    }
	    if (isWeakSet(obj)) {
	        return weakCollectionOf('WeakSet');
	    }
	    if (isWeakRef(obj)) {
	        return weakCollectionOf('WeakRef');
	    }
	    if (isNumber(obj)) {
	        return markBoxed(inspect(Number(obj)));
	    }
	    if (isBigInt(obj)) {
	        return markBoxed(inspect(bigIntValueOf.call(obj)));
	    }
	    if (isBoolean(obj)) {
	        return markBoxed(booleanValueOf.call(obj));
	    }
	    if (isString(obj)) {
	        return markBoxed(inspect(String(obj)));
	    }
	    // note: in IE 8, sometimes `undefined !== window` but both are the prototypes of each other
	    /* eslint-env browser */
	    if (typeof window !== 'undefined' && obj === window) {
	        return '{ [object Window] }';
	    }
	    if (
	        (typeof globalThis !== 'undefined' && obj === globalThis)
	        || (typeof commonjsGlobal$1 !== 'undefined' && obj === commonjsGlobal$1)
	    ) {
	        return '{ [object globalThis] }';
	    }
	    if (!isDate(obj) && !isRegExp(obj)) {
	        var ys = arrObjKeys(obj, inspect);
	        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
	        var protoTag = obj instanceof Object ? '' : 'null prototype';
	        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
	        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
	        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
	        if (ys.length === 0) { return tag + '{}'; }
	        if (indent) {
	            return tag + '{' + indentedJoin(ys, indent) + '}';
	        }
	        return tag + '{ ' + $join.call(ys, ', ') + ' }';
	    }
	    return String(obj);
	};

	function wrapQuotes(s, defaultStyle, opts) {
	    var style = opts.quoteStyle || defaultStyle;
	    var quoteChar = quotes[style];
	    return quoteChar + s + quoteChar;
	}

	function quote(s) {
	    return $replace.call(String(s), /"/g, '&quot;');
	}

	function canTrustToString(obj) {
	    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));
	}
	function isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }
	function isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }
	function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }
	function isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }
	function isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }
	function isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }
	function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }

	// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
	function isSymbol(obj) {
	    if (hasShammedSymbols) {
	        return obj && typeof obj === 'object' && obj instanceof Symbol;
	    }
	    if (typeof obj === 'symbol') {
	        return true;
	    }
	    if (!obj || typeof obj !== 'object' || !symToString) {
	        return false;
	    }
	    try {
	        symToString.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isBigInt(obj) {
	    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
	        return false;
	    }
	    try {
	        bigIntValueOf.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}

	var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
	function has(obj, key) {
	    return hasOwn.call(obj, key);
	}

	function toStr(obj) {
	    return objectToString.call(obj);
	}

	function nameOf(f) {
	    if (f.name) { return f.name; }
	    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
	    if (m) { return m[1]; }
	    return null;
	}

	function indexOf(xs, x) {
	    if (xs.indexOf) { return xs.indexOf(x); }
	    for (var i = 0, l = xs.length; i < l; i++) {
	        if (xs[i] === x) { return i; }
	    }
	    return -1;
	}

	function isMap(x) {
	    if (!mapSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        mapSize.call(x);
	        try {
	            setSize.call(x);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof Map; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakMap(x) {
	    if (!weakMapHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakMapHas.call(x, weakMapHas);
	        try {
	            weakSetHas.call(x, weakSetHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakRef(x) {
	    if (!weakRefDeref || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakRefDeref.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}

	function isSet(x) {
	    if (!setSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        setSize.call(x);
	        try {
	            mapSize.call(x);
	        } catch (m) {
	            return true;
	        }
	        return x instanceof Set; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isWeakSet(x) {
	    if (!weakSetHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakSetHas.call(x, weakSetHas);
	        try {
	            weakMapHas.call(x, weakMapHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}

	function isElement(x) {
	    if (!x || typeof x !== 'object') { return false; }
	    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
	        return true;
	    }
	    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
	}

	function inspectString(str, opts) {
	    if (str.length > opts.maxStringLength) {
	        var remaining = str.length - opts.maxStringLength;
	        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
	        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
	    }
	    var quoteRE = quoteREs[opts.quoteStyle || 'single'];
	    quoteRE.lastIndex = 0;
	    // eslint-disable-next-line no-control-regex
	    var s = $replace.call($replace.call(str, quoteRE, '\\$1'), /[\x00-\x1f]/g, lowbyte);
	    return wrapQuotes(s, 'single', opts);
	}

	function lowbyte(c) {
	    var n = c.charCodeAt(0);
	    var x = {
	        8: 'b',
	        9: 't',
	        10: 'n',
	        12: 'f',
	        13: 'r'
	    }[n];
	    if (x) { return '\\' + x; }
	    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
	}

	function markBoxed(str) {
	    return 'Object(' + str + ')';
	}

	function weakCollectionOf(type) {
	    return type + ' { ? }';
	}

	function collectionOf(type, size, entries, indent) {
	    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
	    return type + ' (' + size + ') {' + joinedEntries + '}';
	}

	function singleLineValues(xs) {
	    for (var i = 0; i < xs.length; i++) {
	        if (indexOf(xs[i], '\n') >= 0) {
	            return false;
	        }
	    }
	    return true;
	}

	function getIndent(opts, depth) {
	    var baseIndent;
	    if (opts.indent === '\t') {
	        baseIndent = '\t';
	    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
	        baseIndent = $join.call(Array(opts.indent + 1), ' ');
	    } else {
	        return null;
	    }
	    return {
	        base: baseIndent,
	        prev: $join.call(Array(depth + 1), baseIndent)
	    };
	}

	function indentedJoin(xs, indent) {
	    if (xs.length === 0) { return ''; }
	    var lineJoiner = '\n' + indent.prev + indent.base;
	    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
	}

	function arrObjKeys(obj, inspect) {
	    var isArr = isArray(obj);
	    var xs = [];
	    if (isArr) {
	        xs.length = obj.length;
	        for (var i = 0; i < obj.length; i++) {
	            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
	        }
	    }
	    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
	    var symMap;
	    if (hasShammedSymbols) {
	        symMap = {};
	        for (var k = 0; k < syms.length; k++) {
	            symMap['$' + syms[k]] = syms[k];
	        }
	    }

	    for (var key in obj) { // eslint-disable-line no-restricted-syntax
	        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
	            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
	            continue; // eslint-disable-line no-restricted-syntax, no-continue
	        } else if ($test.call(/[^\w$]/, key)) {
	            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
	        } else {
	            xs.push(key + ': ' + inspect(obj[key], obj));
	        }
	    }
	    if (typeof gOPS === 'function') {
	        for (var j = 0; j < syms.length; j++) {
	            if (isEnumerable.call(obj, syms[j])) {
	                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
	            }
	        }
	    }
	    return xs;
	}
	return objectInspect;
}

var sideChannelList;
var hasRequiredSideChannelList;

function requireSideChannelList () {
	if (hasRequiredSideChannelList) return sideChannelList;
	hasRequiredSideChannelList = 1;

	var inspect = /*@__PURE__*/ requireObjectInspect();

	var $TypeError = /*@__PURE__*/ requireType();

	/*
	* This function traverses the list returning the node corresponding to the given key.
	*
	* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
	* By doing so, all the recently used nodes can be accessed relatively quickly.
	*/
	/** @type {import('./list.d.ts').listGetNode} */
	// eslint-disable-next-line consistent-return
	var listGetNode = function (list, key, isDelete) {
		/** @type {typeof list | NonNullable<(typeof list)['next']>} */
		var prev = list;
		/** @type {(typeof list)['next']} */
		var curr;
		// eslint-disable-next-line eqeqeq
		for (; (curr = prev.next) != null; prev = curr) {
			if (curr.key === key) {
				prev.next = curr.next;
				if (!isDelete) {
					// eslint-disable-next-line no-extra-parens
					curr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);
					list.next = curr; // eslint-disable-line no-param-reassign
				}
				return curr;
			}
		}
	};

	/** @type {import('./list.d.ts').listGet} */
	var listGet = function (objects, key) {
		if (!objects) {
			return void 0;
		}
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	/** @type {import('./list.d.ts').listSet} */
	var listSet = function (objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) {
			node.value = value;
		} else {
			// Prepend the new node to the beginning of the list
			objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
				key: key,
				next: objects.next,
				value: value
			});
		}
	};
	/** @type {import('./list.d.ts').listHas} */
	var listHas = function (objects, key) {
		if (!objects) {
			return false;
		}
		return !!listGetNode(objects, key);
	};
	/** @type {import('./list.d.ts').listDelete} */
	// eslint-disable-next-line consistent-return
	var listDelete = function (objects, key) {
		if (objects) {
			return listGetNode(objects, key, true);
		}
	};

	/** @type {import('.')} */
	sideChannelList = function getSideChannelList() {
		/** @typedef {ReturnType<typeof getSideChannelList>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				var root = $o && $o.next;
				var deletedNode = listDelete($o, key);
				if (deletedNode && root && root === deletedNode) {
					$o = void 0;
				}
				return !!deletedNode;
			},
			get: function (key) {
				return listGet($o, key);
			},
			has: function (key) {
				return listHas($o, key);
			},
			set: function (key, value) {
				if (!$o) {
					// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
					$o = {
						next: void 0
					};
				}
				// eslint-disable-next-line no-extra-parens
				listSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);
			}
		};
		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	};
	return sideChannelList;
}

var esObjectAtoms;
var hasRequiredEsObjectAtoms;

function requireEsObjectAtoms () {
	if (hasRequiredEsObjectAtoms) return esObjectAtoms;
	hasRequiredEsObjectAtoms = 1;

	/** @type {import('.')} */
	esObjectAtoms = Object;
	return esObjectAtoms;
}

var esErrors;
var hasRequiredEsErrors;

function requireEsErrors () {
	if (hasRequiredEsErrors) return esErrors;
	hasRequiredEsErrors = 1;

	/** @type {import('.')} */
	esErrors = Error;
	return esErrors;
}

var _eval;
var hasRequired_eval;

function require_eval () {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;

	/** @type {import('./eval')} */
	_eval = EvalError;
	return _eval;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	/** @type {import('./range')} */
	range = RangeError;
	return range;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;

	/** @type {import('./ref')} */
	ref = ReferenceError;
	return ref;
}

var syntax;
var hasRequiredSyntax;

function requireSyntax () {
	if (hasRequiredSyntax) return syntax;
	hasRequiredSyntax = 1;

	/** @type {import('./syntax')} */
	syntax = SyntaxError;
	return syntax;
}

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	/** @type {import('./uri')} */
	uri = URIError;
	return uri;
}

var abs;
var hasRequiredAbs;

function requireAbs () {
	if (hasRequiredAbs) return abs;
	hasRequiredAbs = 1;

	/** @type {import('./abs')} */
	abs = Math.abs;
	return abs;
}

var floor;
var hasRequiredFloor;

function requireFloor () {
	if (hasRequiredFloor) return floor;
	hasRequiredFloor = 1;

	/** @type {import('./floor')} */
	floor = Math.floor;
	return floor;
}

var max;
var hasRequiredMax;

function requireMax () {
	if (hasRequiredMax) return max;
	hasRequiredMax = 1;

	/** @type {import('./max')} */
	max = Math.max;
	return max;
}

var min;
var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min;
	hasRequiredMin = 1;

	/** @type {import('./min')} */
	min = Math.min;
	return min;
}

var pow;
var hasRequiredPow;

function requirePow () {
	if (hasRequiredPow) return pow;
	hasRequiredPow = 1;

	/** @type {import('./pow')} */
	pow = Math.pow;
	return pow;
}

var round;
var hasRequiredRound;

function requireRound () {
	if (hasRequiredRound) return round;
	hasRequiredRound = 1;

	/** @type {import('./round')} */
	round = Math.round;
	return round;
}

var _isNaN;
var hasRequired_isNaN;

function require_isNaN () {
	if (hasRequired_isNaN) return _isNaN;
	hasRequired_isNaN = 1;

	/** @type {import('./isNaN')} */
	_isNaN = Number.isNaN || function isNaN(a) {
		return a !== a;
	};
	return _isNaN;
}

var sign;
var hasRequiredSign;

function requireSign () {
	if (hasRequiredSign) return sign;
	hasRequiredSign = 1;

	var $isNaN = /*@__PURE__*/ require_isNaN();

	/** @type {import('./sign')} */
	sign = function sign(number) {
		if ($isNaN(number) || number === 0) {
			return number;
		}
		return number < 0 ? -1 : 1;
	};
	return sign;
}

var gOPD;
var hasRequiredGOPD;

function requireGOPD () {
	if (hasRequiredGOPD) return gOPD;
	hasRequiredGOPD = 1;

	/** @type {import('./gOPD')} */
	gOPD = Object.getOwnPropertyDescriptor;
	return gOPD;
}

var gopd;
var hasRequiredGopd;

function requireGopd () {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;

	/** @type {import('.')} */
	var $gOPD = /*@__PURE__*/ requireGOPD();

	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}

	gopd = $gOPD;
	return gopd;
}

var esDefineProperty;
var hasRequiredEsDefineProperty;

function requireEsDefineProperty () {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;

	/** @type {import('.')} */
	var $defineProperty = Object.defineProperty || false;
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = false;
		}
	}

	esDefineProperty = $defineProperty;
	return esDefineProperty;
}

var shams;
var hasRequiredShams;

function requireShams () {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;

	/** @type {import('./shams')} */
	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	shams = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		/** @type {{ [k in symbol]?: unknown }} */
		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			// eslint-disable-next-line no-extra-parens
			var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};
	return shams;
}

var hasSymbols;
var hasRequiredHasSymbols;

function requireHasSymbols () {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = requireShams();

	/** @type {import('.')} */
	hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};
	return hasSymbols;
}

var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;

function requireReflect_getPrototypeOf () {
	if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
	hasRequiredReflect_getPrototypeOf = 1;

	/** @type {import('./Reflect.getPrototypeOf')} */
	Reflect_getPrototypeOf = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;
	return Reflect_getPrototypeOf;
}

var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;

function requireObject_getPrototypeOf () {
	if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
	hasRequiredObject_getPrototypeOf = 1;

	var $Object = /*@__PURE__*/ requireEsObjectAtoms();

	/** @type {import('./Object.getPrototypeOf')} */
	Object_getPrototypeOf = $Object.getPrototypeOf || null;
	return Object_getPrototypeOf;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';

	var concatty = function concatty(a, b) {
	    var arr = [];

	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }

	    return arr;
	};

	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};

	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};

	implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );

	    };

	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }

	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;

	var implementation = requireImplementation();

	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var functionCall;
var hasRequiredFunctionCall;

function requireFunctionCall () {
	if (hasRequiredFunctionCall) return functionCall;
	hasRequiredFunctionCall = 1;

	/** @type {import('./functionCall')} */
	functionCall = Function.prototype.call;
	return functionCall;
}

var functionApply;
var hasRequiredFunctionApply;

function requireFunctionApply () {
	if (hasRequiredFunctionApply) return functionApply;
	hasRequiredFunctionApply = 1;

	/** @type {import('./functionApply')} */
	functionApply = Function.prototype.apply;
	return functionApply;
}

var reflectApply;
var hasRequiredReflectApply;

function requireReflectApply () {
	if (hasRequiredReflectApply) return reflectApply;
	hasRequiredReflectApply = 1;

	/** @type {import('./reflectApply')} */
	reflectApply = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
	return reflectApply;
}

var actualApply;
var hasRequiredActualApply;

function requireActualApply () {
	if (hasRequiredActualApply) return actualApply;
	hasRequiredActualApply = 1;

	var bind = requireFunctionBind();

	var $apply = requireFunctionApply();
	var $call = requireFunctionCall();
	var $reflectApply = requireReflectApply();

	/** @type {import('./actualApply')} */
	actualApply = $reflectApply || bind.call($call, $apply);
	return actualApply;
}

var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;

function requireCallBindApplyHelpers () {
	if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
	hasRequiredCallBindApplyHelpers = 1;

	var bind = requireFunctionBind();
	var $TypeError = /*@__PURE__*/ requireType();

	var $call = requireFunctionCall();
	var $actualApply = requireActualApply();

	/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
	callBindApplyHelpers = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== 'function') {
			throw new $TypeError('a function is required');
		}
		return $actualApply(bind, $call, args);
	};
	return callBindApplyHelpers;
}

var get;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get;
	hasRequiredGet = 1;

	var callBind = requireCallBindApplyHelpers();
	var gOPD = /*@__PURE__*/ requireGopd();

	var hasProtoAccessor;
	try {
		// eslint-disable-next-line no-extra-parens, no-proto
		hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
			throw e;
		}
	}

	// eslint-disable-next-line no-extra-parens
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;

	/** @type {import('./get')} */
	get = desc && typeof desc.get === 'function'
		? callBind([desc.get])
		: typeof $getPrototypeOf === 'function'
			? /** @type {import('./get')} */ function getDunder(value) {
				// eslint-disable-next-line eqeqeq
				return $getPrototypeOf(value == null ? value : $Object(value));
			}
			: false;
	return get;
}

var getProto;
var hasRequiredGetProto;

function requireGetProto () {
	if (hasRequiredGetProto) return getProto;
	hasRequiredGetProto = 1;

	var reflectGetProto = requireReflect_getPrototypeOf();
	var originalGetProto = requireObject_getPrototypeOf();

	var getDunderProto = /*@__PURE__*/ requireGet();

	/** @type {import('.')} */
	getProto = reflectGetProto
		? function getProto(O) {
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return reflectGetProto(O);
		}
		: originalGetProto
			? function getProto(O) {
				if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
					throw new TypeError('getProto: not an object');
				}
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return originalGetProto(O);
			}
			: getDunderProto
				? function getProto(O) {
					// @ts-expect-error TS can't narrow inside a closure, for some reason
					return getDunderProto(O);
				}
				: null;
	return getProto;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();

	/** @type {import('.')} */
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var getIntrinsic;
var hasRequiredGetIntrinsic;

function requireGetIntrinsic () {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;

	var undefined$1;

	var $Object = /*@__PURE__*/ requireEsObjectAtoms();

	var $Error = /*@__PURE__*/ requireEsErrors();
	var $EvalError = /*@__PURE__*/ require_eval();
	var $RangeError = /*@__PURE__*/ requireRange();
	var $ReferenceError = /*@__PURE__*/ requireRef();
	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();
	var $URIError = /*@__PURE__*/ requireUri();

	var abs = /*@__PURE__*/ requireAbs();
	var floor = /*@__PURE__*/ requireFloor();
	var max = /*@__PURE__*/ requireMax();
	var min = /*@__PURE__*/ requireMin();
	var pow = /*@__PURE__*/ requirePow();
	var round = /*@__PURE__*/ requireRound();
	var sign = /*@__PURE__*/ requireSign();

	var $Function = Function;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};

	var $gOPD = /*@__PURE__*/ requireGopd();
	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols = requireHasSymbols()();

	var getProto = requireGetProto();
	var $ObjectGPO = requireObject_getPrototypeOf();
	var $ReflectGPO = requireReflect_getPrototypeOf();

	var $apply = requireFunctionApply();
	var $call = requireFunctionCall();

	var needsEval = {};

	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		__proto__: null,
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
		'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
		'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': $Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': $EvalError,
		'%Float16Array%': typeof Float16Array === 'undefined' ? undefined$1 : Float16Array,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': $Object,
		'%Object.getOwnPropertyDescriptor%': $gOPD,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': $RangeError,
		'%ReferenceError%': $ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%Symbol%': hasSymbols ? Symbol : undefined$1,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%URIError%': $URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,

		'%Function.prototype.call%': $call,
		'%Function.prototype.apply%': $apply,
		'%Object.defineProperty%': $defineProperty,
		'%Object.getPrototypeOf%': $ObjectGPO,
		'%Math.abs%': abs,
		'%Math.floor%': floor,
		'%Math.max%': max,
		'%Math.min%': min,
		'%Math.pow%': pow,
		'%Math.round%': round,
		'%Math.sign%': sign,
		'%Reflect.getPrototypeOf%': $ReflectGPO
	};

	if (getProto) {
		try {
			null.error; // eslint-disable-line no-unused-expressions
		} catch (e) {
			// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
			var errorProto = getProto(getProto(e));
			INTRINSICS['%Error.prototype%'] = errorProto;
		}
	}

	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}

		INTRINSICS[name] = value;

		return value;
	};

	var LEGACY_ALIASES = {
		__proto__: null,
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};

	var bind = requireFunctionBind();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var $concat = bind.call($call, Array.prototype.concat);
	var $spliceApply = bind.call($apply, Array.prototype.splice);
	var $replace = bind.call($call, String.prototype.replace);
	var $strSlice = bind.call($call, String.prototype.slice);
	var $exec = bind.call($call, RegExp.prototype.exec);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}

		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}

			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}

		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};

	getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}

		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;

		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}

		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}

			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';

			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void 0;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;

					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}

				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};
	return getIntrinsic;
}

var callBound;
var hasRequiredCallBound;

function requireCallBound () {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var callBindBasic = requireCallBindApplyHelpers();

	/** @type {(thisArg: string, searchString: string, position?: number) => number} */
	var $indexOf = callBindBasic([GetIntrinsic('%String.prototype.indexOf%')]);

	/** @type {import('.')} */
	callBound = function callBoundIntrinsic(name, allowMissing) {
		/* eslint no-extra-parens: 0 */

		var intrinsic = /** @type {(this: unknown, ...args: unknown[]) => unknown} */ (GetIntrinsic(name, !!allowMissing));
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBindBasic(/** @type {const} */ ([intrinsic]));
		}
		return intrinsic;
	};
	return callBound;
}

var sideChannelMap;
var hasRequiredSideChannelMap;

function requireSideChannelMap () {
	if (hasRequiredSideChannelMap) return sideChannelMap;
	hasRequiredSideChannelMap = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var callBound = /*@__PURE__*/ requireCallBound();
	var inspect = /*@__PURE__*/ requireObjectInspect();

	var $TypeError = /*@__PURE__*/ requireType();
	var $Map = GetIntrinsic('%Map%', true);

	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => V} */
	var $mapGet = callBound('Map.prototype.get', true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K, value: V) => void} */
	var $mapSet = callBound('Map.prototype.set', true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapHas = callBound('Map.prototype.has', true);
	/** @type {<K, V>(thisArg: Map<K, V>, key: K) => boolean} */
	var $mapDelete = callBound('Map.prototype.delete', true);
	/** @type {<K, V>(thisArg: Map<K, V>) => number} */
	var $mapSize = callBound('Map.prototype.size', true);

	/** @type {import('.')} */
	sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */ function getSideChannelMap() {
		/** @typedef {ReturnType<typeof getSideChannelMap>} Channel */
		/** @typedef {Parameters<Channel['get']>[0]} K */
		/** @typedef {Parameters<Channel['set']>[1]} V */

		/** @type {Map<K, V> | undefined} */ var $m;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				if ($m) {
					var result = $mapDelete($m, key);
					if ($mapSize($m) === 0) {
						$m = void 0;
					}
					return result;
				}
				return false;
			},
			get: function (key) { // eslint-disable-line consistent-return
				if ($m) {
					return $mapGet($m, key);
				}
			},
			has: function (key) {
				if ($m) {
					return $mapHas($m, key);
				}
				return false;
			},
			set: function (key, value) {
				if (!$m) {
					// @ts-expect-error TS can't handle narrowing a variable inside a closure
					$m = new $Map();
				}
				$mapSet($m, key, value);
			}
		};

		// @ts-expect-error TODO: figure out why TS is erroring here
		return channel;
	};
	return sideChannelMap;
}

var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;

function requireSideChannelWeakmap () {
	if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
	hasRequiredSideChannelWeakmap = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var callBound = /*@__PURE__*/ requireCallBound();
	var inspect = /*@__PURE__*/ requireObjectInspect();
	var getSideChannelMap = requireSideChannelMap();

	var $TypeError = /*@__PURE__*/ requireType();
	var $WeakMap = GetIntrinsic('%WeakMap%', true);

	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => V} */
	var $weakMapGet = callBound('WeakMap.prototype.get', true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K, value: V) => void} */
	var $weakMapSet = callBound('WeakMap.prototype.set', true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapHas = callBound('WeakMap.prototype.has', true);
	/** @type {<K extends object, V>(thisArg: WeakMap<K, V>, key: K) => boolean} */
	var $weakMapDelete = callBound('WeakMap.prototype.delete', true);

	/** @type {import('.')} */
	sideChannelWeakmap = $WeakMap
		? /** @type {Exclude<import('.'), false>} */ function getSideChannelWeakMap() {
			/** @typedef {ReturnType<typeof getSideChannelWeakMap>} Channel */
			/** @typedef {Parameters<Channel['get']>[0]} K */
			/** @typedef {Parameters<Channel['set']>[1]} V */

			/** @type {WeakMap<K & object, V> | undefined} */ var $wm;
			/** @type {Channel | undefined} */ var $m;

			/** @type {Channel} */
			var channel = {
				assert: function (key) {
					if (!channel.has(key)) {
						throw new $TypeError('Side channel does not contain ' + inspect(key));
					}
				},
				'delete': function (key) {
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if ($wm) {
							return $weakMapDelete($wm, key);
						}
					} else if (getSideChannelMap) {
						if ($m) {
							return $m['delete'](key);
						}
					}
					return false;
				},
				get: function (key) {
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if ($wm) {
							return $weakMapGet($wm, key);
						}
					}
					return $m && $m.get(key);
				},
				has: function (key) {
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if ($wm) {
							return $weakMapHas($wm, key);
						}
					}
					return !!$m && $m.has(key);
				},
				set: function (key, value) {
					if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
						if (!$wm) {
							$wm = new $WeakMap();
						}
						$weakMapSet($wm, key, value);
					} else if (getSideChannelMap) {
						if (!$m) {
							$m = getSideChannelMap();
						}
						// eslint-disable-next-line no-extra-parens
						/** @type {NonNullable<typeof $m>} */ ($m).set(key, value);
					}
				}
			};

			// @ts-expect-error TODO: figure out why this is erroring
			return channel;
		}
		: getSideChannelMap;
	return sideChannelWeakmap;
}

var sideChannel;
var hasRequiredSideChannel;

function requireSideChannel () {
	if (hasRequiredSideChannel) return sideChannel;
	hasRequiredSideChannel = 1;

	var $TypeError = /*@__PURE__*/ requireType();
	var inspect = /*@__PURE__*/ requireObjectInspect();
	var getSideChannelList = requireSideChannelList();
	var getSideChannelMap = requireSideChannelMap();
	var getSideChannelWeakMap = requireSideChannelWeakmap();

	var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;

	/** @type {import('.')} */
	sideChannel = function getSideChannel() {
		/** @typedef {ReturnType<typeof getSideChannel>} Channel */

		/** @type {Channel | undefined} */ var $channelData;

		/** @type {Channel} */
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			'delete': function (key) {
				return !!$channelData && $channelData['delete'](key);
			},
			get: function (key) {
				return $channelData && $channelData.get(key);
			},
			has: function (key) {
				return !!$channelData && $channelData.has(key);
			},
			set: function (key, value) {
				if (!$channelData) {
					$channelData = makeChannel();
				}

				$channelData.set(key, value);
			}
		};
		// @ts-expect-error TODO: figure out why this is erroring
		return channel;
	};
	return sideChannel;
}

var formats;
var hasRequiredFormats;

function requireFormats () {
	if (hasRequiredFormats) return formats;
	hasRequiredFormats = 1;

	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;

	var Format = {
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};

	formats = {
	    'default': Format.RFC3986,
	    formatters: {
	        RFC1738: function (value) {
	            return replace.call(value, percentTwenties, '+');
	        },
	        RFC3986: function (value) {
	            return String(value);
	        }
	    },
	    RFC1738: Format.RFC1738,
	    RFC3986: Format.RFC3986
	};
	return formats;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	var formats = /*@__PURE__*/ requireFormats();

	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;

	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }

	    return array;
	}());

	var compactQueue = function compactQueue(queue) {
	    while (queue.length > 1) {
	        var item = queue.pop();
	        var obj = item.obj[item.prop];

	        if (isArray(obj)) {
	            var compacted = [];

	            for (var j = 0; j < obj.length; ++j) {
	                if (typeof obj[j] !== 'undefined') {
	                    compacted.push(obj[j]);
	                }
	            }

	            item.obj[item.prop] = compacted;
	        }
	    }
	};

	var arrayToObject = function arrayToObject(source, options) {
	    var obj = options && options.plainObjects ? { __proto__: null } : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	var merge = function merge(target, source, options) {
	    /* eslint no-param-reassign: 0 */
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object' && typeof source !== 'function') {
	        if (isArray(target)) {
	            target.push(source);
	        } else if (target && typeof target === 'object') {
	            if (
	                (options && (options.plainObjects || options.allowPrototypes))
	                || !has.call(Object.prototype, source)
	            ) {
	                target[source] = true;
	            }
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (!target || typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (isArray(target) && !isArray(source)) {
	        mergeTarget = arrayToObject(target, options);
	    }

	    if (isArray(target) && isArray(source)) {
	        source.forEach(function (item, i) {
	            if (has.call(target, i)) {
	                var targetItem = target[i];
	                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
	                    target[i] = merge(targetItem, item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (has.call(acc, key)) {
	            acc[key] = merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	var assign = function assignSingleSource(target, source) {
	    return Object.keys(source).reduce(function (acc, key) {
	        acc[key] = source[key];
	        return acc;
	    }, target);
	};

	var decode = function (str, defaultDecoder, charset) {
	    var strWithoutPlus = str.replace(/\+/g, ' ');
	    if (charset === 'iso-8859-1') {
	        // unescape never throws, no try...catch needed:
	        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
	    }
	    // utf-8
	    try {
	        return decodeURIComponent(strWithoutPlus);
	    } catch (e) {
	        return strWithoutPlus;
	    }
	};

	var limit = 1024;

	/* eslint operator-linebreak: [2, "before"] */

	var encode = function encode(str, defaultEncoder, charset, kind, format) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = str;
	    if (typeof str === 'symbol') {
	        string = Symbol.prototype.toString.call(str);
	    } else if (typeof str !== 'string') {
	        string = String(str);
	    }

	    if (charset === 'iso-8859-1') {
	        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
	            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
	        });
	    }

	    var out = '';
	    for (var j = 0; j < string.length; j += limit) {
	        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
	        var arr = [];

	        for (var i = 0; i < segment.length; ++i) {
	            var c = segment.charCodeAt(i);
	            if (
	                c === 0x2D // -
	                || c === 0x2E // .
	                || c === 0x5F // _
	                || c === 0x7E // ~
	                || (c >= 0x30 && c <= 0x39) // 0-9
	                || (c >= 0x41 && c <= 0x5A) // a-z
	                || (c >= 0x61 && c <= 0x7A) // A-Z
	                || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
	            ) {
	                arr[arr.length] = segment.charAt(i);
	                continue;
	            }

	            if (c < 0x80) {
	                arr[arr.length] = hexTable[c];
	                continue;
	            }

	            if (c < 0x800) {
	                arr[arr.length] = hexTable[0xC0 | (c >> 6)]
	                    + hexTable[0x80 | (c & 0x3F)];
	                continue;
	            }

	            if (c < 0xD800 || c >= 0xE000) {
	                arr[arr.length] = hexTable[0xE0 | (c >> 12)]
	                    + hexTable[0x80 | ((c >> 6) & 0x3F)]
	                    + hexTable[0x80 | (c & 0x3F)];
	                continue;
	            }

	            i += 1;
	            c = 0x10000 + (((c & 0x3FF) << 10) | (segment.charCodeAt(i) & 0x3FF));

	            arr[arr.length] = hexTable[0xF0 | (c >> 18)]
	                + hexTable[0x80 | ((c >> 12) & 0x3F)]
	                + hexTable[0x80 | ((c >> 6) & 0x3F)]
	                + hexTable[0x80 | (c & 0x3F)];
	        }

	        out += arr.join('');
	    }

	    return out;
	};

	var compact = function compact(value) {
	    var queue = [{ obj: { o: value }, prop: 'o' }];
	    var refs = [];

	    for (var i = 0; i < queue.length; ++i) {
	        var item = queue[i];
	        var obj = item.obj[item.prop];

	        var keys = Object.keys(obj);
	        for (var j = 0; j < keys.length; ++j) {
	            var key = keys[j];
	            var val = obj[key];
	            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
	                queue.push({ obj: obj, prop: key });
	                refs.push(val);
	            }
	        }
	    }

	    compactQueue(queue);

	    return value;
	};

	var isRegExp = function isRegExp(obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	var isBuffer = function isBuffer(obj) {
	    if (!obj || typeof obj !== 'object') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

	var combine = function combine(a, b) {
	    return [].concat(a, b);
	};

	var maybeMap = function maybeMap(val, fn) {
	    if (isArray(val)) {
	        var mapped = [];
	        for (var i = 0; i < val.length; i += 1) {
	            mapped.push(fn(val[i]));
	        }
	        return mapped;
	    }
	    return fn(val);
	};

	utils = {
	    arrayToObject: arrayToObject,
	    assign: assign,
	    combine: combine,
	    compact: compact,
	    decode: decode,
	    encode: encode,
	    isBuffer: isBuffer,
	    isRegExp: isRegExp,
	    maybeMap: maybeMap,
	    merge: merge
	};
	return utils;
}

var stringify_1;
var hasRequiredStringify;

function requireStringify () {
	if (hasRequiredStringify) return stringify_1;
	hasRequiredStringify = 1;

	var getSideChannel = requireSideChannel();
	var utils = /*@__PURE__*/ requireUtils();
	var formats = /*@__PURE__*/ requireFormats();
	var has = Object.prototype.hasOwnProperty;

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    comma: 'comma',
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function (arr, valueOrArray) {
	    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};

	var toISO = Date.prototype.toISOString;

	var defaultFormat = formats['default'];
	var defaults = {
	    addQueryPrefix: false,
	    allowDots: false,
	    allowEmptyArrays: false,
	    arrayFormat: 'indices',
	    charset: 'utf-8',
	    charsetSentinel: false,
	    commaRoundTrip: false,
	    delimiter: '&',
	    encode: true,
	    encodeDotInKeys: false,
	    encoder: utils.encode,
	    encodeValuesOnly: false,
	    filter: void 0,
	    format: defaultFormat,
	    formatter: formats.formatters[defaultFormat],
	    // deprecated
	    indices: false,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};

	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
	    return typeof v === 'string'
	        || typeof v === 'number'
	        || typeof v === 'boolean'
	        || typeof v === 'symbol'
	        || typeof v === 'bigint';
	};

	var sentinel = {};

	var stringify = function stringify(
	    object,
	    prefix,
	    generateArrayPrefix,
	    commaRoundTrip,
	    allowEmptyArrays,
	    strictNullHandling,
	    skipNulls,
	    encodeDotInKeys,
	    encoder,
	    filter,
	    sort,
	    allowDots,
	    serializeDate,
	    format,
	    formatter,
	    encodeValuesOnly,
	    charset,
	    sideChannel
	) {
	    var obj = object;

	    var tmpSc = sideChannel;
	    var step = 0;
	    var findFlag = false;
	    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
	        // Where object last appeared in the ref tree
	        var pos = tmpSc.get(object);
	        step += 1;
	        if (typeof pos !== 'undefined') {
	            if (pos === step) {
	                throw new RangeError('Cyclic object value');
	            } else {
	                findFlag = true; // Break while
	            }
	        }
	        if (typeof tmpSc.get(sentinel) === 'undefined') {
	            step = 0;
	        }
	    }

	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        obj = utils.maybeMap(obj, function (value) {
	            if (value instanceof Date) {
	                return serializeDate(value);
	            }
	            return value;
	        });
	    }

	    if (obj === null) {
	        if (strictNullHandling) {
	            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
	        }

	        obj = '';
	    }

	    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
	        if (encoder) {
	            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
	            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        // we need to join elements in
	        if (encodeValuesOnly && encoder) {
	            obj = utils.maybeMap(obj, encoder);
	        }
	        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void 0 }];
	    } else if (isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, '%2E') : String(prefix);

	    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;

	    if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
	        return adjustedPrefix + '[]';
	    }

	    for (var j = 0; j < objKeys.length; ++j) {
	        var key = objKeys[j];
	        var value = typeof key === 'object' && key && typeof key.value !== 'undefined'
	            ? key.value
	            : obj[key];

	        if (skipNulls && value === null) {
	            continue;
	        }

	        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, '%2E') : String(key);
	        var keyPrefix = isArray(obj)
	            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix
	            : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');

	        sideChannel.set(object, step);
	        var valueSideChannel = getSideChannel();
	        valueSideChannel.set(sentinel, sideChannel);
	        pushToArray(values, stringify(
	            value,
	            keyPrefix,
	            generateArrayPrefix,
	            commaRoundTrip,
	            allowEmptyArrays,
	            strictNullHandling,
	            skipNulls,
	            encodeDotInKeys,
	            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            format,
	            formatter,
	            encodeValuesOnly,
	            charset,
	            valueSideChannel
	        ));
	    }

	    return values;
	};

	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
	        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
	    }

	    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
	        throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
	    }

	    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    var charset = opts.charset || defaults.charset;
	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }

	    var format = formats['default'];
	    if (typeof opts.format !== 'undefined') {
	        if (!has.call(formats.formatters, opts.format)) {
	            throw new TypeError('Unknown format option provided.');
	        }
	        format = opts.format;
	    }
	    var formatter = formats.formatters[format];

	    var filter = defaults.filter;
	    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
	        filter = opts.filter;
	    }

	    var arrayFormat;
	    if (opts.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = opts.arrayFormat;
	    } else if ('indices' in opts) {
	        arrayFormat = opts.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = defaults.arrayFormat;
	    }

	    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
	        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
	    }

	    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

	    return {
	        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
	        allowDots: allowDots,
	        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
	        arrayFormat: arrayFormat,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        commaRoundTrip: !!opts.commaRoundTrip,
	        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
	        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
	        encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
	        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
	        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
	        filter: filter,
	        format: format,
	        formatter: formatter,
	        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
	        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
	        sort: typeof opts.sort === 'function' ? opts.sort : null,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};

	stringify_1 = function (object, opts) {
	    var obj = object;
	    var options = normalizeStringifyOptions(opts);

	    var objKeys;
	    var filter;

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (isArray(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
	    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (options.sort) {
	        objKeys.sort(options.sort);
	    }

	    var sideChannel = getSideChannel();
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	        var value = obj[key];

	        if (options.skipNulls && value === null) {
	            continue;
	        }
	        pushToArray(keys, stringify(
	            value,
	            key,
	            generateArrayPrefix,
	            commaRoundTrip,
	            options.allowEmptyArrays,
	            options.strictNullHandling,
	            options.skipNulls,
	            options.encodeDotInKeys,
	            options.encode ? options.encoder : null,
	            options.filter,
	            options.sort,
	            options.allowDots,
	            options.serializeDate,
	            options.format,
	            options.formatter,
	            options.encodeValuesOnly,
	            options.charset,
	            sideChannel
	        ));
	    }

	    var joined = keys.join(options.delimiter);
	    var prefix = options.addQueryPrefix === true ? '?' : '';

	    if (options.charsetSentinel) {
	        if (options.charset === 'iso-8859-1') {
	            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
	            prefix += 'utf8=%26%2310003%3B&';
	        } else {
	            // encodeURIComponent('✓')
	            prefix += 'utf8=%E2%9C%93&';
	        }
	    }

	    return joined.length > 0 ? prefix + joined : '';
	};
	return stringify_1;
}

var parse;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse;
	hasRequiredParse = 1;

	var utils = /*@__PURE__*/ requireUtils();

	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;

	var defaults = {
	    allowDots: false,
	    allowEmptyArrays: false,
	    allowPrototypes: false,
	    allowSparse: false,
	    arrayLimit: 20,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    comma: false,
	    decodeDotInKeys: false,
	    decoder: utils.decode,
	    delimiter: '&',
	    depth: 5,
	    duplicates: 'combine',
	    ignoreQueryPrefix: false,
	    interpretNumericEntities: false,
	    parameterLimit: 1000,
	    parseArrays: true,
	    plainObjects: false,
	    strictDepth: false,
	    strictNullHandling: false,
	    throwOnLimitExceeded: false
	};

	var interpretNumericEntities = function (str) {
	    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
	        return String.fromCharCode(parseInt(numberStr, 10));
	    });
	};

	var parseArrayValue = function (val, options, currentArrayLength) {
	    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
	        return val.split(',');
	    }

	    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
	        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');
	    }

	    return val;
	};

	// This is what browsers will submit when the ✓ character occurs in an
	// application/x-www-form-urlencoded body and the encoding of the page containing
	// the form is iso-8859-1, or when the submitted form has an accept-charset
	// attribute of iso-8859-1. Presumably also with other charsets that do not contain
	// the ✓ character, such as us-ascii.
	var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

	// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
	var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

	var parseValues = function parseQueryStringValues(str, options) {
	    var obj = { __proto__: null };

	    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
	    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');

	    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
	    var parts = cleanStr.split(
	        options.delimiter,
	        options.throwOnLimitExceeded ? limit + 1 : limit
	    );

	    if (options.throwOnLimitExceeded && parts.length > limit) {
	        throw new RangeError('Parameter limit exceeded. Only ' + limit + ' parameter' + (limit === 1 ? '' : 's') + ' allowed.');
	    }

	    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
	    var i;

	    var charset = options.charset;
	    if (options.charsetSentinel) {
	        for (i = 0; i < parts.length; ++i) {
	            if (parts[i].indexOf('utf8=') === 0) {
	                if (parts[i] === charsetSentinel) {
	                    charset = 'utf-8';
	                } else if (parts[i] === isoSentinel) {
	                    charset = 'iso-8859-1';
	                }
	                skipIndex = i;
	                i = parts.length; // The eslint settings do not allow break;
	            }
	        }
	    }

	    for (i = 0; i < parts.length; ++i) {
	        if (i === skipIndex) {
	            continue;
	        }
	        var part = parts[i];

	        var bracketEqualsPos = part.indexOf(']=');
	        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

	        var key;
	        var val;
	        if (pos === -1) {
	            key = options.decoder(part, defaults.decoder, charset, 'key');
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');

	            val = utils.maybeMap(
	                parseArrayValue(
	                    part.slice(pos + 1),
	                    options,
	                    isArray(obj[key]) ? obj[key].length : 0
	                ),
	                function (encodedVal) {
	                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
	                }
	            );
	        }

	        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
	            val = interpretNumericEntities(String(val));
	        }

	        if (part.indexOf('[]=') > -1) {
	            val = isArray(val) ? [val] : val;
	        }

	        var existing = has.call(obj, key);
	        if (existing && options.duplicates === 'combine') {
	            obj[key] = utils.combine(obj[key], val);
	        } else if (!existing || options.duplicates === 'last') {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function (chain, val, options, valuesParsed) {
	    var currentArrayLength = 0;
	    if (chain.length > 0 && chain[chain.length - 1] === '[]') {
	        var parentKey = chain.slice(0, -1).join('');
	        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
	    }

	    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);

	    for (var i = chain.length - 1; i >= 0; --i) {
	        var obj;
	        var root = chain[i];

	        if (root === '[]' && options.parseArrays) {
	            obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))
	                ? []
	                : utils.combine([], leaf);
	        } else {
	            obj = options.plainObjects ? { __proto__: null } : {};
	            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
	            var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
	            var index = parseInt(decodedRoot, 10);
	            if (!options.parseArrays && decodedRoot === '') {
	                obj = { 0: leaf };
	            } else if (
	                !isNaN(index)
	                && root !== decodedRoot
	                && String(index) === decodedRoot
	                && index >= 0
	                && (options.parseArrays && index <= options.arrayLimit)
	            ) {
	                obj = [];
	                obj[index] = leaf;
	            } else if (decodedRoot !== '__proto__') {
	                obj[decodedRoot] = leaf;
	            }
	        }

	        leaf = obj;
	    }

	    return leaf;
	};

	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var brackets = /(\[[^[\]]*])/;
	    var child = /(\[[^[\]]*])/g;

	    // Get the parent

	    var segment = options.depth > 0 && brackets.exec(key);
	    var parent = segment ? key.slice(0, segment.index) : key;

	    // Stash the parent if it exists

	    var keys = [];
	    if (parent) {
	        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, parent)) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(parent);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

	    if (segment) {
	        if (options.strictDepth === true) {
	            throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
	        }
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options, valuesParsed);
	};

	var normalizeParseOptions = function normalizeParseOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
	        throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
	    }

	    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
	        throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
	    }

	    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }

	    if (typeof opts.throwOnLimitExceeded !== 'undefined' && typeof opts.throwOnLimitExceeded !== 'boolean') {
	        throw new TypeError('`throwOnLimitExceeded` option must be a boolean');
	    }

	    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

	    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;

	    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
	        throw new TypeError('The duplicates option must be either combine, first, or last');
	    }

	    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;

	    return {
	        allowDots: allowDots,
	        allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
	        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
	        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
	        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
	        decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
	        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
	        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
	        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
	        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
	        duplicates: duplicates,
	        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
	        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
	        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
	        parseArrays: opts.parseArrays !== false,
	        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
	        strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling,
	        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === 'boolean' ? opts.throwOnLimitExceeded : false
	    };
	};

	parse = function (str, opts) {
	    var options = normalizeParseOptions(opts);

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? { __proto__: null } : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? { __proto__: null } : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
	        obj = utils.merge(obj, newObj, options);
	    }

	    if (options.allowSparse === true) {
	        return obj;
	    }

	    return utils.compact(obj);
	};
	return parse;
}

var lib$1;
var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$1;
	hasRequiredLib$2 = 1;

	var stringify = /*@__PURE__*/ requireStringify();
	var parse = /*@__PURE__*/ requireParse();
	var formats = /*@__PURE__*/ requireFormats();

	lib$1 = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};
	return lib$1;
}

/*
 * Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

var hasRequiredUrl;

function requireUrl () {
	if (hasRequiredUrl) return url;
	hasRequiredUrl = 1;

	var punycode = requirePunycode();

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	/*
	 * define these here so at least they only have to be
	 * compiled once on the first module load.
	 */
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	  portPattern = /:[0-9]*$/,

	  // Special case for a simple path URL
	  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,

	  /*
	   * RFC 2396: characters reserved for delimiting URLs.
	   * We actually just auto-escape these.
	   */
	  delims = [
	    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
	  ],

	  // RFC 2396: characters not allowed for various reasons.
	  unwise = [
	    '{', '}', '|', '\\', '^', '`'
	  ].concat(delims),

	  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	  autoEscape = ['\''].concat(unwise),
	  /*
	   * Characters that are never ever allowed in a hostname.
	   * Note that any invalid chars are also handled, but these
	   * are the ones that are *expected* to be seen, so we fast-path
	   * them.
	   */
	  nonHostChars = [
	    '%', '/', '?', ';', '#'
	  ].concat(autoEscape),
	  hostEndingChars = [
	    '/', '?', '#'
	  ],
	  hostnameMaxLen = 255,
	  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	  // protocols that can allow "unsafe" and "unwise" chars.
	  unsafeProtocol = {
	    javascript: true,
	    'javascript:': true
	  },
	  // protocols that never have a hostname.
	  hostlessProtocol = {
	    javascript: true,
	    'javascript:': true
	  },
	  // protocols that always contain a // bit.
	  slashedProtocol = {
	    http: true,
	    https: true,
	    ftp: true,
	    gopher: true,
	    file: true,
	    'http:': true,
	    'https:': true,
	    'ftp:': true,
	    'gopher:': true,
	    'file:': true
	  },
	  querystring = /*@__PURE__*/ requireLib$2();

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && typeof url === 'object' && url instanceof Url) { return url; }

	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (typeof url !== 'string') {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  /*
	   * Copy chrome, IE, opera backslash-handling behavior.
	   * Back slashes before the query string get converted to forward slashes
	   * See: https://code.google.com/p/chromium/issues/detail?id=25916
	   */
	  var queryIndex = url.indexOf('?'),
	    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
	    uSplit = url.split(splitter),
	    slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);

	  var rest = url;

	  /*
	   * trim before proceeding.
	   * This is to support parse stuff like "  http://foo.com  \n"
	   */
	  rest = rest.trim();

	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  /*
	   * figure out if it's got a host
	   * user@server is *always* interpreted as a hostname, and url
	   * resolution will treat //foo/bar as host=foo,path=bar because that's
	   * how the browser resolves relative URLs.
	   */
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {

	    /*
	     * there's a hostname.
	     * the first instance of /, ?, ;, or # ends the host.
	     *
	     * If there is an @ in the hostname, then non-host chars *are* allowed
	     * to the left of the last @ sign, unless some host-ending character
	     * comes *before* the @-sign.
	     * URLs are obnoxious.
	     *
	     * ex:
	     * http://a@b@c/ => user:a@b host:c
	     * http://a@b?@c => user:a host:c path:/?@c
	     */

	    /*
	     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
	     * Review our test case against browsers more comprehensively.
	     */

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
	    }

	    /*
	     * at this point, either we have an explicit point where the
	     * auth portion cannot go past, or the last @ char is the decider.
	     */
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      /*
	       * atSign must be in auth portion.
	       * http://a@b/c@d => host:b auth:a path:/c@d
	       */
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    /*
	     * Now we have a portion which is definitely the auth.
	     * Pull that off.
	     */
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) { hostEnd = rest.length; }

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    /*
	     * we've indicated that there is a hostname,
	     * so even if it's empty, it has to be present.
	     */
	    this.hostname = this.hostname || '';

	    /*
	     * if hostname begins with [ and ends with ]
	     * assume that it's an IPv6 address.
	     */
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) { continue; }
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              /*
	               * we replace non-ASCII char with a temporary placeholder
	               * we need this to make sure size of hostname is not
	               * broken by replacing non-ASCII by nothing
	               */
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      /*
	       * IDNA Support: Returns a punycoded representation of "domain".
	       * It only converts parts of the domain name that
	       * have non-ASCII characters, i.e. it doesn't matter if
	       * you call it with a domain that already is ASCII-only.
	       */
	      this.hostname = punycode.toASCII(this.hostname);
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    /*
	     * strip [ and ] from the hostname
	     * the host field still retains them, though
	     */
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  /*
	   * now rest is set to the post-host stuff.
	   * chop off any delim chars.
	   */
	  if (!unsafeProtocol[lowerProto]) {

	    /*
	     * First, make 100% sure that any "autoEscape" chars get
	     * escaped, even if encodeURIComponent doesn't think they
	     * need to be.
	     */
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1) { continue; }
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }

	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) { this.pathname = rest; }
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  // to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  /*
	   * ensure it's an object, and not a string url.
	   * If it's an obj, this is a no-op.
	   * this way, you can call url_format() on strings
	   * to clean up potentially wonky urls.
	   */
	  if (typeof obj === 'string') { obj = urlParse(obj); }
	  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
	  return obj.format();
	}

	Url.prototype.format = function () {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	    pathname = this.pathname || '',
	    hash = this.hash || '',
	    host = false,
	    query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query, {
	      arrayFormat: 'repeat',
	      addQueryPrefix: false
	    });
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }

	  /*
	   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	   * unless they had them to begin with.
	   */
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
	  if (search && search.charAt(0) !== '?') { search = '?' + search; }

	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) { return relative; }
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function (relative) {
	  if (typeof relative === 'string') {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }

	  /*
	   * hash is always overridden, no matter what.
	   * even href="" will remove it.
	   */
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
	    }

	    // urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.pathname = '/';
	      result.path = result.pathname;
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    /*
	     * if it's a known url protocol, then changing
	     * the protocol does weird things
	     * first, if it's not file:, then we MUST have a host,
	     * and if there was a path
	     * to begin with, then we MUST have a path.
	     * if it is file:, then the host is dropped,
	     * because that's known to be hostless.
	     * anything else is assumed to be absolute.
	     */
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift())) { }
	      if (!relative.host) { relative.host = ''; }
	      if (!relative.hostname) { relative.hostname = ''; }
	      if (relPath[0] !== '') { relPath.unshift(''); }
	      if (relPath.length < 2) { relPath.unshift(''); }
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
	    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
	    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
	    removeAllDots = mustEndAbs,
	    srcPath = result.pathname && result.pathname.split('/') || [],
	    relPath = relative.pathname && relative.pathname.split('/') || [],
	    psychotic = result.protocol && !slashedProtocol[result.protocol];

	  /*
	   * if the url is a non-slashed url, then relative
	   * links like ../.. should be able
	   * to crawl up to the hostname, as well.  This is strange.
	   * result.protocol has already been set by now.
	   * Later on, put the first path part into the host field.
	   */
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = relative.host || relative.host === '' ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    /*
	     * it's relative
	     * throw away the existing file, and take the new path instead.
	     */
	    if (!srcPath) { srcPath = []; }
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (relative.search != null) {
	    /*
	     * just pull out the search.
	     * like href='?foo'.
	     * Put this after the other two cases because it simplifies the booleans
	     */
	    if (psychotic) {
	      result.host = srcPath.shift();
	      result.hostname = result.host;
	      /*
	       * occationaly the auth can get stuck only in host
	       * this especially happens in cases like
	       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	       */
	      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.hostname = authInHost.shift();
	        result.host = result.hostname;
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    // to support http.request
	    if (result.pathname !== null || result.search !== null) {
	      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    /*
	     * no path at all.  easy.
	     * we've already handled the other stuff above.
	     */
	    result.pathname = null;
	    // to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  /*
	   * if a url ENDs in . or .., then it must get a trailing slash.
	   * however, if it ends in anything else non-slashy,
	   * then it must NOT get a trailing slash.
	   */
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

	  /*
	   * strip single dots, resolve double dots to parent dir
	   * if the path tries to go above the root, `up` ends up > 0
	   */
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
	    result.host = result.hostname;
	    /*
	     * occationaly the auth can get stuck only in host
	     * this especially happens in cases like
	     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	     */
	    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.hostname = authInHost.shift();
	      result.host = result.hostname;
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (srcPath.length > 0) {
	    result.pathname = srcPath.join('/');
	  } else {
	    result.pathname = null;
	    result.path = null;
	  }

	  // to support request.http
	  if (result.pathname !== null || result.search !== null) {
	    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) { this.hostname = host; }
	};

	url.parse = urlParse;
	url.resolve = urlResolve;
	url.resolveObject = urlResolveObject;
	url.format = urlFormat;

	url.Url = Url;
	return url;
}

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.unixify = exports.getWriteSyncArgs = exports.getWriteArgs = exports.bufToUint8 = exports.isWin = void 0;
		exports.promisify = promisify;
		exports.validateCallback = validateCallback;
		exports.modeToNumber = modeToNumber;
		exports.nullCheck = nullCheck;
		exports.pathToFilename = pathToFilename;
		exports.createError = createError;
		exports.genRndStr6 = genRndStr6;
		exports.flagsToNumber = flagsToNumber;
		exports.isFd = isFd;
		exports.validateFd = validateFd;
		exports.streamToBuffer = streamToBuffer;
		exports.dataToBuffer = dataToBuffer;
		exports.bufferToEncoding = bufferToEncoding;
		exports.isReadableStream = isReadableStream;
		const constants_1 = requireConstants();
		const errors = requireErrors$1();
		const buffer_1 = requireBuffer$1();
		const encoding_1 = requireEncoding();
		const buffer_2 = requireBuffer$1();
		const queueMicrotask_1 = requireQueueMicrotask();
		exports.isWin = process$1.platform === 'win32';
		function promisify(fs, fn, getResult = input => input) {
		    return (...args) => new Promise((resolve, reject) => {
		        fs[fn].bind(fs)(...args, (error, result) => {
		            if (error)
		                return reject(error);
		            return resolve(getResult(result));
		        });
		    });
		}
		function validateCallback(callback) {
		    if (typeof callback !== 'function')
		        throw TypeError(constants_1.ERRSTR.CB);
		    return callback;
		}
		function _modeToNumber(mode, def) {
		    if (typeof mode === 'number')
		        return mode;
		    if (typeof mode === 'string')
		        return parseInt(mode, 8);
		    if (def)
		        return modeToNumber(def);
		    return undefined;
		}
		function modeToNumber(mode, def) {
		    const result = _modeToNumber(mode, def);
		    if (typeof result !== 'number' || isNaN(result))
		        throw new TypeError(constants_1.ERRSTR.MODE_INT);
		    return result;
		}
		function nullCheck(path, callback) {
		    if (('' + path).indexOf('\u0000') !== -1) {
		        const er = new Error('Path must be a string without null bytes');
		        er.code = 'ENOENT';
		        if (typeof callback !== 'function')
		            throw er;
		        (0, queueMicrotask_1.default)(() => {
		            callback(er);
		        });
		        return false;
		    }
		    return true;
		}
		function getPathFromURLPosix(url) {
		    if (url.hostname !== '') {
		        throw new errors.TypeError('ERR_INVALID_FILE_URL_HOST', process$1.platform);
		    }
		    const pathname = url.pathname;
		    for (let n = 0; n < pathname.length; n++) {
		        if (pathname[n] === '%') {
		            const third = pathname.codePointAt(n + 2) | 0x20;
		            if (pathname[n + 1] === '2' && third === 102) {
		                throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH', 'must not include encoded / characters');
		            }
		        }
		    }
		    return decodeURIComponent(pathname);
		}
		function pathToFilename(path) {
		    if (path instanceof Uint8Array) {
		        path = (0, buffer_2.bufferFrom)(path);
		    }
		    if (typeof path !== 'string' && !buffer_1.Buffer.isBuffer(path)) {
		        try {
		            if (!(path instanceof requireUrl().URL))
		                throw new TypeError(constants_1.ERRSTR.PATH_STR);
		        }
		        catch (err) {
		            throw new TypeError(constants_1.ERRSTR.PATH_STR);
		        }
		        path = getPathFromURLPosix(path);
		    }
		    const pathString = String(path);
		    nullCheck(pathString);
		    // return slash(pathString);
		    return pathString;
		}
		const ENOENT = 'ENOENT';
		const EBADF = 'EBADF';
		const EINVAL = 'EINVAL';
		const EPERM = 'EPERM';
		const EPROTO = 'EPROTO';
		const EEXIST = 'EEXIST';
		const ENOTDIR = 'ENOTDIR';
		const EMFILE = 'EMFILE';
		const EACCES = 'EACCES';
		const EISDIR = 'EISDIR';
		const ENOTEMPTY = 'ENOTEMPTY';
		const ENOSYS = 'ENOSYS';
		const ERR_FS_EISDIR = 'ERR_FS_EISDIR';
		const ERR_OUT_OF_RANGE = 'ERR_OUT_OF_RANGE';
		function formatError(errorCode, func = '', path = '', path2 = '') {
		    let pathFormatted = '';
		    if (path)
		        pathFormatted = ` '${path}'`;
		    if (path2)
		        pathFormatted += ` -> '${path2}'`;
		    switch (errorCode) {
		        case ENOENT:
		            return `ENOENT: no such file or directory, ${func}${pathFormatted}`;
		        case EBADF:
		            return `EBADF: bad file descriptor, ${func}${pathFormatted}`;
		        case EINVAL:
		            return `EINVAL: invalid argument, ${func}${pathFormatted}`;
		        case EPERM:
		            return `EPERM: operation not permitted, ${func}${pathFormatted}`;
		        case EPROTO:
		            return `EPROTO: protocol error, ${func}${pathFormatted}`;
		        case EEXIST:
		            return `EEXIST: file already exists, ${func}${pathFormatted}`;
		        case ENOTDIR:
		            return `ENOTDIR: not a directory, ${func}${pathFormatted}`;
		        case EISDIR:
		            return `EISDIR: illegal operation on a directory, ${func}${pathFormatted}`;
		        case EACCES:
		            return `EACCES: permission denied, ${func}${pathFormatted}`;
		        case ENOTEMPTY:
		            return `ENOTEMPTY: directory not empty, ${func}${pathFormatted}`;
		        case EMFILE:
		            return `EMFILE: too many open files, ${func}${pathFormatted}`;
		        case ENOSYS:
		            return `ENOSYS: function not implemented, ${func}${pathFormatted}`;
		        case ERR_FS_EISDIR:
		            return `[ERR_FS_EISDIR]: Path is a directory: ${func} returned EISDIR (is a directory) ${path}`;
		        case ERR_OUT_OF_RANGE:
		            return `[ERR_OUT_OF_RANGE]: value out of range, ${func}${pathFormatted}`;
		        default:
		            return `${errorCode}: error occurred, ${func}${pathFormatted}`;
		    }
		}
		function createError(errorCode, func = '', path = '', path2 = '', Constructor = Error) {
		    const error = new Constructor(formatError(errorCode, func, path, path2));
		    error.code = errorCode;
		    if (path) {
		        error.path = path;
		    }
		    return error;
		}
		function genRndStr6() {
		    const str = (Math.random() + 1).toString(36).substring(2, 8);
		    if (str.length === 6)
		        return str;
		    else
		        return genRndStr6();
		}
		function flagsToNumber(flags) {
		    if (typeof flags === 'number')
		        return flags;
		    if (typeof flags === 'string') {
		        const flagsNum = constants_1.FLAGS[flags];
		        if (typeof flagsNum !== 'undefined')
		            return flagsNum;
		    }
		    // throw new TypeError(formatError(ERRSTR_FLAG(flags)));
		    throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);
		}
		function isFd(path) {
		    return path >>> 0 === path;
		}
		function validateFd(fd) {
		    if (!isFd(fd))
		        throw TypeError(constants_1.ERRSTR.FD);
		}
		function streamToBuffer(stream) {
		    const chunks = [];
		    return new Promise((resolve, reject) => {
		        stream.on('data', chunk => chunks.push(chunk));
		        stream.on('end', () => resolve(buffer_1.Buffer.concat(chunks)));
		        stream.on('error', reject);
		    });
		}
		function dataToBuffer(data, encoding = encoding_1.ENCODING_UTF8) {
		    if (buffer_1.Buffer.isBuffer(data))
		        return data;
		    else if (data instanceof Uint8Array)
		        return (0, buffer_2.bufferFrom)(data);
		    else
		        return (0, buffer_2.bufferFrom)(String(data), encoding);
		}
		const bufToUint8 = (buf) => new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
		exports.bufToUint8 = bufToUint8;
		const getWriteArgs = (fd, a, b, c, d, e) => {
		    validateFd(fd);
		    let offset = 0;
		    let length;
		    let position = null;
		    let encoding;
		    let callback;
		    const tipa = typeof a;
		    const tipb = typeof b;
		    const tipc = typeof c;
		    const tipd = typeof d;
		    if (tipa !== 'string') {
		        if (tipb === 'function') {
		            callback = b;
		        }
		        else if (tipc === 'function') {
		            offset = b | 0;
		            callback = c;
		        }
		        else if (tipd === 'function') {
		            offset = b | 0;
		            length = c;
		            callback = d;
		        }
		        else {
		            offset = b | 0;
		            length = c;
		            position = d;
		            callback = e;
		        }
		    }
		    else {
		        if (tipb === 'function') {
		            callback = b;
		        }
		        else if (tipc === 'function') {
		            position = b;
		            callback = c;
		        }
		        else if (tipd === 'function') {
		            position = b;
		            encoding = c;
		            callback = d;
		        }
		    }
		    const buf = dataToBuffer(a, encoding);
		    if (tipa !== 'string') {
		        if (typeof length === 'undefined')
		            length = buf.length;
		    }
		    else {
		        offset = 0;
		        length = buf.length;
		    }
		    const cb = validateCallback(callback);
		    return [fd, tipa === 'string', buf, offset, length, position, cb];
		};
		exports.getWriteArgs = getWriteArgs;
		const getWriteSyncArgs = (fd, a, b, c, d) => {
		    validateFd(fd);
		    let encoding;
		    let offset;
		    let length;
		    let position;
		    const isBuffer = typeof a !== 'string';
		    if (isBuffer) {
		        offset = (b || 0) | 0;
		        length = c;
		        position = d;
		    }
		    else {
		        position = b;
		        encoding = c;
		    }
		    const buf = dataToBuffer(a, encoding);
		    if (isBuffer) {
		        if (typeof length === 'undefined') {
		            length = buf.length;
		        }
		    }
		    else {
		        offset = 0;
		        length = buf.length;
		    }
		    return [fd, buf, offset || 0, length, position];
		};
		exports.getWriteSyncArgs = getWriteSyncArgs;
		function bufferToEncoding(buffer, encoding) {
		    if (!encoding || encoding === 'buffer')
		        return buffer;
		    else
		        return buffer.toString(encoding);
		}
		function isReadableStream(stream) {
		    return (stream !== null &&
		        typeof stream === 'object' &&
		        typeof stream.pipe === 'function' &&
		        typeof stream.on === 'function' &&
		        stream.readable === true);
		}
		const isSeparator = (str, i) => {
		    let char = str[i];
		    return i > 0 && (char === '/' || (exports.isWin && char === '\\'));
		};
		const removeTrailingSeparator = (str) => {
		    let i = str.length - 1;
		    if (i < 2)
		        return str;
		    while (isSeparator(str, i))
		        i--;
		    return str.substr(0, i + 1);
		};
		const normalizePath = (str, stripTrailing) => {
		    if (typeof str !== 'string')
		        throw new TypeError('expected a string');
		    str = str.replace(/[\\\/]+/g, '/');
		    if (stripTrailing !== false)
		        str = removeTrailingSeparator(str);
		    return str;
		};
		const unixify = (filepath, stripTrailing = true) => {
		    if (exports.isWin) {
		        filepath = normalizePath(filepath, stripTrailing);
		        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, '');
		    }
		    return filepath;
		};
		exports.unixify = unixify;
		
	} (util$1));
	return util$1;
}

var hasRequiredFileHandle;

function requireFileHandle () {
	if (hasRequiredFileHandle) return FileHandle;
	hasRequiredFileHandle = 1;
	Object.defineProperty(FileHandle, "__esModule", { value: true });
	FileHandle.FileHandle = void 0;
	const util_1 = requireUtil$1();
	let FileHandle$1 = class FileHandle {
	    constructor(fs, fd) {
	        this.fs = fs;
	        this.fd = fd;
	    }
	    appendFile(data, options) {
	        return (0, util_1.promisify)(this.fs, 'appendFile')(this.fd, data, options);
	    }
	    chmod(mode) {
	        return (0, util_1.promisify)(this.fs, 'fchmod')(this.fd, mode);
	    }
	    chown(uid, gid) {
	        return (0, util_1.promisify)(this.fs, 'fchown')(this.fd, uid, gid);
	    }
	    close() {
	        return (0, util_1.promisify)(this.fs, 'close')(this.fd);
	    }
	    datasync() {
	        return (0, util_1.promisify)(this.fs, 'fdatasync')(this.fd);
	    }
	    createReadStream(options) {
	        return this.fs.createReadStream('', Object.assign(Object.assign({}, options), { fd: this }));
	    }
	    createWriteStream(options) {
	        return this.fs.createWriteStream('', Object.assign(Object.assign({}, options), { fd: this }));
	    }
	    readableWebStream(options) {
	        return new ReadableStream({
	            pull: async (controller) => {
	                const data = await this.readFile();
	                controller.enqueue(data);
	                controller.close();
	            },
	        });
	    }
	    read(buffer, offset, length, position) {
	        return (0, util_1.promisify)(this.fs, 'read', bytesRead => ({ bytesRead, buffer }))(this.fd, buffer, offset, length, position);
	    }
	    readv(buffers, position) {
	        return (0, util_1.promisify)(this.fs, 'readv', bytesRead => ({ bytesRead, buffers }))(this.fd, buffers, position);
	    }
	    readFile(options) {
	        return (0, util_1.promisify)(this.fs, 'readFile')(this.fd, options);
	    }
	    stat(options) {
	        return (0, util_1.promisify)(this.fs, 'fstat')(this.fd, options);
	    }
	    sync() {
	        return (0, util_1.promisify)(this.fs, 'fsync')(this.fd);
	    }
	    truncate(len) {
	        return (0, util_1.promisify)(this.fs, 'ftruncate')(this.fd, len);
	    }
	    utimes(atime, mtime) {
	        return (0, util_1.promisify)(this.fs, 'futimes')(this.fd, atime, mtime);
	    }
	    write(buffer, offset, length, position) {
	        return (0, util_1.promisify)(this.fs, 'write', bytesWritten => ({ bytesWritten, buffer }))(this.fd, buffer, offset, length, position);
	    }
	    writev(buffers, position) {
	        return (0, util_1.promisify)(this.fs, 'writev', bytesWritten => ({ bytesWritten, buffers }))(this.fd, buffers, position);
	    }
	    writeFile(data, options) {
	        return (0, util_1.promisify)(this.fs, 'writeFile')(this.fd, data, options);
	    }
	};
	FileHandle.FileHandle = FileHandle$1;
	
	return FileHandle;
}

var FsPromises = {};

var hasRequiredFsPromises;

function requireFsPromises () {
	if (hasRequiredFsPromises) return FsPromises;
	hasRequiredFsPromises = 1;
	Object.defineProperty(FsPromises, "__esModule", { value: true });
	FsPromises.FsPromises = void 0;
	const util_1 = requireUtil$1();
	const constants_1 = requireConstants$2();
	let FsPromises$1 = class FsPromises {
	    constructor(fs, FileHandle) {
	        this.fs = fs;
	        this.FileHandle = FileHandle;
	        this.constants = constants_1.constants;
	        this.cp = (0, util_1.promisify)(this.fs, 'cp');
	        this.opendir = (0, util_1.promisify)(this.fs, 'opendir');
	        this.statfs = (0, util_1.promisify)(this.fs, 'statfs');
	        this.lutimes = (0, util_1.promisify)(this.fs, 'lutimes');
	        this.access = (0, util_1.promisify)(this.fs, 'access');
	        this.chmod = (0, util_1.promisify)(this.fs, 'chmod');
	        this.chown = (0, util_1.promisify)(this.fs, 'chown');
	        this.copyFile = (0, util_1.promisify)(this.fs, 'copyFile');
	        this.lchmod = (0, util_1.promisify)(this.fs, 'lchmod');
	        this.lchown = (0, util_1.promisify)(this.fs, 'lchown');
	        this.link = (0, util_1.promisify)(this.fs, 'link');
	        this.lstat = (0, util_1.promisify)(this.fs, 'lstat');
	        this.mkdir = (0, util_1.promisify)(this.fs, 'mkdir');
	        this.mkdtemp = (0, util_1.promisify)(this.fs, 'mkdtemp');
	        this.readdir = (0, util_1.promisify)(this.fs, 'readdir');
	        this.readlink = (0, util_1.promisify)(this.fs, 'readlink');
	        this.realpath = (0, util_1.promisify)(this.fs, 'realpath');
	        this.rename = (0, util_1.promisify)(this.fs, 'rename');
	        this.rmdir = (0, util_1.promisify)(this.fs, 'rmdir');
	        this.rm = (0, util_1.promisify)(this.fs, 'rm');
	        this.stat = (0, util_1.promisify)(this.fs, 'stat');
	        this.symlink = (0, util_1.promisify)(this.fs, 'symlink');
	        this.truncate = (0, util_1.promisify)(this.fs, 'truncate');
	        this.unlink = (0, util_1.promisify)(this.fs, 'unlink');
	        this.utimes = (0, util_1.promisify)(this.fs, 'utimes');
	        this.readFile = (id, options) => {
	            return (0, util_1.promisify)(this.fs, 'readFile')(id instanceof this.FileHandle ? id.fd : id, options);
	        };
	        this.appendFile = (path, data, options) => {
	            return (0, util_1.promisify)(this.fs, 'appendFile')(path instanceof this.FileHandle ? path.fd : path, data, options);
	        };
	        this.open = (path, flags = 'r', mode) => {
	            return (0, util_1.promisify)(this.fs, 'open', fd => new this.FileHandle(this.fs, fd))(path, flags, mode);
	        };
	        this.writeFile = (id, data, options) => {
	            const dataPromise = (0, util_1.isReadableStream)(data) ? (0, util_1.streamToBuffer)(data) : Promise.resolve(data);
	            return dataPromise.then(data => (0, util_1.promisify)(this.fs, 'writeFile')(id instanceof this.FileHandle ? id.fd : id, data, options));
	        };
	        this.watch = () => {
	            throw new Error('Not implemented');
	        };
	    }
	};
	FsPromises.FsPromises = FsPromises$1;
	
	return FsPromises;
}

var print = {};

var lib = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* undefined Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

var tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
};

var tslib_es6$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	__addDisposableResource: __addDisposableResource,
	get __assign () { return __assign; },
	__asyncDelegator: __asyncDelegator,
	__asyncGenerator: __asyncGenerator,
	__asyncValues: __asyncValues,
	__await: __await,
	__awaiter: __awaiter,
	__classPrivateFieldGet: __classPrivateFieldGet,
	__classPrivateFieldIn: __classPrivateFieldIn,
	__classPrivateFieldSet: __classPrivateFieldSet,
	__createBinding: __createBinding,
	__decorate: __decorate,
	__disposeResources: __disposeResources,
	__esDecorate: __esDecorate,
	__exportStar: __exportStar,
	__extends: __extends,
	__generator: __generator,
	__importDefault: __importDefault,
	__importStar: __importStar,
	__makeTemplateObject: __makeTemplateObject,
	__metadata: __metadata,
	__param: __param,
	__propKey: __propKey,
	__read: __read,
	__rest: __rest,
	__rewriteRelativeImportExtension: __rewriteRelativeImportExtension,
	__runInitializers: __runInitializers,
	__setFunctionName: __setFunctionName,
	__spread: __spread,
	__spreadArray: __spreadArray,
	__spreadArrays: __spreadArrays,
	__values: __values,
	default: tslib_es6
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

var printTree = {};

var hasRequiredPrintTree;

function requirePrintTree () {
	if (hasRequiredPrintTree) return printTree;
	hasRequiredPrintTree = 1;
	Object.defineProperty(printTree, "__esModule", { value: true });
	printTree.printTree = void 0;
	const printTree$1 = (tab = '', children) => {
	    let str = '';
	    let last = children.length - 1;
	    for (; last >= 0; last--)
	        if (children[last])
	            break;
	    for (let i = 0; i <= last; i++) {
	        const fn = children[i];
	        if (!fn)
	            continue;
	        const isLast = i === last;
	        const child = fn(tab + (isLast ? ' ' : '│') + '  ');
	        const branch = child ? (isLast ? '└─' : '├─') : '│';
	        str += '\n' + tab + branch + (child ? ' ' + child : '');
	    }
	    return str;
	};
	printTree.printTree = printTree$1;
	return printTree;
}

var printBinary = {};

var hasRequiredPrintBinary;

function requirePrintBinary () {
	if (hasRequiredPrintBinary) return printBinary;
	hasRequiredPrintBinary = 1;
	Object.defineProperty(printBinary, "__esModule", { value: true });
	printBinary.printBinary = void 0;
	const printBinary$1 = (tab = '', children) => {
	    const left = children[0], right = children[1];
	    let str = '';
	    if (left)
	        str += '\n' + tab + '← ' + left(tab + '  ');
	    if (right)
	        str += '\n' + tab + '→ ' + right(tab + '  ');
	    return str;
	};
	printBinary.printBinary = printBinary$1;
	return printBinary;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib;
	hasRequiredLib$1 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		const tslib_1 = require$$0;
		tslib_1.__exportStar(requirePrintTree(), exports);
		tslib_1.__exportStar(requirePrintBinary(), exports); 
	} (lib));
	return lib;
}

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	Object.defineProperty(util, "__esModule", { value: true });
	util.newNotAllowedError = util.newTypeMismatchError = util.newNotFoundError = util.assertCanWrite = util.assertName = util.basename = util.ctx = void 0;
	/**
	 * Creates a new {@link NodeFsaContext}.
	 */
	const ctx = (partial = {}) => {
	    return Object.assign({ separator: '/', syncHandleAllowed: false, mode: 'read' }, partial);
	};
	util.ctx = ctx;
	const basename = (path, separator) => {
	    if (path[path.length - 1] === separator)
	        path = path.slice(0, -1);
	    const lastSlashIndex = path.lastIndexOf(separator);
	    return lastSlashIndex === -1 ? path : path.slice(lastSlashIndex + 1);
	};
	util.basename = basename;
	const nameRegex = /^(\.{1,2})$|^(.*([\/\\]).*)$/;
	const assertName = (name, method, klass) => {
	    const isInvalid = !name || nameRegex.test(name);
	    if (isInvalid)
	        throw new TypeError(`Failed to execute '${method}' on '${klass}': Name is not allowed.`);
	};
	util.assertName = assertName;
	const assertCanWrite = (mode) => {
	    if (mode !== 'readwrite')
	        throw new DOMException('The request is not allowed by the user agent or the platform in the current context.', 'NotAllowedError');
	};
	util.assertCanWrite = assertCanWrite;
	const newNotFoundError = () => new DOMException('A requested file or directory could not be found at the time an operation was processed.', 'NotFoundError');
	util.newNotFoundError = newNotFoundError;
	const newTypeMismatchError = () => new DOMException('The path supplied exists, but was not an entry of requested type.', 'TypeMismatchError');
	util.newTypeMismatchError = newTypeMismatchError;
	const newNotAllowedError = () => new DOMException('Permission not granted.', 'NotAllowedError');
	util.newNotAllowedError = newNotAllowedError;
	
	return util;
}

var hasRequiredPrint;

function requirePrint () {
	if (hasRequiredPrint) return print;
	hasRequiredPrint = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.toTreeSync = void 0;
		const tree_dump_1 = requireLib$1();
		const util_1 = requireUtil();
		const toTreeSync = (fs, opts = {}) => {
		    var _a;
		    const separator = opts.separator || '/';
		    let dir = opts.dir || separator;
		    if (dir[dir.length - 1] !== separator)
		        dir += separator;
		    const tab = opts.tab || '';
		    const depth = (_a = opts.depth) !== null && _a !== void 0 ? _a : 10;
		    let subtree = ' (...)';
		    if (depth > 0) {
		        const list = fs.readdirSync(dir, { withFileTypes: true });
		        subtree = (0, tree_dump_1.printTree)(tab, list.map(entry => tab => {
		            if (entry.isDirectory()) {
		                return (0, exports.toTreeSync)(fs, { dir: dir + entry.name, depth: depth - 1, tab });
		            }
		            else if (entry.isSymbolicLink()) {
		                return '' + entry.name + ' → ' + fs.readlinkSync(dir + entry.name);
		            }
		            else {
		                return '' + entry.name;
		            }
		        }));
		    }
		    const base = (0, util_1.basename)(dir, separator) + separator;
		    return base + subtree;
		};
		exports.toTreeSync = toTreeSync;
		
	} (print));
	return print;
}

var options = {};

var hasRequiredOptions;

function requireOptions () {
	if (hasRequiredOptions) return options;
	hasRequiredOptions = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getWriteFileOptions = exports.writeFileDefaults = exports.getRealpathOptsAndCb = exports.getRealpathOptions = exports.getStatOptsAndCb = exports.getStatOptions = exports.getAppendFileOptsAndCb = exports.getAppendFileOpts = exports.getOpendirOptsAndCb = exports.getOpendirOptions = exports.getReaddirOptsAndCb = exports.getReaddirOptions = exports.getReadFileOptions = exports.getRmOptsAndCb = exports.getRmdirOptions = exports.getDefaultOptsAndCb = exports.getDefaultOpts = exports.optsDefaults = exports.getMkdirOptions = void 0;
		exports.getOptions = getOptions;
		exports.optsGenerator = optsGenerator;
		exports.optsAndCbGenerator = optsAndCbGenerator;
		const constants_1 = requireConstants();
		const encoding_1 = requireEncoding();
		const util_1 = requireUtil$1();
		const mkdirDefaults = {
		    mode: 511 /* MODE.DIR */,
		    recursive: false,
		};
		const getMkdirOptions = (options) => {
		    if (typeof options === 'number')
		        return Object.assign({}, mkdirDefaults, { mode: options });
		    return Object.assign({}, mkdirDefaults, options);
		};
		exports.getMkdirOptions = getMkdirOptions;
		const ERRSTR_OPTS = tipeof => `Expected options to be either an object or a string, but got ${tipeof} instead`;
		function getOptions(defaults, options) {
		    let opts;
		    if (!options)
		        return defaults;
		    else {
		        const tipeof = typeof options;
		        switch (tipeof) {
		            case 'string':
		                opts = Object.assign({}, defaults, { encoding: options });
		                break;
		            case 'object':
		                opts = Object.assign({}, defaults, options);
		                break;
		            default:
		                throw TypeError(ERRSTR_OPTS(tipeof));
		        }
		    }
		    if (opts.encoding !== 'buffer')
		        (0, encoding_1.assertEncoding)(opts.encoding);
		    return opts;
		}
		function optsGenerator(defaults) {
		    return options => getOptions(defaults, options);
		}
		function optsAndCbGenerator(getOpts) {
		    return (options, callback) => typeof options === 'function' ? [getOpts(), options] : [getOpts(options), (0, util_1.validateCallback)(callback)];
		}
		exports.optsDefaults = {
		    encoding: 'utf8',
		};
		exports.getDefaultOpts = optsGenerator(exports.optsDefaults);
		exports.getDefaultOptsAndCb = optsAndCbGenerator(exports.getDefaultOpts);
		const rmdirDefaults = {
		    recursive: false,
		};
		const getRmdirOptions = (options) => {
		    return Object.assign({}, rmdirDefaults, options);
		};
		exports.getRmdirOptions = getRmdirOptions;
		const getRmOpts = optsGenerator(exports.optsDefaults);
		exports.getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
		const readFileOptsDefaults = {
		    flag: 'r',
		};
		exports.getReadFileOptions = optsGenerator(readFileOptsDefaults);
		const readdirDefaults = {
		    encoding: 'utf8',
		    recursive: false,
		    withFileTypes: false,
		};
		exports.getReaddirOptions = optsGenerator(readdirDefaults);
		exports.getReaddirOptsAndCb = optsAndCbGenerator(exports.getReaddirOptions);
		const opendirDefaults = {
		    encoding: 'utf8',
		    bufferSize: 32,
		    recursive: false,
		};
		exports.getOpendirOptions = optsGenerator(opendirDefaults);
		exports.getOpendirOptsAndCb = optsAndCbGenerator(exports.getOpendirOptions);
		const appendFileDefaults = {
		    encoding: 'utf8',
		    mode: 438 /* MODE.DEFAULT */,
		    flag: constants_1.FLAGS[constants_1.FLAGS.a],
		};
		exports.getAppendFileOpts = optsGenerator(appendFileDefaults);
		exports.getAppendFileOptsAndCb = optsAndCbGenerator(exports.getAppendFileOpts);
		const statDefaults = {
		    bigint: false,
		};
		const getStatOptions = (options = {}) => Object.assign({}, statDefaults, options);
		exports.getStatOptions = getStatOptions;
		const getStatOptsAndCb = (options, callback) => typeof options === 'function' ? [(0, exports.getStatOptions)(), options] : [(0, exports.getStatOptions)(options), (0, util_1.validateCallback)(callback)];
		exports.getStatOptsAndCb = getStatOptsAndCb;
		const realpathDefaults = exports.optsDefaults;
		exports.getRealpathOptions = optsGenerator(realpathDefaults);
		exports.getRealpathOptsAndCb = optsAndCbGenerator(exports.getRealpathOptions);
		exports.writeFileDefaults = {
		    encoding: 'utf8',
		    mode: 438 /* MODE.DEFAULT */,
		    flag: constants_1.FLAGS[constants_1.FLAGS.w],
		};
		exports.getWriteFileOptions = optsGenerator(exports.writeFileDefaults);
		
	} (options));
	return options;
}

var Dir = {};

var hasRequiredDir;

function requireDir () {
	if (hasRequiredDir) return Dir;
	hasRequiredDir = 1;
	Object.defineProperty(Dir, "__esModule", { value: true });
	Dir.Dir = void 0;
	const util_1 = requireUtil$1();
	const Dirent_1 = requireDirent();
	/**
	 * A directory stream, like `fs.Dir`.
	 */
	let Dir$1 = class Dir {
	    constructor(link, options) {
	        this.link = link;
	        this.options = options;
	        this.iteratorInfo = [];
	        this.path = link.getParentPath();
	        this.iteratorInfo.push(link.children[Symbol.iterator]());
	    }
	    wrapAsync(method, args, callback) {
	        (0, util_1.validateCallback)(callback);
	        Promise.resolve().then(() => {
	            let result;
	            try {
	                result = method.apply(this, args);
	            }
	            catch (err) {
	                callback(err);
	                return;
	            }
	            callback(null, result);
	        });
	    }
	    isFunction(x) {
	        return typeof x === 'function';
	    }
	    promisify(obj, fn) {
	        return (...args) => new Promise((resolve, reject) => {
	            if (this.isFunction(obj[fn])) {
	                obj[fn].bind(obj)(...args, (error, result) => {
	                    if (error)
	                        reject(error);
	                    resolve(result);
	                });
	            }
	            else {
	                reject('Not a function');
	            }
	        });
	    }
	    closeBase() { }
	    readBase(iteratorInfo) {
	        let done;
	        let value;
	        let name;
	        let link;
	        do {
	            do {
	                ({ done, value } = iteratorInfo[iteratorInfo.length - 1].next());
	                if (!done) {
	                    [name, link] = value;
	                }
	                else {
	                    break;
	                }
	            } while (name === '.' || name === '..');
	            if (done) {
	                iteratorInfo.pop();
	                if (iteratorInfo.length === 0) {
	                    break;
	                }
	                else {
	                    done = false;
	                }
	            }
	            else {
	                if (this.options.recursive && link.children.size) {
	                    iteratorInfo.push(link.children[Symbol.iterator]());
	                }
	                return Dirent_1.default.build(link, this.options.encoding);
	            }
	        } while (!done);
	        return null;
	    }
	    closeBaseAsync(callback) {
	        this.wrapAsync(this.closeBase, [], callback);
	    }
	    close(callback) {
	        if (typeof callback === 'function') {
	            this.closeBaseAsync(callback);
	        }
	        else {
	            return this.promisify(this, 'closeBaseAsync')();
	        }
	    }
	    closeSync() {
	        this.closeBase();
	    }
	    readBaseAsync(callback) {
	        this.wrapAsync(this.readBase, [this.iteratorInfo], callback);
	    }
	    read(callback) {
	        if (typeof callback === 'function') {
	            this.readBaseAsync(callback);
	        }
	        else {
	            return this.promisify(this, 'readBaseAsync')();
	        }
	    }
	    readSync() {
	        return this.readBase(this.iteratorInfo);
	    }
	    [Symbol.asyncIterator]() {
	        const iteratorInfo = [];
	        const _this = this;
	        iteratorInfo.push(_this.link.children[Symbol.iterator]());
	        // auxiliary object so promisify() can be used
	        const o = {
	            readBaseAsync(callback) {
	                _this.wrapAsync(_this.readBase, [iteratorInfo], callback);
	            },
	        };
	        return {
	            async next() {
	                const dirEnt = await _this.promisify(o, 'readBaseAsync')();
	                if (dirEnt !== null) {
	                    return { done: false, value: dirEnt };
	                }
	                else {
	                    return { done: true, value: undefined };
	                }
	            },
	            [Symbol.asyncIterator]() {
	                throw new Error('Not implemented');
	            },
	        };
	    }
	};
	Dir.Dir = Dir$1;
	
	return Dir;
}

var hasRequiredVolume;

function requireVolume () {
	if (hasRequiredVolume) return volume;
	hasRequiredVolume = 1;
	Object.defineProperty(volume, "__esModule", { value: true });
	volume.FSWatcher = volume.StatWatcher = volume.Volume = void 0;
	volume.filenameToSteps = filenameToSteps;
	volume.pathToSteps = pathToSteps;
	volume.dataToStr = dataToStr;
	volume.toUnixTimestamp = toUnixTimestamp;
	const pathModule = requirePathBrowserify();
	const node_1 = requireNode();
	const Stats_1 = requireStats();
	const Dirent_1 = requireDirent();
	const buffer_1 = requireBuffer$1();
	const queueMicrotask_1 = requireQueueMicrotask();
	const process_1 = requireProcess();
	const setTimeoutUnref_1 = requireSetTimeoutUnref();
	const stream_1 = requireBrowser();
	const constants_1 = requireConstants$2();
	const events_1 = requireEvents();
	const encoding_1 = requireEncoding();
	const FileHandle_1 = requireFileHandle();
	const util = require$$13;
	const FsPromises_1 = requireFsPromises();
	const print_1 = requirePrint();
	const constants_2 = requireConstants();
	const options_1 = requireOptions();
	const util_1 = requireUtil$1();
	const Dir_1 = requireDir();
	const resolveCrossPlatform = pathModule.resolve;
	const { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_EXCL, O_TRUNC, O_APPEND, O_DIRECTORY, O_SYMLINK, F_OK, COPYFILE_EXCL, COPYFILE_FICLONE_FORCE, } = constants_1.constants;
	const { sep, relative, join, dirname } = pathModule.posix ? pathModule.posix : pathModule;
	// ---------------------------------------- Constants
	const kMinPoolSpace = 128;
	// ---------------------------------------- Error messages
	const EPERM = 'EPERM';
	const ENOENT = 'ENOENT';
	const EBADF = 'EBADF';
	const EINVAL = 'EINVAL';
	const EEXIST = 'EEXIST';
	const ENOTDIR = 'ENOTDIR';
	const EMFILE = 'EMFILE';
	const EACCES = 'EACCES';
	const EISDIR = 'EISDIR';
	const ENOTEMPTY = 'ENOTEMPTY';
	const ENOSYS = 'ENOSYS';
	const ERR_FS_EISDIR = 'ERR_FS_EISDIR';
	const ERR_OUT_OF_RANGE = 'ERR_OUT_OF_RANGE';
	let resolve = (filename, base = process_1.default.cwd()) => resolveCrossPlatform(base, filename);
	if (util_1.isWin) {
	    const _resolve = resolve;
	    resolve = (filename, base) => (0, util_1.unixify)(_resolve(filename, base));
	}
	function filenameToSteps(filename, base) {
	    const fullPath = resolve(filename, base);
	    const fullPathSansSlash = fullPath.substring(1);
	    if (!fullPathSansSlash)
	        return [];
	    return fullPathSansSlash.split(sep);
	}
	function pathToSteps(path) {
	    return filenameToSteps((0, util_1.pathToFilename)(path));
	}
	function dataToStr(data, encoding = encoding_1.ENCODING_UTF8) {
	    if (buffer_1.Buffer.isBuffer(data))
	        return data.toString(encoding);
	    else if (data instanceof Uint8Array)
	        return (0, buffer_1.bufferFrom)(data).toString(encoding);
	    else
	        return String(data);
	}
	// converts Date or number to a fractional UNIX timestamp
	function toUnixTimestamp(time) {
	    // tslint:disable-next-line triple-equals
	    if (typeof time === 'string' && +time == time) {
	        return +time;
	    }
	    if (time instanceof Date) {
	        return time.getTime() / 1000;
	    }
	    if (isFinite(time)) {
	        if (time < 0) {
	            return Date.now() / 1000;
	        }
	        return time;
	    }
	    throw new Error('Cannot parse time: ' + time);
	}
	function validateUid(uid) {
	    if (typeof uid !== 'number')
	        throw TypeError(constants_2.ERRSTR.UID);
	}
	function validateGid(gid) {
	    if (typeof gid !== 'number')
	        throw TypeError(constants_2.ERRSTR.GID);
	}
	function flattenJSON(nestedJSON) {
	    const flatJSON = {};
	    function flatten(pathPrefix, node) {
	        for (const path in node) {
	            const contentOrNode = node[path];
	            const joinedPath = join(pathPrefix, path);
	            if (typeof contentOrNode === 'string' || contentOrNode instanceof buffer_1.Buffer) {
	                flatJSON[joinedPath] = contentOrNode;
	            }
	            else if (typeof contentOrNode === 'object' && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
	                // empty directories need an explicit entry and therefore get handled in `else`, non-empty ones are implicitly considered
	                flatten(joinedPath, contentOrNode);
	            }
	            else {
	                // without this branch null, empty-object or non-object entries would not be handled in the same way
	                // by both fromJSON() and fromNestedJSON()
	                flatJSON[joinedPath] = null;
	            }
	        }
	    }
	    flatten('', nestedJSON);
	    return flatJSON;
	}
	const notImplemented = () => {
	    throw new Error('Not implemented');
	};
	/**
	 * `Volume` represents a file system.
	 */
	class Volume {
	    static fromJSON(json, cwd) {
	        const vol = new Volume();
	        vol.fromJSON(json, cwd);
	        return vol;
	    }
	    static fromNestedJSON(json, cwd) {
	        const vol = new Volume();
	        vol.fromNestedJSON(json, cwd);
	        return vol;
	    }
	    get promises() {
	        if (this.promisesApi === null)
	            throw new Error('Promise is not supported in this environment.');
	        return this.promisesApi;
	    }
	    constructor(props = {}) {
	        // I-node number counter.
	        this.ino = 0;
	        // A mapping for i-node numbers to i-nodes (`Node`);
	        this.inodes = {};
	        // List of released i-node numbers, for reuse.
	        this.releasedInos = [];
	        // A mapping for file descriptors to `File`s.
	        this.fds = {};
	        // A list of reusable (opened and closed) file descriptors, that should be
	        // used first before creating a new file descriptor.
	        this.releasedFds = [];
	        // Max number of open files.
	        this.maxFiles = 10000;
	        // Current number of open files.
	        this.openFiles = 0;
	        this.promisesApi = new FsPromises_1.FsPromises(this, FileHandle_1.FileHandle);
	        this.statWatchers = {};
	        this.cpSync = notImplemented;
	        this.statfsSync = notImplemented;
	        this.cp = notImplemented;
	        this.statfs = notImplemented;
	        this.openAsBlob = notImplemented;
	        this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
	        const root = this.createLink();
	        root.setNode(this.createNode(constants_1.constants.S_IFDIR | 0o777));
	        const self = this; // tslint:disable-line no-this-assignment
	        this.StatWatcher = class extends StatWatcher {
	            constructor() {
	                super(self);
	            }
	        };
	        const _ReadStream = FsReadStream;
	        this.ReadStream = class extends _ReadStream {
	            constructor(...args) {
	                super(self, ...args);
	            }
	        };
	        const _WriteStream = FsWriteStream;
	        this.WriteStream = class extends _WriteStream {
	            constructor(...args) {
	                super(self, ...args);
	            }
	        };
	        this.FSWatcher = class extends FSWatcher {
	            constructor() {
	                super(self);
	            }
	        };
	        root.setChild('.', root);
	        root.getNode().nlink++;
	        root.setChild('..', root);
	        root.getNode().nlink++;
	        this.root = root;
	    }
	    createLink(parent, name, isDirectory = false, mode) {
	        if (!parent) {
	            return new this.props.Link(this, null, '');
	        }
	        if (!name) {
	            throw new Error('createLink: name cannot be empty');
	        }
	        // If no explicit permission is provided, use defaults based on type
	        const finalPerm = mode !== null && mode !== void 0 ? mode : (isDirectory ? 0o777 : 0o666);
	        // To prevent making a breaking change, `mode` can also just be a permission number
	        // and the file type is set based on `isDirectory`
	        const hasFileType = mode && mode & constants_1.constants.S_IFMT;
	        const modeType = hasFileType ? mode & constants_1.constants.S_IFMT : isDirectory ? constants_1.constants.S_IFDIR : constants_1.constants.S_IFREG;
	        const finalMode = (finalPerm & ~constants_1.constants.S_IFMT) | modeType;
	        return parent.createChild(name, this.createNode(finalMode));
	    }
	    deleteLink(link) {
	        const parent = link.parent;
	        if (parent) {
	            parent.deleteChild(link);
	            return true;
	        }
	        return false;
	    }
	    newInoNumber() {
	        const releasedFd = this.releasedInos.pop();
	        if (releasedFd)
	            return releasedFd;
	        else {
	            this.ino = (this.ino + 1) % 0xffffffff;
	            return this.ino;
	        }
	    }
	    newFdNumber() {
	        const releasedFd = this.releasedFds.pop();
	        return typeof releasedFd === 'number' ? releasedFd : Volume.fd--;
	    }
	    createNode(mode) {
	        const node = new this.props.Node(this.newInoNumber(), mode);
	        this.inodes[node.ino] = node;
	        return node;
	    }
	    deleteNode(node) {
	        node.del();
	        delete this.inodes[node.ino];
	        this.releasedInos.push(node.ino);
	    }
	    walk(stepsOrFilenameOrLink, resolveSymlinks = false, checkExistence = false, checkAccess = false, funcName) {
	        var _a;
	        let steps;
	        let filename;
	        if (stepsOrFilenameOrLink instanceof node_1.Link) {
	            steps = stepsOrFilenameOrLink.steps;
	            filename = sep + steps.join(sep);
	        }
	        else if (typeof stepsOrFilenameOrLink === 'string') {
	            steps = filenameToSteps(stepsOrFilenameOrLink);
	            filename = stepsOrFilenameOrLink;
	        }
	        else {
	            steps = stepsOrFilenameOrLink;
	            filename = sep + steps.join(sep);
	        }
	        let curr = this.root;
	        let i = 0;
	        while (i < steps.length) {
	            let node = curr.getNode();
	            // Check access permissions if current link is a directory
	            if (node.isDirectory()) {
	                if (checkAccess && !node.canExecute()) {
	                    throw (0, util_1.createError)(EACCES, funcName, filename);
	                }
	            }
	            else {
	                if (i < steps.length - 1)
	                    throw (0, util_1.createError)(ENOTDIR, funcName, filename);
	            }
	            curr = (_a = curr.getChild(steps[i])) !== null && _a !== void 0 ? _a : null;
	            // Check existence of current link
	            if (!curr)
	                if (checkExistence)
	                    throw (0, util_1.createError)(ENOENT, funcName, filename);
	                else
	                    return null;
	            node = curr === null || curr === void 0 ? void 0 : curr.getNode();
	            // Resolve symlink
	            if (resolveSymlinks && node.isSymlink()) {
	                const resolvedPath = pathModule.isAbsolute(node.symlink)
	                    ? node.symlink
	                    : join(pathModule.dirname(curr.getPath()), node.symlink); // Relative to symlink's parent
	                steps = filenameToSteps(resolvedPath).concat(steps.slice(i + 1));
	                curr = this.root;
	                i = 0;
	                continue;
	            }
	            i++;
	        }
	        return curr;
	    }
	    // Returns a `Link` (hard link) referenced by path "split" into steps.
	    getLink(steps) {
	        return this.walk(steps, false, false, false);
	    }
	    // Just link `getLink`, but throws a correct user error, if link to found.
	    getLinkOrThrow(filename, funcName) {
	        return this.walk(filename, false, true, true, funcName);
	    }
	    // Just like `getLink`, but also dereference/resolves symbolic links.
	    getResolvedLink(filenameOrSteps) {
	        return this.walk(filenameOrSteps, true, false, false);
	    }
	    // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
	    getResolvedLinkOrThrow(filename, funcName) {
	        return this.walk(filename, true, true, true, funcName);
	    }
	    resolveSymlinks(link) {
	        return this.getResolvedLink(link.steps.slice(1));
	    }
	    // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
	    getLinkAsDirOrThrow(filename, funcName) {
	        const link = this.getLinkOrThrow(filename, funcName);
	        if (!link.getNode().isDirectory())
	            throw (0, util_1.createError)(ENOTDIR, funcName, filename);
	        return link;
	    }
	    // Get the immediate parent directory of the link.
	    getLinkParent(steps) {
	        return this.getLink(steps.slice(0, -1));
	    }
	    getLinkParentAsDirOrThrow(filenameOrSteps, funcName) {
	        const steps = (filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps)).slice(0, -1);
	        const filename = sep + steps.join(sep);
	        const link = this.getLinkOrThrow(filename, funcName);
	        if (!link.getNode().isDirectory())
	            throw (0, util_1.createError)(ENOTDIR, funcName, filename);
	        return link;
	    }
	    getFileByFd(fd) {
	        return this.fds[String(fd)];
	    }
	    getFileByFdOrThrow(fd, funcName) {
	        if (!(0, util_1.isFd)(fd))
	            throw TypeError(constants_2.ERRSTR.FD);
	        const file = this.getFileByFd(fd);
	        if (!file)
	            throw (0, util_1.createError)(EBADF, funcName);
	        return file;
	    }
	    /**
	     * @todo This is not used anymore. Remove.
	     */
	    /*
	    private getNodeByIdOrCreate(id: TFileId, flags: number, perm: number): Node {
	      if (typeof id === 'number') {
	        const file = this.getFileByFd(id);
	        if (!file) throw Error('File nto found');
	        return file.node;
	      } else {
	        const steps = pathToSteps(id as PathLike);
	        let link = this.getLink(steps);
	        if (link) return link.getNode();
	  
	        // Try creating a node if not found.
	        if (flags & O_CREAT) {
	          const dirLink = this.getLinkParent(steps);
	          if (dirLink) {
	            const name = steps[steps.length - 1];
	            link = this.createLink(dirLink, name, false, perm);
	            return link.getNode();
	          }
	        }
	  
	        throw createError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
	      }
	    }
	    */
	    wrapAsync(method, args, callback) {
	        (0, util_1.validateCallback)(callback);
	        Promise.resolve().then(() => {
	            let result;
	            try {
	                result = method.apply(this, args);
	            }
	            catch (err) {
	                callback(err);
	                return;
	            }
	            callback(null, result);
	        });
	    }
	    _toJSON(link = this.root, json = {}, path, asBuffer) {
	        let isEmpty = true;
	        let children = link.children;
	        if (link.getNode().isFile()) {
	            children = new Map([[link.getName(), link.parent.getChild(link.getName())]]);
	            link = link.parent;
	        }
	        for (const name of children.keys()) {
	            if (name === '.' || name === '..') {
	                continue;
	            }
	            isEmpty = false;
	            const child = link.getChild(name);
	            if (!child) {
	                throw new Error('_toJSON: unexpected undefined');
	            }
	            const node = child.getNode();
	            if (node.isFile()) {
	                let filename = child.getPath();
	                if (path)
	                    filename = relative(path, filename);
	                json[filename] = asBuffer ? node.getBuffer() : node.getString();
	            }
	            else if (node.isDirectory()) {
	                this._toJSON(child, json, path, asBuffer);
	            }
	        }
	        let dirPath = link.getPath();
	        if (path)
	            dirPath = relative(path, dirPath);
	        if (dirPath && isEmpty) {
	            json[dirPath] = null;
	        }
	        return json;
	    }
	    toJSON(paths, json = {}, isRelative = false, asBuffer = false) {
	        const links = [];
	        if (paths) {
	            if (!Array.isArray(paths))
	                paths = [paths];
	            for (const path of paths) {
	                const filename = (0, util_1.pathToFilename)(path);
	                const link = this.getResolvedLink(filename);
	                if (!link)
	                    continue;
	                links.push(link);
	            }
	        }
	        else {
	            links.push(this.root);
	        }
	        if (!links.length)
	            return json;
	        for (const link of links)
	            this._toJSON(link, json, isRelative ? link.getPath() : '', asBuffer);
	        return json;
	    }
	    // TODO: `cwd` should probably not invoke `process.cwd()`.
	    fromJSON(json, cwd = process_1.default.cwd()) {
	        for (let filename in json) {
	            const data = json[filename];
	            filename = resolve(filename, cwd);
	            if (typeof data === 'string' || data instanceof buffer_1.Buffer) {
	                const dir = dirname(filename);
	                this.mkdirpBase(dir, 511 /* MODE.DIR */);
	                this.writeFileSync(filename, data);
	            }
	            else {
	                this.mkdirpBase(filename, 511 /* MODE.DIR */);
	            }
	        }
	    }
	    fromNestedJSON(json, cwd) {
	        this.fromJSON(flattenJSON(json), cwd);
	    }
	    toTree(opts = { separator: sep }) {
	        return (0, print_1.toTreeSync)(this, opts);
	    }
	    reset() {
	        this.ino = 0;
	        this.inodes = {};
	        this.releasedInos = [];
	        this.fds = {};
	        this.releasedFds = [];
	        this.openFiles = 0;
	        this.root = this.createLink();
	        this.root.setNode(this.createNode(constants_1.constants.S_IFDIR | 0o777));
	    }
	    // Legacy interface
	    mountSync(mountpoint, json) {
	        this.fromJSON(json, mountpoint);
	    }
	    openLink(link, flagsNum, resolveSymlinks = true) {
	        if (this.openFiles >= this.maxFiles) {
	            // Too many open files.
	            throw (0, util_1.createError)(EMFILE, 'open', link.getPath());
	        }
	        // Resolve symlinks.
	        //
	        // @TODO: This should be superfluous. This method is only ever called by openFile(), which does its own symlink resolution
	        // prior to calling.
	        let realLink = link;
	        if (resolveSymlinks)
	            realLink = this.getResolvedLinkOrThrow(link.getPath(), 'open');
	        const node = realLink.getNode();
	        // Check whether node is a directory
	        if (node.isDirectory()) {
	            if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
	                throw (0, util_1.createError)(EISDIR, 'open', link.getPath());
	        }
	        else {
	            if (flagsNum & O_DIRECTORY)
	                throw (0, util_1.createError)(ENOTDIR, 'open', link.getPath());
	        }
	        // Check node permissions
	        if (!(flagsNum & O_WRONLY)) {
	            if (!node.canRead()) {
	                throw (0, util_1.createError)(EACCES, 'open', link.getPath());
	            }
	        }
	        if (!(flagsNum & O_RDONLY)) {
	            if (!node.canWrite()) {
	                throw (0, util_1.createError)(EACCES, 'open', link.getPath());
	            }
	        }
	        const file = new this.props.File(link, node, flagsNum, this.newFdNumber());
	        this.fds[file.fd] = file;
	        this.openFiles++;
	        if (flagsNum & O_TRUNC)
	            file.truncate();
	        return file;
	    }
	    openFile(filename, flagsNum, modeNum, resolveSymlinks = true) {
	        const steps = filenameToSteps(filename);
	        let link;
	        try {
	            link = resolveSymlinks ? this.getResolvedLinkOrThrow(filename, 'open') : this.getLinkOrThrow(filename, 'open');
	            // Check if file already existed when trying to create it exclusively (O_CREAT and O_EXCL flags are set).
	            // This is an error, see https://pubs.opengroup.org/onlinepubs/009695399/functions/open.html:
	            // "If O_CREAT and O_EXCL are set, open() shall fail if the file exists."
	            if (link && flagsNum & O_CREAT && flagsNum & O_EXCL)
	                throw (0, util_1.createError)(EEXIST, 'open', filename);
	        }
	        catch (err) {
	            // Try creating a new file, if it does not exist and O_CREAT flag is set.
	            // Note that this will still throw if the ENOENT came from one of the
	            // intermediate directories instead of the file itself.
	            if (err.code === ENOENT && flagsNum & O_CREAT) {
	                const dirname = pathModule.dirname(filename);
	                const dirLink = this.getResolvedLinkOrThrow(dirname);
	                const dirNode = dirLink.getNode();
	                // Check that the place we create the new file is actually a directory and that we are allowed to do so:
	                if (!dirNode.isDirectory())
	                    throw (0, util_1.createError)(ENOTDIR, 'open', filename);
	                if (!dirNode.canExecute() || !dirNode.canWrite())
	                    throw (0, util_1.createError)(EACCES, 'open', filename);
	                // This is a difference to the original implementation, which would simply not create a file unless modeNum was specified.
	                // However, current Node versions will default to 0o666.
	                modeNum !== null && modeNum !== void 0 ? modeNum : (modeNum = 0o666);
	                link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
	            }
	            else
	                throw err;
	        }
	        if (link)
	            return this.openLink(link, flagsNum, resolveSymlinks);
	        throw (0, util_1.createError)(ENOENT, 'open', filename);
	    }
	    openBase(filename, flagsNum, modeNum, resolveSymlinks = true) {
	        const file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
	        if (!file)
	            throw (0, util_1.createError)(ENOENT, 'open', filename);
	        return file.fd;
	    }
	    openSync(path, flags, mode = 438 /* MODE.DEFAULT */) {
	        // Validate (1) mode; (2) path; (3) flags - in that order.
	        const modeNum = (0, util_1.modeToNumber)(mode);
	        const fileName = (0, util_1.pathToFilename)(path);
	        const flagsNum = (0, util_1.flagsToNumber)(flags);
	        return this.openBase(fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK));
	    }
	    open(path, flags, a, b) {
	        let mode = a;
	        let callback = b;
	        if (typeof a === 'function') {
	            mode = 438 /* MODE.DEFAULT */;
	            callback = a;
	        }
	        mode = mode || 438 /* MODE.DEFAULT */;
	        const modeNum = (0, util_1.modeToNumber)(mode);
	        const fileName = (0, util_1.pathToFilename)(path);
	        const flagsNum = (0, util_1.flagsToNumber)(flags);
	        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum, !(flagsNum & O_SYMLINK)], callback);
	    }
	    closeFile(file) {
	        if (!this.fds[file.fd])
	            return;
	        this.openFiles--;
	        delete this.fds[file.fd];
	        this.releasedFds.push(file.fd);
	    }
	    closeSync(fd) {
	        (0, util_1.validateFd)(fd);
	        const file = this.getFileByFdOrThrow(fd, 'close');
	        this.closeFile(file);
	    }
	    close(fd, callback) {
	        (0, util_1.validateFd)(fd);
	        const file = this.getFileByFdOrThrow(fd, 'close');
	        // NOTE: not calling closeSync because we can reset in between close and closeSync
	        this.wrapAsync(this.closeFile, [file], callback);
	    }
	    openFileOrGetById(id, flagsNum, modeNum) {
	        if (typeof id === 'number') {
	            const file = this.fds[id];
	            if (!file)
	                throw (0, util_1.createError)(ENOENT);
	            return file;
	        }
	        else {
	            return this.openFile((0, util_1.pathToFilename)(id), flagsNum, modeNum);
	        }
	    }
	    readBase(fd, buffer, offset, length, position) {
	        if (buffer.byteLength < length) {
	            throw (0, util_1.createError)(ERR_OUT_OF_RANGE, 'read', undefined, undefined, RangeError);
	        }
	        const file = this.getFileByFdOrThrow(fd);
	        if (file.node.isSymlink()) {
	            throw (0, util_1.createError)(EPERM, 'read', file.link.getPath());
	        }
	        return file.read(buffer, Number(offset), Number(length), position === -1 || typeof position !== 'number' ? undefined : position);
	    }
	    readSync(fd, buffer, offset, length, position) {
	        (0, util_1.validateFd)(fd);
	        return this.readBase(fd, buffer, offset, length, position);
	    }
	    read(fd, buffer, offset, length, position, callback) {
	        (0, util_1.validateCallback)(callback);
	        // This `if` branch is from Node.js
	        if (length === 0) {
	            return (0, queueMicrotask_1.default)(() => {
	                if (callback)
	                    callback(null, 0, buffer);
	            });
	        }
	        Promise.resolve().then(() => {
	            try {
	                const bytes = this.readBase(fd, buffer, offset, length, position);
	                callback(null, bytes, buffer);
	            }
	            catch (err) {
	                callback(err);
	            }
	        });
	    }
	    readvBase(fd, buffers, position) {
	        const file = this.getFileByFdOrThrow(fd);
	        let p = position !== null && position !== void 0 ? position : undefined;
	        if (p === -1) {
	            p = undefined;
	        }
	        let bytesRead = 0;
	        for (const buffer of buffers) {
	            const bytes = file.read(buffer, 0, buffer.byteLength, p);
	            p = undefined;
	            bytesRead += bytes;
	            if (bytes < buffer.byteLength)
	                break;
	        }
	        return bytesRead;
	    }
	    readv(fd, buffers, a, b) {
	        let position = a;
	        let callback = b;
	        if (typeof a === 'function') {
	            position = null;
	            callback = a;
	        }
	        (0, util_1.validateCallback)(callback);
	        Promise.resolve().then(() => {
	            try {
	                const bytes = this.readvBase(fd, buffers, position);
	                callback(null, bytes, buffers);
	            }
	            catch (err) {
	                callback(err);
	            }
	        });
	    }
	    readvSync(fd, buffers, position) {
	        (0, util_1.validateFd)(fd);
	        return this.readvBase(fd, buffers, position);
	    }
	    readFileBase(id, flagsNum, encoding) {
	        let result;
	        const isUserFd = typeof id === 'number';
	        const userOwnsFd = isUserFd && (0, util_1.isFd)(id);
	        let fd;
	        if (userOwnsFd)
	            fd = id;
	        else {
	            const filename = (0, util_1.pathToFilename)(id);
	            const link = this.getResolvedLinkOrThrow(filename, 'open');
	            const node = link.getNode();
	            if (node.isDirectory())
	                throw (0, util_1.createError)(EISDIR, 'open', link.getPath());
	            fd = this.openSync(id, flagsNum);
	        }
	        try {
	            result = (0, util_1.bufferToEncoding)(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
	        }
	        finally {
	            if (!userOwnsFd) {
	                this.closeSync(fd);
	            }
	        }
	        return result;
	    }
	    readFileSync(file, options) {
	        const opts = (0, options_1.getReadFileOptions)(options);
	        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
	        return this.readFileBase(file, flagsNum, opts.encoding);
	    }
	    readFile(id, a, b) {
	        const [opts, callback] = (0, options_1.optsAndCbGenerator)(options_1.getReadFileOptions)(a, b);
	        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
	        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
	    }
	    writeBase(fd, buf, offset, length, position) {
	        const file = this.getFileByFdOrThrow(fd, 'write');
	        if (file.node.isSymlink()) {
	            throw (0, util_1.createError)(EBADF, 'write', file.link.getPath());
	        }
	        return file.write(buf, offset, length, position === -1 || typeof position !== 'number' ? undefined : position);
	    }
	    writeSync(fd, a, b, c, d) {
	        const [, buf, offset, length, position] = (0, util_1.getWriteSyncArgs)(fd, a, b, c, d);
	        return this.writeBase(fd, buf, offset, length, position);
	    }
	    write(fd, a, b, c, d, e) {
	        const [, asStr, buf, offset, length, position, cb] = (0, util_1.getWriteArgs)(fd, a, b, c, d, e);
	        Promise.resolve().then(() => {
	            try {
	                const bytes = this.writeBase(fd, buf, offset, length, position);
	                if (!asStr) {
	                    cb(null, bytes, buf);
	                }
	                else {
	                    cb(null, bytes, a);
	                }
	            }
	            catch (err) {
	                cb(err);
	            }
	        });
	    }
	    writevBase(fd, buffers, position) {
	        const file = this.getFileByFdOrThrow(fd);
	        let p = position !== null && position !== void 0 ? position : undefined;
	        if (p === -1) {
	            p = undefined;
	        }
	        let bytesWritten = 0;
	        for (const buffer of buffers) {
	            const nodeBuf = buffer_1.Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
	            const bytes = file.write(nodeBuf, 0, nodeBuf.byteLength, p);
	            p = undefined;
	            bytesWritten += bytes;
	            if (bytes < nodeBuf.byteLength)
	                break;
	        }
	        return bytesWritten;
	    }
	    writev(fd, buffers, a, b) {
	        let position = a;
	        let callback = b;
	        if (typeof a === 'function') {
	            position = null;
	            callback = a;
	        }
	        (0, util_1.validateCallback)(callback);
	        Promise.resolve().then(() => {
	            try {
	                const bytes = this.writevBase(fd, buffers, position);
	                callback(null, bytes, buffers);
	            }
	            catch (err) {
	                callback(err);
	            }
	        });
	    }
	    writevSync(fd, buffers, position) {
	        (0, util_1.validateFd)(fd);
	        return this.writevBase(fd, buffers, position);
	    }
	    writeFileBase(id, buf, flagsNum, modeNum) {
	        // console.log('writeFileBase', id, buf, flagsNum, modeNum);
	        // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
	        // node.setBuffer(buf);
	        const isUserFd = typeof id === 'number';
	        let fd;
	        if (isUserFd)
	            fd = id;
	        else {
	            fd = this.openBase((0, util_1.pathToFilename)(id), flagsNum, modeNum);
	            // fd = this.openSync(id as PathLike, flagsNum, modeNum);
	        }
	        let offset = 0;
	        let length = buf.length;
	        let position = flagsNum & O_APPEND ? undefined : 0;
	        try {
	            while (length > 0) {
	                const written = this.writeSync(fd, buf, offset, length, position);
	                offset += written;
	                length -= written;
	                if (position !== undefined)
	                    position += written;
	            }
	        }
	        finally {
	            if (!isUserFd)
	                this.closeSync(fd);
	        }
	    }
	    writeFileSync(id, data, options) {
	        const opts = (0, options_1.getWriteFileOptions)(options);
	        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
	        const modeNum = (0, util_1.modeToNumber)(opts.mode);
	        const buf = (0, util_1.dataToBuffer)(data, opts.encoding);
	        this.writeFileBase(id, buf, flagsNum, modeNum);
	    }
	    writeFile(id, data, a, b) {
	        let options = a;
	        let callback = b;
	        if (typeof a === 'function') {
	            options = options_1.writeFileDefaults;
	            callback = a;
	        }
	        const cb = (0, util_1.validateCallback)(callback);
	        const opts = (0, options_1.getWriteFileOptions)(options);
	        const flagsNum = (0, util_1.flagsToNumber)(opts.flag);
	        const modeNum = (0, util_1.modeToNumber)(opts.mode);
	        const buf = (0, util_1.dataToBuffer)(data, opts.encoding);
	        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
	    }
	    linkBase(filename1, filename2) {
	        let link1;
	        try {
	            link1 = this.getLinkOrThrow(filename1, 'link');
	        }
	        catch (err) {
	            // Augment error with filename2
	            if (err.code)
	                err = (0, util_1.createError)(err.code, 'link', filename1, filename2);
	            throw err;
	        }
	        const dirname2 = pathModule.dirname(filename2);
	        let dir2;
	        try {
	            dir2 = this.getLinkOrThrow(dirname2, 'link');
	        }
	        catch (err) {
	            // Augment error with filename1
	            if (err.code)
	                err = (0, util_1.createError)(err.code, 'link', filename1, filename2);
	            throw err;
	        }
	        const name = pathModule.basename(filename2);
	        // Check if new file already exists.
	        if (dir2.getChild(name))
	            throw (0, util_1.createError)(EEXIST, 'link', filename1, filename2);
	        const node = link1.getNode();
	        node.nlink++;
	        dir2.createChild(name, node);
	    }
	    copyFileBase(src, dest, flags) {
	        const buf = this.readFileSync(src);
	        if (flags & COPYFILE_EXCL) {
	            if (this.existsSync(dest)) {
	                throw (0, util_1.createError)(EEXIST, 'copyFile', src, dest);
	            }
	        }
	        if (flags & COPYFILE_FICLONE_FORCE) {
	            throw (0, util_1.createError)(ENOSYS, 'copyFile', src, dest);
	        }
	        this.writeFileBase(dest, buf, constants_2.FLAGS.w, 438 /* MODE.DEFAULT */);
	    }
	    copyFileSync(src, dest, flags) {
	        const srcFilename = (0, util_1.pathToFilename)(src);
	        const destFilename = (0, util_1.pathToFilename)(dest);
	        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
	    }
	    copyFile(src, dest, a, b) {
	        const srcFilename = (0, util_1.pathToFilename)(src);
	        const destFilename = (0, util_1.pathToFilename)(dest);
	        let flags;
	        let callback;
	        if (typeof a === 'function') {
	            flags = 0;
	            callback = a;
	        }
	        else {
	            flags = a;
	            callback = b;
	        }
	        (0, util_1.validateCallback)(callback);
	        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
	    }
	    linkSync(existingPath, newPath) {
	        const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
	        const newPathFilename = (0, util_1.pathToFilename)(newPath);
	        this.linkBase(existingPathFilename, newPathFilename);
	    }
	    link(existingPath, newPath, callback) {
	        const existingPathFilename = (0, util_1.pathToFilename)(existingPath);
	        const newPathFilename = (0, util_1.pathToFilename)(newPath);
	        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
	    }
	    unlinkBase(filename) {
	        const link = this.getLinkOrThrow(filename, 'unlink');
	        // TODO: Check if it is file, dir, other...
	        if (link.length)
	            throw Error('Dir not empty...');
	        this.deleteLink(link);
	        const node = link.getNode();
	        node.nlink--;
	        // When all hard links to i-node are deleted, remove the i-node, too.
	        if (node.nlink <= 0) {
	            this.deleteNode(node);
	        }
	    }
	    unlinkSync(path) {
	        const filename = (0, util_1.pathToFilename)(path);
	        this.unlinkBase(filename);
	    }
	    unlink(path, callback) {
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.unlinkBase, [filename], callback);
	    }
	    symlinkBase(targetFilename, pathFilename) {
	        const pathSteps = filenameToSteps(pathFilename);
	        // Check if directory exists, where we about to create a symlink.
	        let dirLink;
	        try {
	            dirLink = this.getLinkParentAsDirOrThrow(pathSteps);
	        }
	        catch (err) {
	            // Catch error to populate with the correct fields - getLinkParentAsDirOrThrow won't be aware of the second path
	            if (err.code)
	                err = (0, util_1.createError)(err.code, 'symlink', targetFilename, pathFilename);
	            throw err;
	        }
	        const name = pathSteps[pathSteps.length - 1];
	        // Check if new file already exists.
	        if (dirLink.getChild(name))
	            throw (0, util_1.createError)(EEXIST, 'symlink', targetFilename, pathFilename);
	        // Check permissions on the path where we are creating the symlink.
	        // Note we're not checking permissions on the target path: It is not an error to create a symlink to a
	        // non-existent or inaccessible target
	        const node = dirLink.getNode();
	        if (!node.canExecute() || !node.canWrite())
	            throw (0, util_1.createError)(EACCES, 'symlink', targetFilename, pathFilename);
	        // Create symlink.
	        const symlink = dirLink.createChild(name);
	        symlink.getNode().makeSymlink(targetFilename);
	        return symlink;
	    }
	    // `type` argument works only on Windows.
	    symlinkSync(target, path, type) {
	        const targetFilename = (0, util_1.pathToFilename)(target);
	        const pathFilename = (0, util_1.pathToFilename)(path);
	        this.symlinkBase(targetFilename, pathFilename);
	    }
	    symlink(target, path, a, b) {
	        const callback = (0, util_1.validateCallback)(typeof a === 'function' ? a : b);
	        const targetFilename = (0, util_1.pathToFilename)(target);
	        const pathFilename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
	    }
	    realpathBase(filename, encoding) {
	        const realLink = this.getResolvedLinkOrThrow(filename, 'realpath');
	        return (0, encoding_1.strToEncoding)(realLink.getPath() || '/', encoding);
	    }
	    realpathSync(path, options) {
	        return this.realpathBase((0, util_1.pathToFilename)(path), (0, options_1.getRealpathOptions)(options).encoding);
	    }
	    realpath(path, a, b) {
	        const [opts, callback] = (0, options_1.getRealpathOptsAndCb)(a, b);
	        const pathFilename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
	    }
	    lstatBase(filename, bigint = false, throwIfNoEntry = false) {
	        let link;
	        try {
	            link = this.getLinkOrThrow(filename, 'lstat');
	        }
	        catch (err) {
	            if (err.code === ENOENT && !throwIfNoEntry)
	                return undefined;
	            else
	                throw err;
	        }
	        return Stats_1.default.build(link.getNode(), bigint);
	    }
	    lstatSync(path, options) {
	        const { throwIfNoEntry = true, bigint = false } = (0, options_1.getStatOptions)(options);
	        return this.lstatBase((0, util_1.pathToFilename)(path), bigint, throwIfNoEntry);
	    }
	    lstat(path, a, b) {
	        const [{ throwIfNoEntry = true, bigint = false }, callback] = (0, options_1.getStatOptsAndCb)(a, b);
	        this.wrapAsync(this.lstatBase, [(0, util_1.pathToFilename)(path), bigint, throwIfNoEntry], callback);
	    }
	    statBase(filename, bigint = false, throwIfNoEntry = true) {
	        let link;
	        try {
	            link = this.getResolvedLinkOrThrow(filename, 'stat');
	        }
	        catch (err) {
	            if (err.code === ENOENT && !throwIfNoEntry)
	                return undefined;
	            else
	                throw err;
	        }
	        return Stats_1.default.build(link.getNode(), bigint);
	    }
	    statSync(path, options) {
	        const { bigint = true, throwIfNoEntry = true } = (0, options_1.getStatOptions)(options);
	        return this.statBase((0, util_1.pathToFilename)(path), bigint, throwIfNoEntry);
	    }
	    stat(path, a, b) {
	        const [{ bigint = false, throwIfNoEntry = true }, callback] = (0, options_1.getStatOptsAndCb)(a, b);
	        this.wrapAsync(this.statBase, [(0, util_1.pathToFilename)(path), bigint, throwIfNoEntry], callback);
	    }
	    fstatBase(fd, bigint = false) {
	        const file = this.getFileByFd(fd);
	        if (!file)
	            throw (0, util_1.createError)(EBADF, 'fstat');
	        return Stats_1.default.build(file.node, bigint);
	    }
	    fstatSync(fd, options) {
	        return this.fstatBase(fd, (0, options_1.getStatOptions)(options).bigint);
	    }
	    fstat(fd, a, b) {
	        const [opts, callback] = (0, options_1.getStatOptsAndCb)(a, b);
	        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
	    }
	    renameBase(oldPathFilename, newPathFilename) {
	        let link;
	        try {
	            link = this.getResolvedLinkOrThrow(oldPathFilename);
	        }
	        catch (err) {
	            // Augment err with newPathFilename
	            if (err.code)
	                err = (0, util_1.createError)(err.code, 'rename', oldPathFilename, newPathFilename);
	            throw err;
	        }
	        // TODO: Check if it is directory, if non-empty, we cannot move it, right?
	        // Check directory exists for the new location.
	        let newPathDirLink;
	        try {
	            newPathDirLink = this.getLinkParentAsDirOrThrow(newPathFilename);
	        }
	        catch (err) {
	            // Augment error with oldPathFilename
	            if (err.code)
	                err = (0, util_1.createError)(err.code, 'rename', oldPathFilename, newPathFilename);
	            throw err;
	        }
	        // TODO: Also treat cases with directories and symbolic links.
	        // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
	        // Remove hard link from old folder.
	        const oldLinkParent = link.parent;
	        // Check we have access and write permissions in both places
	        const oldParentNode = oldLinkParent.getNode();
	        const newPathDirNode = newPathDirLink.getNode();
	        if (!oldParentNode.canExecute() ||
	            !oldParentNode.canWrite() ||
	            !newPathDirNode.canExecute() ||
	            !newPathDirNode.canWrite()) {
	            throw (0, util_1.createError)(EACCES, 'rename', oldPathFilename, newPathFilename);
	        }
	        oldLinkParent.deleteChild(link);
	        // Rename should overwrite the new path, if that exists.
	        const name = pathModule.basename(newPathFilename);
	        link.name = name;
	        link.steps = [...newPathDirLink.steps, name];
	        newPathDirLink.setChild(link.getName(), link);
	    }
	    renameSync(oldPath, newPath) {
	        const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
	        const newPathFilename = (0, util_1.pathToFilename)(newPath);
	        this.renameBase(oldPathFilename, newPathFilename);
	    }
	    rename(oldPath, newPath, callback) {
	        const oldPathFilename = (0, util_1.pathToFilename)(oldPath);
	        const newPathFilename = (0, util_1.pathToFilename)(newPath);
	        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
	    }
	    existsBase(filename) {
	        return !!this.statBase(filename);
	    }
	    existsSync(path) {
	        try {
	            return this.existsBase((0, util_1.pathToFilename)(path));
	        }
	        catch (err) {
	            return false;
	        }
	    }
	    exists(path, callback) {
	        const filename = (0, util_1.pathToFilename)(path);
	        if (typeof callback !== 'function')
	            throw Error(constants_2.ERRSTR.CB);
	        Promise.resolve().then(() => {
	            try {
	                callback(this.existsBase(filename));
	            }
	            catch (err) {
	                callback(false);
	            }
	        });
	    }
	    accessBase(filename, mode) {
	        this.getLinkOrThrow(filename, 'access');
	    }
	    accessSync(path, mode = F_OK) {
	        const filename = (0, util_1.pathToFilename)(path);
	        mode = mode | 0;
	        this.accessBase(filename, mode);
	    }
	    access(path, a, b) {
	        let mode = F_OK;
	        let callback;
	        if (typeof a !== 'function') {
	            mode = a | 0; // cast to number
	            callback = (0, util_1.validateCallback)(b);
	        }
	        else {
	            callback = a;
	        }
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.accessBase, [filename, mode], callback);
	    }
	    appendFileSync(id, data, options) {
	        const opts = (0, options_1.getAppendFileOpts)(options);
	        // force append behavior when using a supplied file descriptor
	        if (!opts.flag || (0, util_1.isFd)(id))
	            opts.flag = 'a';
	        this.writeFileSync(id, data, opts);
	    }
	    appendFile(id, data, a, b) {
	        const [opts, callback] = (0, options_1.getAppendFileOptsAndCb)(a, b);
	        // force append behavior when using a supplied file descriptor
	        if (!opts.flag || (0, util_1.isFd)(id))
	            opts.flag = 'a';
	        this.writeFile(id, data, opts, callback);
	    }
	    readdirBase(filename, options) {
	        filenameToSteps(filename);
	        const link = this.getResolvedLinkOrThrow(filename, 'scandir');
	        const node = link.getNode();
	        if (!node.isDirectory())
	            throw (0, util_1.createError)(ENOTDIR, 'scandir', filename);
	        // Check we have permissions
	        if (!node.canRead())
	            throw (0, util_1.createError)(EACCES, 'scandir', filename);
	        const list = []; // output list
	        for (const name of link.children.keys()) {
	            const child = link.getChild(name);
	            if (!child || name === '.' || name === '..')
	                continue;
	            list.push(Dirent_1.default.build(child, options.encoding));
	            // recursion
	            if (options.recursive && child.children.size) {
	                const recurseOptions = Object.assign(Object.assign({}, options), { recursive: true, withFileTypes: true });
	                const childList = this.readdirBase(child.getPath(), recurseOptions);
	                list.push(...childList);
	            }
	        }
	        if (!util_1.isWin && options.encoding !== 'buffer')
	            list.sort((a, b) => {
	                if (a.name < b.name)
	                    return -1;
	                if (a.name > b.name)
	                    return 1;
	                return 0;
	            });
	        if (options.withFileTypes)
	            return list;
	        let filename2 = filename;
	        if (util_1.isWin) {
	            filename2 = filename2.replace(/\\/g, '/');
	        }
	        return list.map(dirent => {
	            if (options.recursive) {
	                let fullPath = pathModule.join(dirent.parentPath, dirent.name.toString());
	                if (util_1.isWin) {
	                    fullPath = fullPath.replace(/\\/g, '/');
	                }
	                return fullPath.replace(filename2 + pathModule.posix.sep, '');
	            }
	            return dirent.name;
	        });
	    }
	    readdirSync(path, options) {
	        const opts = (0, options_1.getReaddirOptions)(options);
	        const filename = (0, util_1.pathToFilename)(path);
	        return this.readdirBase(filename, opts);
	    }
	    readdir(path, a, b) {
	        const [options, callback] = (0, options_1.getReaddirOptsAndCb)(a, b);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.readdirBase, [filename, options], callback);
	    }
	    readlinkBase(filename, encoding) {
	        const link = this.getLinkOrThrow(filename, 'readlink');
	        const node = link.getNode();
	        if (!node.isSymlink())
	            throw (0, util_1.createError)(EINVAL, 'readlink', filename);
	        return (0, encoding_1.strToEncoding)(node.symlink, encoding);
	    }
	    readlinkSync(path, options) {
	        const opts = (0, options_1.getDefaultOpts)(options);
	        const filename = (0, util_1.pathToFilename)(path);
	        return this.readlinkBase(filename, opts.encoding);
	    }
	    readlink(path, a, b) {
	        const [opts, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
	    }
	    fsyncBase(fd) {
	        this.getFileByFdOrThrow(fd, 'fsync');
	    }
	    fsyncSync(fd) {
	        this.fsyncBase(fd);
	    }
	    fsync(fd, callback) {
	        this.wrapAsync(this.fsyncBase, [fd], callback);
	    }
	    fdatasyncBase(fd) {
	        this.getFileByFdOrThrow(fd, 'fdatasync');
	    }
	    fdatasyncSync(fd) {
	        this.fdatasyncBase(fd);
	    }
	    fdatasync(fd, callback) {
	        this.wrapAsync(this.fdatasyncBase, [fd], callback);
	    }
	    ftruncateBase(fd, len) {
	        const file = this.getFileByFdOrThrow(fd, 'ftruncate');
	        file.truncate(len);
	    }
	    ftruncateSync(fd, len) {
	        this.ftruncateBase(fd, len);
	    }
	    ftruncate(fd, a, b) {
	        const len = typeof a === 'number' ? a : 0;
	        const callback = (0, util_1.validateCallback)(typeof a === 'number' ? b : a);
	        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
	    }
	    truncateBase(path, len) {
	        const fd = this.openSync(path, 'r+');
	        try {
	            this.ftruncateSync(fd, len);
	        }
	        finally {
	            this.closeSync(fd);
	        }
	    }
	    /**
	     * `id` should be a file descriptor or a path. `id` as file descriptor will
	     * not be supported soon.
	     */
	    truncateSync(id, len) {
	        if ((0, util_1.isFd)(id))
	            return this.ftruncateSync(id, len);
	        this.truncateBase(id, len);
	    }
	    truncate(id, a, b) {
	        const len = typeof a === 'number' ? a : 0;
	        const callback = (0, util_1.validateCallback)(typeof a === 'number' ? b : a);
	        if ((0, util_1.isFd)(id))
	            return this.ftruncate(id, len, callback);
	        this.wrapAsync(this.truncateBase, [id, len], callback);
	    }
	    futimesBase(fd, atime, mtime) {
	        const file = this.getFileByFdOrThrow(fd, 'futimes');
	        const node = file.node;
	        node.atime = new Date(atime * 1000);
	        node.mtime = new Date(mtime * 1000);
	    }
	    futimesSync(fd, atime, mtime) {
	        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
	    }
	    futimes(fd, atime, mtime, callback) {
	        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
	    }
	    utimesBase(filename, atime, mtime, followSymlinks = true) {
	        const link = followSymlinks
	            ? this.getResolvedLinkOrThrow(filename, 'utimes')
	            : this.getLinkOrThrow(filename, 'lutimes');
	        const node = link.getNode();
	        node.atime = new Date(atime * 1000);
	        node.mtime = new Date(mtime * 1000);
	    }
	    utimesSync(path, atime, mtime) {
	        this.utimesBase((0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), true);
	    }
	    utimes(path, atime, mtime, callback) {
	        this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), true], callback);
	    }
	    lutimesSync(path, atime, mtime) {
	        this.utimesBase((0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), false);
	    }
	    lutimes(path, atime, mtime, callback) {
	        this.wrapAsync(this.utimesBase, [(0, util_1.pathToFilename)(path), toUnixTimestamp(atime), toUnixTimestamp(mtime), false], callback);
	    }
	    mkdirBase(filename, modeNum) {
	        const steps = filenameToSteps(filename);
	        // This will throw if user tries to create root dir `fs.mkdirSync('/')`.
	        if (!steps.length) {
	            throw (0, util_1.createError)(EEXIST, 'mkdir', filename);
	        }
	        const dir = this.getLinkParentAsDirOrThrow(filename, 'mkdir');
	        // Check path already exists.
	        const name = steps[steps.length - 1];
	        if (dir.getChild(name))
	            throw (0, util_1.createError)(EEXIST, 'mkdir', filename);
	        const node = dir.getNode();
	        if (!node.canWrite() || !node.canExecute())
	            throw (0, util_1.createError)(EACCES, 'mkdir', filename);
	        dir.createChild(name, this.createNode(constants_1.constants.S_IFDIR | modeNum));
	    }
	    /**
	     * Creates directory tree recursively.
	     */
	    mkdirpBase(filename, modeNum) {
	        let created = false;
	        const steps = filenameToSteps(filename);
	        let curr = null;
	        let i = steps.length;
	        // Find the longest subpath of filename that still exists:
	        for (i = steps.length; i >= 0; i--) {
	            curr = this.getResolvedLink(steps.slice(0, i));
	            if (curr)
	                break;
	        }
	        if (!curr) {
	            curr = this.root;
	            i = 0;
	        }
	        // curr is now the last directory that still exists.
	        // (If none of them existed, curr is the root.)
	        // Check access the lazy way:
	        curr = this.getResolvedLinkOrThrow(sep + steps.slice(0, i).join(sep), 'mkdir');
	        // Start creating directories:
	        for (i; i < steps.length; i++) {
	            const node = curr.getNode();
	            if (node.isDirectory()) {
	                // Check we have permissions
	                if (!node.canExecute() || !node.canWrite())
	                    throw (0, util_1.createError)(EACCES, 'mkdir', filename);
	            }
	            else {
	                throw (0, util_1.createError)(ENOTDIR, 'mkdir', filename);
	            }
	            created = true;
	            curr = curr.createChild(steps[i], this.createNode(constants_1.constants.S_IFDIR | modeNum));
	        }
	        return created ? filename : undefined;
	    }
	    mkdirSync(path, options) {
	        const opts = (0, options_1.getMkdirOptions)(options);
	        const modeNum = (0, util_1.modeToNumber)(opts.mode, 0o777);
	        const filename = (0, util_1.pathToFilename)(path);
	        if (opts.recursive)
	            return this.mkdirpBase(filename, modeNum);
	        this.mkdirBase(filename, modeNum);
	    }
	    mkdir(path, a, b) {
	        const opts = (0, options_1.getMkdirOptions)(a);
	        const callback = (0, util_1.validateCallback)(typeof a === 'function' ? a : b);
	        const modeNum = (0, util_1.modeToNumber)(opts.mode, 0o777);
	        const filename = (0, util_1.pathToFilename)(path);
	        if (opts.recursive)
	            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
	        else
	            this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
	    }
	    mkdtempBase(prefix, encoding, retry = 5) {
	        const filename = prefix + (0, util_1.genRndStr6)();
	        try {
	            this.mkdirBase(filename, 511 /* MODE.DIR */);
	            return (0, encoding_1.strToEncoding)(filename, encoding);
	        }
	        catch (err) {
	            if (err.code === EEXIST) {
	                if (retry > 1)
	                    return this.mkdtempBase(prefix, encoding, retry - 1);
	                else
	                    throw Error('Could not create temp dir.');
	            }
	            else
	                throw err;
	        }
	    }
	    mkdtempSync(prefix, options) {
	        const { encoding } = (0, options_1.getDefaultOpts)(options);
	        if (!prefix || typeof prefix !== 'string')
	            throw new TypeError('filename prefix is required');
	        (0, util_1.nullCheck)(prefix);
	        return this.mkdtempBase(prefix, encoding);
	    }
	    mkdtemp(prefix, a, b) {
	        const [{ encoding }, callback] = (0, options_1.getDefaultOptsAndCb)(a, b);
	        if (!prefix || typeof prefix !== 'string')
	            throw new TypeError('filename prefix is required');
	        if (!(0, util_1.nullCheck)(prefix))
	            return;
	        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
	    }
	    rmdirBase(filename, options) {
	        const opts = (0, options_1.getRmdirOptions)(options);
	        const link = this.getLinkAsDirOrThrow(filename, 'rmdir');
	        // Check directory is empty.
	        if (link.length && !opts.recursive)
	            throw (0, util_1.createError)(ENOTEMPTY, 'rmdir', filename);
	        this.deleteLink(link);
	    }
	    rmdirSync(path, options) {
	        this.rmdirBase((0, util_1.pathToFilename)(path), options);
	    }
	    rmdir(path, a, b) {
	        const opts = (0, options_1.getRmdirOptions)(a);
	        const callback = (0, util_1.validateCallback)(typeof a === 'function' ? a : b);
	        this.wrapAsync(this.rmdirBase, [(0, util_1.pathToFilename)(path), opts], callback);
	    }
	    rmBase(filename, options = {}) {
	        // "stat" is used to match Node's native error message.
	        let link;
	        try {
	            link = this.getResolvedLinkOrThrow(filename, 'stat');
	        }
	        catch (err) {
	            // Silently ignore missing paths if force option is true
	            if (err.code === ENOENT && options.force)
	                return;
	            else
	                throw err;
	        }
	        if (link.getNode().isDirectory() && !options.recursive)
	            throw (0, util_1.createError)(ERR_FS_EISDIR, 'rm', filename);
	        // Check permissions
	        if (!link.parent.getNode().canWrite())
	            throw (0, util_1.createError)(EACCES, 'rm', filename);
	        this.deleteLink(link);
	    }
	    rmSync(path, options) {
	        this.rmBase((0, util_1.pathToFilename)(path), options);
	    }
	    rm(path, a, b) {
	        const [opts, callback] = (0, options_1.getRmOptsAndCb)(a, b);
	        this.wrapAsync(this.rmBase, [(0, util_1.pathToFilename)(path), opts], callback);
	    }
	    fchmodBase(fd, modeNum) {
	        const file = this.getFileByFdOrThrow(fd, 'fchmod');
	        file.chmod(modeNum);
	    }
	    fchmodSync(fd, mode) {
	        this.fchmodBase(fd, (0, util_1.modeToNumber)(mode));
	    }
	    fchmod(fd, mode, callback) {
	        this.wrapAsync(this.fchmodBase, [fd, (0, util_1.modeToNumber)(mode)], callback);
	    }
	    chmodBase(filename, modeNum, followSymlinks = true) {
	        const link = followSymlinks
	            ? this.getResolvedLinkOrThrow(filename, 'chmod')
	            : this.getLinkOrThrow(filename, 'chmod');
	        const node = link.getNode();
	        node.chmod(modeNum);
	    }
	    chmodSync(path, mode) {
	        const modeNum = (0, util_1.modeToNumber)(mode);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.chmodBase(filename, modeNum, true);
	    }
	    chmod(path, mode, callback) {
	        const modeNum = (0, util_1.modeToNumber)(mode);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
	    }
	    lchmodBase(filename, modeNum) {
	        this.chmodBase(filename, modeNum, false);
	    }
	    lchmodSync(path, mode) {
	        const modeNum = (0, util_1.modeToNumber)(mode);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.lchmodBase(filename, modeNum);
	    }
	    lchmod(path, mode, callback) {
	        const modeNum = (0, util_1.modeToNumber)(mode);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
	    }
	    fchownBase(fd, uid, gid) {
	        this.getFileByFdOrThrow(fd, 'fchown').chown(uid, gid);
	    }
	    fchownSync(fd, uid, gid) {
	        validateUid(uid);
	        validateGid(gid);
	        this.fchownBase(fd, uid, gid);
	    }
	    fchown(fd, uid, gid, callback) {
	        validateUid(uid);
	        validateGid(gid);
	        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
	    }
	    chownBase(filename, uid, gid) {
	        const link = this.getResolvedLinkOrThrow(filename, 'chown');
	        const node = link.getNode();
	        node.chown(uid, gid);
	        // if(node.isFile() || node.isSymlink()) {
	        //
	        // } else if(node.isDirectory()) {
	        //
	        // } else {
	        // TODO: What do we do here?
	        // }
	    }
	    chownSync(path, uid, gid) {
	        validateUid(uid);
	        validateGid(gid);
	        this.chownBase((0, util_1.pathToFilename)(path), uid, gid);
	    }
	    chown(path, uid, gid, callback) {
	        validateUid(uid);
	        validateGid(gid);
	        this.wrapAsync(this.chownBase, [(0, util_1.pathToFilename)(path), uid, gid], callback);
	    }
	    lchownBase(filename, uid, gid) {
	        this.getLinkOrThrow(filename, 'lchown').getNode().chown(uid, gid);
	    }
	    lchownSync(path, uid, gid) {
	        validateUid(uid);
	        validateGid(gid);
	        this.lchownBase((0, util_1.pathToFilename)(path), uid, gid);
	    }
	    lchown(path, uid, gid, callback) {
	        validateUid(uid);
	        validateGid(gid);
	        this.wrapAsync(this.lchownBase, [(0, util_1.pathToFilename)(path), uid, gid], callback);
	    }
	    watchFile(path, a, b) {
	        const filename = (0, util_1.pathToFilename)(path);
	        let options = a;
	        let listener = b;
	        if (typeof options === 'function') {
	            listener = a;
	            options = null;
	        }
	        if (typeof listener !== 'function') {
	            throw Error('"watchFile()" requires a listener function');
	        }
	        let interval = 5007;
	        let persistent = true;
	        if (options && typeof options === 'object') {
	            if (typeof options.interval === 'number')
	                interval = options.interval;
	            if (typeof options.persistent === 'boolean')
	                persistent = options.persistent;
	        }
	        let watcher = this.statWatchers[filename];
	        if (!watcher) {
	            watcher = new this.StatWatcher();
	            watcher.start(filename, persistent, interval);
	            this.statWatchers[filename] = watcher;
	        }
	        watcher.addListener('change', listener);
	        return watcher;
	    }
	    unwatchFile(path, listener) {
	        const filename = (0, util_1.pathToFilename)(path);
	        const watcher = this.statWatchers[filename];
	        if (!watcher)
	            return;
	        if (typeof listener === 'function') {
	            watcher.removeListener('change', listener);
	        }
	        else {
	            watcher.removeAllListeners('change');
	        }
	        if (watcher.listenerCount('change') === 0) {
	            watcher.stop();
	            delete this.statWatchers[filename];
	        }
	    }
	    createReadStream(path, options) {
	        return new this.ReadStream(path, options);
	    }
	    createWriteStream(path, options) {
	        return new this.WriteStream(path, options);
	    }
	    // watch(path: PathLike): FSWatcher;
	    // watch(path: PathLike, options?: IWatchOptions | string): FSWatcher;
	    watch(path, options, listener) {
	        const filename = (0, util_1.pathToFilename)(path);
	        let givenOptions = options;
	        if (typeof options === 'function') {
	            listener = options;
	            givenOptions = null;
	        }
	        // tslint:disable-next-line prefer-const
	        let { persistent, recursive, encoding } = (0, options_1.getDefaultOpts)(givenOptions);
	        if (persistent === undefined)
	            persistent = true;
	        if (recursive === undefined)
	            recursive = false;
	        const watcher = new this.FSWatcher();
	        watcher.start(filename, persistent, recursive, encoding);
	        if (listener) {
	            watcher.addListener('change', listener);
	        }
	        return watcher;
	    }
	    opendirBase(filename, options) {
	        const link = this.getResolvedLinkOrThrow(filename, 'scandir');
	        const node = link.getNode();
	        if (!node.isDirectory())
	            throw (0, util_1.createError)(ENOTDIR, 'scandir', filename);
	        return new Dir_1.Dir(link, options);
	    }
	    opendirSync(path, options) {
	        const opts = (0, options_1.getOpendirOptions)(options);
	        const filename = (0, util_1.pathToFilename)(path);
	        return this.opendirBase(filename, opts);
	    }
	    opendir(path, a, b) {
	        const [options, callback] = (0, options_1.getOpendirOptsAndCb)(a, b);
	        const filename = (0, util_1.pathToFilename)(path);
	        this.wrapAsync(this.opendirBase, [filename, options], callback);
	    }
	}
	volume.Volume = Volume;
	/**
	 * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
	 * up, so here, in order not to conflict with them, we choose some big number and descrease
	 * the file descriptor of every new opened file.
	 * @type {number}
	 * @todo This should not be static, right?
	 */
	Volume.fd = 0x7fffffff;
	function emitStop(self) {
	    self.emit('stop');
	}
	class StatWatcher extends events_1.EventEmitter {
	    constructor(vol) {
	        super();
	        this.onInterval = () => {
	            try {
	                const stats = this.vol.statSync(this.filename);
	                if (this.hasChanged(stats)) {
	                    this.emit('change', stats, this.prev);
	                    this.prev = stats;
	                }
	            }
	            finally {
	                this.loop();
	            }
	        };
	        this.vol = vol;
	    }
	    loop() {
	        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
	    }
	    hasChanged(stats) {
	        // if(!this.prev) return false;
	        if (stats.mtimeMs > this.prev.mtimeMs)
	            return true;
	        if (stats.nlink !== this.prev.nlink)
	            return true;
	        return false;
	    }
	    start(path, persistent = true, interval = 5007) {
	        this.filename = (0, util_1.pathToFilename)(path);
	        this.setTimeout = persistent
	            ? setTimeout.bind(typeof globalThis !== 'undefined' ? globalThis : commonjsGlobal$1)
	            : setTimeoutUnref_1.default;
	        this.interval = interval;
	        this.prev = this.vol.statSync(this.filename);
	        this.loop();
	    }
	    stop() {
	        clearTimeout(this.timeoutRef);
	        (0, queueMicrotask_1.default)(() => {
	            emitStop.call(this, this);
	        });
	    }
	}
	volume.StatWatcher = StatWatcher;
	/* tslint:disable no-var-keyword prefer-const */
	// ---------------------------------------- ReadStream
	var pool;
	function allocNewPool(poolSize) {
	    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
	    pool.used = 0;
	}
	util.inherits(FsReadStream, stream_1.Readable);
	volume.ReadStream = FsReadStream;
	function FsReadStream(vol, path, options) {
	    if (!(this instanceof FsReadStream))
	        return new FsReadStream(vol, path, options);
	    this._vol = vol;
	    // a little bit bigger buffer and water marks by default
	    options = Object.assign({}, (0, options_1.getOptions)(options, {}));
	    if (options.highWaterMark === undefined)
	        options.highWaterMark = 64 * 1024;
	    stream_1.Readable.call(this, options);
	    this.path = (0, util_1.pathToFilename)(path);
	    this.fd = options.fd === undefined ? null : typeof options.fd !== 'number' ? options.fd.fd : options.fd;
	    this.flags = options.flags === undefined ? 'r' : options.flags;
	    this.mode = options.mode === undefined ? 0o666 : options.mode;
	    this.start = options.start;
	    this.end = options.end;
	    this.autoClose = options.autoClose === undefined ? true : options.autoClose;
	    this.pos = undefined;
	    this.bytesRead = 0;
	    if (this.start !== undefined) {
	        if (typeof this.start !== 'number') {
	            throw new TypeError('"start" option must be a Number');
	        }
	        if (this.end === undefined) {
	            this.end = Infinity;
	        }
	        else if (typeof this.end !== 'number') {
	            throw new TypeError('"end" option must be a Number');
	        }
	        if (this.start > this.end) {
	            throw new Error('"start" option must be <= "end" option');
	        }
	        this.pos = this.start;
	    }
	    if (typeof this.fd !== 'number')
	        this.open();
	    this.on('end', function () {
	        if (this.autoClose) {
	            if (this.destroy)
	                this.destroy();
	        }
	    });
	}
	FsReadStream.prototype.open = function () {
	    var self = this; // tslint:disable-line no-this-assignment
	    this._vol.open(this.path, this.flags, this.mode, (er, fd) => {
	        if (er) {
	            if (self.autoClose) {
	                if (self.destroy)
	                    self.destroy();
	            }
	            self.emit('error', er);
	            return;
	        }
	        self.fd = fd;
	        self.emit('open', fd);
	        // start the flow of data.
	        self.read();
	    });
	};
	FsReadStream.prototype._read = function (n) {
	    if (typeof this.fd !== 'number') {
	        return this.once('open', function () {
	            this._read(n);
	        });
	    }
	    if (this.destroyed)
	        return;
	    if (!pool || pool.length - pool.used < kMinPoolSpace) {
	        // discard the old pool.
	        allocNewPool(this._readableState.highWaterMark);
	    }
	    // Grab another reference to the pool in the case that while we're
	    // in the thread pool another read() finishes up the pool, and
	    // allocates a new one.
	    var thisPool = pool;
	    var toRead = Math.min(pool.length - pool.used, n);
	    var start = pool.used;
	    if (this.pos !== undefined)
	        toRead = Math.min(this.end - this.pos + 1, toRead);
	    // already read everything we were supposed to read!
	    // treat as EOF.
	    if (toRead <= 0)
	        return this.push(null);
	    // the actual read.
	    var self = this; // tslint:disable-line no-this-assignment
	    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
	    // move the pool positions, and internal position for reading.
	    if (this.pos !== undefined)
	        this.pos += toRead;
	    pool.used += toRead;
	    function onread(er, bytesRead) {
	        if (er) {
	            if (self.autoClose && self.destroy) {
	                self.destroy();
	            }
	            self.emit('error', er);
	        }
	        else {
	            var b = null;
	            if (bytesRead > 0) {
	                self.bytesRead += bytesRead;
	                b = thisPool.slice(start, start + bytesRead);
	            }
	            self.push(b);
	        }
	    }
	};
	FsReadStream.prototype._destroy = function (err, cb) {
	    this.close(err2 => {
	        cb(err || err2);
	    });
	};
	FsReadStream.prototype.close = function (cb) {
	    var _a;
	    if (cb)
	        this.once('close', cb);
	    if (this.closed || typeof this.fd !== 'number') {
	        if (typeof this.fd !== 'number') {
	            this.once('open', closeOnOpen);
	            return;
	        }
	        return (0, queueMicrotask_1.default)(() => this.emit('close'));
	    }
	    // Since Node 18, there is only a getter for '.closed'.
	    // The first branch mimics other setters from Readable.
	    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/readable.js#L1243
	    if (typeof ((_a = this._readableState) === null || _a === void 0 ? void 0 : _a.closed) === 'boolean') {
	        this._readableState.closed = true;
	    }
	    else {
	        this.closed = true;
	    }
	    this._vol.close(this.fd, er => {
	        if (er)
	            this.emit('error', er);
	        else
	            this.emit('close');
	    });
	    this.fd = null;
	};
	// needed because as it will be called with arguments
	// that does not match this.close() signature
	function closeOnOpen(fd) {
	    this.close();
	}
	util.inherits(FsWriteStream, stream_1.Writable);
	volume.WriteStream = FsWriteStream;
	function FsWriteStream(vol, path, options) {
	    if (!(this instanceof FsWriteStream))
	        return new FsWriteStream(vol, path, options);
	    this._vol = vol;
	    options = Object.assign({}, (0, options_1.getOptions)(options, {}));
	    stream_1.Writable.call(this, options);
	    this.path = (0, util_1.pathToFilename)(path);
	    this.fd = options.fd === undefined ? null : typeof options.fd !== 'number' ? options.fd.fd : options.fd;
	    this.flags = options.flags === undefined ? 'w' : options.flags;
	    this.mode = options.mode === undefined ? 0o666 : options.mode;
	    this.start = options.start;
	    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
	    this.pos = undefined;
	    this.bytesWritten = 0;
	    this.pending = true;
	    if (this.start !== undefined) {
	        if (typeof this.start !== 'number') {
	            throw new TypeError('"start" option must be a Number');
	        }
	        if (this.start < 0) {
	            throw new Error('"start" must be >= zero');
	        }
	        this.pos = this.start;
	    }
	    if (options.encoding)
	        this.setDefaultEncoding(options.encoding);
	    if (typeof this.fd !== 'number')
	        this.open();
	    // dispose on finish.
	    this.once('finish', function () {
	        if (this.autoClose) {
	            this.close();
	        }
	    });
	}
	FsWriteStream.prototype.open = function () {
	    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
	        if (er) {
	            if (this.autoClose && this.destroy) {
	                this.destroy();
	            }
	            this.emit('error', er);
	            return;
	        }
	        this.fd = fd;
	        this.pending = false;
	        this.emit('open', fd);
	    }.bind(this));
	};
	FsWriteStream.prototype._write = function (data, encoding, cb) {
	    if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
	        return this.emit('error', new Error('Invalid data'));
	    if (typeof this.fd !== 'number') {
	        return this.once('open', function () {
	            this._write(data, encoding, cb);
	        });
	    }
	    var self = this; // tslint:disable-line no-this-assignment
	    this._vol.write(this.fd, data, 0, data.length, this.pos, (er, bytes) => {
	        if (er) {
	            if (self.autoClose && self.destroy) {
	                self.destroy();
	            }
	            return cb(er);
	        }
	        self.bytesWritten += bytes;
	        cb();
	    });
	    if (this.pos !== undefined)
	        this.pos += data.length;
	};
	FsWriteStream.prototype._writev = function (data, cb) {
	    if (typeof this.fd !== 'number') {
	        return this.once('open', function () {
	            this._writev(data, cb);
	        });
	    }
	    const self = this; // tslint:disable-line no-this-assignment
	    const len = data.length;
	    const chunks = new Array(len);
	    var size = 0;
	    for (var i = 0; i < len; i++) {
	        var chunk = data[i].chunk;
	        chunks[i] = chunk;
	        size += chunk.length;
	    }
	    const buf = buffer_1.Buffer.concat(chunks);
	    this._vol.write(this.fd, buf, 0, buf.length, this.pos, (er, bytes) => {
	        if (er) {
	            if (self.destroy)
	                self.destroy();
	            return cb(er);
	        }
	        self.bytesWritten += bytes;
	        cb();
	    });
	    if (this.pos !== undefined)
	        this.pos += size;
	};
	FsWriteStream.prototype.close = function (cb) {
	    var _a;
	    if (cb)
	        this.once('close', cb);
	    if (this.closed || typeof this.fd !== 'number') {
	        if (typeof this.fd !== 'number') {
	            this.once('open', closeOnOpen);
	            return;
	        }
	        return (0, queueMicrotask_1.default)(() => this.emit('close'));
	    }
	    // Since Node 18, there is only a getter for '.closed'.
	    // The first branch mimics other setters from Writable.
	    // See https://github.com/nodejs/node/blob/v18.0.0/lib/internal/streams/writable.js#L766
	    if (typeof ((_a = this._writableState) === null || _a === void 0 ? void 0 : _a.closed) === 'boolean') {
	        this._writableState.closed = true;
	    }
	    else {
	        this.closed = true;
	    }
	    this._vol.close(this.fd, er => {
	        if (er)
	            this.emit('error', er);
	        else
	            this.emit('close');
	    });
	    this.fd = null;
	};
	FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
	// There is no shutdown() for files.
	FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
	// ---------------------------------------- FSWatcher
	class FSWatcher extends events_1.EventEmitter {
	    constructor(vol) {
	        super();
	        this._filename = '';
	        this._filenameEncoded = '';
	        // _persistent: boolean = true;
	        this._recursive = false;
	        this._encoding = encoding_1.ENCODING_UTF8;
	        // inode -> removers
	        this._listenerRemovers = new Map();
	        this._onParentChild = (link) => {
	            if (link.getName() === this._getName()) {
	                this._emit('rename');
	            }
	        };
	        this._emit = (type) => {
	            this.emit('change', type, this._filenameEncoded);
	        };
	        this._persist = () => {
	            this._timer = setTimeout(this._persist, 1e6);
	        };
	        this._vol = vol;
	        // TODO: Emit "error" messages when watching.
	        // this._handle.onchange = function(status, eventType, filename) {
	        //     if (status < 0) {
	        //         self._handle.close();
	        //         const error = !filename ?
	        //             errnoException(status, 'Error watching file for changes:') :
	        //             errnoException(status, `Error watching file ${filename} for changes:`);
	        //         error.filename = filename;
	        //         self.emit('error', error);
	        //     } else {
	        //         self.emit('change', eventType, filename);
	        //     }
	        // };
	    }
	    _getName() {
	        return this._steps[this._steps.length - 1];
	    }
	    start(path, persistent = true, recursive = false, encoding = encoding_1.ENCODING_UTF8) {
	        this._filename = (0, util_1.pathToFilename)(path);
	        this._steps = filenameToSteps(this._filename);
	        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
	        // this._persistent = persistent;
	        this._recursive = recursive;
	        this._encoding = encoding;
	        try {
	            this._link = this._vol.getLinkOrThrow(this._filename, 'FSWatcher');
	        }
	        catch (err) {
	            const error = new Error(`watch ${this._filename} ${err.code}`);
	            error.code = err.code;
	            error.errno = err.code;
	            throw error;
	        }
	        const watchLinkNodeChanged = (link) => {
	            var _a;
	            const filepath = link.getPath();
	            const node = link.getNode();
	            const onNodeChange = () => {
	                let filename = relative(this._filename, filepath);
	                if (!filename) {
	                    filename = this._getName();
	                }
	                return this.emit('change', 'change', filename);
	            };
	            node.on('change', onNodeChange);
	            const removers = (_a = this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];
	            removers.push(() => node.removeListener('change', onNodeChange));
	            this._listenerRemovers.set(node.ino, removers);
	        };
	        const watchLinkChildrenChanged = (link) => {
	            var _a;
	            const node = link.getNode();
	            // when a new link added
	            const onLinkChildAdd = (l) => {
	                this.emit('change', 'rename', relative(this._filename, l.getPath()));
	                setTimeout(() => {
	                    // 1. watch changes of the new link-node
	                    watchLinkNodeChanged(l);
	                    // 2. watch changes of the new link-node's children
	                    watchLinkChildrenChanged(l);
	                });
	            };
	            // when a new link deleted
	            const onLinkChildDelete = (l) => {
	                // remove the listeners of the children nodes
	                const removeLinkNodeListeners = (curLink) => {
	                    const ino = curLink.getNode().ino;
	                    const removers = this._listenerRemovers.get(ino);
	                    if (removers) {
	                        removers.forEach(r => r());
	                        this._listenerRemovers.delete(ino);
	                    }
	                    for (const [name, childLink] of curLink.children.entries()) {
	                        if (childLink && name !== '.' && name !== '..') {
	                            removeLinkNodeListeners(childLink);
	                        }
	                    }
	                };
	                removeLinkNodeListeners(l);
	                this.emit('change', 'rename', relative(this._filename, l.getPath()));
	            };
	            // children nodes changed
	            for (const [name, childLink] of link.children.entries()) {
	                if (childLink && name !== '.' && name !== '..') {
	                    watchLinkNodeChanged(childLink);
	                }
	            }
	            // link children add/remove
	            link.on('child:add', onLinkChildAdd);
	            link.on('child:delete', onLinkChildDelete);
	            const removers = (_a = this._listenerRemovers.get(node.ino)) !== null && _a !== void 0 ? _a : [];
	            removers.push(() => {
	                link.removeListener('child:add', onLinkChildAdd);
	                link.removeListener('child:delete', onLinkChildDelete);
	            });
	            if (recursive) {
	                for (const [name, childLink] of link.children.entries()) {
	                    if (childLink && name !== '.' && name !== '..') {
	                        watchLinkChildrenChanged(childLink);
	                    }
	                }
	            }
	        };
	        watchLinkNodeChanged(this._link);
	        watchLinkChildrenChanged(this._link);
	        const parent = this._link.parent;
	        if (parent) {
	            // parent.on('child:add', this._onParentChild);
	            parent.setMaxListeners(parent.getMaxListeners() + 1);
	            parent.on('child:delete', this._onParentChild);
	        }
	        if (persistent)
	            this._persist();
	    }
	    close() {
	        clearTimeout(this._timer);
	        this._listenerRemovers.forEach(removers => {
	            removers.forEach(r => r());
	        });
	        this._listenerRemovers.clear();
	        const parent = this._link.parent;
	        if (parent) {
	            // parent.removeListener('child:add', this._onParentChild);
	            parent.removeListener('child:delete', this._onParentChild);
	        }
	    }
	}
	volume.FSWatcher = FSWatcher;
	
	return volume;
}

var fsSynchronousApiList = {};

var hasRequiredFsSynchronousApiList;

function requireFsSynchronousApiList () {
	if (hasRequiredFsSynchronousApiList) return fsSynchronousApiList;
	hasRequiredFsSynchronousApiList = 1;
	Object.defineProperty(fsSynchronousApiList, "__esModule", { value: true });
	fsSynchronousApiList.fsSynchronousApiList = void 0;
	fsSynchronousApiList.fsSynchronousApiList = [
	    'accessSync',
	    'appendFileSync',
	    'chmodSync',
	    'chownSync',
	    'closeSync',
	    'copyFileSync',
	    'existsSync',
	    'fchmodSync',
	    'fchownSync',
	    'fdatasyncSync',
	    'fstatSync',
	    'fsyncSync',
	    'ftruncateSync',
	    'futimesSync',
	    'lchmodSync',
	    'lchownSync',
	    'linkSync',
	    'lstatSync',
	    'mkdirSync',
	    'mkdtempSync',
	    'openSync',
	    'readdirSync',
	    'readFileSync',
	    'readlinkSync',
	    'readSync',
	    'readvSync',
	    'realpathSync',
	    'renameSync',
	    'rmdirSync',
	    'rmSync',
	    'statSync',
	    'symlinkSync',
	    'truncateSync',
	    'unlinkSync',
	    'utimesSync',
	    'lutimesSync',
	    'writeFileSync',
	    'writeSync',
	    'writevSync',
	    // 'cpSync',
	    // 'statfsSync',
	];
	
	return fsSynchronousApiList;
}

var fsCallbackApiList = {};

var hasRequiredFsCallbackApiList;

function requireFsCallbackApiList () {
	if (hasRequiredFsCallbackApiList) return fsCallbackApiList;
	hasRequiredFsCallbackApiList = 1;
	Object.defineProperty(fsCallbackApiList, "__esModule", { value: true });
	fsCallbackApiList.fsCallbackApiList = void 0;
	fsCallbackApiList.fsCallbackApiList = [
	    'access',
	    'appendFile',
	    'chmod',
	    'chown',
	    'close',
	    'copyFile',
	    'createReadStream',
	    'createWriteStream',
	    'exists',
	    'fchmod',
	    'fchown',
	    'fdatasync',
	    'fstat',
	    'fsync',
	    'ftruncate',
	    'futimes',
	    'lchmod',
	    'lchown',
	    'link',
	    'lstat',
	    'mkdir',
	    'mkdtemp',
	    'open',
	    'read',
	    'readv',
	    'readdir',
	    'readFile',
	    'readlink',
	    'realpath',
	    'rename',
	    'rm',
	    'rmdir',
	    'stat',
	    'symlink',
	    'truncate',
	    'unlink',
	    'unwatchFile',
	    'utimes',
	    'lutimes',
	    'watch',
	    'watchFile',
	    'write',
	    'writev',
	    'writeFile',
	];
	
	return fsCallbackApiList;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$2.exports;
	hasRequiredLib = 1;
	(function (module, exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.memfs = exports.fs = exports.vol = exports.Volume = void 0;
		exports.createFsFromVolume = createFsFromVolume;
		const Stats_1 = requireStats();
		const Dirent_1 = requireDirent();
		const volume_1 = requireVolume();
		Object.defineProperty(exports, "Volume", { enumerable: true, get: function () { return volume_1.Volume; } });
		const constants_1 = requireConstants$2();
		const fsSynchronousApiList_1 = requireFsSynchronousApiList();
		const fsCallbackApiList_1 = requireFsCallbackApiList();
		const { F_OK, R_OK, W_OK, X_OK } = constants_1.constants;
		// Default volume.
		exports.vol = new volume_1.Volume();
		function createFsFromVolume(vol) {
		    const fs = { F_OK, R_OK, W_OK, X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
		    // Bind FS methods.
		    for (const method of fsSynchronousApiList_1.fsSynchronousApiList)
		        if (typeof vol[method] === 'function')
		            fs[method] = vol[method].bind(vol);
		    for (const method of fsCallbackApiList_1.fsCallbackApiList)
		        if (typeof vol[method] === 'function')
		            fs[method] = vol[method].bind(vol);
		    fs.StatWatcher = vol.StatWatcher;
		    fs.FSWatcher = vol.FSWatcher;
		    fs.WriteStream = vol.WriteStream;
		    fs.ReadStream = vol.ReadStream;
		    fs.promises = vol.promises;
		    fs._toUnixTimestamp = volume_1.toUnixTimestamp;
		    fs.__vol = vol;
		    return fs;
		}
		exports.fs = createFsFromVolume(exports.vol);
		/**
		 * Creates a new file system instance.
		 *
		 * @param json File system structure expressed as a JSON object.
		 *        Use `null` for empty directories and empty string for empty files.
		 * @param cwd Current working directory. The JSON structure will be created
		 *        relative to this path.
		 * @returns A `memfs` file system instance, which is a drop-in replacement for
		 *          the `fs` module.
		 */
		const memfs = (json = {}, cwd = '/') => {
		    const vol = volume_1.Volume.fromNestedJSON(json, cwd);
		    const fs = createFsFromVolume(vol);
		    return { fs, vol };
		};
		exports.memfs = memfs;
		module.exports = Object.assign(Object.assign({}, module.exports), exports.fs);
		module.exports.semantic = true;
		
	} (lib$2, lib$2.exports));
	return lib$2.exports;
}

var libExports = requireLib();
var index = /*@__PURE__*/getDefaultExportFromCjs$1(libExports);

var memfsExported = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: index
}, [libExports]);

const { createFsFromVolume, Volume, fs, memfs } = memfsExported;

export { Volume, createFsFromVolume, fs, memfs, memfsExported };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnMuanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9TdGF0cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2ludGVybmFsL2J1ZmZlci5qcyIsIi4uL2Fzc2VydC5janMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtaW5zcGVjdC1leHRyYWN0ZWQvZGlzdC9pbnNwZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL25vZGUtaW5zcGVjdC1leHRyYWN0ZWQvaW5kZXgubWpzIiwiLi4vdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW50ZXJuYWwvZXJyb3JzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9lbmNvZGluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvRGlyZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvcHJvY2Vzcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9ub2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9xdWV1ZU1pY3JvdGFzay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvc2V0VGltZW91dFVucmVmLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9wcmltb3JkaWFscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvdXRpbC9pbnNwZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy9lcnJvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvYWJvcnQtY29udHJvbGxlci9icm93c2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvb3Vycy91dGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvdmFsaWRhdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvdXRpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcmVhZGFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3dyaXRhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXhpZnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2R1cGxleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvdHJhbnNmb3JtLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9wYXNzdGhyb3VnaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL29wZXJhdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL3N0cmVhbS9wcm9taXNlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL3N0cmVhbS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL291cnMvYnJvd3Nlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS9jb25zdGFudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvb2JqZWN0LWluc3BlY3QvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsLWxpc3QvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtb2JqZWN0LWF0b21zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvZXZhbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvcmFuZ2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZXMtZXJyb3JzL3JlZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy1lcnJvcnMvc3ludGF4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2VzLWVycm9ycy91cmkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL2Ficy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3MvZmxvb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL21heC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3MvbWluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9wb3cuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbWF0aC1pbnRyaW5zaWNzL3JvdW5kLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21hdGgtaW50cmluc2ljcy9pc05hTi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tYXRoLWludHJpbnNpY3Mvc2lnbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9nb3BkL2dPUEQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ29wZC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lcy1kZWZpbmUtcHJvcGVydHkvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL1JlZmxlY3QuZ2V0UHJvdG90eXBlT2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL09iamVjdC5nZXRQcm90b3R5cGVPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25DYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2Z1bmN0aW9uQXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvcmVmbGVjdEFwcGx5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2FjdHVhbEFwcGx5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC1hcHBseS1oZWxwZXJzL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2R1bmRlci1wcm90by9nZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2V0LXByb3RvL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2hhc293bi9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NhbGwtYm91bmQvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsLW1hcC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zaWRlLWNoYW5uZWwtd2Vha21hcC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9zaWRlLWNoYW5uZWwvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9ub2RlL3V0aWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL25vZGUvRmlsZUhhbmRsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS9Gc1Byb21pc2VzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdHJlZS1kdW1wL2xpYi9wcmludFRyZWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdHJlZS1kdW1wL2xpYi9wcmludEJpbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy90cmVlLWR1bXAvbGliL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9ub2RlLXRvLWZzYS91dGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9wcmludC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS9vcHRpb25zLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9EaXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3ZvbHVtZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS9saXN0cy9mc1N5bmNocm9ub3VzQXBpTGlzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS9saXN0cy9mc0NhbGxiYWNrQXBpTGlzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW5kZXguanMiLCIuLi9mcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uc3RhbnRzID0gdm9pZCAwO1xuZXhwb3J0cy5jb25zdGFudHMgPSB7XG4gICAgT19SRE9OTFk6IDAsXG4gICAgT19XUk9OTFk6IDEsXG4gICAgT19SRFdSOiAyLFxuICAgIFNfSUZNVDogNjE0NDAsXG4gICAgU19JRlJFRzogMzI3NjgsXG4gICAgU19JRkRJUjogMTYzODQsXG4gICAgU19JRkNIUjogODE5MixcbiAgICBTX0lGQkxLOiAyNDU3NixcbiAgICBTX0lGSUZPOiA0MDk2LFxuICAgIFNfSUZMTks6IDQwOTYwLFxuICAgIFNfSUZTT0NLOiA0OTE1MixcbiAgICBPX0NSRUFUOiA2NCxcbiAgICBPX0VYQ0w6IDEyOCxcbiAgICBPX05PQ1RUWTogMjU2LFxuICAgIE9fVFJVTkM6IDUxMixcbiAgICBPX0FQUEVORDogMTAyNCxcbiAgICBPX0RJUkVDVE9SWTogNjU1MzYsXG4gICAgT19OT0FUSU1FOiAyNjIxNDQsXG4gICAgT19OT0ZPTExPVzogMTMxMDcyLFxuICAgIE9fU1lOQzogMTA1MjY3MixcbiAgICBPX1NZTUxJTks6IDIwOTcxNTIsXG4gICAgT19ESVJFQ1Q6IDE2Mzg0LFxuICAgIE9fTk9OQkxPQ0s6IDIwNDgsXG4gICAgU19JUldYVTogNDQ4LFxuICAgIFNfSVJVU1I6IDI1NixcbiAgICBTX0lXVVNSOiAxMjgsXG4gICAgU19JWFVTUjogNjQsXG4gICAgU19JUldYRzogNTYsXG4gICAgU19JUkdSUDogMzIsXG4gICAgU19JV0dSUDogMTYsXG4gICAgU19JWEdSUDogOCxcbiAgICBTX0lSV1hPOiA3LFxuICAgIFNfSVJPVEg6IDQsXG4gICAgU19JV09USDogMixcbiAgICBTX0lYT1RIOiAxLFxuICAgIEZfT0s6IDAsXG4gICAgUl9PSzogNCxcbiAgICBXX09LOiAyLFxuICAgIFhfT0s6IDEsXG4gICAgVVZfRlNfU1lNTElOS19ESVI6IDEsXG4gICAgVVZfRlNfU1lNTElOS19KVU5DVElPTjogMixcbiAgICBVVl9GU19DT1BZRklMRV9FWENMOiAxLFxuICAgIFVWX0ZTX0NPUFlGSUxFX0ZJQ0xPTkU6IDIsXG4gICAgVVZfRlNfQ09QWUZJTEVfRklDTE9ORV9GT1JDRTogNCxcbiAgICBDT1BZRklMRV9FWENMOiAxLFxuICAgIENPUFlGSUxFX0ZJQ0xPTkU6IDIsXG4gICAgQ09QWUZJTEVfRklDTE9ORV9GT1JDRTogNCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXRzID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB7IFNfSUZNVCwgU19JRkRJUiwgU19JRlJFRywgU19JRkJMSywgU19JRkNIUiwgU19JRkxOSywgU19JRklGTywgU19JRlNPQ0sgfSA9IGNvbnN0YW50c18xLmNvbnN0YW50cztcbi8qKlxuICogU3RhdGlzdGljcyBhYm91dCBhIGZpbGUvZGlyZWN0b3J5LCBsaWtlIGBmcy5TdGF0c2AuXG4gKi9cbmNsYXNzIFN0YXRzIHtcbiAgICBzdGF0aWMgYnVpbGQobm9kZSwgYmlnaW50ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBuZXcgU3RhdHMoKTtcbiAgICAgICAgY29uc3QgeyB1aWQsIGdpZCwgYXRpbWUsIG10aW1lLCBjdGltZSB9ID0gbm9kZTtcbiAgICAgICAgY29uc3QgZ2V0U3RhdE51bWJlciA9ICFiaWdpbnQgPyBudW1iZXIgPT4gbnVtYmVyIDogbnVtYmVyID0+IEJpZ0ludChudW1iZXIpO1xuICAgICAgICAvLyBDb3B5IGFsbCB2YWx1ZXMgb24gU3RhdHMgZnJvbSBOb2RlLCBzbyB0aGF0IGlmIE5vZGUgdmFsdWVzXG4gICAgICAgIC8vIGNoYW5nZSwgdmFsdWVzIG9uIFN0YXRzIHdvdWxkIHN0aWxsIGJlIHRoZSBvbGQgb25lcyxcbiAgICAgICAgLy8ganVzdCBsaWtlIGluIE5vZGUgZnMuXG4gICAgICAgIHN0YXRzLnVpZCA9IGdldFN0YXROdW1iZXIodWlkKTtcbiAgICAgICAgc3RhdHMuZ2lkID0gZ2V0U3RhdE51bWJlcihnaWQpO1xuICAgICAgICBzdGF0cy5yZGV2ID0gZ2V0U3RhdE51bWJlcihub2RlLnJkZXYpO1xuICAgICAgICBzdGF0cy5ibGtzaXplID0gZ2V0U3RhdE51bWJlcig0MDk2KTtcbiAgICAgICAgc3RhdHMuaW5vID0gZ2V0U3RhdE51bWJlcihub2RlLmlubyk7XG4gICAgICAgIHN0YXRzLnNpemUgPSBnZXRTdGF0TnVtYmVyKG5vZGUuZ2V0U2l6ZSgpKTtcbiAgICAgICAgc3RhdHMuYmxvY2tzID0gZ2V0U3RhdE51bWJlcigxKTtcbiAgICAgICAgc3RhdHMuYXRpbWUgPSBhdGltZTtcbiAgICAgICAgc3RhdHMubXRpbWUgPSBtdGltZTtcbiAgICAgICAgc3RhdHMuY3RpbWUgPSBjdGltZTtcbiAgICAgICAgc3RhdHMuYmlydGh0aW1lID0gY3RpbWU7XG4gICAgICAgIHN0YXRzLmF0aW1lTXMgPSBnZXRTdGF0TnVtYmVyKGF0aW1lLmdldFRpbWUoKSk7XG4gICAgICAgIHN0YXRzLm10aW1lTXMgPSBnZXRTdGF0TnVtYmVyKG10aW1lLmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IGN0aW1lTXMgPSBnZXRTdGF0TnVtYmVyKGN0aW1lLmdldFRpbWUoKSk7XG4gICAgICAgIHN0YXRzLmN0aW1lTXMgPSBjdGltZU1zO1xuICAgICAgICBzdGF0cy5iaXJ0aHRpbWVNcyA9IGN0aW1lTXM7XG4gICAgICAgIGlmIChiaWdpbnQpIHtcbiAgICAgICAgICAgIHN0YXRzLmF0aW1lTnMgPSBCaWdJbnQoYXRpbWUuZ2V0VGltZSgpKSAqIEJpZ0ludCgxMDAwMDAwKTtcbiAgICAgICAgICAgIHN0YXRzLm10aW1lTnMgPSBCaWdJbnQobXRpbWUuZ2V0VGltZSgpKSAqIEJpZ0ludCgxMDAwMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGN0aW1lTnMgPSBCaWdJbnQoY3RpbWUuZ2V0VGltZSgpKSAqIEJpZ0ludCgxMDAwMDAwKTtcbiAgICAgICAgICAgIHN0YXRzLmN0aW1lTnMgPSBjdGltZU5zO1xuICAgICAgICAgICAgc3RhdHMuYmlydGh0aW1lTnMgPSBjdGltZU5zO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRzLmRldiA9IGdldFN0YXROdW1iZXIoMCk7XG4gICAgICAgIHN0YXRzLm1vZGUgPSBnZXRTdGF0TnVtYmVyKG5vZGUubW9kZSk7XG4gICAgICAgIHN0YXRzLm5saW5rID0gZ2V0U3RhdE51bWJlcihub2RlLm5saW5rKTtcbiAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH1cbiAgICBfY2hlY2tNb2RlUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIChOdW1iZXIodGhpcy5tb2RlKSAmIFNfSUZNVCkgPT09IHByb3BlcnR5O1xuICAgIH1cbiAgICBpc0RpcmVjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZESVIpO1xuICAgIH1cbiAgICBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGUkVHKTtcbiAgICB9XG4gICAgaXNCbG9ja0RldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZCTEspO1xuICAgIH1cbiAgICBpc0NoYXJhY3RlckRldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZDSFIpO1xuICAgIH1cbiAgICBpc1N5bWJvbGljTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZMTkspO1xuICAgIH1cbiAgICBpc0ZJRk8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGSUZPKTtcbiAgICB9XG4gICAgaXNTb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGU09DSyk7XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0cyA9IFN0YXRzO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0cy5qcy5tYXAiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSAnYmFzZTY0LWpzJ1xuaW1wb3J0ICogYXMgaWVlZTc1NCBmcm9tICdpZWVlNzU0J1xuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5jb25zdCBJTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmNvbnN0IGtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IElOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuXG5leHBvcnQge1xuICBCdWZmZXIsXG4gIFNsb3dCdWZmZXIsXG4gIElOU1BFQ1RfTUFYX0JZVEVTLFxuICBrTWF4TGVuZ3RoLFxufSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWZmZXJGcm9tID0gZXhwb3J0cy5idWZmZXJBbGxvY1Vuc2FmZSA9IGV4cG9ydHMuQnVmZmVyID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWZmZXJfMS5CdWZmZXI7IH0gfSk7XG5mdW5jdGlvbiBidWZmZXJWMFAxMlBvbnlmaWxsKGFyZzAsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IGJ1ZmZlcl8xLkJ1ZmZlcihhcmcwLCAuLi5hcmdzKTtcbn1cbmNvbnN0IGJ1ZmZlckFsbG9jVW5zYWZlID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jVW5zYWZlIHx8IGJ1ZmZlclYwUDEyUG9ueWZpbGw7XG5leHBvcnRzLmJ1ZmZlckFsbG9jVW5zYWZlID0gYnVmZmVyQWxsb2NVbnNhZmU7XG5jb25zdCBidWZmZXJGcm9tID0gYnVmZmVyXzEuQnVmZmVyLmZyb20gfHwgYnVmZmVyVjBQMTJQb255ZmlsbDtcbmV4cG9ydHMuYnVmZmVyRnJvbSA9IGJ1ZmZlckZyb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIiwiZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFxuXG5tb2R1bGUuZXhwb3J0cy5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgIT09IGIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7YX0gdG8gc3RyaWN0IGVxdWFsICR7Yn1gKVxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBwcmltb3JkaWFscyA9IHtleHBvcnRzOiB7fX07XG5cbi8vIGJhY2stcGF0Y2ggaW4gcHJpbW9yZGlhbHMgaW4gdXNlci1sYW5kXG5cbmNvbnN0IGNyZWF0ZVNhZmVJdGVyYXRvciA9IChmYWN0b3J5LCBuZXh0KSA9PiB7XG4gIGNsYXNzIFNhZmVJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcmFibGUpIHtcbiAgICAgIHRoaXMuX2l0ZXJhdG9yID0gZmFjdG9yeShpdGVyYWJsZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICByZXR1cm4gbmV4dCh0aGlzLl9pdGVyYXRvcik7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihTYWZlSXRlcmF0b3IucHJvdG90eXBlLCBudWxsKTtcbiAgT2JqZWN0LmZyZWV6ZShTYWZlSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgT2JqZWN0LmZyZWV6ZShTYWZlSXRlcmF0b3IpO1xuICByZXR1cm4gU2FmZUl0ZXJhdG9yO1xufTtcblxuZnVuY3Rpb24gZ2V0R2V0dGVyKGNscywgZ2V0dGVyKSB7XG4gIC8vIFRPRE86IF9fbG9va3VwR2V0dGVyX18gaXMgZGVwcmVjYXRlZCwgYnV0IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgLy8gZG9lc24ndCB3b3JrIG9uIGJ1aWx0LWlucyBsaWtlIFR5cGVkIEFycmF5cy5cbiAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoY2xzLnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKGdldHRlcikpO1xufVxuXG5mdW5jdGlvbiBnZXR0ZXJDYWxsZXIoZ2V0dGVyKSB7XG4gIHJldHVybiAodmFsKSA9PiB7XG4gICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19sb29rdXBHZXR0ZXJfXyhnZXR0ZXIpLmNhbGwodmFsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZnVuYykge1xuICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChmdW5jKTtcbn1cblxuY29uc3QgY29weVByb3BzID0gKHNyYywgZGVzdCkgPT4ge1xuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFJlZmxlY3Qub3duS2V5cyhzcmMpLCAoa2V5KSA9PiB7XG4gICAgaWYgKCFSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZXN0LCBrZXkpKSB7XG4gICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICBkZXN0LFxuICAgICAgICBrZXksXG4gICAgICAgIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywga2V5KSk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IG1ha2VTYWZlID0gKHVuc2FmZSwgc2FmZSkgPT4ge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIHVuc2FmZS5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBkdW1teSA9IG5ldyB1bnNhZmUoKTtcbiAgICBsZXQgbmV4dDsgLy8gV2UgY2FuIHJldXNlIHRoZSBzYW1lIGBuZXh0YCBtZXRob2QuXG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFJlZmxlY3Qub3duS2V5cyh1bnNhZmUucHJvdG90eXBlKSwgKGtleSkgPT4ge1xuICAgICAgaWYgKCFSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzYWZlLnByb3RvdHlwZSwga2V5KSkge1xuICAgICAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodW5zYWZlLnByb3RvdHlwZSwga2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSAnZnVuY3Rpb24nICYmIGRlc2MudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsZWQgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5jYWxsKGRlc2MudmFsdWUsIGR1bW15KSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gKHR5cGVvZiBjYWxsZWQgPT09IFwib2JqZWN0XCIgPyBjYWxsZWQgOiB7fSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGVJdGVyYXRvciA9IHVuY3VycnlUaGlzKGRlc2MudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHVuY3VycnlUaGlzKGNyZWF0ZUl0ZXJhdG9yKGR1bW15KS5uZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgU2FmZUl0ZXJhdG9yID0gY3JlYXRlU2FmZUl0ZXJhdG9yKGNyZWF0ZUl0ZXJhdG9yLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBkZXNjLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZUl0ZXJhdG9yKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShzYWZlLnByb3RvdHlwZSwga2V5LCBkZXNjKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb3B5UHJvcHModW5zYWZlLnByb3RvdHlwZSwgc2FmZS5wcm90b3R5cGUpO1xuICB9XG4gIGNvcHlQcm9wcyh1bnNhZmUsIHNhZmUpO1xuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihzYWZlLnByb3RvdHlwZSwgbnVsbCk7XG4gIE9iamVjdC5mcmVlemUoc2FmZS5wcm90b3R5cGUpO1xuICBPYmplY3QuZnJlZXplKHNhZmUpO1xuICByZXR1cm4gc2FmZTtcbn07XG5cbmNvbnN0IFN0cmluZ0l0ZXJhdG9yID1cbiAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0pO1xuY29uc3QgU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUgPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKFN0cmluZ0l0ZXJhdG9yKCcnKSk7XG5cbmZ1bmN0aW9uIEVycm9yQ2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0T2JqZWN0KSB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gIC8vIFJlbW92ZSB0aGUgc2Vjb25kIGxpbmUsIHdoaWNoIGlzIHRoaXMgZnVuY3Rpb25cbiAgdGFyZ2V0T2JqZWN0LnN0YWNrID0gc3RhY2sucmVwbGFjZSgvLipcXG4uKi8sICckMScpO1xufVxuXG5wcmltb3JkaWFscy5leHBvcnRzID0ge1xuICBtYWtlU2FmZSwgLy8gZXhwb3J0ZWQgZm9yIHRlc3RpbmdcbiAgaW50ZXJuYWxCaW5kaW5nKG1vZCkge1xuICAgIGlmIChtb2QgPT09ICdjb25maWcnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNJbnRsOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBtb2R1bGU6IFwiJHttb2R9XCJgKTtcbiAgfSxcbiAgQXJyYXksXG4gIEFycmF5SXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgQXJyYXlQcm90b3R5cGVGaWx0ZXI6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmZpbHRlciksXG4gIEFycmF5UHJvdG90eXBlRm9yRWFjaDogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuZm9yRWFjaCksXG4gIEFycmF5UHJvdG90eXBlSW5jbHVkZXM6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpLFxuICBBcnJheVByb3RvdHlwZUluZGV4T2Y6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpLFxuICBBcnJheVByb3RvdHlwZUpvaW46IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmpvaW4pLFxuICBBcnJheVByb3RvdHlwZU1hcDogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUubWFwKSxcbiAgQXJyYXlQcm90b3R5cGVQb3A6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnBvcCksXG4gIEFycmF5UHJvdG90eXBlUHVzaDogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUucHVzaCksXG4gIEFycmF5UHJvdG90eXBlUHVzaEFwcGx5OiBGdW5jdGlvbi5hcHBseS5iaW5kKEFycmF5LnByb3RvdHlwZS5wdXNoKSxcbiAgQXJyYXlQcm90b3R5cGVTbGljZTogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuc2xpY2UpLFxuICBBcnJheVByb3RvdHlwZVNvcnQ6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNvcnQpLFxuICBBcnJheVByb3RvdHlwZVNwbGljZTogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUuc3BsaWNlKSxcbiAgQXJyYXlQcm90b3R5cGVVbnNoaWZ0OiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKEFycmF5LnByb3RvdHlwZS51bnNoaWZ0KSxcbiAgQmlnSW50UHJvdG90eXBlVmFsdWVPZjpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZiksXG4gIEJvb2xlYW5Qcm90b3R5cGVWYWx1ZU9mOlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZiksXG4gIERhdGVQcm90b3R5cGVHZXRUaW1lOiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLmdldFRpbWUpLFxuICBEYXRlUHJvdG90eXBlVG9JU09TdHJpbmc6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyksXG4gIERhdGVQcm90b3R5cGVUb1N0cmluZzpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKERhdGUucHJvdG90eXBlLnRvU3RyaW5nKSxcbiAgRXJyb3JDYXB0dXJlU3RhY2tUcmFjZSxcbiAgRXJyb3JQcm90b3R5cGVUb1N0cmluZzpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKEVycm9yLnByb3RvdHlwZS50b1N0cmluZyksXG4gIEZ1bmN0aW9uUHJvdG90eXBlQmluZDogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChGdW5jdGlvbi5wcm90b3R5cGUuYmluZCksXG4gIEZ1bmN0aW9uUHJvdG90eXBlQ2FsbDpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKSxcbiAgRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZzpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyksXG4gIGdsb2JhbFRoaXM6ICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcpID8gY29tbW9uanNHbG9iYWwgOiBnbG9iYWxUaGlzLFxuICBKU09OU3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSxcbiAgTWFwUHJvdG90eXBlR2V0U2l6ZTogZ2V0R2V0dGVyKE1hcCwgJ3NpemUnKSxcbiAgTWFwUHJvdG90eXBlRW50cmllczogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChNYXAucHJvdG90eXBlLmVudHJpZXMpLFxuICBNYXRoRmxvb3I6IE1hdGguZmxvb3IsXG4gIE1hdGhNYXg6IE1hdGgubWF4LFxuICBNYXRoTWluOiBNYXRoLm1pbixcbiAgTWF0aFJvdW5kOiBNYXRoLnJvdW5kLFxuICBNYXRoU3FydDogTWF0aC5zcXJ0LFxuICBNYXRoVHJ1bmM6IE1hdGgudHJ1bmMsXG4gIE51bWJlcixcbiAgTnVtYmVySXNGaW5pdGU6IE51bWJlci5pc0Zpbml0ZSxcbiAgTnVtYmVySXNOYU46IE51bWJlci5pc05hTixcbiAgTnVtYmVyUGFyc2VGbG9hdDogTnVtYmVyLnBhcnNlRmxvYXQsXG4gIE51bWJlclBhcnNlSW50OiBOdW1iZXIucGFyc2VJbnQsXG4gIE51bWJlclByb3RvdHlwZVRvU3RyaW5nOiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKE51bWJlci5wcm90b3R5cGUudG9TdHJpbmcpLFxuICBOdW1iZXJQcm90b3R5cGVWYWx1ZU9mOlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKSxcbiAgT2JqZWN0LFxuICBPYmplY3RBc3NpZ246IE9iamVjdC5hc3NpZ24sXG4gIE9iamVjdENyZWF0ZTogT2JqZWN0LmNyZWF0ZSxcbiAgT2JqZWN0RGVmaW5lUHJvcGVydHk6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgT2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICBPYmplY3RHZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICBPYmplY3RJczogT2JqZWN0LmlzLFxuICBPYmplY3RLZXlzOiBPYmplY3Qua2V5cyxcbiAgT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHk6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KSxcbiAgT2JqZWN0UHJvdG90eXBlUHJvcGVydHlJc0VudW1lcmFibGU6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKSxcbiAgT2JqZWN0U2VhbDogT2JqZWN0LnNlYWwsXG4gIE9iamVjdFNldFByb3RvdHlwZU9mOiBPYmplY3Quc2V0UHJvdG90eXBlT2YsXG4gIFJlZmxlY3RBcHBseTogUmVmbGVjdC5hcHBseSxcbiAgUmVmbGVjdE93bktleXM6IFJlZmxlY3Qub3duS2V5cyxcbiAgUmVnRXhwLFxuICBSZWdFeHBQcm90b3R5cGVFeGVjOiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFJlZ0V4cC5wcm90b3R5cGUuZXhlYyksXG4gIFJlZ0V4cFByb3RvdHlwZVN5bWJvbFJlcGxhY2U6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoUmVnRXhwLnByb3RvdHlwZVtTeW1ib2wucmVwbGFjZV0pLFxuICBSZWdFeHBQcm90b3R5cGVTeW1ib2xTcGxpdDogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5zcGxpdF0pLFxuICBSZWdFeHBQcm90b3R5cGVUZXN0OiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFJlZ0V4cC5wcm90b3R5cGUudGVzdCksXG4gIFJlZ0V4cFByb3RvdHlwZVRvU3RyaW5nOlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZyksXG4gIFNhZmVTdHJpbmdJdGVyYXRvcjogY3JlYXRlU2FmZUl0ZXJhdG9yKFxuICAgIFN0cmluZ0l0ZXJhdG9yLFxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUubmV4dCksXG4gICksXG4gIFNhZmVNYXA6IG1ha2VTYWZlKFxuICAgIE1hcCxcbiAgICBjbGFzcyBTYWZlTWFwIGV4dGVuZHMgTWFwIHtcbiAgICAgIGNvbnN0cnVjdG9yKGkpIHsgc3VwZXIoaSk7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgfSksXG4gIFNhZmVTZXQ6IG1ha2VTYWZlKFxuICAgIFNldCxcbiAgICBjbGFzcyBTYWZlU2V0IGV4dGVuZHMgU2V0IHtcbiAgICAgIGNvbnN0cnVjdG9yKGkpIHsgc3VwZXIoaSk7IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWNvbnN0cnVjdG9yXG4gICAgfSksXG4gIFNldFByb3RvdHlwZUdldFNpemU6IGdldEdldHRlcihTZXQsICdzaXplJyksXG4gIFNldFByb3RvdHlwZVZhbHVlczogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTZXQucHJvdG90eXBlLnZhbHVlcyksXG4gIFN0cmluZyxcbiAgU3RyaW5nUHJvdG90eXBlQ2hhckNvZGVBdDpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdCksXG4gIFN0cmluZ1Byb3RvdHlwZUNvZGVQb2ludEF0OlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCksXG4gIFN0cmluZ1Byb3RvdHlwZUVuZHNXaXRoOlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCksXG4gIFN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzOlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyksXG4gIFN0cmluZ1Byb3RvdHlwZUluZGV4T2Y6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLmluZGV4T2YpLFxuICBTdHJpbmdQcm90b3R5cGVMYXN0SW5kZXhPZjpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUubGFzdEluZGV4T2YpLFxuICBTdHJpbmdQcm90b3R5cGVOb3JtYWxpemU6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSksXG4gIFN0cmluZ1Byb3RvdHlwZVBhZEVuZDpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUucGFkRW5kKSxcbiAgU3RyaW5nUHJvdG90eXBlUGFkU3RhcnQ6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0KSxcbiAgU3RyaW5nUHJvdG90eXBlUmVwZWF0OiBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUucmVwZWF0KSxcbiAgU3RyaW5nUHJvdG90eXBlUmVwbGFjZTpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSksXG4gIFN0cmluZ1Byb3RvdHlwZVJlcGxhY2VBbGw6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VBbGwpLFxuICBTdHJpbmdQcm90b3R5cGVTbGljZTogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnNsaWNlKSxcbiAgU3RyaW5nUHJvdG90eXBlU3BsaXQ6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS5zcGxpdCksXG4gIFN0cmluZ1Byb3RvdHlwZVN0YXJ0c1dpdGg6IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSxcbiAgU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2U6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKSxcbiAgU3RyaW5nUHJvdG90eXBlVHJpbTogRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTdHJpbmcucHJvdG90eXBlLnRyaW0pLFxuICBTdHJpbmdQcm90b3R5cGVWYWx1ZU9mOlxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLmJpbmQoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKSxcbiAgU3ltYm9sUHJvdG90eXBlVG9TdHJpbmc6XG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nKSxcbiAgU3ltYm9sUHJvdG90eXBlVmFsdWVPZjpcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbC5iaW5kKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZiksXG4gIFN5bWJvbEl0ZXJhdG9yOiBTeW1ib2wuaXRlcmF0b3IsXG4gIFN5bWJvbEZvcjogU3ltYm9sLmZvcixcbiAgU3ltYm9sVG9TdHJpbmdUYWc6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgVHlwZWRBcnJheVByb3RvdHlwZUdldExlbmd0aDogZ2V0dGVyQ2FsbGVyKCdsZW5ndGgnKSxcbiAgVWludDhBcnJheSxcbiAgdW5jdXJyeVRoaXMsXG59O1xuXG4vLyBOb2RlIDE0XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICghU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsKSB7XG4gIC8vIExpZnRlZCBhbmQgc2ltcGxpZmllZCBmcm9tIGNvcmUtanMgZm9yIHRoZSBtb21lbnQuICBXaWxsIHJlbW92ZSB3aGVuIHdlXG4gIC8vIGRyb3Agbm9kZSAxNCBzdXBwb3J0LlxuXG4gIGZ1bmN0aW9uIHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpIHtcbiAgICBpZiAoaXQgPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICAgIHJldHVybiBpdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgICBjb25zdCB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICBjb25zdCBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIGxldCBzeW1ib2xzID0gL1xcJChbJCYnYF18XFxkezEsMn0pLztcbiAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuYW1lZENhcHR1cmVzID0gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUobmFtZWRDYXB0dXJlcykpO1xuICAgICAgc3ltYm9scyA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9fDxbXj5dKj4pL2c7XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlbWVudC5yZXBsYWNlKHN5bWJvbHMsIChtYXRjaCwgY2gpID0+IHtcbiAgICAgIGxldCBjYXB0dXJlO1xuICAgICAgc3dpdGNoIChjaC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgICAgY2FzZSAnYCc6IHJldHVybiBzdHIuc2xpY2UoMCwgcG9zaXRpb24pO1xuICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXB0dXJlID0gbmFtZWRDYXB0dXJlc1tjaC5zbGljZSgxLCAtMSldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7IC8vIFxcZFxcZD9cbiAgICAgICAgICBjb25zdCBuID0gK2NoO1xuICAgICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgaWYgKG4gPiBtKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gTWF0aC5mbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmUgPT09IHVuZGVmaW5lZCA/ICcnIDogY2FwdHVyZTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaW1vcmRpYWxzLmV4cG9ydHMuU3RyaW5nUHJvdG90eXBlUmVwbGFjZUFsbCA9IChzdHIsIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpID0+IHtcbiAgICBjb25zdCBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZShzdHIpO1xuICAgIGxldCBJU19SRUdfRVhQLCBmbGFncywgcmVwbGFjZXIsIHJlcGxhY2VtZW50O1xuICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgbGV0IGVuZE9mTGFzdE1hdGNoID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgaWYgKHNlYXJjaFZhbHVlICE9IG51bGwpIHtcbiAgICAgIElTX1JFR19FWFAgPSBzZWFyY2hWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgIGlmIChJU19SRUdfRVhQKSB7XG4gICAgICAgIGZsYWdzID0gc2VhcmNoVmFsdWUuZmxhZ3M7XG4gICAgICAgIGlmICghfmZsYWdzLmluZGV4T2YoJ2cnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2AucmVwbGFjZUFsbGAgZG9lcyBub3QgYWxsb3cgbm9uLWdsb2JhbCByZWdleGVzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcGxhY2VyID0gc2VhcmNoVmFsdWVbU3ltYm9sLnJlcGxhY2VdO1xuICAgICAgaWYgKHJlcGxhY2VyKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdHJpbmcgPSBTdHJpbmcoTyk7XG4gICAgY29uc3Qgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaFZhbHVlKTtcbiAgICBjb25zdCBmdW5jdGlvbmFsUmVwbGFjZSA9ICh0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nKTtcbiAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSBTdHJpbmcocmVwbGFjZVZhbHVlKTtcbiAgICBjb25zdCBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgIGNvbnN0IGFkdmFuY2VCeSA9IE1hdGgubWF4KDEsIHNlYXJjaExlbmd0aCk7XG4gICAgcG9zaXRpb24gPSBzdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcsIDApO1xuICAgIHdoaWxlIChwb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gZnVuY3Rpb25hbFJlcGxhY2UgP1xuICAgICAgICBTdHJpbmcocmVwbGFjZVZhbHVlKHNlYXJjaFN0cmluZywgcG9zaXRpb24sIHN0cmluZykpIDpcbiAgICAgICAgZ2V0U3Vic3RpdHV0aW9uKHNlYXJjaFN0cmluZywgc3RyaW5nLCBwb3NpdGlvbiwgW10sIHVuZGVmaW5lZCwgcmVwbGFjZVZhbHVlKTtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoZW5kT2ZMYXN0TWF0Y2gsIHBvc2l0aW9uKSArIHJlcGxhY2VtZW50O1xuICAgICAgZW5kT2ZMYXN0TWF0Y2ggPSBwb3NpdGlvbiArIHNlYXJjaExlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gc3RyaW5nLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiArIGFkdmFuY2VCeSk7XG4gICAgfVxuICAgIGlmIChlbmRPZkxhc3RNYXRjaCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoZW5kT2ZMYXN0TWF0Y2gpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxudmFyIHByaW1vcmRpYWxzRXhwb3J0cyA9IHByaW1vcmRpYWxzLmV4cG9ydHM7XG5cbmNvbnN0IEFMTF9QUk9YSUVTID0gbmV3IFdlYWtNYXAoKTtcblxuLy8gV3JhcCBQcm94eSdzIHRvIHJlbWVtYmVyIHRoZWlyIGRldGFpbHMuXG5jbGFzcyBQcnh5IHtcbiAgY29uc3RydWN0b3IodGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcCA9IG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpO1xuICAgIEFMTF9QUk9YSUVTLnNldChwLCBbdGFyZ2V0LCBoYW5kbGVyXSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgIHJldHVybiBwO1xuICB9XG4gIHN0YXRpYyBnZXRQcm94eURldGFpbHMob2JqLCBnZXRGdWxsUHJveHkgPSB0cnVlKSB7XG4gICAgY29uc3QgZGVldHMgPSBBTExfUFJPWElFUy5nZXQob2JqKTtcbiAgICBpZiAoIWRlZXRzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZ2V0RnVsbFByb3h5KSB7XG4gICAgICByZXR1cm4gZGVldHM7XG4gICAgfVxuICAgIHJldHVybiBkZWV0c1swXTtcbiAgfVxuICBzdGF0aWMgcmV2b2NhYmxlKHRhcmdldCwgaGFuZGxlcikge1xuICAgIGNvbnN0IHAgPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCBoYW5kbGVyKTtcbiAgICBBTExfUFJPWElFUy5zZXQocC5wcm94eSwgW3RhcmdldCwgaGFuZGxlcl0pO1xuICAgIGNvbnN0IHJldm9rZSA9IHAucmV2b2tlO1xuICAgIHAucmV2b2tlID0gKCkgPT4ge1xuICAgICAgQUxMX1BST1hJRVMuc2V0KHAucHJveHksIFtudWxsLCBudWxsXSk7XG4gICAgICByZXZva2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBwO1xuICB9XG59XG5cbnZhciBwcm94eSA9IHtcbiAgZ2V0UHJveHlEZXRhaWxzOiBQcnh5LmdldFByb3h5RGV0YWlscy5iaW5kKFByeHkpLFxuICBQcm94eTogUHJ4eSxcbn07XG5cbmNvbnN0IHByeHkgPSBwcm94eTtcbmNvbnN0IEFMTF9QUk9QRVJUSUVTID0gMDtcbmNvbnN0IE9OTFlfRU5VTUVSQUJMRSA9IDI7XG5jb25zdCBrUGVuZGluZyA9IFN5bWJvbCgna1BlbmRpbmcnKTtcbmNvbnN0IGtSZWplY3RlZCA9IFN5bWJvbCgna1JlamVjdGVkJyk7XG5cbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyhhLCBmaWx0ZXIgPSBPTkxZX0VOVU1FUkFCTEUpIHtcbiAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGEpO1xuICBjb25zdCByZXQgPSBbXTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZGVzYykpIHtcbiAgICBpZiAoIS9eKDB8WzEtOV1bMC05XSopJC8udGVzdChrKSB8fFxuICAgICAgICAocGFyc2VJbnQoaywgMTApID49ICgyICoqIDMyIC0gMSkpKSB7IC8vIEFycmF5cyBhcmUgbGltaXRlZCBpbiBzaXplXG4gICAgICBpZiAoKGZpbHRlciA9PT0gT05MWV9FTlVNRVJBQkxFKSAmJiAhdi5lbnVtZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0LnB1c2goayk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcyBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGEpKSB7XG4gICAgY29uc3QgdiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgcyk7XG4gICAgaWYgKChmaWx0ZXIgPT09IE9OTFlfRU5VTUVSQUJMRSkgJiYgIXYuZW51bWVyYWJsZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldC5wdXNoKHMpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciB1dGlsJDEgPSB7XG4gIGNvbnN0YW50czoge1xuICAgIGtQZW5kaW5nLFxuICAgIGtSZWplY3RlZCxcbiAgICBBTExfUFJPUEVSVElFUyxcbiAgICBPTkxZX0VOVU1FUkFCTEUsXG4gIH0sXG4gIGdldE93bk5vbkluZGV4UHJvcGVydGllcyxcbiAgZ2V0UHJvbWlzZURldGFpbHMoKSB7IHJldHVybiBba1BlbmRpbmcsIHVuZGVmaW5lZF07IH0sXG4gIGdldFByb3h5RGV0YWlsczogcHJ4eS5nZXRQcm94eURldGFpbHMsXG4gIFByb3h5OiBwcnh5LlByb3h5LFxuICBwcmV2aWV3RW50cmllcyh2YWwpIHtcbiAgICByZXR1cm4gW1tdLCBmYWxzZV07XG4gIH0sXG4gIGdldENvbnN0cnVjdG9yTmFtZSh2YWwpIHtcbiAgICBpZiAoIXZhbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICAgIH1cbiAgICBpZiAodmFsLmNvbnN0cnVjdG9yICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgIC8vIGUuZy4gW29iamVjdCBCb29sZWFuXVxuICAgIGNvbnN0IG0gPSBzdHIubWF0Y2goL15cXFtvYmplY3QgKFteXFxdXSspXFxdLyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBtWzFdO1xuICAgIH1cbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH0sXG4gIGdldEV4dGVybmFsVmFsdWUoKSB7IHJldHVybiBCaWdJbnQoMCk7IH0sXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgY29sb3JSZWdFeHAgPSAvXFx1MDAxYlxcW1xcZFxcZD9tL2c7XG5cbnZhciB1dGlsID0ge1xuICBjdXN0b21JbnNwZWN0U3ltYm9sOiBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpLFxuICBpc0Vycm9yKGUpIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEVycm9yO1xuICB9LFxuICBqb2luOiBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmpvaW4pLFxuICByZW1vdmVDb2xvcnMoc3RyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZS5jYWxsKHN0ciwgY29sb3JSZWdFeHAsICcnKTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGFzc2VydChwKSB7XG4gIGlmICghcCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG59XG5cbmFzc2VydC5mYWlsID0gZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn07XG5cbnZhciBhc3NlcnRfMSA9IGFzc2VydDtcblxuLyogZXNsaW50IG5vZGUtY29yZS9kb2N1bWVudGVkLWVycm9yczogXCJlcnJvclwiICovXG5cbnZhciBlcnJvcnM7XG52YXIgaGFzUmVxdWlyZWRFcnJvcnM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVFcnJvcnMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRFcnJvcnMpIHJldHVybiBlcnJvcnM7XG5cdGhhc1JlcXVpcmVkRXJyb3JzID0gMTtcblxuXHQvLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cblx0Ly8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuXHQvLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcblx0Ly8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuXHQvLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cblx0Y29uc3Qge1xuXHQgIEFycmF5SXNBcnJheSxcblx0ICBBcnJheVByb3RvdHlwZUluY2x1ZGVzLFxuXHQgIEFycmF5UHJvdG90eXBlSW5kZXhPZixcblx0ICBBcnJheVByb3RvdHlwZUpvaW4sXG5cdCAgQXJyYXlQcm90b3R5cGVQb3AsXG5cdCAgQXJyYXlQcm90b3R5cGVQdXNoLFxuXHQgIEFycmF5UHJvdG90eXBlU3BsaWNlLFxuXHQgIEVycm9yQ2FwdHVyZVN0YWNrVHJhY2UsXG5cdCAgT2JqZWN0RGVmaW5lUHJvcGVydHksXG5cdCAgUmVmbGVjdEFwcGx5LFxuXHQgIFJlZ0V4cFByb3RvdHlwZVRlc3QsXG5cdCAgU2FmZU1hcCxcblx0ICBTdHJpbmdQcm90b3R5cGVFbmRzV2l0aCxcblx0ICBTdHJpbmdQcm90b3R5cGVJbmNsdWRlcyxcblx0ICBTdHJpbmdQcm90b3R5cGVTbGljZSxcblx0ICBTdHJpbmdQcm90b3R5cGVUb0xvd2VyQ2FzZSxcblx0fSA9IHByaW1vcmRpYWxzRXhwb3J0cztcblxuXHRjb25zdCBtZXNzYWdlcyA9IG5ldyBTYWZlTWFwKCk7XG5cdGNvbnN0IGNvZGVzID0ge307XG5cblx0Y29uc3QgY2xhc3NSZWdFeHAgPSAvXihbQS1aXVthLXowLTldKikrJC87XG5cdC8vIFNvcnRlZCBieSBhIHJvdWdoIGVzdGltYXRlIG9uIG1vc3QgZnJlcXVlbnRseSB1c2VkIGVudHJpZXMuXG5cdGNvbnN0IGtUeXBlcyA9IFtcblx0ICAnc3RyaW5nJyxcblx0ICAnZnVuY3Rpb24nLFxuXHQgICdudW1iZXInLFxuXHQgICdvYmplY3QnLFxuXHQgIC8vIEFjY2VwdCAnRnVuY3Rpb24nIGFuZCAnT2JqZWN0JyBhcyBhbHRlcm5hdGl2ZSB0byB0aGUgbG93ZXIgY2FzZWQgdmVyc2lvbi5cblx0ICAnRnVuY3Rpb24nLFxuXHQgICdPYmplY3QnLFxuXHQgICdib29sZWFuJyxcblx0ICAnYmlnaW50Jyxcblx0ICAnc3ltYm9sJyxcblx0XTtcblxuXHRsZXQgdXNlclN0YWNrVHJhY2VMaW1pdDtcblx0Y29uc3Qgbm9kZUludGVybmFsUHJlZml4ID0gJ19fbm9kZV9pbnRlcm5hbF8nO1xuXG5cdC8vIExhemlseSBsb2FkZWRcblx0bGV0IGFzc2VydDtcblx0bGV0IGludGVybmFsVXRpbEluc3BlY3QgPSBudWxsO1xuXHRmdW5jdGlvbiBsYXp5SW50ZXJuYWxVdGlsSW5zcGVjdCgpIHtcblx0ICBpZiAoIWludGVybmFsVXRpbEluc3BlY3QpIHtcblx0ICAgIGludGVybmFsVXRpbEluc3BlY3QgPSByZXF1aXJlSW5zcGVjdCgpO1xuXHQgIH1cblx0ICByZXR1cm4gaW50ZXJuYWxVdGlsSW5zcGVjdDtcblx0fVxuXG5cdGNvbnN0IGFkZENvZGVUb05hbWUgPSBoaWRlU3RhY2tGcmFtZXMoZnVuY3Rpb24gYWRkQ29kZVRvTmFtZShlcnIsIG5hbWUsIGNvZGUpIHtcblx0ICAvLyBTZXQgdGhlIHN0YWNrXG5cdCAgZXJyID0gY2FwdHVyZUxhcmdlclN0YWNrVHJhY2UoZXJyKTtcblx0ICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG5cdCAgZXJyLm5hbWUgPSBgJHtuYW1lfSBbJHtjb2RlfV1gO1xuXHQgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG5cdCAgLy8gZnJvbSB0aGUgbmFtZS5cblx0ICBlcnIuc3RhY2s7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdCAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuXHQgIGRlbGV0ZSBlcnIubmFtZTtcblx0fSk7XG5cblx0ZnVuY3Rpb24gbWFrZU5vZGVFcnJvcldpdGhDb2RlKEJhc2UsIGtleSkge1xuXHQgIHJldHVybiBmdW5jdGlvbiBOb2RlRXJyb3IoLi4uYXJncykge1xuXHQgICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG5cdCAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuXHQgICAgY29uc3QgZXJyb3IgPSBuZXcgQmFzZSgpO1xuXHQgICAgLy8gUmVzZXQgdGhlIGxpbWl0IGFuZCBzZXR0aW5nIHRoZSBuYW1lIHByb3BlcnR5LlxuXHQgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG5cdCAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZShrZXksIGFyZ3MsIGVycm9yKTtcblx0ICAgIE9iamVjdERlZmluZVByb3BlcnR5KGVycm9yLCAnbWVzc2FnZScsIHtcblx0ICAgICAgdmFsdWU6IG1lc3NhZ2UsXG5cdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgfSk7XG5cdCAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShlcnJvciwgJ3RvU3RyaW5nJywge1xuXHQgICAgICB2YWx1ZSgpIHtcblx0ICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtrZXl9XTogJHt0aGlzLm1lc3NhZ2V9YDtcblx0ICAgICAgfSxcblx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHQgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICB9KTtcblx0ICAgIGFkZENvZGVUb05hbWUoZXJyb3IsIEJhc2UubmFtZSwga2V5KTtcblx0ICAgIGVycm9yLmNvZGUgPSBrZXk7XG5cdCAgICByZXR1cm4gZXJyb3I7XG5cdCAgfTtcblx0fVxuXG5cdC8vIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyB1bm5lY2Vzc2FyeSBmcmFtZXMgZnJvbSBOb2RlLmpzIGNvcmUgZXJyb3JzLlxuXHRmdW5jdGlvbiBoaWRlU3RhY2tGcmFtZXMoZm4pIHtcblx0ICAvLyBXZSByZW5hbWUgdGhlIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgaGlkZGVuIHRvIGN1dCBvZmYgdGhlIHN0YWNrdHJhY2Vcblx0ICAvLyBhdCB0aGUgb3V0ZXJtb3N0IG9uZVxuXHQgIGNvbnN0IGhpZGRlbiA9IG5vZGVJbnRlcm5hbFByZWZpeCArIGZuLm5hbWU7XG5cdCAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywgeyB2YWx1ZTogaGlkZGVuIH0pO1xuXHQgIHJldHVybiBmbjtcblx0fVxuXG5cdC8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIHRoZSBlcnJvciBjb2Rlcy4gT25seSB1c2VkIGhlcmUuIEV4cG9ydGVkXG5cdC8vICpvbmx5KiB0byBhbGxvdyBmb3IgdGVzdGluZy5cblx0ZnVuY3Rpb24gRShzeW0sIHZhbCwgZGVmKSB7XG5cdCAgLy8gU3BlY2lhbCBjYXNlIGZvciBTeXN0ZW1FcnJvciB0aGF0IGZvcm1hdHMgdGhlIGVycm9yIG1lc3NhZ2UgZGlmZmVyZW50bHlcblx0ICAvLyBUaGUgU3lzdGVtRXJyb3JzIG9ubHkgaGF2ZSBTeXN0ZW1FcnJvciBhcyB0aGVpciBiYXNlIGNsYXNzZXMuXG5cdCAgbWVzc2FnZXMuc2V0KHN5bSwgdmFsKTtcblx0ICBjb2Rlc1tzeW1dID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGRlZiwgc3ltKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1lc3NhZ2Uoa2V5LCBhcmdzLCBzZWxmKSB7XG5cdCAgY29uc3QgbXNnID0gbWVzc2FnZXMuZ2V0KGtleSk7XG5cblx0ICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IGFzc2VydF8xO1xuXG5cdCAgYXNzZXJ0KHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpO1xuXHQgIGFzc2VydChcblx0ICAgIG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsIC8vIERlZmF1bHQgb3B0aW9ucyBkbyBub3QgY291bnQuXG5cdCAgICBgQ29kZTogJHtrZXl9OyBUaGUgcHJvdmlkZWQgYXJndW1lbnRzIGxlbmd0aCAoJHthcmdzLmxlbmd0aH0pIGRvZXMgbm90IGAgK1xuXHQgICAgICBgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7bXNnLmxlbmd0aH0pLmAsXG5cdCAgKTtcblx0ICByZXR1cm4gUmVmbGVjdEFwcGx5KG1zZywgc2VsZiwgYXJncyk7XG5cdH1cblxuXHRjb25zdCBjYXB0dXJlTGFyZ2VyU3RhY2tUcmFjZSA9IGhpZGVTdGFja0ZyYW1lcyhcblx0ICBmdW5jdGlvbiBjYXB0dXJlTGFyZ2VyU3RhY2tUcmFjZShlcnIpIHtcblx0ICAgIHVzZXJTdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG5cdCAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBJbmZpbml0eTtcblx0ICAgIEVycm9yQ2FwdHVyZVN0YWNrVHJhY2UoZXJyKTtcblx0ICAgIC8vIFJlc2V0IHRoZSBsaW1pdFxuXHQgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gdXNlclN0YWNrVHJhY2VMaW1pdDtcblxuXHQgICAgcmV0dXJuIGVycjtcblx0ICB9KTtcblxuXHRsZXQgbWF4U3RhY2tfRXJyb3JOYW1lO1xuXHRsZXQgbWF4U3RhY2tfRXJyb3JNZXNzYWdlO1xuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGBlcnIubmFtZWAgYW5kIGBlcnIubWVzc2FnZWAgYXJlIGVxdWFsIHRvIGVuZ2luZS1zcGVjaWZpY1xuXHQgKiB2YWx1ZXMgaW5kaWNhdGluZyBtYXggY2FsbCBzdGFjayBzaXplIGhhcyBiZWVuIGV4Y2VlZGVkLlxuXHQgKiBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIgaW4gVjguXG5cdCAqIEBwYXJhbSB7RXJyb3J9IGVyclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzU3RhY2tPdmVyZmxvd0Vycm9yKGVycikge1xuXHQgIGlmIChtYXhTdGFja19FcnJvck1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgZnVuY3Rpb24gb3ZlcmZsb3dTdGFjaygpIHsgb3ZlcmZsb3dTdGFjaygpOyB9XG5cdCAgICAgIG92ZXJmbG93U3RhY2soKTtcblx0ICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICBtYXhTdGFja19FcnJvck1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblx0ICAgICAgbWF4U3RhY2tfRXJyb3JOYW1lID0gZXJyLm5hbWU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGVyciAmJiBlcnIubmFtZSA9PT0gbWF4U3RhY2tfRXJyb3JOYW1lICYmXG5cdCAgICAgICAgIGVyci5tZXNzYWdlID09PSBtYXhTdGFja19FcnJvck1lc3NhZ2U7XG5cdH1cblxuXHRlcnJvcnMgPSB7XG5cdCAgY29kZXMsXG5cdCAgaGlkZVN0YWNrRnJhbWVzLFxuXHQgIGlzU3RhY2tPdmVyZmxvd0Vycm9yLFxuXHR9O1xuXG5cdEUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcblx0ICAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkgPT4ge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblx0ICAgIGlmICghQXJyYXlJc0FycmF5KGV4cGVjdGVkKSkge1xuXHQgICAgICBleHBlY3RlZCA9IFtleHBlY3RlZF07XG5cdCAgICB9XG5cblx0ICAgIGxldCBtc2cgPSAnVGhlICc7XG5cdCAgICBpZiAoU3RyaW5nUHJvdG90eXBlRW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG5cdCAgICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcblx0ICAgICAgbXNnICs9IGAke25hbWV9IGA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBjb25zdCB0eXBlID0gU3RyaW5nUHJvdG90eXBlSW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuXHQgICAgICBtc2cgKz0gYFwiJHtuYW1lfVwiICR7dHlwZX0gYDtcblx0ICAgIH1cblx0ICAgIG1zZyArPSAnbXVzdCBiZSAnO1xuXG5cdCAgICBjb25zdCB0eXBlcyA9IFtdO1xuXHQgICAgY29uc3QgaW5zdGFuY2VzID0gW107XG5cdCAgICBjb25zdCBvdGhlciA9IFtdO1xuXG5cdCAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGV4cGVjdGVkKSB7XG5cdCAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuXHQgICAgICAgICAgICAgJ0FsbCBleHBlY3RlZCBlbnRyaWVzIGhhdmUgdG8gYmUgb2YgdHlwZSBzdHJpbmcnKTtcblx0ICAgICAgaWYgKEFycmF5UHJvdG90eXBlSW5jbHVkZXMoa1R5cGVzLCB2YWx1ZSkpIHtcblx0ICAgICAgICBBcnJheVByb3RvdHlwZVB1c2godHlwZXMsIFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlKHZhbHVlKSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoUmVnRXhwUHJvdG90eXBlVGVzdChjbGFzc1JlZ0V4cCwgdmFsdWUpKSB7XG5cdCAgICAgICAgQXJyYXlQcm90b3R5cGVQdXNoKGluc3RhbmNlcywgdmFsdWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGFzc2VydCh2YWx1ZSAhPT0gJ29iamVjdCcsXG5cdCAgICAgICAgICAgICAgICdUaGUgdmFsdWUgXCJvYmplY3RcIiBzaG91bGQgYmUgd3JpdHRlbiBhcyBcIk9iamVjdFwiJyk7XG5cdCAgICAgICAgQXJyYXlQcm90b3R5cGVQdXNoKG90aGVyLCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gU3BlY2lhbCBoYW5kbGUgYG9iamVjdGAgaW4gY2FzZSBvdGhlciBpbnN0YW5jZXMgYXJlIGFsbG93ZWQgdG8gb3V0bGluZVxuXHQgICAgLy8gdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gZWFjaCBvdGhlci5cblx0ICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICBjb25zdCBwb3MgPSBBcnJheVByb3RvdHlwZUluZGV4T2YodHlwZXMsICdvYmplY3QnKTtcblx0ICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcblx0ICAgICAgICBBcnJheVByb3RvdHlwZVNwbGljZSh0eXBlcywgcG9zLCAxKTtcblx0ICAgICAgICBBcnJheVByb3RvdHlwZVB1c2goaW5zdGFuY2VzLCAnT2JqZWN0Jyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgaWYgKHR5cGVzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXlQcm90b3R5cGVQb3AodHlwZXMpO1xuXHQgICAgICAgIG1zZyArPSBgb25lIG9mIHR5cGUgJHtBcnJheVByb3RvdHlwZUpvaW4odHlwZXMsICcsICcpfSwgb3IgJHtsYXN0fWA7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZXMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgbXNnICs9IGBvbmUgb2YgdHlwZSAke3R5cGVzWzBdfSBvciAke3R5cGVzWzFdfWA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgbXNnICs9IGBvZiB0eXBlICR7dHlwZXNbMF19YDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDAgfHwgb3RoZXIubGVuZ3RoID4gMClcblx0ICAgICAgICBtc2cgKz0gJyBvciAnO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDApIHtcblx0ICAgICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5UHJvdG90eXBlUG9wKGluc3RhbmNlcyk7XG5cdCAgICAgICAgbXNnICs9XG5cdCAgICAgICAgICBgYW4gaW5zdGFuY2Ugb2YgJHtBcnJheVByb3RvdHlwZUpvaW4oaW5zdGFuY2VzLCAnLCAnKX0sIG9yICR7bGFzdH1gO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG1zZyArPSBgYW4gaW5zdGFuY2Ugb2YgJHtpbnN0YW5jZXNbMF19YDtcblx0ICAgICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICAgICAgbXNnICs9IGAgb3IgJHtpbnN0YW5jZXNbMV19YDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDApXG5cdCAgICAgICAgbXNnICs9ICcgb3IgJztcblx0ICAgIH1cblxuXHQgICAgaWYgKG90aGVyLmxlbmd0aCA+IDApIHtcblx0ICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXlQcm90b3R5cGVQb3Aob3RoZXIpO1xuXHQgICAgICAgIG1zZyArPSBgb25lIG9mICR7QXJyYXlQcm90b3R5cGVKb2luKG90aGVyLCAnLCAnKX0sIG9yICR7bGFzdH1gO1xuXHQgICAgICB9IGVsc2UgaWYgKG90aGVyLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICAgIG1zZyArPSBgb25lIG9mICR7b3RoZXJbMF19IG9yICR7b3RoZXJbMV19YDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2Uob3RoZXJbMF0pICE9PSBvdGhlclswXSlcblx0ICAgICAgICAgIG1zZyArPSAnYW4gJztcblx0ICAgICAgICBtc2cgKz0gYCR7b3RoZXJbMF19YDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoYWN0dWFsID09IG51bGwpIHtcblx0ICAgICAgbXNnICs9IGAuIFJlY2VpdmVkICR7YWN0dWFsfWA7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICdmdW5jdGlvbicgJiYgYWN0dWFsLm5hbWUpIHtcblx0ICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIGZ1bmN0aW9uICR7YWN0dWFsLm5hbWV9YDtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgaWYgKGFjdHVhbC5jb25zdHJ1Y3RvciAmJiBhY3R1YWwuY29uc3RydWN0b3IubmFtZSkge1xuXHQgICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCBhbiBpbnN0YW5jZSBvZiAke2FjdHVhbC5jb25zdHJ1Y3Rvci5uYW1lfWA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY29uc3QgaW5zcGVjdGVkID0gbGF6eUludGVybmFsVXRpbEluc3BlY3QoKVxuXHQgICAgICAgICAgLmluc3BlY3QoYWN0dWFsLCB7IGRlcHRoOiAtMSB9KTtcblx0ICAgICAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgJHtpbnNwZWN0ZWR9YDtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbGV0IGluc3BlY3RlZCA9IGxhenlJbnRlcm5hbFV0aWxJbnNwZWN0KClcblx0ICAgICAgICAuaW5zcGVjdChhY3R1YWwsIHsgY29sb3JzOiBmYWxzZSB9KTtcblx0ICAgICAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAyNSlcblx0ICAgICAgICBpbnNwZWN0ZWQgPSBgJHtTdHJpbmdQcm90b3R5cGVTbGljZShpbnNwZWN0ZWQsIDAsIDI1KX0uLi5gO1xuXHQgICAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9ICgke2luc3BlY3RlZH0pYDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBtc2c7XG5cdCAgfSwgVHlwZUVycm9yKTtcblx0cmV0dXJuIGVycm9ycztcbn1cblxuY29uc3QgeyBnZXRDb25zdHJ1Y3Rvck5hbWUgfSA9IHV0aWwkMTtcblxuLy8gRnJvbSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuLyogYzggaWdub3JlIHN0YXJ0ICovIC8vIG9ubHkgbmVlZGVkIGZvciBub2RlIDEwXG4oZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdfX21hZ2ljX18nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB9KTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIF9fbWFnaWNfXy5nbG9iYWxUaGlzID0gX19tYWdpY19fO1xuICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX187XG59KCkpO1xuLyogYzggaWdub3JlIHN0b3AgKi9cblxuZnVuY3Rpb24gY29uc3RydWN0b3JOYW1lZCh2YWwsIC4uLm5hbWUpIHtcbiAgLy8gUGFzcyBpbiBuYW1lcyByYXRoZXIgdGhhbiB0eXBlcywgaW4gY2FzZSBTaGFyZWRBcnJheUJ1ZmZlciAoZS5nLikgaXNuJ3RcbiAgLy8gaW4geW91ciBicm93c2VyXG4gIGZvciAoY29uc3QgbiBvZiBuYW1lKSB7XG4gICAgY29uc3QgdHlwID0gZ2xvYmFsVGhpc1tuXTtcbiAgICBpZiAodHlwKSB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgdHlwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBpbnN0YW5jZU9mIGRvZXNuJ3Qgd29yayBhY3Jvc3Mgdm0gYm91bmRhcmllcywgc28gY2hlY2sgdGhlIHdob2xlXG4gIC8vIGluaGVyaXRhbmNlIGNoYWluXG4gIHdoaWxlICh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5hbWUuaW5kZXhPZihnZXRDb25zdHJ1Y3Rvck5hbWUodmFsKSkgPj0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhbCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3goY2xzKSB7XG4gIHJldHVybiAodmFsKSA9PiB7XG4gICAgaWYgKCFjb25zdHJ1Y3Rvck5hbWVkKHZhbCwgY2xzLm5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjbHMucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuY29uc3QgaXNTdHJpbmdPYmplY3QgPSBjaGVja0JveChTdHJpbmcpO1xuY29uc3QgaXNOdW1iZXJPYmplY3QgPSBjaGVja0JveChOdW1iZXIpO1xuY29uc3QgaXNCb29sZWFuT2JqZWN0ID0gY2hlY2tCb3goQm9vbGVhbik7XG5jb25zdCBpc0JpZ0ludE9iamVjdCA9IGNoZWNrQm94KEJpZ0ludCk7XG5jb25zdCBpc1N5bWJvbE9iamVjdCA9IGNoZWNrQm94KFN5bWJvbCk7XG5cbnZhciB0eXBlcyA9IHtcbiAgaXNBc3luY0Z1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc3RhcnRzV2l0aCgnYXN5bmMnKTtcbiAgfSxcbiAgaXNHZW5lcmF0b3JGdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpICYmXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLm1hdGNoKC9eKGFzeW5jXFxzKyk/ZnVuY3Rpb24gKlxcKi8pO1xuICB9LFxuICBpc0FueUFycmF5QnVmZmVyKHZhbCkge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWVkKHZhbCwgJ0FycmF5QnVmZmVyJywgJ1NoYXJlZEFycmF5QnVmZmVyJyk7XG4gIH0sXG4gIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZWQodmFsLCAnQXJyYXlCdWZmZXInKTtcbiAgfSxcbiAgaXNBcmd1bWVudHNPYmplY3QodmFsKSB7XG4gICAgY29uc3QgY29uZCA9ICh2YWwgIT09IG51bGwpICYmXG4gICAgICAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpICYmXG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgICAodHlwZW9mIHZhbC5sZW5ndGggPT09ICdudW1iZXInKSAmJlxuICAgICAgKHZhbC5sZW5ndGggPT09ICh2YWwubGVuZ3RoIHwgMCkpICYmXG4gICAgICAodmFsLmxlbmd0aCA+PSAwKTtcbiAgICBpZiAoY29uZCkge1xuICAgICAgY29uc3QgcHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsLCAnY2FsbGVlJyk7XG4gICAgICByZXR1cm4gcHJvcCAmJiAhcHJvcC5lbnVtZXJhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGlzQm94ZWRQcmltaXRpdmUodmFsKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbCkgfHxcbiAgICAgIGlzU3RyaW5nT2JqZWN0KHZhbCkgfHxcbiAgICAgIGlzQm9vbGVhbk9iamVjdCh2YWwpIHx8XG4gICAgICBpc0JpZ0ludE9iamVjdCh2YWwpIHx8XG4gICAgICBpc1N5bWJvbE9iamVjdCh2YWwpO1xuICB9LFxuICBpc0RhdGFWaWV3KHZhbCkge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWVkKHZhbCwgJ0RhdGFWaWV3Jyk7XG4gIH0sXG4gIGlzRXh0ZXJuYWwodmFsKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JykgJiZcbiAgICAgIChPYmplY3QuaXNGcm96ZW4odmFsKSkgJiZcbiAgICAgIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSA9PSBudWxsKTtcbiAgfSxcbiAgaXNNYXAodmFsKSB7XG4gICAgaWYgKCFjb25zdHJ1Y3Rvck5hbWVkKHZhbCwgJ01hcCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB2YWwuaGFzKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBpc01hcEl0ZXJhdG9yKHZhbCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCkpID09PVxuICAgICAgJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG4gIH0sXG4gIGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbCkge1xuICAgIC8vIFRPRE86IHRoaXMgaXMgd2VhayBhbmQgZWFzaWx5IGZha2VkXG4gICAgcmV0dXJuIHZhbCAmJlxuICAgICAgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSAmJlxuICAgICAgKHZhbFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJyk7XG4gIH0sXG4gIGlzTmF0aXZlRXJyb3IodmFsKSB7XG4gICAgcmV0dXJuICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgJiYgY29uc3RydWN0b3JOYW1lZChcbiAgICAgIHZhbCxcbiAgICAgICdFcnJvcicsXG4gICAgICAnRXZhbEVycm9yJyxcbiAgICAgICdSYW5nZUVycm9yJyxcbiAgICAgICdSZWZlcmVuY2VFcnJvcicsXG4gICAgICAnU3ludGF4RXJyb3InLFxuICAgICAgJ1R5cGVFcnJvcicsXG4gICAgICAnVVJJRXJyb3InLFxuICAgICAgJ0FnZ3JlZ2F0ZUVycm9yJyk7XG4gIH0sXG4gIGlzUHJvbWlzZSh2YWwpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lZCh2YWwsICdQcm9taXNlJyk7XG4gIH0sXG4gIGlzU2V0KHZhbCkge1xuICAgIGlmICghY29uc3RydWN0b3JOYW1lZCh2YWwsICdTZXQnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFsLmhhcygpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaXNTZXRJdGVyYXRvcih2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpKSA9PT1cbiAgICAgICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xuICB9LFxuICBpc1dlYWtNYXAodmFsKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZWQodmFsLCAnV2Vha01hcCcpO1xuICB9LFxuICBpc1dlYWtTZXQodmFsKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZWQodmFsLCAnV2Vha1NldCcpO1xuICB9LFxuICBpc1JlZ0V4cCh2YWwpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lZCh2YWwsICdSZWdFeHAnKTtcbiAgfSxcbiAgaXNEYXRlKHZhbCkge1xuICAgIGlmIChjb25zdHJ1Y3Rvck5hbWVkKHZhbCwgJ0RhdGUnKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbCk7IC8vIFRocm93cyBmb3IgcHNldWRvLWRhdGVzXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIElnbm9yZWRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBpc1R5cGVkQXJyYXkodmFsKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yTmFtZWQoXG4gICAgICB2YWwsXG4gICAgICAnSW50OEFycmF5JyxcbiAgICAgICdVaW50OEFycmF5JyxcbiAgICAgICdVaW50OENsYW1wZWRBcnJheScsXG4gICAgICAnSW50MTZBcnJheScsXG4gICAgICAnVWludDE2QXJyYXknLFxuICAgICAgJ0ludDMyQXJyYXknLFxuICAgICAgJ1VpbnQzMkFycmF5JyxcbiAgICAgICdGbG9hdDMyQXJyYXknLFxuICAgICAgJ0Zsb2F0NjRBcnJheScsXG4gICAgICAnQmlnSW50NjRBcnJheScsXG4gICAgICAnQmlnVWludDY0QXJyYXknLFxuICAgICk7XG4gIH0sXG4gIGlzU3RyaW5nT2JqZWN0LFxuICBpc051bWJlck9iamVjdCxcbiAgaXNCb29sZWFuT2JqZWN0LFxuICBpc0JpZ0ludE9iamVjdCxcbiAgaXNTeW1ib2xPYmplY3QsXG59O1xuXG52YXIgcmVhbG0gPSB7fTtcblxuLy8gVGhpcyBpcyBhIHNuYXBzaG90IGZyb20gbm9kZSAxOC4xMS4wXG5jb25zdCBidWlsdGluTW9kdWxlcyA9IFtcbiAgJ19odHRwX2FnZW50JyxcbiAgJ19odHRwX2NsaWVudCcsXG4gICdfaHR0cF9jb21tb24nLFxuICAnX2h0dHBfaW5jb21pbmcnLFxuICAnX2h0dHBfb3V0Z29pbmcnLFxuICAnX2h0dHBfc2VydmVyJyxcbiAgJ19zdHJlYW1fZHVwbGV4JyxcbiAgJ19zdHJlYW1fcGFzc3Rocm91Z2gnLFxuICAnX3N0cmVhbV9yZWFkYWJsZScsXG4gICdfc3RyZWFtX3RyYW5zZm9ybScsXG4gICdfc3RyZWFtX3dyYXAnLFxuICAnX3N0cmVhbV93cml0YWJsZScsXG4gICdfdGxzX2NvbW1vbicsXG4gICdfdGxzX3dyYXAnLFxuICAnYXNzZXJ0JyxcbiAgJ2Fzc2VydC9zdHJpY3QnLFxuICAnYXN5bmNfaG9va3MnLFxuICAnYnVmZmVyJyxcbiAgJ2NoaWxkX3Byb2Nlc3MnLFxuICAnY2x1c3RlcicsXG4gICdjb25zb2xlJyxcbiAgJ2NvbnN0YW50cycsXG4gICdjcnlwdG8nLFxuICAnZGdyYW0nLFxuICAnZGlhZ25vc3RpY3NfY2hhbm5lbCcsXG4gICdkbnMnLFxuICAnZG5zL3Byb21pc2VzJyxcbiAgJ2RvbWFpbicsXG4gICdldmVudHMnLFxuICAnZnMnLFxuICAnZnMvcHJvbWlzZXMnLFxuICAnaHR0cCcsXG4gICdodHRwMicsXG4gICdodHRwcycsXG4gICdpbnNwZWN0b3InLFxuICAnbW9kdWxlJyxcbiAgJ01vZHVsZScsXG4gICduZXQnLFxuICAnb3MnLFxuICAncGF0aCcsXG4gICdwYXRoL3Bvc2l4JyxcbiAgJ3BhdGgvd2luMzInLFxuICAncGVyZl9ob29rcycsXG4gICdwcm9jZXNzJyxcbiAgJ3B1bnljb2RlJyxcbiAgJ3F1ZXJ5c3RyaW5nJyxcbiAgJ3JlYWRsaW5lJyxcbiAgJ3JlYWRsaW5lL3Byb21pc2VzJyxcbiAgJ3JlcGwnLFxuICAnc3RyZWFtJyxcbiAgJ3N0cmVhbS9jb25zdW1lcnMnLFxuICAnc3RyZWFtL3Byb21pc2VzJyxcbiAgJ3N0cmVhbS93ZWInLFxuICAnc3RyaW5nX2RlY29kZXInLFxuICAnc3lzJyxcbiAgJ3RpbWVycycsXG4gICd0aW1lcnMvcHJvbWlzZXMnLFxuICAndGxzJyxcbiAgJ3RyYWNlX2V2ZW50cycsXG4gICd0dHknLFxuICAndXJsJyxcbiAgJ3V0aWwnLFxuICAndXRpbC90eXBlcycsXG4gICd2OCcsXG4gICd2bScsXG4gICd3YXNpJyxcbiAgJ3dvcmtlcl90aHJlYWRzJyxcbiAgJ3psaWInLFxuXTtcblxucmVhbG0uQnVpbHRpbk1vZHVsZSA9IHtcbiAgZXhpc3RzKHMpIHtcbiAgICByZXR1cm4gcy5zdGFydHNXaXRoKCdpbnRlcm5hbC8nKSB8fCBidWlsdGluTW9kdWxlcy5pbmRleE9mKHMpICE9PSAtMTtcbiAgfSxcbn07XG5cbnZhciB2YWxpZGF0b3JzO1xudmFyIGhhc1JlcXVpcmVkVmFsaWRhdG9ycztcblxuZnVuY3Rpb24gcmVxdWlyZVZhbGlkYXRvcnMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRWYWxpZGF0b3JzKSByZXR1cm4gdmFsaWRhdG9ycztcblx0aGFzUmVxdWlyZWRWYWxpZGF0b3JzID0gMTtcblxuXHRjb25zdCB7XG5cdCAgQXJyYXlJc0FycmF5LFxuXHR9ID0gcHJpbW9yZGlhbHNFeHBvcnRzO1xuXG5cdGNvbnN0IHtcblx0ICBoaWRlU3RhY2tGcmFtZXMsXG5cdCAgY29kZXM6IHtcblx0ICAgIEVSUl9JTlZBTElEX0FSR19UWVBFLFxuXHQgIH0sXG5cdH0gPSByZXF1aXJlRXJyb3JzKCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHBhcmFtIHt7XG5cdCAqICAgYWxsb3dBcnJheT86IGJvb2xlYW4sXG5cdCAqICAgYWxsb3dGdW5jdGlvbj86IGJvb2xlYW4sXG5cdCAqICAgbnVsbGFibGU/OiBib29sZWFuXG5cdCAqIH19IFtvcHRpb25zXVxuXHQgKi9cblx0Y29uc3QgdmFsaWRhdGVPYmplY3QgPSBoaWRlU3RhY2tGcmFtZXMoXG5cdCAgKHZhbHVlLCBuYW1lLCBvcHRpb25zKSA9PiB7XG5cdCAgICBjb25zdCB1c2VEZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMgPT0gbnVsbDtcblx0ICAgIGNvbnN0IGFsbG93QXJyYXkgPSB1c2VEZWZhdWx0T3B0aW9ucyA/IGZhbHNlIDogb3B0aW9ucy5hbGxvd0FycmF5O1xuXHQgICAgY29uc3QgYWxsb3dGdW5jdGlvbiA9IHVzZURlZmF1bHRPcHRpb25zID8gZmFsc2UgOiBvcHRpb25zLmFsbG93RnVuY3Rpb247XG5cdCAgICBjb25zdCBudWxsYWJsZSA9IHVzZURlZmF1bHRPcHRpb25zID8gZmFsc2UgOiBvcHRpb25zLm51bGxhYmxlO1xuXHQgICAgaWYgKCghbnVsbGFibGUgJiYgdmFsdWUgPT09IG51bGwpIHx8XG5cdCAgICAgICAgKCFhbGxvd0FycmF5ICYmIEFycmF5SXNBcnJheSh2YWx1ZSkpIHx8XG5cdCAgICAgICAgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgJiYgKFxuXHQgICAgICAgICAgIWFsbG93RnVuY3Rpb24gfHwgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nXG5cdCAgICAgICAgKSkpIHtcblx0ICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdPYmplY3QnLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfSk7XG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIG5hbWUpIHtcblx0ICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcblx0ICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnc3RyaW5nJywgdmFsdWUpO1xuXHR9XG5cblx0dmFsaWRhdG9ycyA9IHtcblx0ICB2YWxpZGF0ZU9iamVjdCxcblx0ICB2YWxpZGF0ZVN0cmluZyxcblx0fTtcblx0cmV0dXJuIHZhbGlkYXRvcnM7XG59XG5cbnZhciBjb25zdGFudHM7XG52YXIgaGFzUmVxdWlyZWRDb25zdGFudHM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVDb25zdGFudHMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRDb25zdGFudHMpIHJldHVybiBjb25zdGFudHM7XG5cdGhhc1JlcXVpcmVkQ29uc3RhbnRzID0gMTtcblxuXHRjb25zdGFudHMgPSB7XG5cdCAgLy8gTm9uLWFscGhhYmV0aWMgY2hhcnMuXG5cdCAgQ0hBUl9ET1Q6IDQ2LCAvKiAuICovXG5cdCAgQ0hBUl9GT1JXQVJEX1NMQVNIOiA0NywgLyogLyAqL1xuXHQgIENIQVJfQkFDS1dBUkRfU0xBU0g6IDkyLCAvKiBcXCAqL1xuXHR9O1xuXHRyZXR1cm4gY29uc3RhbnRzO1xufVxuXG52YXIgcGF0aDtcbnZhciBoYXNSZXF1aXJlZFBhdGg7XG5cbmZ1bmN0aW9uIHJlcXVpcmVQYXRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUGF0aCkgcmV0dXJuIHBhdGg7XG5cdGhhc1JlcXVpcmVkUGF0aCA9IDE7XG5cblx0Y29uc3Qge1xuXHQgIFN0cmluZ1Byb3RvdHlwZUNoYXJDb2RlQXQsXG5cdCAgU3RyaW5nUHJvdG90eXBlTGFzdEluZGV4T2YsXG5cdCAgU3RyaW5nUHJvdG90eXBlU2xpY2UsXG5cdH0gPSBwcmltb3JkaWFsc0V4cG9ydHM7XG5cblx0Y29uc3Qge1xuXHQgIENIQVJfRE9ULFxuXHQgIENIQVJfRk9SV0FSRF9TTEFTSCxcblx0fSA9IHJlcXVpcmVDb25zdGFudHMoKTtcblx0Y29uc3Qge1xuXHQgIHZhbGlkYXRlU3RyaW5nLFxuXHR9ID0gcmVxdWlyZVZhbGlkYXRvcnMoKTtcblxuXHRmdW5jdGlvbiBwb3NpeEN3ZCgpIHtcblx0ICByZXR1cm4gJy8nOyAvLyBGYWtlIGZvciB0aGUgd2ViIGNhc2Vcblx0fVxuXG5cdGZ1bmN0aW9uIGlzUG9zaXhQYXRoU2VwYXJhdG9yKGNvZGUpIHtcblx0ICByZXR1cm4gY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuXHR9XG5cblx0Ly8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZyhwYXRoLCBhbGxvd0Fib3ZlUm9vdCwgc2VwYXJhdG9yLCBpc1BhdGhTZXBhcmF0b3IpIHtcblx0ICBsZXQgcmVzID0gJyc7XG5cdCAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcblx0ICBsZXQgbGFzdFNsYXNoID0gLTE7XG5cdCAgbGV0IGRvdHMgPSAwO1xuXHQgIGxldCBjb2RlID0gMDtcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgKytpKSB7XG5cdCAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKVxuXHQgICAgICBjb2RlID0gU3RyaW5nUHJvdG90eXBlQ2hhckNvZGVBdChwYXRoLCBpKTtcblx0ICAgIGVsc2UgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSlcblx0ICAgICAgYnJlYWs7XG5cdCAgICBlbHNlXG5cdCAgICAgIGNvZGUgPSBDSEFSX0ZPUldBUkRfU0xBU0g7XG5cblx0ICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcblx0ICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkgOyBlbHNlIGlmIChkb3RzID09PSAyKSB7XG5cdCAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8XG5cdCAgICAgICAgICAgIFN0cmluZ1Byb3RvdHlwZUNoYXJDb2RlQXQocmVzLCByZXMubGVuZ3RoIC0gMSkgIT09IENIQVJfRE9UIHx8XG5cdCAgICAgICAgICAgIFN0cmluZ1Byb3RvdHlwZUNoYXJDb2RlQXQocmVzLCByZXMubGVuZ3RoIC0gMikgIT09IENIQVJfRE9UKSB7XG5cdCAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSBTdHJpbmdQcm90b3R5cGVMYXN0SW5kZXhPZihyZXMsIHNlcGFyYXRvcik7XG5cdCAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICByZXMgPSAnJztcblx0ICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgcmVzID0gU3RyaW5nUHJvdG90eXBlU2xpY2UocmVzLCAwLCBsYXN0U2xhc2hJbmRleCk7XG5cdCAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPVxuXHQgICAgICAgICAgICAgICAgcmVzLmxlbmd0aCAtIDEgLSBTdHJpbmdQcm90b3R5cGVMYXN0SW5kZXhPZihyZXMsIHNlcGFyYXRvcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcblx0ICAgICAgICAgICAgZG90cyA9IDA7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHJlcyA9ICcnO1xuXHQgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG5cdCAgICAgICAgICAgIGRvdHMgPSAwO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGFsbG93QWJvdmVSb290KSB7XG5cdCAgICAgICAgICByZXMgKz0gcmVzLmxlbmd0aCA+IDAgPyBgJHtzZXBhcmF0b3J9Li5gIDogJy4uJztcblx0ICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuXHQgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke1N0cmluZ1Byb3RvdHlwZVNsaWNlKHBhdGgsIGxhc3RTbGFzaCArIDEsIGkpfWA7XG5cdCAgICAgICAgZWxzZVxuXHQgICAgICAgICAgcmVzID0gU3RyaW5nUHJvdG90eXBlU2xpY2UocGF0aCwgbGFzdFNsYXNoICsgMSwgaSk7XG5cdCAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcblx0ICAgICAgfVxuXHQgICAgICBsYXN0U2xhc2ggPSBpO1xuXHQgICAgICBkb3RzID0gMDtcblx0ICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gQ0hBUl9ET1QgJiYgZG90cyAhPT0gLTEpIHtcblx0ICAgICAgKytkb3RzO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZG90cyA9IC0xO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZSguLi5hcmdzKSB7XG5cdCAgbGV0IHJlc29sdmVkUGF0aCA9ICcnO1xuXHQgIGxldCByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cblx0ICBmb3IgKGxldCBpID0gYXJncy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcblx0ICAgIGNvbnN0IHBhdGggPSBpID49IDAgPyBhcmdzW2ldIDogcG9zaXhDd2QoKTtcblxuXHQgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcblxuXHQgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG5cdCAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIHJlc29sdmVkUGF0aCA9IGAke3BhdGh9LyR7cmVzb2x2ZWRQYXRofWA7XG5cdCAgICByZXNvbHZlZEFic29sdXRlID1cblx0ICAgICAgU3RyaW5nUHJvdG90eXBlQ2hhckNvZGVBdChwYXRoLCAwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuXHQgIH1cblxuXHQgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcblx0ICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuXHQgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuXHQgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZyhyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlLCAnLycsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTtcblxuXHQgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG5cdCAgICByZXR1cm4gYC8ke3Jlc29sdmVkUGF0aH1gO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDAgPyByZXNvbHZlZFBhdGggOiAnLic7XG5cdH1cblxuXHRwYXRoID0ge1xuXHQgIHJlc29sdmUsXG5cdH07XG5cdHJldHVybiBwYXRoO1xufVxuXG52YXIgdXJsO1xudmFyIGhhc1JlcXVpcmVkVXJsO1xuXG5mdW5jdGlvbiByZXF1aXJlVXJsICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVXJsKSByZXR1cm4gdXJsO1xuXHRoYXNSZXF1aXJlZFVybCA9IDE7XG5cblx0Ly8gVGhlIG1haW4gdXNlIGNhc2UgaXMgYnJvd3NlcnMsIGFuZCBJIHJhcmVseSB0ZXN0IG9uIFdpbmRvd3MsIHNvIGFsbCBvZiB0aGVcblx0Ly8gV2luZG93cy1zcGVjaWZpYyBzdHVmZiBpcyByZW1vdmVkLlxuXG5cdGNvbnN0IHtcblx0ICBTdHJpbmdQcm90b3R5cGVDaGFyQ29kZUF0LFxuXHQgIFN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzLFxuXHQgIFN0cmluZ1Byb3RvdHlwZVJlcGxhY2UsXG5cdH0gPSBwcmltb3JkaWFsc0V4cG9ydHM7XG5cblx0Y29uc3Qge1xuXHQgIENIQVJfRk9SV0FSRF9TTEFTSCxcblx0fSA9IHJlcXVpcmVDb25zdGFudHMoKTtcblx0Y29uc3QgcGF0aCA9IHJlcXVpcmVQYXRoKCk7XG5cblx0Y29uc3QgcGVyY2VudFJlZ0V4ID0gLyUvZztcblx0Y29uc3QgYmFja3NsYXNoUmVnRXggPSAvXFxcXC9nO1xuXHRjb25zdCBuZXdsaW5lUmVnRXggPSAvXFxuL2c7XG5cdGNvbnN0IGNhcnJpYWdlUmV0dXJuUmVnRXggPSAvXFxyL2c7XG5cdGNvbnN0IHRhYlJlZ0V4ID0gL1xcdC9nO1xuXG5cdGZ1bmN0aW9uIGVuY29kZVBhdGhDaGFycyhmaWxlcGF0aCkge1xuXHQgIGlmIChTdHJpbmdQcm90b3R5cGVJbmNsdWRlcyhmaWxlcGF0aCwgJyUnKSlcblx0ICAgIGZpbGVwYXRoID0gU3RyaW5nUHJvdG90eXBlUmVwbGFjZShmaWxlcGF0aCwgcGVyY2VudFJlZ0V4LCAnJTI1Jyk7XG5cdCAgLy8gSW4gcG9zaXgsIGJhY2tzbGFzaCBpcyBhIHZhbGlkIGNoYXJhY3RlciBpbiBwYXRoczpcblx0ICBpZiAoU3RyaW5nUHJvdG90eXBlSW5jbHVkZXMoZmlsZXBhdGgsICdcXFxcJykpXG5cdCAgICBmaWxlcGF0aCA9IFN0cmluZ1Byb3RvdHlwZVJlcGxhY2UoZmlsZXBhdGgsIGJhY2tzbGFzaFJlZ0V4LCAnJTVDJyk7XG5cdCAgaWYgKFN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKGZpbGVwYXRoLCAnXFxuJykpXG5cdCAgICBmaWxlcGF0aCA9IFN0cmluZ1Byb3RvdHlwZVJlcGxhY2UoZmlsZXBhdGgsIG5ld2xpbmVSZWdFeCwgJyUwQScpO1xuXHQgIGlmIChTdHJpbmdQcm90b3R5cGVJbmNsdWRlcyhmaWxlcGF0aCwgJ1xccicpKVxuXHQgICAgZmlsZXBhdGggPSBTdHJpbmdQcm90b3R5cGVSZXBsYWNlKGZpbGVwYXRoLCBjYXJyaWFnZVJldHVyblJlZ0V4LCAnJTBEJyk7XG5cdCAgaWYgKFN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKGZpbGVwYXRoLCAnXFx0JykpXG5cdCAgICBmaWxlcGF0aCA9IFN0cmluZ1Byb3RvdHlwZVJlcGxhY2UoZmlsZXBhdGgsIHRhYlJlZ0V4LCAnJTA5Jyk7XG5cdCAgcmV0dXJuIGZpbGVwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGF0aFRvRmlsZVVSTChmaWxlcGF0aCkge1xuXHQgIGNvbnN0IG91dFVSTCA9IG5ldyBVUkwoJ2ZpbGU6Ly8nKTtcblxuXHQgIGxldCByZXNvbHZlZCA9IHBhdGgucmVzb2x2ZShmaWxlcGF0aCk7XG5cdCAgLy8gcGF0aC5yZXNvbHZlIHN0cmlwcyB0cmFpbGluZyBzbGFzaGVzIHNvIHdlIG11c3QgYWRkIHRoZW0gYmFja1xuXHQgIGNvbnN0IGZpbGVQYXRoTGFzdCA9IFN0cmluZ1Byb3RvdHlwZUNoYXJDb2RlQXQoZmlsZXBhdGgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcGF0aC5sZW5ndGggLSAxKTtcblx0ICBpZiAoKGZpbGVQYXRoTGFzdCA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSAmJlxuXHQgICAgICByZXNvbHZlZFtyZXNvbHZlZC5sZW5ndGggLSAxXSAhPT0gcGF0aC5zZXApXG5cdCAgICByZXNvbHZlZCArPSAnLyc7XG5cdCAgb3V0VVJMLnBhdGhuYW1lID0gZW5jb2RlUGF0aENoYXJzKHJlc29sdmVkKTtcblxuXHQgIHJldHVybiBvdXRVUkw7XG5cdH1cblxuXHR1cmwgPSB7XG5cdCAgcGF0aFRvRmlsZVVSTCxcblx0fTtcblx0cmV0dXJuIHVybDtcbn1cblxudmFyIGJ1ZmZlciA9IHt9O1xuXG52YXIgaGFzUmVxdWlyZWRCdWZmZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVCdWZmZXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRCdWZmZXIpIHJldHVybiBidWZmZXI7XG5cdGhhc1JlcXVpcmVkQnVmZmVyID0gMTtcblxuXHRjbGFzcyBCdWZmZXIge1xuXHQgIGhleFNsaWNlKHN0YXJ0ID0gMCwgZW5kKSB7XG5cdCAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKFxuXHQgICAgICB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLFxuXHQgICAgICAoeCkgPT4gKCcwMCcgKyB4LnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpKVxuXHQgICAgICAuam9pbignJyk7XG5cdCAgfVxuXHR9XG5cblx0YnVmZmVyLkJ1ZmZlciA9IEJ1ZmZlcjtcblx0cmV0dXJuIGJ1ZmZlcjtcbn1cblxudmFyIGluc3BlY3RfMTtcbnZhciBoYXNSZXF1aXJlZEluc3BlY3Q7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJbnNwZWN0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSW5zcGVjdCkgcmV0dXJuIGluc3BlY3RfMTtcblx0aGFzUmVxdWlyZWRJbnNwZWN0ID0gMTtcblxuXHRjb25zdCBwcmltb3JkaWFscyA9IHByaW1vcmRpYWxzRXhwb3J0cztcblx0Y29uc3Qge1xuXHQgIGludGVybmFsQmluZGluZyxcblx0ICBBcnJheSxcblx0ICBBcnJheUlzQXJyYXksXG5cdCAgQXJyYXlQcm90b3R5cGVGaWx0ZXIsXG5cdCAgQXJyYXlQcm90b3R5cGVGb3JFYWNoLFxuXHQgIEFycmF5UHJvdG90eXBlSW5jbHVkZXMsXG5cdCAgQXJyYXlQcm90b3R5cGVJbmRleE9mLFxuXHQgIEFycmF5UHJvdG90eXBlSm9pbixcblx0ICBBcnJheVByb3RvdHlwZU1hcCxcblx0ICBBcnJheVByb3RvdHlwZVBvcCxcblx0ICBBcnJheVByb3RvdHlwZVB1c2gsXG5cdCAgQXJyYXlQcm90b3R5cGVQdXNoQXBwbHksXG5cdCAgQXJyYXlQcm90b3R5cGVTbGljZSxcblx0ICBBcnJheVByb3RvdHlwZVNwbGljZSxcblx0ICBBcnJheVByb3RvdHlwZVNvcnQsXG5cdCAgQXJyYXlQcm90b3R5cGVVbnNoaWZ0LFxuXHQgIEJpZ0ludFByb3RvdHlwZVZhbHVlT2YsXG5cdCAgQm9vbGVhblByb3RvdHlwZVZhbHVlT2YsXG5cdCAgRGF0ZVByb3RvdHlwZUdldFRpbWUsXG5cdCAgRGF0ZVByb3RvdHlwZVRvSVNPU3RyaW5nLFxuXHQgIERhdGVQcm90b3R5cGVUb1N0cmluZyxcblx0ICBFcnJvclByb3RvdHlwZVRvU3RyaW5nLFxuXHQgIEZ1bmN0aW9uUHJvdG90eXBlQmluZCxcblx0ICBGdW5jdGlvblByb3RvdHlwZUNhbGwsXG5cdCAgRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZyxcblx0ICBKU09OU3RyaW5naWZ5LFxuXHQgIE1hcFByb3RvdHlwZUdldFNpemUsXG5cdCAgTWFwUHJvdG90eXBlRW50cmllcyxcblx0ICBNYXRoRmxvb3IsXG5cdCAgTWF0aE1heCxcblx0ICBNYXRoTWluLFxuXHQgIE1hdGhSb3VuZCxcblx0ICBNYXRoU3FydCxcblx0ICBNYXRoVHJ1bmMsXG5cdCAgTnVtYmVyLFxuXHQgIE51bWJlcklzRmluaXRlLFxuXHQgIE51bWJlcklzTmFOLFxuXHQgIE51bWJlclBhcnNlRmxvYXQsXG5cdCAgTnVtYmVyUGFyc2VJbnQsXG5cdCAgTnVtYmVyUHJvdG90eXBlVG9TdHJpbmcsXG5cdCAgTnVtYmVyUHJvdG90eXBlVmFsdWVPZixcblx0ICBPYmplY3QsXG5cdCAgT2JqZWN0QXNzaWduLFxuXHQgIE9iamVjdERlZmluZVByb3BlcnR5LFxuXHQgIE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcblx0ICBPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLFxuXHQgIE9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyxcblx0ICBPYmplY3RHZXRQcm90b3R5cGVPZixcblx0ICBPYmplY3RJcyxcblx0ICBPYmplY3RLZXlzLFxuXHQgIE9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5LFxuXHQgIE9iamVjdFByb3RvdHlwZVByb3BlcnR5SXNFbnVtZXJhYmxlLFxuXHQgIE9iamVjdFNlYWwsXG5cdCAgT2JqZWN0U2V0UHJvdG90eXBlT2YsXG5cdCAgUmVmbGVjdEFwcGx5LFxuXHQgIFJlZmxlY3RPd25LZXlzLFxuXHQgIFJlZ0V4cCxcblx0ICBSZWdFeHBQcm90b3R5cGVFeGVjLFxuXHQgIFJlZ0V4cFByb3RvdHlwZVN5bWJvbFJlcGxhY2UsXG5cdCAgUmVnRXhwUHJvdG90eXBlU3ltYm9sU3BsaXQsXG5cdCAgUmVnRXhwUHJvdG90eXBlVG9TdHJpbmcsXG5cdCAgU2FmZVN0cmluZ0l0ZXJhdG9yLFxuXHQgIFNhZmVNYXAsXG5cdCAgU2FmZVNldCxcblx0ICBTZXRQcm90b3R5cGVHZXRTaXplLFxuXHQgIFNldFByb3RvdHlwZVZhbHVlcyxcblx0ICBTdHJpbmcsXG5cdCAgU3RyaW5nUHJvdG90eXBlQ2hhckNvZGVBdCxcblx0ICBTdHJpbmdQcm90b3R5cGVDb2RlUG9pbnRBdCxcblx0ICBTdHJpbmdQcm90b3R5cGVJbmNsdWRlcyxcblx0ICBTdHJpbmdQcm90b3R5cGVJbmRleE9mLFxuXHQgIFN0cmluZ1Byb3RvdHlwZUxhc3RJbmRleE9mLFxuXHQgIFN0cmluZ1Byb3RvdHlwZU5vcm1hbGl6ZSxcblx0ICBTdHJpbmdQcm90b3R5cGVQYWRFbmQsXG5cdCAgU3RyaW5nUHJvdG90eXBlUGFkU3RhcnQsXG5cdCAgU3RyaW5nUHJvdG90eXBlUmVwZWF0LFxuXHQgIFN0cmluZ1Byb3RvdHlwZVJlcGxhY2VBbGwsXG5cdCAgU3RyaW5nUHJvdG90eXBlU2xpY2UsXG5cdCAgU3RyaW5nUHJvdG90eXBlU3BsaXQsXG5cdCAgU3RyaW5nUHJvdG90eXBlRW5kc1dpdGgsXG5cdCAgU3RyaW5nUHJvdG90eXBlU3RhcnRzV2l0aCxcblx0ICBTdHJpbmdQcm90b3R5cGVUb0xvd2VyQ2FzZSxcblx0ICBTdHJpbmdQcm90b3R5cGVUcmltLFxuXHQgIFN0cmluZ1Byb3RvdHlwZVZhbHVlT2YsXG5cdCAgU3ltYm9sUHJvdG90eXBlVG9TdHJpbmcsXG5cdCAgU3ltYm9sUHJvdG90eXBlVmFsdWVPZixcblx0ICBTeW1ib2xJdGVyYXRvcixcblx0ICBTeW1ib2xUb1N0cmluZ1RhZyxcblx0ICBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoLFxuXHQgIFR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyxcblx0ICBVaW50OEFycmF5LFxuXHQgIGdsb2JhbFRoaXMsXG5cdCAgdW5jdXJyeVRoaXMsXG5cdH0gPSBwcmltb3JkaWFscztcblxuXHRjb25zdCB7XG5cdCAgY29uc3RhbnRzOiB7XG5cdCAgICBBTExfUFJPUEVSVElFUyxcblx0ICAgIE9OTFlfRU5VTUVSQUJMRSxcblx0ICAgIGtQZW5kaW5nLFxuXHQgICAga1JlamVjdGVkLFxuXHQgIH0sXG5cdCAgZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzLFxuXHQgIGdldFByb21pc2VEZXRhaWxzLFxuXHQgIGdldFByb3h5RGV0YWlscyxcblx0ICBwcmV2aWV3RW50cmllcyxcblx0ICBnZXRDb25zdHJ1Y3Rvck5hbWU6IGludGVybmFsR2V0Q29uc3RydWN0b3JOYW1lLFxuXHQgIGdldEV4dGVybmFsVmFsdWUsXG5cdCAgUHJveHksXG5cdH0gPSB1dGlsJDE7XG5cblx0Y29uc3Qge1xuXHQgIGN1c3RvbUluc3BlY3RTeW1ib2wsXG5cdCAgaXNFcnJvcixcblx0ICBqb2luLFxuXHQgIHJlbW92ZUNvbG9ycyxcblx0fSA9IHV0aWw7XG5cblx0Y29uc3Qge1xuXHQgIGlzU3RhY2tPdmVyZmxvd0Vycm9yLFxuXHR9ID0gcmVxdWlyZUVycm9ycygpO1xuXG5cdGNvbnN0IHtcblx0ICBpc0FzeW5jRnVuY3Rpb24sXG5cdCAgaXNHZW5lcmF0b3JGdW5jdGlvbixcblx0ICBpc0FueUFycmF5QnVmZmVyLFxuXHQgIGlzQXJyYXlCdWZmZXIsXG5cdCAgaXNBcmd1bWVudHNPYmplY3QsXG5cdCAgaXNCb3hlZFByaW1pdGl2ZSxcblx0ICBpc0RhdGFWaWV3LFxuXHQgIGlzRXh0ZXJuYWwsXG5cdCAgaXNNYXAsXG5cdCAgaXNNYXBJdGVyYXRvcixcblx0ICBpc01vZHVsZU5hbWVzcGFjZU9iamVjdCxcblx0ICBpc05hdGl2ZUVycm9yLFxuXHQgIGlzUHJvbWlzZSxcblx0ICBpc1NldCxcblx0ICBpc1NldEl0ZXJhdG9yLFxuXHQgIGlzV2Vha01hcCxcblx0ICBpc1dlYWtTZXQsXG5cdCAgaXNSZWdFeHAsXG5cdCAgaXNEYXRlLFxuXHQgIGlzVHlwZWRBcnJheSxcblx0ICBpc1N0cmluZ09iamVjdCxcblx0ICBpc051bWJlck9iamVjdCxcblx0ICBpc0Jvb2xlYW5PYmplY3QsXG5cdCAgaXNCaWdJbnRPYmplY3QsXG5cdH0gPSB0eXBlcztcblxuXHRjb25zdCBhc3NlcnQgPSBhc3NlcnRfMTtcblxuXHRjb25zdCB7IEJ1aWx0aW5Nb2R1bGUgfSA9IHJlYWxtO1xuXHRjb25zdCB7XG5cdCAgdmFsaWRhdGVPYmplY3QsXG5cdCAgdmFsaWRhdGVTdHJpbmcsXG5cdH0gPSByZXF1aXJlVmFsaWRhdG9ycygpO1xuXG5cdGxldCBoZXhTbGljZTtcblx0bGV0IGludGVybmFsVXJsO1xuXG5cdGZ1bmN0aW9uIHBhdGhUb0ZpbGVVcmxIcmVmKGZpbGVwYXRoKSB7XG5cdCAgLy8gTWFpbnRhaW4gbm9kZSAxNCBjb21wYXRcblx0ICAvLyBpbnRlcm5hbFVybCA/Pz0gcmVxdWlyZSgnLi9pbnRlcm5hbC91cmwnKTtcblx0ICBpbnRlcm5hbFVybCA9IChpbnRlcm5hbFVybCA9PSBudWxsKSA/IHJlcXVpcmVVcmwoKSA6IGludGVybmFsVXJsO1xuXHQgIHJldHVybiBpbnRlcm5hbFVybC5wYXRoVG9GaWxlVVJMKGZpbGVwYXRoKS5ocmVmO1xuXHR9XG5cblx0Y29uc3QgYnVpbHRJbk9iamVjdHMgPSBuZXcgU2FmZVNldChcblx0ICBBcnJheVByb3RvdHlwZUZpbHRlcihcblx0ICAgIE9iamVjdEdldE93blByb3BlcnR5TmFtZXMoZ2xvYmFsVGhpcyksXG5cdCAgICAoZSkgPT4gUmVnRXhwUHJvdG90eXBlRXhlYygvXltBLVpdW2EtekEtWjAtOV0rJC8sIGUpICE9PSBudWxsLFxuXHQgICksXG5cdCk7XG5cblx0Ly8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdFxuXHRjb25zdCBpc1VuZGV0ZWN0YWJsZU9iamVjdCA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcgJiYgdiAhPT0gdW5kZWZpbmVkO1xuXG5cdC8vIFRoZXNlIG9wdGlvbnMgbXVzdCBzdGF5IGluIHN5bmMgd2l0aCBgZ2V0VXNlck9wdGlvbnNgLiBTbyBpZiBhbnkgb3B0aW9uIHdpbGxcblx0Ly8gYmUgYWRkZWQgb3IgcmVtb3ZlZCwgYGdldFVzZXJPcHRpb25zYCBtdXN0IGFsc28gYmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cblx0Y29uc3QgaW5zcGVjdERlZmF1bHRPcHRpb25zID0gT2JqZWN0U2VhbCh7XG5cdCAgc2hvd0hpZGRlbjogZmFsc2UsXG5cdCAgZGVwdGg6IDIsXG5cdCAgY29sb3JzOiBmYWxzZSxcblx0ICBjdXN0b21JbnNwZWN0OiB0cnVlLFxuXHQgIHNob3dQcm94eTogZmFsc2UsXG5cdCAgbWF4QXJyYXlMZW5ndGg6IDEwMCxcblx0ICBtYXhTdHJpbmdMZW5ndGg6IDEwMDAwLFxuXHQgIGJyZWFrTGVuZ3RoOiA4MCxcblx0ICBjb21wYWN0OiAzLFxuXHQgIHNvcnRlZDogZmFsc2UsXG5cdCAgZ2V0dGVyczogZmFsc2UsXG5cdCAgbnVtZXJpY1NlcGFyYXRvcjogZmFsc2UsXG5cdH0pO1xuXG5cdGNvbnN0IGtPYmplY3RUeXBlID0gMDtcblx0Y29uc3Qga0FycmF5VHlwZSA9IDE7XG5cdGNvbnN0IGtBcnJheUV4dHJhc1R5cGUgPSAyO1xuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblx0Ly8gV29yay1hcm91bmRzIGZvciBTYWZhcmkgbm90IGltcGxlbWVudGluZyBuZWdhdGl2ZSBsb29rLWJlaGluZHMuXG5cdC8vIFJlbW92ZSBhbGwgb2YgdGhpcyBvbmNlIFNhZmFyaSAxNi40IGlzIHJvbGxlZCBvdXQgXCJlbm91Z2hcIi5cblx0bGV0IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCxcblx0ICBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlcixcblx0ICBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHBTaW5nbGUsXG5cdCAgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGUsXG5cdCAgZXh0cmFjdGVkU3BsaXROZXdMaW5lcztcblx0dHJ5IHtcblx0ICAvLyBDaGFuZ2UgZnJvbSByZWdleCBsaXRlcmFscyB0byBSZWdFeHAgY29uc3RydWN0b3JzIHRvIGF2b2lkIHVucmVjb3ZlcmFibGVcblx0ICAvLyBzeW50YXggZXJyb3IgYXQgbG9hZCB0aW1lLlxuXHQgIHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuXHQgICAgbmV3IFJlZ0V4cCgnW1xcXFx4MDAtXFxcXHgxZlxcXFx4MjdcXFxceDVjXFxcXHg3Zi1cXFxceDlmXXxbXFxcXHVkODAwLVxcXFx1ZGJmZl0oPyFbXFxcXHVkYzAwLVxcXFx1ZGZmZl0pfCg/PCFbXFxcXHVkODAwLVxcXFx1ZGJmZl0pW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyk7XG5cdCAgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIgPVxuXHQgICAgbmV3IFJlZ0V4cChcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cblx0ICAgICAgJ1tcXHgwMC1cXFxceDFmXFxcXHgyN1xcXFx4NWNcXFxceDdmLVxcXFx4OWZdfFtcXFxcdWQ4MDAtXFxcXHVkYmZmXSg/IVtcXFxcdWRjMDAtXFxcXHVkZmZmXSl8KD88IVtcXFxcdWQ4MDAtXFxcXHVkYmZmXSlbXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuXHQgICAgICAnZycsXG5cdCAgICApO1xuXHQgIHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSA9XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuXHQgICAgbmV3IFJlZ0V4cCgnW1xcXFx4MDAtXFxcXHgxZlxcXFx4NWNcXFxceDdmLVxcXFx4OWZdfFtcXFxcdWQ4MDAtXFxcXHVkYmZmXSg/IVtcXFxcdWRjMDAtXFxcXHVkZmZmXSl8KD88IVtcXFxcdWQ4MDAtXFxcXHVkYmZmXSlbXFxcXHVkYzAwLVxcXFx1ZGZmZl0nKTtcblx0ICBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZSA9XG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuXHQgICAgbmV3IFJlZ0V4cCgnW1xcXFx4MDAtXFxcXHgxZlxcXFx4NWNcXFxceDdmLVxcXFx4OWZdfFtcXFxcdWQ4MDAtXFxcXHVkYmZmXSg/IVtcXFxcdWRjMDAtXFxcXHVkZmZmXSl8KD88IVtcXFxcdWQ4MDAtXFxcXHVkYmZmXSlbXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLCAnZycpO1xuXHQgIGNvbnN0IGV4dHJhY3RlZE5ld0xpbmVSZSA9IG5ldyBSZWdFeHAoJyg/PD1cXFxcbiknKTtcblx0ICBleHRyYWN0ZWRTcGxpdE5ld0xpbmVzID0gKHZhbHVlKSA9PiBSZWdFeHBQcm90b3R5cGVTeW1ib2xTcGxpdChleHRyYWN0ZWROZXdMaW5lUmUsIHZhbHVlKTtcblx0ICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cblx0ICAvLyBDSSBkb2Vzbid0IHJ1biBpbiBhbiBlbGRlcmx5IHJ1bnRpbWVcblx0fSBjYXRjaCB7XG5cdCAgLy8gVGhlc2UgYXJlIGZyb20gYSBwcmV2aW91cyB2ZXJzaW9uIG9mIG5vZGUsXG5cdCAgLy8gc2VlIGNvbW1pdCA3NjM3MjYwN2E2NzQzY2M3NWVhZTUwY2E1ODY1N2M5ZThhNjU0NDI4XG5cdCAgLy8gZGF0ZWQgMjAyMS0xMi0wNlxuXHQgIHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cCA9IC9bXFx4MDAtXFx4MWZcXHgyN1xceDVjXFx4N2YtXFx4OWZdLztcblx0ICBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciA9IC9bXFx4MDAtXFx4MWZcXHgyN1xceDVjXFx4N2YtXFx4OWZdL2c7XG5cdCAgc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlID0gL1tcXHgwMC1cXHgxZlxceDVjXFx4N2YtXFx4OWZdLztcblx0ICBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZSA9IC9bXFx4MDAtXFx4MWZcXHg1Y1xceDdmLVxceDlmXS9nO1xuXHQgIGV4dHJhY3RlZFNwbGl0TmV3TGluZXMgPSAodmFsdWUpID0+IHtcblx0ICAgIGNvbnN0IGxpbmVzID0gUmVnRXhwUHJvdG90eXBlU3ltYm9sU3BsaXQoL1xcbi8sIHZhbHVlKTtcblx0ICAgIGNvbnN0IGxhc3QgPSBBcnJheVByb3RvdHlwZVBvcChsaW5lcyk7XG5cdCAgICBjb25zdCBubExpbmVzID0gQXJyYXlQcm90b3R5cGVNYXAobGluZXMsIChsaW5lKSA9PiBsaW5lICsgJ1xcbicpO1xuXHQgICAgaWYgKGxhc3QgIT09ICcnKSB7XG5cdCAgICAgIG5sTGluZXMucHVzaChsYXN0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBubExpbmVzO1xuXHQgIH07XG5cdH1cblx0LyogYzggaWdub3JlIHN0b3AgKi9cblx0LyogZXNsaW50LWVuYWJsZSBuby1jb250cm9sLXJlZ2V4ICovXG5cblx0Y29uc3Qga2V5U3RyUmVnRXhwID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC87XG5cdGNvbnN0IG51bWJlclJlZ0V4cCA9IC9eKDB8WzEtOV1bMC05XSopJC87XG5cblx0Y29uc3QgY29yZU1vZHVsZVJlZ0V4cCA9IC9eIHs0fWF0ICg/OlteL1xcXFwoXSsgXFwofClub2RlOiguKyk6XFxkKzpcXGQrXFwpPyQvO1xuXHRjb25zdCBub2RlTW9kdWxlc1JlZ0V4cCA9IC9bL1xcXFxdbm9kZV9tb2R1bGVzWy9cXFxcXSguKz8pKD89Wy9cXFxcXSkvZztcblxuXHRjb25zdCBjbGFzc1JlZ0V4cCA9IC9eKFxccytbXihdKj8pXFxzKnsvO1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS1jb3JlL25vLXVuZXNjYXBlZC1yZWdleHAtZG90XG5cdGNvbnN0IHN0cmlwQ29tbWVudHNSZWdFeHAgPSAvKFxcL1xcLy4qP1xcbil8KFxcL1xcKigufFxcbikqP1xcKlxcLykvZztcblxuXHRjb25zdCBrTWluTGluZUxlbmd0aCA9IDE2O1xuXG5cdC8vIENvbnN0YW50cyB0byBtYXAgdGhlIGl0ZXJhdG9yIHN0YXRlLlxuXHRjb25zdCBrV2VhayA9IDA7XG5cdGNvbnN0IGtJdGVyYXRvciA9IDE7XG5cdGNvbnN0IGtNYXBFbnRyaWVzID0gMjtcblxuXHQvLyBFc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyAocGx1cyB0aGUgc2luZ2xlIHF1b3RlIGFuZCB0aGUgYmFja3NsYXNoKS4gVXNlXG5cdC8vIGVtcHR5IHN0cmluZ3MgdG8gZmlsbCB1cCB1bnVzZWQgZW50cmllcy5cblx0Y29uc3QgbWV0YSA9IFtcblx0ICAnXFxcXHgwMCcsICdcXFxceDAxJywgJ1xcXFx4MDInLCAnXFxcXHgwMycsICdcXFxceDA0JywgJ1xcXFx4MDUnLCAnXFxcXHgwNicsICdcXFxceDA3JywgLy8geDA3XG5cdCAgJ1xcXFxiJywgJ1xcXFx0JywgJ1xcXFxuJywgJ1xcXFx4MEInLCAnXFxcXGYnLCAnXFxcXHInLCAnXFxcXHgwRScsICdcXFxceDBGJywgICAgICAgICAgIC8vIHgwRlxuXHQgICdcXFxceDEwJywgJ1xcXFx4MTEnLCAnXFxcXHgxMicsICdcXFxceDEzJywgJ1xcXFx4MTQnLCAnXFxcXHgxNScsICdcXFxceDE2JywgJ1xcXFx4MTcnLCAvLyB4MTdcblx0ICAnXFxcXHgxOCcsICdcXFxceDE5JywgJ1xcXFx4MUEnLCAnXFxcXHgxQicsICdcXFxceDFDJywgJ1xcXFx4MUQnLCAnXFxcXHgxRScsICdcXFxceDFGJywgLy8geDFGXG5cdCAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsIFwiXFxcXCdcIiwgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAgICAgIC8vIHgyRlxuXHQgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAgICAgICAgIC8vIHgzRlxuXHQgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAgICAgICAgIC8vIHg0RlxuXHQgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdcXFxcXFxcXCcsICcnLCAnJywgJycsICAgICAvLyB4NUZcblx0ICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgICAgICAgICAvLyB4NkZcblx0ICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnXFxcXHg3RicsICAgIC8vIHg3RlxuXHQgICdcXFxceDgwJywgJ1xcXFx4ODEnLCAnXFxcXHg4MicsICdcXFxceDgzJywgJ1xcXFx4ODQnLCAnXFxcXHg4NScsICdcXFxceDg2JywgJ1xcXFx4ODcnLCAvLyB4ODdcblx0ICAnXFxcXHg4OCcsICdcXFxceDg5JywgJ1xcXFx4OEEnLCAnXFxcXHg4QicsICdcXFxceDhDJywgJ1xcXFx4OEQnLCAnXFxcXHg4RScsICdcXFxceDhGJywgLy8geDhGXG5cdCAgJ1xcXFx4OTAnLCAnXFxcXHg5MScsICdcXFxceDkyJywgJ1xcXFx4OTMnLCAnXFxcXHg5NCcsICdcXFxceDk1JywgJ1xcXFx4OTYnLCAnXFxcXHg5NycsIC8vIHg5N1xuXHQgICdcXFxceDk4JywgJ1xcXFx4OTknLCAnXFxcXHg5QScsICdcXFxceDlCJywgJ1xcXFx4OUMnLCAnXFxcXHg5RCcsICdcXFxceDlFJywgJ1xcXFx4OUYnLCAvLyB4OUZcblx0XTtcblxuXHQvLyBSZWdleCB1c2VkIGZvciBhbnNpIGVzY2FwZSBjb2RlIHNwbGl0dGluZ1xuXHQvLyBBZG9wdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2Fuc2ktcmVnZXgvYmxvYi9IRUFEL2luZGV4LmpzXG5cdC8vIExpY2Vuc2U6IE1JVCwgYXV0aG9yczogQHNpbmRyZXNvcmh1cywgUWl4LSwgYXJqdW5tZWh0YSBhbmQgTGl0b01vcmVcblx0Ly8gTWF0Y2hlcyBhbGwgYW5zaSBlc2NhcGUgY29kZSBzZXF1ZW5jZXMgaW4gYSBzdHJpbmdcblx0Y29uc3QgYW5zaVBhdHRlcm4gPSAnW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKicgK1xuXHQgICcoPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSonICtcblx0ICAnfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJyArXG5cdCAgJ3woPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKSc7XG5cdGNvbnN0IGFuc2kgPSBuZXcgUmVnRXhwKGFuc2lQYXR0ZXJuLCAnZycpO1xuXG5cdGxldCBnZXRTdHJpbmdXaWR0aDtcblxuXHRmdW5jdGlvbiBnZXRVc2VyT3B0aW9ucyhjdHgsIGlzQ3Jvc3NDb250ZXh0KSB7XG5cdCAgY29uc3QgcmV0ID0ge1xuXHQgICAgc3R5bGl6ZTogY3R4LnN0eWxpemUsXG5cdCAgICBzaG93SGlkZGVuOiBjdHguc2hvd0hpZGRlbixcblx0ICAgIGRlcHRoOiBjdHguZGVwdGgsXG5cdCAgICBjb2xvcnM6IGN0eC5jb2xvcnMsXG5cdCAgICBjdXN0b21JbnNwZWN0OiBjdHguY3VzdG9tSW5zcGVjdCxcblx0ICAgIHNob3dQcm94eTogY3R4LnNob3dQcm94eSxcblx0ICAgIG1heEFycmF5TGVuZ3RoOiBjdHgubWF4QXJyYXlMZW5ndGgsXG5cdCAgICBtYXhTdHJpbmdMZW5ndGg6IGN0eC5tYXhTdHJpbmdMZW5ndGgsXG5cdCAgICBicmVha0xlbmd0aDogY3R4LmJyZWFrTGVuZ3RoLFxuXHQgICAgY29tcGFjdDogY3R4LmNvbXBhY3QsXG5cdCAgICBzb3J0ZWQ6IGN0eC5zb3J0ZWQsXG5cdCAgICBnZXR0ZXJzOiBjdHguZ2V0dGVycyxcblx0ICAgIG51bWVyaWNTZXBhcmF0b3I6IGN0eC5udW1lcmljU2VwYXJhdG9yLFxuXHQgICAgLi4uY3R4LnVzZXJPcHRpb25zLFxuXHQgIH07XG5cblx0ICAvLyBUeXBpY2FsbHksIHRoZSB0YXJnZXQgdmFsdWUgd2lsbCBiZSBhbiBpbnN0YW5jZSBvZiBgT2JqZWN0YC4gSWYgdGhhdCBpc1xuXHQgIC8vICpub3QqIHRoZSBjYXNlLCB0aGUgb2JqZWN0IG1heSBjb21lIGZyb20gYW5vdGhlciB2bS5Db250ZXh0LCBhbmQgd2Ugd2FudFxuXHQgIC8vIHRvIGF2b2lkIHBhc3NpbmcgaXQgb2JqZWN0cyBmcm9tIHRoaXMgQ29udGV4dCBpbiB0aGF0IGNhc2UsIHNvIHdlIHJlbW92ZVxuXHQgIC8vIHRoZSBwcm90b3R5cGUgZnJvbSB0aGUgcmV0dXJuZWQgb2JqZWN0IGl0c2VsZiArIHRoZSBgc3R5bGl6ZSgpYCBmdW5jdGlvbixcblx0ICAvLyBhbmQgcmVtb3ZlIGFsbCBvdGhlciBub24tcHJpbWl0aXZlcywgaW5jbHVkaW5nIG5vbi1wcmltaXRpdmUgdXNlciBvcHRpb25zLlxuXHQgIGlmIChpc0Nyb3NzQ29udGV4dCkge1xuXHQgICAgT2JqZWN0U2V0UHJvdG90eXBlT2YocmV0LCBudWxsKTtcblx0ICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdEtleXMocmV0KSkge1xuXHQgICAgICBpZiAoKHR5cGVvZiByZXRba2V5XSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHJldFtrZXldID09PSAnZnVuY3Rpb24nKSAmJlxuXHQgICAgICAgICAgcmV0W2tleV0gIT09IG51bGwpIHtcblx0ICAgICAgICBkZWxldGUgcmV0W2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldC5zdHlsaXplID0gT2JqZWN0U2V0UHJvdG90eXBlT2YoKHZhbHVlLCBmbGF2b3VyKSA9PiB7XG5cdCAgICAgIGxldCBzdHlsaXplZDtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBzdHlsaXplZCA9IGAke2N0eC5zdHlsaXplKHZhbHVlLCBmbGF2b3VyKX1gO1xuXHQgICAgICB9IGNhdGNoIHtcblx0ICAgICAgICAvLyBDb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yLlxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBzdHlsaXplZCAhPT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgLy8gYHN0eWxpemVkYCBpcyBhIHN0cmluZyBhcyBpdCBzaG91bGQgYmUsIHdoaWNoIGlzIHNhZmUgdG8gcGFzcyBhbG9uZy5cblx0ICAgICAgcmV0dXJuIHN0eWxpemVkO1xuXHQgICAgfSwgbnVsbCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBFY2hvcyB0aGUgdmFsdWUgb2YgYW55IGlucHV0LiBUcmllcyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG5cdCAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIHByaW50IG91dC5cblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cblx0ICovXG5cdC8qIExlZ2FjeTogdmFsdWUsIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMgKi9cblx0ZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgb3B0cykge1xuXHQgIC8vIERlZmF1bHQgb3B0aW9uc1xuXHQgIGNvbnN0IGN0eCA9IHtcblx0ICAgIGJ1ZGdldDoge30sXG5cdCAgICBpbmRlbnRhdGlvbkx2bDogMCxcblx0ICAgIHNlZW46IFtdLFxuXHQgICAgY3VycmVudERlcHRoOiAwLFxuXHQgICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IsXG5cdCAgICBzaG93SGlkZGVuOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc2hvd0hpZGRlbixcblx0ICAgIGRlcHRoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuZGVwdGgsXG5cdCAgICBjb2xvcnM6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jb2xvcnMsXG5cdCAgICBjdXN0b21JbnNwZWN0OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY3VzdG9tSW5zcGVjdCxcblx0ICAgIHNob3dQcm94eTogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNob3dQcm94eSxcblx0ICAgIG1heEFycmF5TGVuZ3RoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMubWF4QXJyYXlMZW5ndGgsXG5cdCAgICBtYXhTdHJpbmdMZW5ndGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5tYXhTdHJpbmdMZW5ndGgsXG5cdCAgICBicmVha0xlbmd0aDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmJyZWFrTGVuZ3RoLFxuXHQgICAgY29tcGFjdDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmNvbXBhY3QsXG5cdCAgICBzb3J0ZWQ6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zb3J0ZWQsXG5cdCAgICBnZXR0ZXJzOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuZ2V0dGVycyxcblx0ICAgIG51bWVyaWNTZXBhcmF0b3I6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5udW1lcmljU2VwYXJhdG9yLFxuXHQgIH07XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICAvLyBMZWdhY3kuLi5cblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHQgICAgICBpZiAoYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gU2V0IHVzZXItc3BlY2lmaWVkIG9wdGlvbnNcblx0ICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Jvb2xlYW4nKSB7XG5cdCAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcblx0ICAgIH0gZWxzZSBpZiAob3B0cykge1xuXHQgICAgICBjb25zdCBvcHRLZXlzID0gT2JqZWN0S2V5cyhvcHRzKTtcblx0ICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRLZXlzLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgY29uc3Qga2V5ID0gb3B0S2V5c1tpXTtcblx0ICAgICAgICAvLyBUT0RPKEJyaWRnZUFSKTogRmluZCBhIHNvbHV0aW9uIHdoYXQgdG8gZG8gYWJvdXQgc3R5bGl6ZS4gRWl0aGVyIG1ha2Vcblx0ICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHB1YmxpYyBvciBhZGQgYSBuZXcgQVBJIHdpdGggYSBzaW1pbGFyIG9yIGJldHRlclxuXHQgICAgICAgIC8vIGZ1bmN0aW9uYWxpdHkuXG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkoaW5zcGVjdERlZmF1bHRPcHRpb25zLCBrZXkpIHx8XG5cdCAgICAgICAgICBrZXkgPT09ICdzdHlsaXplJykge1xuXHQgICAgICAgICAgY3R4W2tleV0gPSBvcHRzW2tleV07XG5cdCAgICAgICAgfSBlbHNlIGlmIChjdHgudXNlck9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBwYXNzIHRocm91Z2ggdGhlIGFjdHVhbCB1c2VyIGlucHV0LlxuXHQgICAgICAgICAgY3R4LnVzZXJPcHRpb25zID0gb3B0cztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcblx0ICBpZiAoY3R4Lm1heEFycmF5TGVuZ3RoID09PSBudWxsKSBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcblx0ICBpZiAoY3R4Lm1heFN0cmluZ0xlbmd0aCA9PT0gbnVsbCkgY3R4Lm1heFN0cmluZ0xlbmd0aCA9IEluZmluaXR5O1xuXHQgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCAwKTtcblx0fVxuXHRpbnNwZWN0LmN1c3RvbSA9IGN1c3RvbUluc3BlY3RTeW1ib2w7XG5cblx0T2JqZWN0RGVmaW5lUHJvcGVydHkoaW5zcGVjdCwgJ2RlZmF1bHRPcHRpb25zJywge1xuXHQgIF9fcHJvdG9fXzogbnVsbCxcblx0ICBnZXQoKSB7XG5cdCAgICByZXR1cm4gaW5zcGVjdERlZmF1bHRPcHRpb25zO1xuXHQgIH0sXG5cdCAgc2V0KG9wdGlvbnMpIHtcblx0ICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdCAgICByZXR1cm4gT2JqZWN0QXNzaWduKGluc3BlY3REZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgfSxcblx0fSk7XG5cblx0Ly8gU2V0IEdyYXBoaWNzIFJlbmRpdGlvbiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5cdC8vIEVhY2ggY29sb3IgY29uc2lzdHMgb2YgYW4gYXJyYXkgd2l0aCB0aGUgY29sb3IgY29kZSBhcyBmaXJzdCBlbnRyeSBhbmQgdGhlXG5cdC8vIHJlc2V0IGNvZGUgYXMgc2Vjb25kIGVudHJ5LlxuXHRjb25zdCBkZWZhdWx0RkcgPSAzOTtcblx0Y29uc3QgZGVmYXVsdEJHID0gNDk7XG5cdGluc3BlY3QuY29sb3JzID0ge1xuXHQgIF9fcHJvdG9fXzogbnVsbCxcblx0ICByZXNldDogWzAsIDBdLFxuXHQgIGJvbGQ6IFsxLCAyMl0sXG5cdCAgZGltOiBbMiwgMjJdLCAvLyBBbGlhczogZmFpbnRcblx0ICBpdGFsaWM6IFszLCAyM10sXG5cdCAgdW5kZXJsaW5lOiBbNCwgMjRdLFxuXHQgIGJsaW5rOiBbNSwgMjVdLFxuXHQgIC8vIFN3YXAgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvcnNcblx0ICBpbnZlcnNlOiBbNywgMjddLCAvLyBBbGlhczogc3dhcGNvbG9ycywgc3dhcENvbG9yc1xuXHQgIGhpZGRlbjogWzgsIDI4XSwgLy8gQWxpYXM6IGNvbmNlYWxcblx0ICBzdHJpa2V0aHJvdWdoOiBbOSwgMjldLCAvLyBBbGlhczogc3RyaWtlVGhyb3VnaCwgY3Jvc3NlZG91dCwgY3Jvc3NlZE91dFxuXHQgIGRvdWJsZXVuZGVybGluZTogWzIxLCAyNF0sIC8vIEFsaWFzOiBkb3VibGVVbmRlcmxpbmVcblx0ICBibGFjazogWzMwLCBkZWZhdWx0RkddLFxuXHQgIHJlZDogWzMxLCBkZWZhdWx0RkddLFxuXHQgIGdyZWVuOiBbMzIsIGRlZmF1bHRGR10sXG5cdCAgeWVsbG93OiBbMzMsIGRlZmF1bHRGR10sXG5cdCAgYmx1ZTogWzM0LCBkZWZhdWx0RkddLFxuXHQgIG1hZ2VudGE6IFszNSwgZGVmYXVsdEZHXSxcblx0ICBjeWFuOiBbMzYsIGRlZmF1bHRGR10sXG5cdCAgd2hpdGU6IFszNywgZGVmYXVsdEZHXSxcblx0ICBiZ0JsYWNrOiBbNDAsIGRlZmF1bHRCR10sXG5cdCAgYmdSZWQ6IFs0MSwgZGVmYXVsdEJHXSxcblx0ICBiZ0dyZWVuOiBbNDIsIGRlZmF1bHRCR10sXG5cdCAgYmdZZWxsb3c6IFs0MywgZGVmYXVsdEJHXSxcblx0ICBiZ0JsdWU6IFs0NCwgZGVmYXVsdEJHXSxcblx0ICBiZ01hZ2VudGE6IFs0NSwgZGVmYXVsdEJHXSxcblx0ICBiZ0N5YW46IFs0NiwgZGVmYXVsdEJHXSxcblx0ICBiZ1doaXRlOiBbNDcsIGRlZmF1bHRCR10sXG5cdCAgZnJhbWVkOiBbNTEsIDU0XSxcblx0ICBvdmVybGluZWQ6IFs1MywgNTVdLFxuXHQgIGdyYXk6IFs5MCwgZGVmYXVsdEZHXSwgLy8gQWxpYXM6IGdyZXksIGJsYWNrQnJpZ2h0XG5cdCAgcmVkQnJpZ2h0OiBbOTEsIGRlZmF1bHRGR10sXG5cdCAgZ3JlZW5CcmlnaHQ6IFs5MiwgZGVmYXVsdEZHXSxcblx0ICB5ZWxsb3dCcmlnaHQ6IFs5MywgZGVmYXVsdEZHXSxcblx0ICBibHVlQnJpZ2h0OiBbOTQsIGRlZmF1bHRGR10sXG5cdCAgbWFnZW50YUJyaWdodDogWzk1LCBkZWZhdWx0RkddLFxuXHQgIGN5YW5CcmlnaHQ6IFs5NiwgZGVmYXVsdEZHXSxcblx0ICB3aGl0ZUJyaWdodDogWzk3LCBkZWZhdWx0RkddLFxuXHQgIGJnR3JheTogWzEwMCwgZGVmYXVsdEJHXSwgLy8gQWxpYXM6IGJnR3JleSwgYmdCbGFja0JyaWdodFxuXHQgIGJnUmVkQnJpZ2h0OiBbMTAxLCBkZWZhdWx0QkddLFxuXHQgIGJnR3JlZW5CcmlnaHQ6IFsxMDIsIGRlZmF1bHRCR10sXG5cdCAgYmdZZWxsb3dCcmlnaHQ6IFsxMDMsIGRlZmF1bHRCR10sXG5cdCAgYmdCbHVlQnJpZ2h0OiBbMTA0LCBkZWZhdWx0QkddLFxuXHQgIGJnTWFnZW50YUJyaWdodDogWzEwNSwgZGVmYXVsdEJHXSxcblx0ICBiZ0N5YW5CcmlnaHQ6IFsxMDYsIGRlZmF1bHRCR10sXG5cdCAgYmdXaGl0ZUJyaWdodDogWzEwNywgZGVmYXVsdEJHXSxcblx0fTtcblxuXHRmdW5jdGlvbiBkZWZpbmVDb2xvckFsaWFzKHRhcmdldCwgYWxpYXMpIHtcblx0ICBPYmplY3REZWZpbmVQcm9wZXJ0eShpbnNwZWN0LmNvbG9ycywgYWxpYXMsIHtcblx0ICAgIF9fcHJvdG9fXzogbnVsbCxcblx0ICAgIGdldCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXNbdGFyZ2V0XTtcblx0ICAgIH0sXG5cdCAgICBzZXQodmFsdWUpIHtcblx0ICAgICAgdGhpc1t0YXJnZXRdID0gdmFsdWU7XG5cdCAgICB9LFxuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgfSk7XG5cdH1cblxuXHRkZWZpbmVDb2xvckFsaWFzKCdncmF5JywgJ2dyZXknKTtcblx0ZGVmaW5lQ29sb3JBbGlhcygnZ3JheScsICdibGFja0JyaWdodCcpO1xuXHRkZWZpbmVDb2xvckFsaWFzKCdiZ0dyYXknLCAnYmdHcmV5Jyk7XG5cdGRlZmluZUNvbG9yQWxpYXMoJ2JnR3JheScsICdiZ0JsYWNrQnJpZ2h0Jyk7XG5cdGRlZmluZUNvbG9yQWxpYXMoJ2RpbScsICdmYWludCcpO1xuXHRkZWZpbmVDb2xvckFsaWFzKCdzdHJpa2V0aHJvdWdoJywgJ2Nyb3NzZWRvdXQnKTtcblx0ZGVmaW5lQ29sb3JBbGlhcygnc3RyaWtldGhyb3VnaCcsICdzdHJpa2VUaHJvdWdoJyk7XG5cdGRlZmluZUNvbG9yQWxpYXMoJ3N0cmlrZXRocm91Z2gnLCAnY3Jvc3NlZE91dCcpO1xuXHRkZWZpbmVDb2xvckFsaWFzKCdoaWRkZW4nLCAnY29uY2VhbCcpO1xuXHRkZWZpbmVDb2xvckFsaWFzKCdpbnZlcnNlJywgJ3N3YXBDb2xvcnMnKTtcblx0ZGVmaW5lQ29sb3JBbGlhcygnaW52ZXJzZScsICdzd2FwY29sb3JzJyk7XG5cdGRlZmluZUNvbG9yQWxpYXMoJ2RvdWJsZXVuZGVybGluZScsICdkb3VibGVVbmRlcmxpbmUnKTtcblxuXHQvLyBUT0RPKEJyaWRnZUFSKTogQWRkIGZ1bmN0aW9uIHN0eWxlIHN1cHBvcnQgZm9yIG1vcmUgY29tcGxleCBzdHlsZXMuXG5cdC8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuXHRpbnNwZWN0LnN0eWxlcyA9IE9iamVjdEFzc2lnbih7IF9fcHJvdG9fXzogbnVsbCB9LCB7XG5cdCAgc3BlY2lhbDogJ2N5YW4nLFxuXHQgIG51bWJlcjogJ3llbGxvdycsXG5cdCAgYmlnaW50OiAneWVsbG93Jyxcblx0ICBib29sZWFuOiAneWVsbG93Jyxcblx0ICB1bmRlZmluZWQ6ICdncmV5Jyxcblx0ICBudWxsOiAnYm9sZCcsXG5cdCAgc3RyaW5nOiAnZ3JlZW4nLFxuXHQgIHN5bWJvbDogJ2dyZWVuJyxcblx0ICBkYXRlOiAnbWFnZW50YScsXG5cdCAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcblx0ICAvLyBUT0RPKEJyaWRnZUFSKTogSGlnaGxpZ2h0IHJlZ3VsYXIgZXhwcmVzc2lvbnMgcHJvcGVybHkuXG5cdCAgcmVnZXhwOiAncmVkJyxcblx0ICBtb2R1bGU6ICd1bmRlcmxpbmUnLFxuXHR9KTtcblxuXHRmdW5jdGlvbiBhZGRRdW90ZXMoc3RyLCBxdW90ZXMpIHtcblx0ICBpZiAocXVvdGVzID09PSAtMSkge1xuXHQgICAgcmV0dXJuIGBcIiR7c3RyfVwiYDtcblx0ICB9XG5cdCAgaWYgKHF1b3RlcyA9PT0gLTIpIHtcblx0ICAgIHJldHVybiBgXFxgJHtzdHJ9XFxgYDtcblx0ICB9XG5cdCAgcmV0dXJuIGAnJHtzdHJ9J2A7XG5cdH1cblxuXHRmdW5jdGlvbiBlc2NhcGVGbihzdHIpIHtcblx0ICBjb25zdCBjaGFyQ29kZSA9IFN0cmluZ1Byb3RvdHlwZUNoYXJDb2RlQXQoc3RyKTtcblx0ICByZXR1cm4gbWV0YS5sZW5ndGggPiBjaGFyQ29kZSA/IG1ldGFbY2hhckNvZGVdIDogYFxcXFx1JHtOdW1iZXJQcm90b3R5cGVUb1N0cmluZyhjaGFyQ29kZSwgMTYpfWA7XG5cdH1cblxuXHQvLyBFc2NhcGUgY29udHJvbCBjaGFyYWN0ZXJzLCBzaW5nbGUgcXVvdGVzIGFuZCB0aGUgYmFja3NsYXNoLlxuXHQvLyBUaGlzIGlzIHNpbWlsYXIgdG8gSlNPTiBzdHJpbmdpZnkgZXNjYXBpbmcuXG5cdGZ1bmN0aW9uIHN0ckVzY2FwZShzdHIpIHtcblx0ICBsZXQgZXNjYXBlVGVzdCA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cDtcblx0ICBsZXQgZXNjYXBlUmVwbGFjZSA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyO1xuXHQgIGxldCBzaW5nbGVRdW90ZSA9IDM5O1xuXG5cdCAgLy8gQ2hlY2sgZm9yIGRvdWJsZSBxdW90ZXMuIElmIG5vdCBwcmVzZW50LCBkbyBub3QgZXNjYXBlIHNpbmdsZSBxdW90ZXMgYW5kXG5cdCAgLy8gaW5zdGVhZCB3cmFwIHRoZSB0ZXh0IGluIGRvdWJsZSBxdW90ZXMuIElmIGRvdWJsZSBxdW90ZXMgZXhpc3QsIGNoZWNrIGZvclxuXHQgIC8vIGJhY2t0aWNrcy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIHVzZSB0aG9zZSBhcyBmYWxsYmFjayBpbnN0ZWFkIG9mIHRoZVxuXHQgIC8vIGRvdWJsZSBxdW90ZXMuXG5cdCAgaWYgKFN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKHN0ciwgXCInXCIpKSB7XG5cdCAgICAvLyBUaGlzIGludmFsaWRhdGVzIHRoZSBjaGFyQ29kZSBhbmQgdGhlcmVmb3JlIGNhbiBub3QgYmUgbWF0Y2hlZCBmb3Jcblx0ICAgIC8vIGFueW1vcmUuXG5cdCAgICBpZiAoIVN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKHN0ciwgJ1wiJykpIHtcblx0ICAgICAgc2luZ2xlUXVvdGUgPSAtMTtcblx0ICAgIH0gZWxzZSBpZiAoIVN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKHN0ciwgJ2AnKSAmJlxuXHQgICAgICAgICAgICAgICAhU3RyaW5nUHJvdG90eXBlSW5jbHVkZXMoc3RyLCAnJHsnKSkge1xuXHQgICAgICBzaW5nbGVRdW90ZSA9IC0yO1xuXHQgICAgfVxuXHQgICAgaWYgKHNpbmdsZVF1b3RlICE9PSAzOSkge1xuXHQgICAgICBlc2NhcGVUZXN0ID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwU2luZ2xlO1xuXHQgICAgICBlc2NhcGVSZXBsYWNlID0gc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGU7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gU29tZSBtYWdpYyBudW1iZXJzIHRoYXQgd29ya2VkIG91dCBmaW5lIHdoaWxlIGJlbmNobWFya2luZyB3aXRoIHY4IDYuMFxuXHQgIGlmIChzdHIubGVuZ3RoIDwgNTAwMCAmJiBSZWdFeHBQcm90b3R5cGVFeGVjKGVzY2FwZVRlc3QsIHN0cikgPT09IG51bGwpXG5cdCAgICByZXR1cm4gYWRkUXVvdGVzKHN0ciwgc2luZ2xlUXVvdGUpO1xuXHQgIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG5cdCAgICBzdHIgPSBSZWdFeHBQcm90b3R5cGVTeW1ib2xSZXBsYWNlKGVzY2FwZVJlcGxhY2UsIHN0ciwgZXNjYXBlRm4pO1xuXHQgICAgcmV0dXJuIGFkZFF1b3RlcyhzdHIsIHNpbmdsZVF1b3RlKTtcblx0ICB9XG5cblx0ICBsZXQgcmVzdWx0ID0gJyc7XG5cdCAgbGV0IGxhc3QgPSAwO1xuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBjb25zdCBwb2ludCA9IFN0cmluZ1Byb3RvdHlwZUNoYXJDb2RlQXQoc3RyLCBpKTtcblx0ICAgIGlmIChwb2ludCA9PT0gc2luZ2xlUXVvdGUgfHxcblx0ICAgICAgICBwb2ludCA9PT0gOTIgfHxcblx0ICAgICAgICBwb2ludCA8IDMyIHx8XG5cdCAgICAgICAgKHBvaW50ID4gMTI2ICYmIHBvaW50IDwgMTYwKSkge1xuXHQgICAgICBpZiAobGFzdCA9PT0gaSkge1xuXHQgICAgICAgIHJlc3VsdCArPSBtZXRhW3BvaW50XTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXN1bHQgKz0gYCR7U3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RyLCBsYXN0LCBpKX0ke21ldGFbcG9pbnRdfWA7XG5cdCAgICAgIH1cblx0ICAgICAgbGFzdCA9IGkgKyAxO1xuXHQgICAgfSBlbHNlIGlmIChwb2ludCA+PSAweGQ4MDAgJiYgcG9pbnQgPD0gMHhkZmZmKSB7XG5cdCAgICAgIGlmIChwb2ludCA8PSAweGRiZmYgJiYgaSArIDEgPCBzdHIubGVuZ3RoKSB7XG5cdCAgICAgICAgY29uc3QgcG9pbnQgPSBTdHJpbmdQcm90b3R5cGVDaGFyQ29kZUF0KHN0ciwgaSArIDEpO1xuXHQgICAgICAgIGlmIChwb2ludCA+PSAweGRjMDAgJiYgcG9pbnQgPD0gMHhkZmZmKSB7XG5cdCAgICAgICAgICBpKys7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmVzdWx0ICs9IGAke1N0cmluZ1Byb3RvdHlwZVNsaWNlKHN0ciwgbGFzdCwgaSl9XFxcXHUke051bWJlclByb3RvdHlwZVRvU3RyaW5nKHBvaW50LCAxNil9YDtcblx0ICAgICAgbGFzdCA9IGkgKyAxO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChsYXN0ICE9PSBzdHIubGVuZ3RoKSB7XG5cdCAgICByZXN1bHQgKz0gU3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RyLCBsYXN0KTtcblx0ICB9XG5cdCAgcmV0dXJuIGFkZFF1b3RlcyhyZXN1bHQsIHNpbmdsZVF1b3RlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcblx0ICBjb25zdCBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cdCAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGNvbnN0IGNvbG9yID0gaW5zcGVjdC5jb2xvcnNbc3R5bGVdO1xuXHQgICAgaWYgKGNvbG9yICE9PSB1bmRlZmluZWQpXG5cdCAgICAgIHJldHVybiBgXFx1MDAxYlske2NvbG9yWzBdfW0ke3N0cn1cXHUwMDFiWyR7Y29sb3JbMV19bWA7XG5cdCAgfVxuXHQgIHJldHVybiBzdHI7XG5cdH1cblxuXHRmdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIpIHtcblx0ICByZXR1cm4gc3RyO1xuXHR9XG5cblx0Ly8gUmV0dXJuIGEgbmV3IGVtcHR5IGFycmF5IHRvIHB1c2ggaW4gdGhlIHJlc3VsdHMgb2YgdGhlIGRlZmF1bHQgZm9ybWF0dGVyLlxuXHRmdW5jdGlvbiBnZXRFbXB0eUZvcm1hdEFycmF5KCkge1xuXHQgIHJldHVybiBbXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzSW5zdGFuY2VvZihvYmplY3QsIHByb3RvKSB7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBwcm90bztcblx0ICB9IGNhdGNoIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUob2JqLCBjdHgsIHJlY3Vyc2VUaW1lcywgcHJvdG9Qcm9wcykge1xuXHQgIGxldCBmaXJzdFByb3RvO1xuXHQgIGNvbnN0IHRtcCA9IG9iajtcblx0ICB3aGlsZSAob2JqIHx8IGlzVW5kZXRlY3RhYmxlT2JqZWN0KG9iaikpIHtcblx0ICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCAnY29uc3RydWN0b3InKTtcblx0ICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiZcblx0ICAgICAgICB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHQgICAgICAgIGRlc2NyaXB0b3IudmFsdWUubmFtZSAhPT0gJycgJiZcblx0ICAgICAgICBpc0luc3RhbmNlb2YodG1wLCBkZXNjcmlwdG9yLnZhbHVlKSkge1xuXHQgICAgICBpZiAocHJvdG9Qcm9wcyAhPT0gdW5kZWZpbmVkICYmXG5cdCAgICAgICAgIChmaXJzdFByb3RvICE9PSBvYmogfHxcblx0ICAgICAgICAgIWJ1aWx0SW5PYmplY3RzLmhhcyhkZXNjcmlwdG9yLnZhbHVlLm5hbWUpKSkge1xuXHQgICAgICAgIGFkZFByb3RvdHlwZVByb3BlcnRpZXMoXG5cdCAgICAgICAgICBjdHgsIHRtcCwgZmlyc3RQcm90byB8fCB0bXAsIHJlY3Vyc2VUaW1lcywgcHJvdG9Qcm9wcyk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFN0cmluZyhkZXNjcmlwdG9yLnZhbHVlLm5hbWUpO1xuXHQgICAgfVxuXG5cdCAgICBvYmogPSBPYmplY3RHZXRQcm90b3R5cGVPZihvYmopO1xuXHQgICAgaWYgKGZpcnN0UHJvdG8gPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBmaXJzdFByb3RvID0gb2JqO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChmaXJzdFByb3RvID09PSBudWxsKSB7XG5cdCAgICByZXR1cm4gbnVsbDtcblx0ICB9XG5cblx0ICBjb25zdCByZXMgPSBpbnRlcm5hbEdldENvbnN0cnVjdG9yTmFtZSh0bXApO1xuXG5cdCAgaWYgKHJlY3Vyc2VUaW1lcyA+IGN0eC5kZXB0aCAmJiBjdHguZGVwdGggIT09IG51bGwpIHtcblx0ICAgIHJldHVybiBgJHtyZXN9IDxDb21wbGV4IHByb3RvdHlwZT5gO1xuXHQgIH1cblxuXHQgIGNvbnN0IHByb3RvQ29uc3RyID0gZ2V0Q29uc3RydWN0b3JOYW1lKFxuXHQgICAgZmlyc3RQcm90bywgY3R4LCByZWN1cnNlVGltZXMgKyAxLCBwcm90b1Byb3BzKTtcblxuXHQgIGlmIChwcm90b0NvbnN0ciA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGAke3Jlc30gPCR7aW5zcGVjdChmaXJzdFByb3RvLCB7XG5cdCAgICAgIC4uLmN0eCxcblx0ICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG5cdCAgICAgIGRlcHRoOiAtMSxcblx0ICAgIH0pfT5gO1xuXHQgIH1cblxuXHQgIHJldHVybiBgJHtyZXN9IDwke3Byb3RvQ29uc3RyfT5gO1xuXHR9XG5cblx0Ly8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNpZGUgZWZmZWN0IG9mIGFkZGluZyBwcm90b3R5cGUgcHJvcGVydGllcyB0byB0aGVcblx0Ly8gYG91dHB1dGAgYXJndW1lbnQgKHdoaWNoIGlzIGFuIGFycmF5KS4gVGhpcyBpcyBpbnRlbmRlZCB0byBoaWdobGlnaHQgdXNlclxuXHQvLyBkZWZpbmVkIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuXHRmdW5jdGlvbiBhZGRQcm90b3R5cGVQcm9wZXJ0aWVzKGN0eCwgbWFpbiwgb2JqLCByZWN1cnNlVGltZXMsIG91dHB1dCkge1xuXHQgIGxldCBkZXB0aCA9IDA7XG5cdCAgbGV0IGtleXM7XG5cdCAgbGV0IGtleVNldDtcblx0ICBkbyB7XG5cdCAgICBpZiAoZGVwdGggIT09IDAgfHwgbWFpbiA9PT0gb2JqKSB7XG5cdCAgICAgIG9iaiA9IE9iamVjdEdldFByb3RvdHlwZU9mKG9iaik7XG5cdCAgICAgIC8vIFN0b3AgYXMgc29vbiBhcyBhIG51bGwgcHJvdG90eXBlIGlzIGVuY291bnRlcmVkLlxuXHQgICAgICBpZiAob2JqID09PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIFN0b3AgYXMgc29vbiBhcyBhIGJ1aWx0LWluIG9iamVjdCB0eXBlIGlzIGRldGVjdGVkLlxuXHQgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdCAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiZcblx0ICAgICAgICAgIHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICAgICAgICBidWlsdEluT2JqZWN0cy5oYXMoZGVzY3JpcHRvci52YWx1ZS5uYW1lKSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAoZGVwdGggPT09IDApIHtcblx0ICAgICAga2V5U2V0ID0gbmV3IFNhZmVTZXQoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIEFycmF5UHJvdG90eXBlRm9yRWFjaChrZXlzLCAoa2V5KSA9PiBrZXlTZXQuYWRkKGtleSkpO1xuXHQgICAgfVxuXHQgICAgLy8gR2V0IGFsbCBvd24gcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG5cdCAgICBrZXlzID0gUmVmbGVjdE93bktleXMob2JqKTtcblx0ICAgIEFycmF5UHJvdG90eXBlUHVzaChjdHguc2VlbiwgbWFpbik7XG5cdCAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG5cdCAgICAgIC8vIElnbm9yZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBhbmQga2V5cyB0aGF0IGV4aXN0IG9uIGxheWVycyBhYm92ZS5cblx0ICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fFxuXHQgICAgICAgICAgT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkobWFpbiwga2V5KSB8fFxuXHQgICAgICAgICAgKGRlcHRoICE9PSAwICYmIGtleVNldC5oYXMoa2V5KSkpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfVxuXHQgICAgICBjb25zdCBkZXNjID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblx0ICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH1cblx0ICAgICAgY29uc3QgdmFsdWUgPSBmb3JtYXRQcm9wZXJ0eShcblx0ICAgICAgICBjdHgsIG9iaiwgcmVjdXJzZVRpbWVzLCBrZXksIGtPYmplY3RUeXBlLCBkZXNjLCBtYWluKTtcblx0ICAgICAgaWYgKGN0eC5jb2xvcnMpIHtcblx0ICAgICAgICAvLyBGYWludCFcblx0ICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCBgXFx1MDAxYlsybSR7dmFsdWV9XFx1MDAxYlsyMm1gKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIEFycmF5UHJvdG90eXBlUG9wKGN0eC5zZWVuKTtcblx0ICAvLyBMaW1pdCB0aGUgaW5zcGVjdGlvbiB0byB1cCB0byB0aHJlZSBwcm90b3R5cGUgbGF5ZXJzLiBVc2luZyBgcmVjdXJzZVRpbWVzYFxuXHQgIC8vIGlzIG5vdCBhIGdvb2QgY2hvaWNlIGhlcmUsIGJlY2F1c2UgaXQncyBhcyBpZiB0aGUgcHJvcGVydGllcyBhcmUgZGVjbGFyZWRcblx0ICAvLyBvbiB0aGUgY3VycmVudCBvYmplY3QgZnJvbSB0aGUgdXNlcnMgcGVyc3BlY3RpdmUuXG5cdCAgfSB3aGlsZSAoKytkZXB0aCAhPT0gMyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgZmFsbGJhY2ssIHNpemUgPSAnJykge1xuXHQgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuXHQgICAgaWYgKHRhZyAhPT0gJycgJiYgZmFsbGJhY2sgIT09IHRhZykge1xuXHQgICAgICByZXR1cm4gYFske2ZhbGxiYWNrfSR7c2l6ZX06IG51bGwgcHJvdG90eXBlXSBbJHt0YWd9XSBgO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGBbJHtmYWxsYmFja30ke3NpemV9OiBudWxsIHByb3RvdHlwZV0gYDtcblx0ICB9XG5cblx0ICBpZiAodGFnICE9PSAnJyAmJiBjb25zdHJ1Y3RvciAhPT0gdGFnKSB7XG5cdCAgICByZXR1cm4gYCR7Y29uc3RydWN0b3J9JHtzaXplfSBbJHt0YWd9XSBgO1xuXHQgIH1cblx0ICByZXR1cm4gYCR7Y29uc3RydWN0b3J9JHtzaXplfSBgO1xuXHR9XG5cblx0Ly8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuXHRmdW5jdGlvbiBnZXRLZXlzKHZhbHVlLCBzaG93SGlkZGVuKSB7XG5cdCAgbGV0IGtleXM7XG5cdCAgY29uc3Qgc3ltYm9scyA9IE9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cdCAgaWYgKHNob3dIaWRkZW4pIHtcblx0ICAgIGtleXMgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcblx0ICAgIGlmIChzeW1ib2xzLmxlbmd0aCAhPT0gMClcblx0ICAgICAgQXJyYXlQcm90b3R5cGVQdXNoQXBwbHkoa2V5cywgc3ltYm9scyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFRoaXMgbWlnaHQgdGhyb3cgaWYgYHZhbHVlYCBpcyBhIE1vZHVsZSBOYW1lc3BhY2UgT2JqZWN0IGZyb20gYW5cblx0ICAgIC8vIHVuZXZhbHVhdGVkIG1vZHVsZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gcGVyZm9ybSB0aGUgYWN0dWFsIHR5cGVcblx0ICAgIC8vIGNoZWNrIGJlY2F1c2UgaXQncyBleHBlbnNpdmUuXG5cdCAgICAvLyBUT0RPKGRldnNuZWspOiB0cmFjayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL2lzc3Vlcy8xMjA5XG5cdCAgICAvLyBhbmQgbW9kaWZ5IHRoaXMgbG9naWMgYXMgbmVlZGVkLlxuXHQgICAgdHJ5IHtcblx0ICAgICAga2V5cyA9IE9iamVjdEtleXModmFsdWUpO1xuXHQgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgIGFzc2VydChpc05hdGl2ZUVycm9yKGVycikgJiYgZXJyLm5hbWUgPT09ICdSZWZlcmVuY2VFcnJvcicgJiZcblx0ICAgICAgICAgICAgIGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSk7XG5cdCAgICAgIGtleXMgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmIChzeW1ib2xzLmxlbmd0aCAhPT0gMCkge1xuXHQgICAgICBjb25zdCBmaWx0ZXIgPSAoa2V5KSA9PiBPYmplY3RQcm90b3R5cGVQcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWx1ZSwga2V5KTtcblx0ICAgICAgQXJyYXlQcm90b3R5cGVQdXNoQXBwbHkoa2V5cywgQXJyYXlQcm90b3R5cGVGaWx0ZXIoc3ltYm9scywgZmlsdGVyKSk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBrZXlzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpIHtcblx0ICBsZXQgZmFsbGJhY2sgPSAnJztcblx0ICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcblx0ICAgIGZhbGxiYWNrID0gaW50ZXJuYWxHZXRDb25zdHJ1Y3Rvck5hbWUodmFsdWUpO1xuXHQgICAgaWYgKGZhbGxiYWNrID09PSB0YWcpIHtcblx0ICAgICAgZmFsbGJhY2sgPSAnT2JqZWN0Jztcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjayk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQcm94eShjdHgsIHByb3h5LCByZWN1cnNlVGltZXMpIHtcblx0ICBpZiAocmVjdXJzZVRpbWVzID4gY3R4LmRlcHRoICYmIGN0eC5kZXB0aCAhPT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdQcm94eSBbQXJyYXldJywgJ3NwZWNpYWwnKTtcblx0ICB9XG5cdCAgcmVjdXJzZVRpbWVzICs9IDE7XG5cdCAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cdCAgY29uc3QgcmVzID0gW1xuXHQgICAgZm9ybWF0VmFsdWUoY3R4LCBwcm94eVswXSwgcmVjdXJzZVRpbWVzKSxcblx0ICAgIGZvcm1hdFZhbHVlKGN0eCwgcHJveHlbMV0sIHJlY3Vyc2VUaW1lcyksXG5cdCAgXTtcblx0ICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcblx0ICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcoXG5cdCAgICBjdHgsIHJlcywgJycsIFsnUHJveHkgWycsICddJ10sIGtBcnJheUV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcyk7XG5cdH1cblxuXHQvLyBOb3RlOiB1c2luZyBgZm9ybWF0VmFsdWVgIGRpcmVjdGx5IHJlcXVpcmVzIHRoZSBpbmRlbnRhdGlvbiBsZXZlbCB0byBiZVxuXHQvLyBjb3JyZWN0ZWQgYnkgc2V0dGluZyBgY3R4LmluZGVudGF0aW9uTHZMICs9IGRpZmZgIGFuZCB0aGVuIHRvIGRlY3JlYXNlIHRoZVxuXHQvLyB2YWx1ZSBhZnRlcndhcmRzIGFnYWluLlxuXHRmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcblx0ICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllcy5cblx0ICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJlxuXHQgICAgICB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiZcblx0ICAgICAgIWlzVW5kZXRlY3RhYmxlT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIGZvcm1hdFByaW1pdGl2ZShjdHguc3R5bGl6ZSwgdmFsdWUsIGN0eCk7XG5cdCAgfVxuXHQgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHQgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcblx0ICB9XG5cblx0ICAvLyBNZW1vcml6ZSB0aGUgY29udGV4dCBmb3IgY3VzdG9tIGluc3BlY3Rpb24gb24gcHJveGllcy5cblx0ICBjb25zdCBjb250ZXh0ID0gdmFsdWU7XG5cdCAgLy8gQWx3YXlzIGNoZWNrIGZvciBwcm94aWVzIHRvIHByZXZlbnQgc2lkZSBlZmZlY3RzIGFuZCB0byBwcmV2ZW50IHRyaWdnZXJpbmdcblx0ICAvLyBhbnkgcHJveHkgaGFuZGxlcnMuXG5cdCAgY29uc3QgcHJveHkgPSBnZXRQcm94eURldGFpbHModmFsdWUsICEhY3R4LnNob3dQcm94eSk7XG5cdCAgaWYgKHByb3h5ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGlmIChwcm94eSA9PT0gbnVsbCB8fCBwcm94eVswXSA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJzxSZXZva2VkIFByb3h5PicsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgICBpZiAoY3R4LnNob3dQcm94eSkge1xuXHQgICAgICByZXR1cm4gZm9ybWF0UHJveHkoY3R4LCBwcm94eSwgcmVjdXJzZVRpbWVzKTtcblx0ICAgIH1cblx0ICAgIHZhbHVlID0gcHJveHk7XG5cdCAgfVxuXG5cdCAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuXHQgIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdC5cblx0ICBpZiAoY3R4LmN1c3RvbUluc3BlY3QpIHtcblx0ICAgIGNvbnN0IG1heWJlQ3VzdG9tID0gdmFsdWVbY3VzdG9tSW5zcGVjdFN5bWJvbF07XG5cdCAgICBpZiAodHlwZW9mIG1heWJlQ3VzdG9tID09PSAnZnVuY3Rpb24nICYmXG5cdCAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0cyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWwuXG5cdCAgICAgICAgbWF5YmVDdXN0b20gIT09IGluc3BlY3QgJiZcblx0ICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cblx0ICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG5cdCAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGUgcmVjdXJzZVRpbWVzIGFyZSByZXBvcnRlZCBhcyBiZWZvcmUgd2hpbGUgdXNpbmdcblx0ICAgICAgLy8gYSBjb3VudGVyIGludGVybmFsbHkuXG5cdCAgICAgIGNvbnN0IGRlcHRoID0gY3R4LmRlcHRoID09PSBudWxsID8gbnVsbCA6IGN0eC5kZXB0aCAtIHJlY3Vyc2VUaW1lcztcblx0ICAgICAgY29uc3QgaXNDcm9zc0NvbnRleHQgPVxuXHQgICAgICAgIHByb3h5ICE9PSB1bmRlZmluZWQgfHwgIShjb250ZXh0IGluc3RhbmNlb2YgT2JqZWN0KTtcblx0ICAgICAgY29uc3QgcmV0ID0gRnVuY3Rpb25Qcm90b3R5cGVDYWxsKFxuXHQgICAgICAgIG1heWJlQ3VzdG9tLFxuXHQgICAgICAgIGNvbnRleHQsXG5cdCAgICAgICAgZGVwdGgsXG5cdCAgICAgICAgZ2V0VXNlck9wdGlvbnMoY3R4LCBpc0Nyb3NzQ29udGV4dCksXG5cdCAgICAgICAgaW5zcGVjdCxcblx0ICAgICAgKTtcblx0ICAgICAgLy8gSWYgdGhlIGN1c3RvbSBpbnNwZWN0aW9uIG1ldGhvZCByZXR1cm5lZCBgdGhpc2AsIGRvbid0IGdvIGludG9cblx0ICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXHQgICAgICBpZiAocmV0ICE9PSBjb250ZXh0KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBTdHJpbmdQcm90b3R5cGVSZXBsYWNlQWxsKHJldCwgJ1xcbicsIGBcXG4ke1N0cmluZ1Byb3RvdHlwZVJlcGVhdCgnICcsIGN0eC5pbmRlbnRhdGlvbkx2bCl9YCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICAvLyBVc2luZyBhbiBhcnJheSBoZXJlIGlzIGFjdHVhbGx5IGJldHRlciBmb3IgdGhlIGF2ZXJhZ2UgY2FzZSB0aGFuIHVzaW5nXG5cdCAgLy8gYSBTZXQuIGBzZWVuYCB3aWxsIG9ubHkgY2hlY2sgZm9yIHRoZSBkZXB0aCBhbmQgd2lsbCBuZXZlciBncm93IHRvbyBsYXJnZS5cblx0ICBpZiAoY3R4LnNlZW4uaW5jbHVkZXModmFsdWUpKSB7XG5cdCAgICBsZXQgaW5kZXggPSAxO1xuXHQgICAgaWYgKGN0eC5jaXJjdWxhciA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGN0eC5jaXJjdWxhciA9IG5ldyBTYWZlTWFwKCk7XG5cdCAgICAgIGN0eC5jaXJjdWxhci5zZXQodmFsdWUsIGluZGV4KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLmdldCh2YWx1ZSk7XG5cdCAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaW5kZXggPSBjdHguY2lyY3VsYXIuc2l6ZSArIDE7XG5cdCAgICAgICAgY3R4LmNpcmN1bGFyLnNldCh2YWx1ZSwgaW5kZXgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3R4LnN0eWxpemUoYFtDaXJjdWxhciAqJHtpbmRleH1dYCwgJ3NwZWNpYWwnKTtcblx0ICB9XG5cblx0ICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRSYXcoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB0eXBlZEFycmF5KSB7XG5cdCAgbGV0IGtleXM7XG5cdCAgbGV0IHByb3RvUHJvcHM7XG5cdCAgaWYgKGN0eC5zaG93SGlkZGVuICYmIChyZWN1cnNlVGltZXMgPD0gY3R4LmRlcHRoIHx8IGN0eC5kZXB0aCA9PT0gbnVsbCkpIHtcblx0ICAgIHByb3RvUHJvcHMgPSBbXTtcblx0ICB9XG5cblx0ICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSwgY3R4LCByZWN1cnNlVGltZXMsIHByb3RvUHJvcHMpO1xuXHQgIC8vIFJlc2V0IHRoZSB2YXJpYWJsZSB0byBjaGVjayBmb3IgdGhpcyBsYXRlciBvbi5cblx0ICBpZiAocHJvdG9Qcm9wcyAhPT0gdW5kZWZpbmVkICYmIHByb3RvUHJvcHMubGVuZ3RoID09PSAwKSB7XG5cdCAgICBwcm90b1Byb3BzID0gdW5kZWZpbmVkO1xuXHQgIH1cblxuXHQgIGxldCB0YWcgPSB2YWx1ZVtTeW1ib2xUb1N0cmluZ1RhZ107XG5cdCAgLy8gT25seSBsaXN0IHRoZSB0YWcgaW4gY2FzZSBpdCdzIG5vbi1lbnVtZXJhYmxlIC8gbm90IGFuIG93biBwcm9wZXJ0eS5cblx0ICAvLyBPdGhlcndpc2Ugd2UnZCBwcmludCB0aGlzIHR3aWNlLlxuXHQgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJyB8fFxuXHQgICAgICAodGFnICE9PSAnJyAmJlxuXHQgICAgICAoY3R4LnNob3dIaWRkZW4gP1xuXHQgICAgICAgIE9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5IDpcblx0ICAgICAgICBPYmplY3RQcm90b3R5cGVQcm9wZXJ0eUlzRW51bWVyYWJsZSkoXG5cdCAgICAgICAgdmFsdWUsIFN5bWJvbFRvU3RyaW5nVGFnLFxuXHQgICAgICApKSkge1xuXHQgICAgdGFnID0gJyc7XG5cdCAgfVxuXHQgIGxldCBiYXNlID0gJyc7XG5cdCAgbGV0IGZvcm1hdHRlciA9IGdldEVtcHR5Rm9ybWF0QXJyYXk7XG5cdCAgbGV0IGJyYWNlcztcblx0ICBsZXQgbm9JdGVyYXRvciA9IHRydWU7XG5cdCAgbGV0IGkgPSAwO1xuXHQgIGNvbnN0IGZpbHRlciA9IGN0eC5zaG93SGlkZGVuID8gQUxMX1BST1BFUlRJRVMgOiBPTkxZX0VOVU1FUkFCTEU7XG5cblx0ICBsZXQgZXh0cmFzVHlwZSA9IGtPYmplY3RUeXBlO1xuXG5cdCAgLy8gSXRlcmF0b3JzIGFuZCB0aGUgcmVzdCBhcmUgc3BsaXQgdG8gcmVkdWNlIGNoZWNrcy5cblx0ICAvLyBXZSBoYXZlIHRvIGNoZWNrIGFsbCB2YWx1ZXMgaW4gY2FzZSB0aGUgY29uc3RydWN0b3IgaXMgc2V0IHRvIG51bGwuXG5cdCAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIG5vdCBwb3NzaWJsZSB0byBpZGVudGlmeSBhbGwgdHlwZXMgcHJvcGVybHkuXG5cdCAgaWYgKFN5bWJvbEl0ZXJhdG9yIGluIHZhbHVlIHx8IGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG5cdCAgICBub0l0ZXJhdG9yID0gZmFsc2U7XG5cdCAgICBpZiAoQXJyYXlJc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAvLyBPbmx5IHNldCB0aGUgY29uc3RydWN0b3IgZm9yIG5vbiBvcmRpbmFyeSAoXCJBcnJheSBbLi4uXVwiKSBhcnJheXMuXG5cdCAgICAgIGNvbnN0IHByZWZpeCA9IChjb25zdHJ1Y3RvciAhPT0gJ0FycmF5JyB8fCB0YWcgIT09ICcnKSA/XG5cdCAgICAgICAgZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdBcnJheScsIGAoJHt2YWx1ZS5sZW5ndGh9KWApIDpcblx0ICAgICAgICAnJztcblx0ICAgICAga2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWx1ZSwgZmlsdGVyKTtcblx0ICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH1bYCwgJ10nXTtcblx0ICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCAmJiBwcm90b1Byb3BzID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgcmV0dXJuIGAke2JyYWNlc1swXX1dYDtcblx0ICAgICAgZXh0cmFzVHlwZSA9IGtBcnJheUV4dHJhc1R5cGU7XG5cdCAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEFycmF5O1xuXHQgICAgfSBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcblx0ICAgICAgY29uc3Qgc2l6ZSA9IFNldFByb3RvdHlwZUdldFNpemUodmFsdWUpO1xuXHQgICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1NldCcsIGAoJHtzaXplfSlgKTtcblx0ICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcblx0ICAgICAgZm9ybWF0dGVyID0gY29uc3RydWN0b3IgIT09IG51bGwgP1xuXHQgICAgICAgIEZ1bmN0aW9uUHJvdG90eXBlQmluZChmb3JtYXRTZXQsIG51bGwsIHZhbHVlKSA6XG5cdCAgICAgICAgRnVuY3Rpb25Qcm90b3R5cGVCaW5kKGZvcm1hdFNldCwgbnVsbCwgU2V0UHJvdG90eXBlVmFsdWVzKHZhbHVlKSk7XG5cdCAgICAgIGlmIChzaXplID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwICYmIHByb3RvUHJvcHMgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICByZXR1cm4gYCR7cHJlZml4fXt9YDtcblx0ICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH17YCwgJ30nXTtcblx0ICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG5cdCAgICAgIGNvbnN0IHNpemUgPSBNYXBQcm90b3R5cGVHZXRTaXplKHZhbHVlKTtcblx0ICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdNYXAnLCBgKCR7c2l6ZX0pYCk7XG5cdCAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG5cdCAgICAgIGZvcm1hdHRlciA9IGNvbnN0cnVjdG9yICE9PSBudWxsID9cblx0ICAgICAgICBGdW5jdGlvblByb3RvdHlwZUJpbmQoZm9ybWF0TWFwLCBudWxsLCB2YWx1ZSkgOlxuXHQgICAgICAgIEZ1bmN0aW9uUHJvdG90eXBlQmluZChmb3JtYXRNYXAsIG51bGwsIE1hcFByb3RvdHlwZUVudHJpZXModmFsdWUpKTtcblx0ICAgICAgaWYgKHNpemUgPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDAgJiYgcHJvdG9Qcm9wcyA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgIHJldHVybiBgJHtwcmVmaXh9e31gO1xuXHQgICAgICBicmFjZXMgPSBbYCR7cHJlZml4fXtgLCAnfSddO1xuXHQgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgIGtleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUsIGZpbHRlcik7XG5cdCAgICAgIGxldCBib3VuZCA9IHZhbHVlO1xuXHQgICAgICBsZXQgZmFsbGJhY2sgPSAnJztcblx0ICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBudWxsKSB7XG5cdCAgICAgICAgZmFsbGJhY2sgPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0U3ltYm9sVG9TdHJpbmdUYWcodmFsdWUpO1xuXHQgICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBhcnJheSBpbmZvcm1hdGlvbi5cblx0ICAgICAgICBib3VuZCA9IG5ldyBwcmltb3JkaWFsc1tmYWxsYmFja10odmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICAgIGNvbnN0IHNpemUgPSBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoKHZhbHVlKTtcblx0ICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrLCBgKCR7c2l6ZX0pYCk7XG5cdCAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9W2AsICddJ107XG5cdCAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDAgJiYgIWN0eC5zaG93SGlkZGVuKVxuXHQgICAgICAgIHJldHVybiBgJHticmFjZXNbMF19XWA7XG5cdCAgICAgIC8vIFNwZWNpYWwgaGFuZGxlIHRoZSB2YWx1ZS4gVGhlIG9yaWdpbmFsIHZhbHVlIGlzIHJlcXVpcmVkIGJlbG93LiBUaGVcblx0ICAgICAgLy8gYm91bmQgZnVuY3Rpb24gaXMgcmVxdWlyZWQgdG8gcmVjb25zdHJ1Y3QgbWlzc2luZyBpbmZvcm1hdGlvbi5cblx0ICAgICAgZm9ybWF0dGVyID0gRnVuY3Rpb25Qcm90b3R5cGVCaW5kKGZvcm1hdFR5cGVkQXJyYXksIG51bGwsIGJvdW5kLCBzaXplKTtcblx0ICAgICAgZXh0cmFzVHlwZSA9IGtBcnJheUV4dHJhc1R5cGU7XG5cdCAgICB9IGVsc2UgaWYgKGlzTWFwSXRlcmF0b3IodmFsdWUpKSB7XG5cdCAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG5cdCAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdNYXAnLCB0YWcpO1xuXHQgICAgICAvLyBBZGQgYnJhY2VzIHRvIHRoZSBmb3JtYXR0ZXIgcGFyYW1ldGVycy5cblx0ICAgICAgZm9ybWF0dGVyID0gRnVuY3Rpb25Qcm90b3R5cGVCaW5kKGZvcm1hdEl0ZXJhdG9yLCBudWxsLCBicmFjZXMpO1xuXHQgICAgfSBlbHNlIGlmIChpc1NldEl0ZXJhdG9yKHZhbHVlKSkge1xuXHQgICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuXHQgICAgICBicmFjZXMgPSBnZXRJdGVyYXRvckJyYWNlcygnU2V0JywgdGFnKTtcblx0ICAgICAgLy8gQWRkIGJyYWNlcyB0byB0aGUgZm9ybWF0dGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgIGZvcm1hdHRlciA9IEZ1bmN0aW9uUHJvdG90eXBlQmluZChmb3JtYXRJdGVyYXRvciwgbnVsbCwgYnJhY2VzKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5vSXRlcmF0b3IgPSB0cnVlO1xuXHQgICAgfVxuXHQgIH1cblx0ICBpZiAobm9JdGVyYXRvcikge1xuXHQgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcblx0ICAgIGJyYWNlcyA9IFsneycsICd9J107XG5cdCAgICBpZiAoY29uc3RydWN0b3IgPT09ICdPYmplY3QnKSB7XG5cdCAgICAgIGlmIChpc0FyZ3VtZW50c09iamVjdCh2YWx1ZSkpIHtcblx0ICAgICAgICBicmFjZXNbMF0gPSAnW0FyZ3VtZW50c10geyc7XG5cdCAgICAgIH0gZWxzZSBpZiAodGFnICE9PSAnJykge1xuXHQgICAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnT2JqZWN0Jyl9e2A7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmIHByb3RvUHJvcHMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBgJHticmFjZXNbMF19fWA7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIGJhc2UgPSBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpO1xuXHQgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgcHJvdG9Qcm9wcyA9PT0gdW5kZWZpbmVkKVxuXHQgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAnc3BlY2lhbCcpO1xuXHQgICAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcblx0ICAgICAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcblx0ICAgICAgYmFzZSA9IFJlZ0V4cFByb3RvdHlwZVRvU3RyaW5nKFxuXHQgICAgICAgIGNvbnN0cnVjdG9yICE9PSBudWxsID8gdmFsdWUgOiBuZXcgUmVnRXhwKHZhbHVlKSxcblx0ICAgICAgKTtcblx0ICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdSZWdFeHAnKTtcblx0ICAgICAgaWYgKHByZWZpeCAhPT0gJ1JlZ0V4cCAnKVxuXHQgICAgICAgIGJhc2UgPSBgJHtwcmVmaXh9JHtiYXNlfWA7XG5cdCAgICAgIGlmICgoa2V5cy5sZW5ndGggPT09IDAgJiYgcHJvdG9Qcm9wcyA9PT0gdW5kZWZpbmVkKSB8fFxuXHQgICAgICAgICAgKHJlY3Vyc2VUaW1lcyA+IGN0eC5kZXB0aCAmJiBjdHguZGVwdGggIT09IG51bGwpKSB7XG5cdCAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdyZWdleHAnKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChpc0RhdGUodmFsdWUpKSB7XG5cdCAgICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuXHQgICAgICBiYXNlID0gTnVtYmVySXNOYU4oRGF0ZVByb3RvdHlwZUdldFRpbWUodmFsdWUpKSA/XG5cdCAgICAgICAgRGF0ZVByb3RvdHlwZVRvU3RyaW5nKHZhbHVlKSA6XG5cdCAgICAgICAgRGF0ZVByb3RvdHlwZVRvSVNPU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdEYXRlJyk7XG5cdCAgICAgIGlmIChwcmVmaXggIT09ICdEYXRlICcpXG5cdCAgICAgICAgYmFzZSA9IGAke3ByZWZpeH0ke2Jhc2V9YDtcblx0ICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmIHByb3RvUHJvcHMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCAnZGF0ZScpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG5cdCAgICAgIGJhc2UgPSBmb3JtYXRFcnJvcih2YWx1ZSwgY29uc3RydWN0b3IsIHRhZywgY3R4LCBrZXlzKTtcblx0ICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmIHByb3RvUHJvcHMgPT09IHVuZGVmaW5lZClcblx0ICAgICAgICByZXR1cm4gYmFzZTtcblx0ICAgIH0gZWxzZSBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcblx0ICAgICAgLy8gRmFzdCBwYXRoIGZvciBBcnJheUJ1ZmZlciBhbmQgU2hhcmVkQXJyYXlCdWZmZXIuXG5cdCAgICAgIC8vIENhbid0IGRvIHRoZSBzYW1lIGZvciBEYXRhVmlldyBiZWNhdXNlIGl0IGhhcyBhIG5vbi1wcmltaXRpdmVcblx0ICAgICAgLy8gLmJ1ZmZlciBwcm9wZXJ0eSB0aGF0IHdlIG5lZWQgdG8gcmVjdXJzZSBmb3IuXG5cdCAgICAgIGNvbnN0IGFycmF5VHlwZSA9IGlzQXJyYXlCdWZmZXIodmFsdWUpID8gJ0FycmF5QnVmZmVyJyA6XG5cdCAgICAgICAgJ1NoYXJlZEFycmF5QnVmZmVyJztcblx0ICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGFycmF5VHlwZSk7XG5cdCAgICAgIGlmICh0eXBlZEFycmF5ID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRBcnJheUJ1ZmZlcjtcblx0ICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiBwcm90b1Byb3BzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gcHJlZml4ICtcblx0ICAgICAgICAgICAgICBgeyBieXRlTGVuZ3RoOiAke2Zvcm1hdE51bWJlcihjdHguc3R5bGl6ZSwgdmFsdWUuYnl0ZUxlbmd0aCwgZmFsc2UpfSB9YDtcblx0ICAgICAgfVxuXHQgICAgICBicmFjZXNbMF0gPSBgJHtwcmVmaXh9e2A7XG5cdCAgICAgIEFycmF5UHJvdG90eXBlVW5zaGlmdChrZXlzLCAnYnl0ZUxlbmd0aCcpO1xuXHQgICAgfSBlbHNlIGlmIChpc0RhdGFWaWV3KHZhbHVlKSkge1xuXHQgICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0RhdGFWaWV3Jyl9e2A7XG5cdCAgICAgIC8vIC5idWZmZXIgZ29lcyBsYXN0LCBpdCdzIG5vdCBhIHByaW1pdGl2ZSBsaWtlIHRoZSBvdGhlcnMuXG5cdCAgICAgIEFycmF5UHJvdG90eXBlVW5zaGlmdChrZXlzLCAnYnl0ZUxlbmd0aCcsICdieXRlT2Zmc2V0JywgJ2J1ZmZlcicpO1xuXHQgICAgfSBlbHNlIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG5cdCAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnUHJvbWlzZScpfXtgO1xuXHQgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRQcm9taXNlO1xuXHQgICAgfSBlbHNlIGlmIChpc1dlYWtTZXQodmFsdWUpKSB7XG5cdCAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnV2Vha1NldCcpfXtgO1xuXHQgICAgICBmb3JtYXR0ZXIgPSBjdHguc2hvd0hpZGRlbiA/IGZvcm1hdFdlYWtTZXQgOiBmb3JtYXRXZWFrQ29sbGVjdGlvbjtcblx0ICAgIH0gZWxzZSBpZiAoaXNXZWFrTWFwKHZhbHVlKSkge1xuXHQgICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1dlYWtNYXAnKX17YDtcblx0ICAgICAgZm9ybWF0dGVyID0gY3R4LnNob3dIaWRkZW4gPyBmb3JtYXRXZWFrTWFwIDogZm9ybWF0V2Vha0NvbGxlY3Rpb247XG5cdCAgICB9IGVsc2UgaWYgKGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ01vZHVsZScpfXtgO1xuXHQgICAgICAvLyBTcGVjaWFsIGhhbmRsZSBrZXlzIGZvciBuYW1lc3BhY2Ugb2JqZWN0cy5cblx0ICAgICAgZm9ybWF0dGVyID0gZm9ybWF0TmFtZXNwYWNlT2JqZWN0LmJpbmQobnVsbCwga2V5cyk7XG5cdCAgICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsdWUpKSB7XG5cdCAgICAgIGJhc2UgPSBnZXRCb3hlZEJhc2UodmFsdWUsIGN0eCwga2V5cywgY29uc3RydWN0b3IsIHRhZyk7XG5cdCAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiBwcm90b1Byb3BzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICByZXR1cm4gYmFzZTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmIHByb3RvUHJvcHMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmIChpc0V4dGVybmFsKHZhbHVlKSkge1xuXHQgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEV4dGVybmFsVmFsdWUodmFsdWUpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICAgIHJldHVybiBjdHguc3R5bGl6ZShgW0V4dGVybmFsOiAke2FkZHJlc3N9XWAsICdzcGVjaWFsJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBgJHtnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyl9e31gO1xuXHQgICAgICB9XG5cdCAgICAgIGJyYWNlc1swXSA9IGAke2dldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKX17YDtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBpZiAocmVjdXJzZVRpbWVzID4gY3R4LmRlcHRoICYmIGN0eC5kZXB0aCAhPT0gbnVsbCkge1xuXHQgICAgbGV0IGNvbnN0cnVjdG9yTmFtZSA9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKGdldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKSwgMCwgLTEpO1xuXHQgICAgaWYgKGNvbnN0cnVjdG9yICE9PSBudWxsKVxuXHQgICAgICBjb25zdHJ1Y3Rvck5hbWUgPSBgWyR7Y29uc3RydWN0b3JOYW1lfV1gO1xuXHQgICAgcmV0dXJuIGN0eC5zdHlsaXplKGNvbnN0cnVjdG9yTmFtZSwgJ3NwZWNpYWwnKTtcblx0ICB9XG5cdCAgcmVjdXJzZVRpbWVzICs9IDE7XG5cblx0ICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblx0ICBjdHguY3VycmVudERlcHRoID0gcmVjdXJzZVRpbWVzO1xuXHQgIGxldCBvdXRwdXQ7XG5cdCAgY29uc3QgaW5kZW50YXRpb25MdmwgPSBjdHguaW5kZW50YXRpb25Mdmw7XG5cdCAgdHJ5IHtcblx0ICAgIG91dHB1dCA9IGZvcm1hdHRlcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgQXJyYXlQcm90b3R5cGVQdXNoKFxuXHQgICAgICAgIG91dHB1dCxcblx0ICAgICAgICBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleXNbaV0sIGV4dHJhc1R5cGUpLFxuXHQgICAgICApO1xuXHQgICAgfVxuXHQgICAgaWYgKHByb3RvUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBBcnJheVByb3RvdHlwZVB1c2hBcHBseShvdXRwdXQsIHByb3RvUHJvcHMpO1xuXHQgICAgfVxuXHQgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgY29uc3QgY29uc3RydWN0b3JOYW1lID0gU3RyaW5nUHJvdG90eXBlU2xpY2UoZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpLCAwLCAtMSk7XG5cdCAgICByZXR1cm4gaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZShjdHgsIGVyciwgY29uc3RydWN0b3JOYW1lLCBpbmRlbnRhdGlvbkx2bCk7XG5cdCAgfVxuXHQgIGlmIChjdHguY2lyY3VsYXIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgY29uc3QgaW5kZXggPSBjdHguY2lyY3VsYXIuZ2V0KHZhbHVlKTtcblx0ICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IGN0eC5zdHlsaXplKGA8cmVmICoke2luZGV4fT5gLCAnc3BlY2lhbCcpO1xuXHQgICAgICAvLyBBZGQgcmVmZXJlbmNlIGFsd2F5cyB0byB0aGUgdmVyeSBiZWdpbm5pbmcgb2YgdGhlIG91dHB1dC5cblx0ICAgICAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlKSB7XG5cdCAgICAgICAgYmFzZSA9IGJhc2UgPT09ICcnID8gcmVmZXJlbmNlIDogYCR7cmVmZXJlbmNlfSAke2Jhc2V9YDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBicmFjZXNbMF0gPSBgJHtyZWZlcmVuY2V9ICR7YnJhY2VzWzBdfWA7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgY3R4LnNlZW4ucG9wKCk7XG5cblx0ICBpZiAoY3R4LnNvcnRlZCkge1xuXHQgICAgY29uc3QgY29tcGFyYXRvciA9IGN0eC5zb3J0ZWQgPT09IHRydWUgPyB1bmRlZmluZWQgOiBjdHguc29ydGVkO1xuXHQgICAgaWYgKGV4dHJhc1R5cGUgPT09IGtPYmplY3RUeXBlKSB7XG5cdCAgICAgIEFycmF5UHJvdG90eXBlU29ydChvdXRwdXQsIGNvbXBhcmF0b3IpO1xuXHQgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgY29uc3Qgc29ydGVkID0gQXJyYXlQcm90b3R5cGVTb3J0KEFycmF5UHJvdG90eXBlU2xpY2Uob3V0cHV0LCBvdXRwdXQubGVuZ3RoIC0ga2V5cy5sZW5ndGgpLCBjb21wYXJhdG9yKTtcblx0ICAgICAgQXJyYXlQcm90b3R5cGVVbnNoaWZ0KHNvcnRlZCwgb3V0cHV0LCBvdXRwdXQubGVuZ3RoIC0ga2V5cy5sZW5ndGgsIGtleXMubGVuZ3RoKTtcblx0ICAgICAgUmVmbGVjdEFwcGx5KEFycmF5UHJvdG90eXBlU3BsaWNlLCBudWxsLCBzb3J0ZWQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGNvbnN0IHJlcyA9IHJlZHVjZVRvU2luZ2xlU3RyaW5nKFxuXHQgICAgY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSk7XG5cdCAgY29uc3QgYnVkZ2V0ID0gY3R4LmJ1ZGdldFtjdHguaW5kZW50YXRpb25MdmxdIHx8IDA7XG5cdCAgY29uc3QgbmV3TGVuZ3RoID0gYnVkZ2V0ICsgcmVzLmxlbmd0aDtcblx0ICBjdHguYnVkZ2V0W2N0eC5pbmRlbnRhdGlvbkx2bF0gPSBuZXdMZW5ndGg7XG5cdCAgLy8gSWYgYW55IGluZGVudGF0aW9uTHZsIGV4Y2VlZHMgdGhpcyBsaW1pdCwgbGltaXQgZnVydGhlciBpbnNwZWN0aW5nIHRvIHRoZVxuXHQgIC8vIG1pbmltdW0uIE90aGVyd2lzZSB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobSBtaWdodCBjb250aW51ZSBpbnNwZWN0aW5nIHRoZVxuXHQgIC8vIG9iamVjdCBldmVuIHRob3VnaCB0aGUgbWF4aW11bSBzdHJpbmcgc2l6ZSAofjIgKiogMjggb24gMzIgYml0IHN5c3RlbXMgYW5kXG5cdCAgLy8gfjIgKiogMzAgb24gNjQgYml0IHN5c3RlbXMpIGV4Y2VlZGVkLiBUaGUgYWN0dWFsIG91dHB1dCBpcyBub3QgbGltaXRlZCBhdFxuXHQgIC8vIGV4YWN0bHkgMiAqKiAyNyBidXQgYSBiaXQgaGlnaGVyLiBUaGlzIGRlcGVuZHMgb24gdGhlIG9iamVjdCBzaGFwZS5cblx0ICAvLyBUaGlzIGxpbWl0IGFsc28gbWFrZXMgc3VyZSB0aGF0IGh1Z2Ugb2JqZWN0cyBkb24ndCBibG9jayB0aGUgZXZlbnQgbG9vcFxuXHQgIC8vIHNpZ25pZmljYW50bHkuXG5cdCAgaWYgKG5ld0xlbmd0aCA+IDIgKiogMjcpIHtcblx0ICAgIGN0eC5kZXB0aCA9IC0xO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0b3JCcmFjZXModHlwZSwgdGFnKSB7XG5cdCAgaWYgKHRhZyAhPT0gYCR7dHlwZX0gSXRlcmF0b3JgKSB7XG5cdCAgICBpZiAodGFnICE9PSAnJylcblx0ICAgICAgdGFnICs9ICddIFsnO1xuXHQgICAgdGFnICs9IGAke3R5cGV9IEl0ZXJhdG9yYDtcblx0ICB9XG5cdCAgcmV0dXJuIFtgWyR7dGFnfV0ge2AsICd9J107XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCb3hlZEJhc2UodmFsdWUsIGN0eCwga2V5cywgY29uc3RydWN0b3IsIHRhZykge1xuXHQgIGxldCBmbjtcblx0ICBsZXQgdHlwZTtcblx0ICBpZiAoaXNOdW1iZXJPYmplY3QodmFsdWUpKSB7XG5cdCAgICBmbiA9IE51bWJlclByb3RvdHlwZVZhbHVlT2Y7XG5cdCAgICB0eXBlID0gJ051bWJlcic7XG5cdCAgfSBlbHNlIGlmIChpc1N0cmluZ09iamVjdCh2YWx1ZSkpIHtcblx0ICAgIGZuID0gU3RyaW5nUHJvdG90eXBlVmFsdWVPZjtcblx0ICAgIHR5cGUgPSAnU3RyaW5nJztcblx0ICAgIC8vIEZvciBib3hlZCBTdHJpbmdzLCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgMC1uIGluZGV4ZWQgZW50cmllcyxcblx0ICAgIC8vIHNpbmNlIHRoZXkganVzdCBub2lzeSB1cCB0aGUgb3V0cHV0IGFuZCBhcmUgcmVkdW5kYW50XG5cdCAgICAvLyBNYWtlIGJveGVkIHByaW1pdGl2ZSBTdHJpbmdzIGxvb2sgbGlrZSBzdWNoXG5cdCAgICBrZXlzLnNwbGljZSgwLCB2YWx1ZS5sZW5ndGgpO1xuXHQgIH0gZWxzZSBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgZm4gPSBCb29sZWFuUHJvdG90eXBlVmFsdWVPZjtcblx0ICAgIHR5cGUgPSAnQm9vbGVhbic7XG5cdCAgfSBlbHNlIGlmIChpc0JpZ0ludE9iamVjdCh2YWx1ZSkpIHtcblx0ICAgIGZuID0gQmlnSW50UHJvdG90eXBlVmFsdWVPZjtcblx0ICAgIHR5cGUgPSAnQmlnSW50Jztcblx0ICB9IGVsc2Uge1xuXHQgICAgZm4gPSBTeW1ib2xQcm90b3R5cGVWYWx1ZU9mO1xuXHQgICAgdHlwZSA9ICdTeW1ib2wnO1xuXHQgIH1cblx0ICBsZXQgYmFzZSA9IGBbJHt0eXBlfWA7XG5cdCAgaWYgKHR5cGUgIT09IGNvbnN0cnVjdG9yKSB7XG5cdCAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcblx0ICAgICAgYmFzZSArPSAnIChudWxsIHByb3RvdHlwZSknO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYmFzZSArPSBgICgke2NvbnN0cnVjdG9yfSlgO1xuXHQgICAgfVxuXHQgIH1cblx0ICBiYXNlICs9IGA6ICR7Zm9ybWF0UHJpbWl0aXZlKHN0eWxpemVOb0NvbG9yLCBmbih2YWx1ZSksIGN0eCl9XWA7XG5cdCAgaWYgKHRhZyAhPT0gJycgJiYgdGFnICE9PSBjb25zdHJ1Y3Rvcikge1xuXHQgICAgYmFzZSArPSBgIFske3RhZ31dYDtcblx0ICB9XG5cdCAgaWYgKGtleXMubGVuZ3RoICE9PSAwIHx8IGN0eC5zdHlsaXplID09PSBzdHlsaXplTm9Db2xvcilcblx0ICAgIHJldHVybiBiYXNlO1xuXHQgIHJldHVybiBjdHguc3R5bGl6ZShiYXNlLCBTdHJpbmdQcm90b3R5cGVUb0xvd2VyQ2FzZSh0eXBlKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDbGFzc0Jhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpIHtcblx0ICBjb25zdCBoYXNOYW1lID0gT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkodmFsdWUsICduYW1lJyk7XG5cdCAgY29uc3QgbmFtZSA9IChoYXNOYW1lICYmIHZhbHVlLm5hbWUpIHx8ICcoYW5vbnltb3VzKSc7XG5cdCAgbGV0IGJhc2UgPSBgY2xhc3MgJHtuYW1lfWA7XG5cdCAgaWYgKGNvbnN0cnVjdG9yICE9PSAnRnVuY3Rpb24nICYmIGNvbnN0cnVjdG9yICE9PSBudWxsKSB7XG5cdCAgICBiYXNlICs9IGAgWyR7Y29uc3RydWN0b3J9XWA7XG5cdCAgfVxuXHQgIGlmICh0YWcgIT09ICcnICYmIGNvbnN0cnVjdG9yICE9PSB0YWcpIHtcblx0ICAgIGJhc2UgKz0gYCBbJHt0YWd9XWA7XG5cdCAgfVxuXHQgIGlmIChjb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuXHQgICAgY29uc3Qgc3VwZXJOYW1lID0gT2JqZWN0R2V0UHJvdG90eXBlT2YodmFsdWUpLm5hbWU7XG5cdCAgICBpZiAoc3VwZXJOYW1lKSB7XG5cdCAgICAgIGJhc2UgKz0gYCBleHRlbmRzICR7c3VwZXJOYW1lfWA7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJhc2UgKz0gJyBleHRlbmRzIFtudWxsIHByb3RvdHlwZV0nO1xuXHQgIH1cblx0ICByZXR1cm4gYFske2Jhc2V9XWA7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpIHtcblx0ICBjb25zdCBzdHJpbmdpZmllZCA9IEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcodmFsdWUpO1xuXHQgIGlmIChTdHJpbmdQcm90b3R5cGVTdGFydHNXaXRoKHN0cmluZ2lmaWVkLCAnY2xhc3MnKSAmJiBTdHJpbmdQcm90b3R5cGVFbmRzV2l0aChzdHJpbmdpZmllZCwgJ30nKSkge1xuXHQgICAgY29uc3Qgc2xpY2UgPSBTdHJpbmdQcm90b3R5cGVTbGljZShzdHJpbmdpZmllZCwgNSwgLTEpO1xuXHQgICAgY29uc3QgYnJhY2tldEluZGV4ID0gU3RyaW5nUHJvdG90eXBlSW5kZXhPZihzbGljZSwgJ3snKTtcblx0ICAgIGlmIChicmFja2V0SW5kZXggIT09IC0xICYmXG5cdCAgICAgICAgKCFTdHJpbmdQcm90b3R5cGVJbmNsdWRlcyhTdHJpbmdQcm90b3R5cGVTbGljZShzbGljZSwgMCwgYnJhY2tldEluZGV4KSwgJygnKSB8fFxuXHQgICAgICAgIC8vIFNsb3cgcGF0aCB0byBndWFyYW50ZWUgdGhhdCBpdCdzIGluZGVlZCBhIGNsYXNzLlxuXHQgICAgICAgIFJlZ0V4cFByb3RvdHlwZUV4ZWMoY2xhc3NSZWdFeHAsIFJlZ0V4cFByb3RvdHlwZVN5bWJvbFJlcGxhY2Uoc3RyaXBDb21tZW50c1JlZ0V4cCwgc2xpY2UpKSAhPT0gbnVsbClcblx0ICAgICkge1xuXHQgICAgICByZXR1cm4gZ2V0Q2xhc3NCYXNlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgbGV0IHR5cGUgPSAnRnVuY3Rpb24nO1xuXHQgIGlmIChpc0dlbmVyYXRvckZ1bmN0aW9uKHZhbHVlKSkge1xuXHQgICAgdHlwZSA9IGBHZW5lcmF0b3Ike3R5cGV9YDtcblx0ICB9XG5cdCAgaWYgKGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkpIHtcblx0ICAgIHR5cGUgPSBgQXN5bmMke3R5cGV9YDtcblx0ICB9XG5cdCAgbGV0IGJhc2UgPSBgWyR7dHlwZX1gO1xuXHQgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuXHQgICAgYmFzZSArPSAnIChudWxsIHByb3RvdHlwZSknO1xuXHQgIH1cblx0ICBpZiAodmFsdWUubmFtZSA9PT0gJycpIHtcblx0ICAgIGJhc2UgKz0gJyAoYW5vbnltb3VzKSc7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJhc2UgKz0gYDogJHt2YWx1ZS5uYW1lfWA7XG5cdCAgfVxuXHQgIGJhc2UgKz0gJ10nO1xuXHQgIGlmIChjb25zdHJ1Y3RvciAhPT0gdHlwZSAmJiBjb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuXHQgICAgYmFzZSArPSBgICR7Y29uc3RydWN0b3J9YDtcblx0ICB9XG5cdCAgaWYgKHRhZyAhPT0gJycgJiYgY29uc3RydWN0b3IgIT09IHRhZykge1xuXHQgICAgYmFzZSArPSBgIFske3RhZ31dYDtcblx0ICB9XG5cdCAgcmV0dXJuIGJhc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBpZGVudGljYWxTZXF1ZW5jZVJhbmdlKGEsIGIpIHtcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoIC0gMzsgaSsrKSB7XG5cdCAgICAvLyBGaW5kIHRoZSBmaXJzdCBlbnRyeSBvZiBiIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBlbnRyeSBvZiBhLlxuXHQgICAgY29uc3QgcG9zID0gYi5pbmRleE9mKGFbaV0pO1xuXHQgICAgaWYgKHBvcyAhPT0gLTEpIHtcblx0ICAgICAgY29uc3QgcmVzdCA9IGIubGVuZ3RoIC0gcG9zO1xuXHQgICAgICBpZiAocmVzdCA+IDMpIHtcblx0ICAgICAgICBsZXQgbGVuID0gMTtcblx0ICAgICAgICBjb25zdCBtYXhMZW4gPSBNYXRoTWluKGEubGVuZ3RoIC0gaSwgcmVzdCk7XG5cdCAgICAgICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBlbnRyaWVzLlxuXHQgICAgICAgIHdoaWxlIChtYXhMZW4gPiBsZW4gJiYgYVtpICsgbGVuXSA9PT0gYltwb3MgKyBsZW5dKSB7XG5cdCAgICAgICAgICBsZW4rKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxlbiA+IDMpIHtcblx0ICAgICAgICAgIHJldHVybiB7IGxlbiwgb2Zmc2V0OiBpIH07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHsgbGVuOiAwLCBvZmZzZXQ6IDAgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFN0YWNrU3RyaW5nKGVycm9yKSB7XG5cdCAgcmV0dXJuIGVycm9yLnN0YWNrID8gU3RyaW5nKGVycm9yLnN0YWNrKSA6IEVycm9yUHJvdG90eXBlVG9TdHJpbmcoZXJyb3IpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U3RhY2tGcmFtZXMoY3R4LCBlcnIsIHN0YWNrKSB7XG5cdCAgY29uc3QgZnJhbWVzID0gU3RyaW5nUHJvdG90eXBlU3BsaXQoc3RhY2ssICdcXG4nKTtcblxuXHQgIGxldCBjYXVzZTtcblx0ICB0cnkge1xuXHQgICAgKHsgY2F1c2UgfSA9IGVycik7XG5cdCAgfSBjYXRjaCB7XG5cdCAgICAvLyBJZiAnY2F1c2UnIGlzIGEgZ2V0dGVyIHRoYXQgdGhyb3dzLCBpZ25vcmUgaXQuXG5cdCAgfVxuXG5cdCAgLy8gUmVtb3ZlIHN0YWNrIGZyYW1lcyBpZGVudGljYWwgdG8gZnJhbWVzIGluIGNhdXNlLlxuXHQgIGlmIChjYXVzZSAhPSBudWxsICYmIGlzRXJyb3IoY2F1c2UpKSB7XG5cdCAgICBjb25zdCBjYXVzZVN0YWNrID0gZ2V0U3RhY2tTdHJpbmcoY2F1c2UpO1xuXHQgICAgY29uc3QgY2F1c2VTdGFja1N0YXJ0ID0gU3RyaW5nUHJvdG90eXBlSW5kZXhPZihjYXVzZVN0YWNrLCAnXFxuICAgIGF0Jyk7XG5cdCAgICBpZiAoY2F1c2VTdGFja1N0YXJ0ICE9PSAtMSkge1xuXHQgICAgICBjb25zdCBjYXVzZUZyYW1lcyA9IFN0cmluZ1Byb3RvdHlwZVNwbGl0KFN0cmluZ1Byb3RvdHlwZVNsaWNlKGNhdXNlU3RhY2ssIGNhdXNlU3RhY2tTdGFydCArIDEpLCAnXFxuJyk7XG5cdCAgICAgIGNvbnN0IHsgbGVuLCBvZmZzZXQgfSA9IGlkZW50aWNhbFNlcXVlbmNlUmFuZ2UoZnJhbWVzLCBjYXVzZUZyYW1lcyk7XG5cdCAgICAgIGlmIChsZW4gPiAwKSB7XG5cdCAgICAgICAgY29uc3Qgc2tpcHBlZCA9IGxlbiAtIDI7XG5cdCAgICAgICAgY29uc3QgbXNnID0gYCAgICAuLi4gJHtza2lwcGVkfSBsaW5lcyBtYXRjaGluZyBjYXVzZSBzdGFjayB0cmFjZSAuLi5gO1xuXHQgICAgICAgIGZyYW1lcy5zcGxpY2Uob2Zmc2V0ICsgMSwgc2tpcHBlZCwgY3R4LnN0eWxpemUobXNnLCAndW5kZWZpbmVkJykpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBmcmFtZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXByb3ZlU3RhY2soc3RhY2ssIGNvbnN0cnVjdG9yLCBuYW1lLCB0YWcpIHtcblx0ICAvLyBBIHN0YWNrIHRyYWNlIG1heSBjb250YWluIGFyYml0cmFyeSBkYXRhLiBPbmx5IG1hbmlwdWxhdGUgdGhlIG91dHB1dFxuXHQgIC8vIGZvciBcInJlZ3VsYXIgZXJyb3JzXCIgKGVycm9ycyB0aGF0IFwibG9vayBub3JtYWxcIikgZm9yIG5vdy5cblx0ICBsZXQgbGVuID0gbmFtZS5sZW5ndGg7XG5cblx0ICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwgfHxcblx0ICAgICAgKFN0cmluZ1Byb3RvdHlwZUVuZHNXaXRoKG5hbWUsICdFcnJvcicpICYmXG5cdCAgICAgIFN0cmluZ1Byb3RvdHlwZVN0YXJ0c1dpdGgoc3RhY2ssIG5hbWUpICYmXG5cdCAgICAgIChzdGFjay5sZW5ndGggPT09IGxlbiB8fCBzdGFja1tsZW5dID09PSAnOicgfHwgc3RhY2tbbGVuXSA9PT0gJ1xcbicpKSkge1xuXHQgICAgbGV0IGZhbGxiYWNrID0gJ0Vycm9yJztcblx0ICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuXHQgICAgICBjb25zdCBzdGFydCA9IFJlZ0V4cFByb3RvdHlwZUV4ZWMoL14oW0EtWl1bYS16XyBBLVowLTlbXFxdKCktXSspKD86OnxcXG4gezR9YXQpLywgc3RhY2spIHx8XG5cdCAgICAgIFJlZ0V4cFByb3RvdHlwZUV4ZWMoL14oW2Etel9BLVowLTktXSpFcnJvcikkLywgc3RhY2spO1xuXHQgICAgICBmYWxsYmFjayA9IChzdGFydCAmJiBzdGFydFsxXSkgfHwgJyc7XG5cdCAgICAgIGxlbiA9IGZhbGxiYWNrLmxlbmd0aDtcblx0ICAgICAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCAnRXJyb3InO1xuXHQgICAgfVxuXHQgICAgY29uc3QgcHJlZml4ID0gU3RyaW5nUHJvdG90eXBlU2xpY2UoZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrKSwgMCwgLTEpO1xuXHQgICAgaWYgKG5hbWUgIT09IHByZWZpeCkge1xuXHQgICAgICBpZiAoU3RyaW5nUHJvdG90eXBlSW5jbHVkZXMocHJlZml4LCBuYW1lKSkge1xuXHQgICAgICAgIGlmIChsZW4gPT09IDApIHtcblx0ICAgICAgICAgIHN0YWNrID0gYCR7cHJlZml4fTogJHtzdGFja31gO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBzdGFjayA9IGAke3ByZWZpeH0ke1N0cmluZ1Byb3RvdHlwZVNsaWNlKHN0YWNrLCBsZW4pfWA7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0YWNrID0gYCR7cHJlZml4fSBbJHtuYW1lfV0ke1N0cmluZ1Byb3RvdHlwZVNsaWNlKHN0YWNrLCBsZW4pfWA7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHN0YWNrO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlRXJyb3JLZXlzKGN0eCwga2V5cywgZXJyLCBzdGFjaykge1xuXHQgIGlmICghY3R4LnNob3dIaWRkZW4gJiYga2V5cy5sZW5ndGggIT09IDApIHtcblx0ICAgIGZvciAoY29uc3QgbmFtZSBvZiBbJ25hbWUnLCAnbWVzc2FnZScsICdzdGFjayddKSB7XG5cdCAgICAgIGNvbnN0IGluZGV4ID0gQXJyYXlQcm90b3R5cGVJbmRleE9mKGtleXMsIG5hbWUpO1xuXHQgICAgICAvLyBPbmx5IGhpZGUgdGhlIHByb3BlcnR5IGluIGNhc2UgaXQncyBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBzdGFja1xuXHQgICAgICBpZiAoaW5kZXggIT09IC0xICYmIFN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKHN0YWNrLCBlcnJbbmFtZV0pKSB7XG5cdCAgICAgICAgQXJyYXlQcm90b3R5cGVTcGxpY2Uoa2V5cywgaW5kZXgsIDEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya05vZGVNb2R1bGVzKGN0eCwgbGluZSkge1xuXHQgIGxldCB0ZW1wTGluZSA9ICcnO1xuXHQgIGxldCBub2RlTW9kdWxlO1xuXHQgIGxldCBwb3MgPSAwO1xuXHQgIHdoaWxlICgobm9kZU1vZHVsZSA9IG5vZGVNb2R1bGVzUmVnRXhwLmV4ZWMobGluZSkpICE9PSBudWxsKSB7XG5cdCAgICAvLyAnL25vZGVfbW9kdWxlcy8nLmxlbmd0aCA9PT0gMTRcblx0ICAgIHRlbXBMaW5lICs9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKGxpbmUsIHBvcywgbm9kZU1vZHVsZS5pbmRleCArIDE0KTtcblx0ICAgIHRlbXBMaW5lICs9IGN0eC5zdHlsaXplKG5vZGVNb2R1bGVbMV0sICdtb2R1bGUnKTtcblx0ICAgIHBvcyA9IG5vZGVNb2R1bGUuaW5kZXggKyBub2RlTW9kdWxlWzBdLmxlbmd0aDtcblx0ICB9XG5cdCAgaWYgKHBvcyAhPT0gMCkge1xuXHQgICAgbGluZSA9IHRlbXBMaW5lICsgU3RyaW5nUHJvdG90eXBlU2xpY2UobGluZSwgcG9zKTtcblx0ICB9XG5cdCAgcmV0dXJuIGxpbmU7XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrQ3dkKGN0eCwgbGluZSwgd29ya2luZ0RpcmVjdG9yeSkge1xuXHQgIGxldCBjd2RTdGFydFBvcyA9IFN0cmluZ1Byb3RvdHlwZUluZGV4T2YobGluZSwgd29ya2luZ0RpcmVjdG9yeSk7XG5cdCAgbGV0IHRlbXBMaW5lID0gJyc7XG5cdCAgbGV0IGN3ZExlbmd0aCA9IHdvcmtpbmdEaXJlY3RvcnkubGVuZ3RoO1xuXHQgIGlmIChjd2RTdGFydFBvcyAhPT0gLTEpIHtcblx0ICAgIGlmIChTdHJpbmdQcm90b3R5cGVTbGljZShsaW5lLCBjd2RTdGFydFBvcyAtIDcsIGN3ZFN0YXJ0UG9zKSA9PT0gJ2ZpbGU6Ly8nKSB7XG5cdCAgICAgIGN3ZExlbmd0aCArPSA3O1xuXHQgICAgICBjd2RTdGFydFBvcyAtPSA3O1xuXHQgICAgfVxuXHQgICAgY29uc3Qgc3RhcnQgPSBsaW5lW2N3ZFN0YXJ0UG9zIC0gMV0gPT09ICcoJyA/IGN3ZFN0YXJ0UG9zIC0gMSA6IGN3ZFN0YXJ0UG9zO1xuXHQgICAgY29uc3QgZW5kID0gc3RhcnQgIT09IGN3ZFN0YXJ0UG9zICYmIFN0cmluZ1Byb3RvdHlwZUVuZHNXaXRoKGxpbmUsICcpJykgPyAtMSA6IGxpbmUubGVuZ3RoO1xuXHQgICAgY29uc3Qgd29ya2luZ0RpcmVjdG9yeUVuZFBvcyA9IGN3ZFN0YXJ0UG9zICsgY3dkTGVuZ3RoICsgMTtcblx0ICAgIGNvbnN0IGN3ZFNsaWNlID0gU3RyaW5nUHJvdG90eXBlU2xpY2UobGluZSwgc3RhcnQsIHdvcmtpbmdEaXJlY3RvcnlFbmRQb3MpO1xuXG5cdCAgICB0ZW1wTGluZSArPSBTdHJpbmdQcm90b3R5cGVTbGljZShsaW5lLCAwLCBzdGFydCk7XG5cdCAgICB0ZW1wTGluZSArPSBjdHguc3R5bGl6ZShjd2RTbGljZSwgJ3VuZGVmaW5lZCcpO1xuXHQgICAgdGVtcExpbmUgKz0gU3RyaW5nUHJvdG90eXBlU2xpY2UobGluZSwgd29ya2luZ0RpcmVjdG9yeUVuZFBvcywgZW5kKTtcblx0ICAgIGlmIChlbmQgPT09IC0xKSB7XG5cdCAgICAgIHRlbXBMaW5lICs9IGN0eC5zdHlsaXplKCcpJywgJ3VuZGVmaW5lZCcpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICB0ZW1wTGluZSArPSBsaW5lO1xuXHQgIH1cblx0ICByZXR1cm4gdGVtcExpbmU7XG5cdH1cblxuXHRmdW5jdGlvbiBzYWZlR2V0Q1dEKCkge1xuXHQgIGxldCB3b3JraW5nRGlyZWN0b3J5O1xuXHQgIHRyeSB7XG5cdCAgICB3b3JraW5nRGlyZWN0b3J5ID0gcHJvY2Vzcy5jd2QoKTtcblx0ICB9IGNhdGNoIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgcmV0dXJuIHdvcmtpbmdEaXJlY3Rvcnk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcihlcnIsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCwga2V5cykge1xuXHQgIGNvbnN0IG5hbWUgPSBlcnIubmFtZSAhPSBudWxsID8gU3RyaW5nKGVyci5uYW1lKSA6ICdFcnJvcic7XG5cdCAgbGV0IHN0YWNrID0gZ2V0U3RhY2tTdHJpbmcoZXJyKTtcblxuXHQgIHJlbW92ZUR1cGxpY2F0ZUVycm9yS2V5cyhjdHgsIGtleXMsIGVyciwgc3RhY2spO1xuXG5cdCAgaWYgKCdjYXVzZScgaW4gZXJyICYmXG5cdCAgICAgIChrZXlzLmxlbmd0aCA9PT0gMCB8fCAhQXJyYXlQcm90b3R5cGVJbmNsdWRlcyhrZXlzLCAnY2F1c2UnKSkpIHtcblx0ICAgIEFycmF5UHJvdG90eXBlUHVzaChrZXlzLCAnY2F1c2UnKTtcblx0ICB9XG5cblx0ICAvLyBQcmludCBlcnJvcnMgYWdncmVnYXRlZCBpbnRvIEFnZ3JlZ2F0ZUVycm9yXG5cdCAgaWYgKEFycmF5SXNBcnJheShlcnIuZXJyb3JzKSAmJlxuXHQgICAgICAoa2V5cy5sZW5ndGggPT09IDAgfHwgIUFycmF5UHJvdG90eXBlSW5jbHVkZXMoa2V5cywgJ2Vycm9ycycpKSkge1xuXHQgICAgQXJyYXlQcm90b3R5cGVQdXNoKGtleXMsICdlcnJvcnMnKTtcblx0ICB9XG5cblx0ICBzdGFjayA9IGltcHJvdmVTdGFjayhzdGFjaywgY29uc3RydWN0b3IsIG5hbWUsIHRhZyk7XG5cblx0ICAvLyBJZ25vcmUgdGhlIGVycm9yIG1lc3NhZ2UgaWYgaXQncyBjb250YWluZWQgaW4gdGhlIHN0YWNrLlxuXHQgIGxldCBwb3MgPSAoZXJyLm1lc3NhZ2UgJiYgU3RyaW5nUHJvdG90eXBlSW5kZXhPZihzdGFjaywgZXJyLm1lc3NhZ2UpKSB8fCAtMTtcblx0ICBpZiAocG9zICE9PSAtMSlcblx0ICAgIHBvcyArPSBlcnIubWVzc2FnZS5sZW5ndGg7XG5cdCAgLy8gV3JhcCB0aGUgZXJyb3IgaW4gYnJhY2tldHMgaW4gY2FzZSBpdCBoYXMgbm8gc3RhY2sgdHJhY2UuXG5cdCAgY29uc3Qgc3RhY2tTdGFydCA9IFN0cmluZ1Byb3RvdHlwZUluZGV4T2Yoc3RhY2ssICdcXG4gICAgYXQnLCBwb3MpO1xuXHQgIGlmIChzdGFja1N0YXJ0ID09PSAtMSkge1xuXHQgICAgc3RhY2sgPSBgWyR7c3RhY2t9XWA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGxldCBuZXdTdGFjayA9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKHN0YWNrLCAwLCBzdGFja1N0YXJ0KTtcblx0ICAgIGNvbnN0IHN0YWNrRnJhbWVQYXJ0ID0gU3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RhY2ssIHN0YWNrU3RhcnQgKyAxKTtcblx0ICAgIGNvbnN0IGxpbmVzID0gZ2V0U3RhY2tGcmFtZXMoY3R4LCBlcnIsIHN0YWNrRnJhbWVQYXJ0KTtcblx0ICAgIGlmIChjdHguY29sb3JzKSB7XG5cdCAgICAgIC8vIEhpZ2hsaWdodCB1c2VybGFuZCBjb2RlIGFuZCBub2RlIG1vZHVsZXMuXG5cdCAgICAgIGNvbnN0IHdvcmtpbmdEaXJlY3RvcnkgPSBzYWZlR2V0Q1dEKCk7XG5cdCAgICAgIGxldCBlc21Xb3JraW5nRGlyZWN0b3J5O1xuXHQgICAgICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG5cdCAgICAgICAgY29uc3QgY29yZSA9IFJlZ0V4cFByb3RvdHlwZUV4ZWMoY29yZU1vZHVsZVJlZ0V4cCwgbGluZSk7XG5cdCAgICAgICAgaWYgKGNvcmUgIT09IG51bGwgJiYgQnVpbHRpbk1vZHVsZS5leGlzdHMoY29yZVsxXSkpIHtcblx0ICAgICAgICAgIG5ld1N0YWNrICs9IGBcXG4ke2N0eC5zdHlsaXplKGxpbmUsICd1bmRlZmluZWQnKX1gO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBuZXdTdGFjayArPSAnXFxuJztcblxuXHQgICAgICAgICAgbGluZSA9IG1hcmtOb2RlTW9kdWxlcyhjdHgsIGxpbmUpO1xuXHQgICAgICAgICAgaWYgKHdvcmtpbmdEaXJlY3RvcnkgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBsZXQgbmV3TGluZSA9IG1hcmtDd2QoY3R4LCBsaW5lLCB3b3JraW5nRGlyZWN0b3J5KTtcblx0ICAgICAgICAgICAgaWYgKG5ld0xpbmUgPT09IGxpbmUpIHtcblx0ICAgICAgICAgICAgICAvLyBNYWludGFpbiBub2RlIDE0IGNvbXBhdFxuXHQgICAgICAgICAgICAgIC8vIGVzbVdvcmtpbmdEaXJlY3RvcnkgPz89IHBhdGhUb0ZpbGVVcmxIcmVmKHdvcmtpbmdEaXJlY3RvcnkpO1xuXHQgICAgICAgICAgICAgIGVzbVdvcmtpbmdEaXJlY3RvcnkgPVxuXHQgICAgICAgICAgICAgICAgKGVzbVdvcmtpbmdEaXJlY3RvcnkgPT0gbnVsbCkgPyBwYXRoVG9GaWxlVXJsSHJlZih3b3JraW5nRGlyZWN0b3J5KSA6IGVzbVdvcmtpbmdEaXJlY3Rvcnk7XG5cdCAgICAgICAgICAgICAgbmV3TGluZSA9IG1hcmtDd2QoY3R4LCBsaW5lLCBlc21Xb3JraW5nRGlyZWN0b3J5KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsaW5lID0gbmV3TGluZTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgbmV3U3RhY2sgKz0gbGluZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG5ld1N0YWNrICs9IGBcXG4ke0FycmF5UHJvdG90eXBlSm9pbihsaW5lcywgJ1xcbicpfWA7XG5cdCAgICB9XG5cdCAgICBzdGFjayA9IG5ld1N0YWNrO1xuXHQgIH1cblx0ICAvLyBUaGUgbWVzc2FnZSBhbmQgdGhlIHN0YWNrIGhhdmUgdG8gYmUgaW5kZW50ZWQgYXMgd2VsbCFcblx0ICBpZiAoY3R4LmluZGVudGF0aW9uTHZsICE9PSAwKSB7XG5cdCAgICBjb25zdCBpbmRlbnRhdGlvbiA9IFN0cmluZ1Byb3RvdHlwZVJlcGVhdCgnICcsIGN0eC5pbmRlbnRhdGlvbkx2bCk7XG5cdCAgICBzdGFjayA9IFN0cmluZ1Byb3RvdHlwZVJlcGxhY2VBbGwoc3RhY2ssICdcXG4nLCBgXFxuJHtpbmRlbnRhdGlvbn1gKTtcblx0ICB9XG5cdCAgcmV0dXJuIHN0YWNrO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSkge1xuXHQgIGxldCB0b3RhbExlbmd0aCA9IDA7XG5cdCAgbGV0IG1heExlbmd0aCA9IDA7XG5cdCAgbGV0IGkgPSAwO1xuXHQgIGxldCBvdXRwdXRMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHQgIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG5cdCAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhlIFwiLi4uIG4gbW9yZSBpdGVtc1wiIHBhcnQgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cblx0ICAgIG91dHB1dExlbmd0aC0tO1xuXHQgIH1cblx0ICBjb25zdCBzZXBhcmF0b3JTcGFjZSA9IDI7IC8vIEFkZCAxIGZvciB0aGUgc3BhY2UgYW5kIDEgZm9yIHRoZSBzZXBhcmF0b3IuXG5cdCAgY29uc3QgZGF0YUxlbiA9IG5ldyBBcnJheShvdXRwdXRMZW5ndGgpO1xuXHQgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbGVuZ3RoIG9mIGFsbCBvdXRwdXQgZW50cmllcyBhbmQgdGhlIGluZGl2aWR1YWwgbWF4XG5cdCAgLy8gZW50cmllcyBsZW5ndGggb2YgYWxsIG91dHB1dCBlbnRyaWVzLiBXZSBoYXZlIHRvIHJlbW92ZSBjb2xvcnMgZmlyc3QsXG5cdCAgLy8gb3RoZXJ3aXNlIHRoZSBsZW5ndGggd291bGQgbm90IGJlIGNhbGN1bGF0ZWQgcHJvcGVybHkuXG5cdCAgZm9yICg7IGkgPCBvdXRwdXRMZW5ndGg7IGkrKykge1xuXHQgICAgY29uc3QgbGVuID0gZ2V0U3RyaW5nV2lkdGgob3V0cHV0W2ldLCBjdHguY29sb3JzKTtcblx0ICAgIGRhdGFMZW5baV0gPSBsZW47XG5cdCAgICB0b3RhbExlbmd0aCArPSBsZW4gKyBzZXBhcmF0b3JTcGFjZTtcblx0ICAgIGlmIChtYXhMZW5ndGggPCBsZW4pXG5cdCAgICAgIG1heExlbmd0aCA9IGxlbjtcblx0ICB9XG5cdCAgLy8gQWRkIHR3byB0byBgbWF4TGVuZ3RoYCBhcyB3ZSBhZGQgYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgcGx1cyBhIGNvbW1hXG5cdCAgLy8gaW4tYmV0d2VlbiB0d28gZW50cmllcy5cblx0ICBjb25zdCBhY3R1YWxNYXggPSBtYXhMZW5ndGggKyBzZXBhcmF0b3JTcGFjZTtcblx0ICAvLyBDaGVjayBpZiBhdCBsZWFzdCB0aHJlZSBlbnRyaWVzIGZpdCBuZXh0IHRvIGVhY2ggb3RoZXIgYW5kIHByZXZlbnQgZ3JvdXBpbmdcblx0ICAvLyBvZiBhcnJheXMgdGhhdCBjb250YWlucyBlbnRyaWVzIG9mIHZlcnkgZGlmZmVyZW50IGxlbmd0aCAoaS5lLiwgaWYgYSBzaW5nbGVcblx0ICAvLyBlbnRyeSBpcyBsb25nZXIgdGhhbiAxLzUgb2YgYWxsIG90aGVyIGVudHJpZXMgY29tYmluZWQpLiBPdGhlcndpc2UgdGhlXG5cdCAgLy8gc3BhY2UgaW4tYmV0d2VlbiBzbWFsbCBlbnRyaWVzIHdvdWxkIGJlIGVub3Jtb3VzLlxuXHQgIGlmIChhY3R1YWxNYXggKiAzICsgY3R4LmluZGVudGF0aW9uTHZsIDwgY3R4LmJyZWFrTGVuZ3RoICYmXG5cdCAgICAgICh0b3RhbExlbmd0aCAvIGFjdHVhbE1heCA+IDUgfHwgbWF4TGVuZ3RoIDw9IDYpKSB7XG5cblx0ICAgIGNvbnN0IGFwcHJveENoYXJIZWlnaHRzID0gMi41O1xuXHQgICAgY29uc3QgYXZlcmFnZUJpYXMgPSBNYXRoU3FydChhY3R1YWxNYXggLSB0b3RhbExlbmd0aCAvIG91dHB1dC5sZW5ndGgpO1xuXHQgICAgY29uc3QgYmlhc2VkTWF4ID0gTWF0aE1heChhY3R1YWxNYXggLSAzIC0gYXZlcmFnZUJpYXMsIDEpO1xuXHQgICAgLy8gRHluYW1pY2FsbHkgY2hlY2sgaG93IG1hbnkgY29sdW1ucyBzZWVtIHBvc3NpYmxlLlxuXHQgICAgY29uc3QgY29sdW1ucyA9IE1hdGhNaW4oXG5cdCAgICAgIC8vIElkZWFsbHkgYSBzcXVhcmUgc2hvdWxkIGJlIGRyYXduLiBXZSBleHBlY3QgYSBjaGFyYWN0ZXIgdG8gYmUgYWJvdXQgMi41XG5cdCAgICAgIC8vIHRpbWVzIGFzIGhpZ2ggYXMgd2lkZS4gVGhpcyBpcyB0aGUgYXJlYSBmb3JtdWxhIHRvIGNhbGN1bGF0ZSBhIHNxdWFyZVxuXHQgICAgICAvLyB3aGljaCBjb250YWlucyBuIHJlY3RhbmdsZXMgb2Ygc2l6ZSBgYWN0dWFsTWF4ICogYXBwcm94Q2hhckhlaWdodHNgLlxuXHQgICAgICAvLyBEaXZpZGUgdGhhdCBieSBgYWN0dWFsTWF4YCB0byByZWNlaXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBjb2x1bW5zLlxuXHQgICAgICAvLyBUaGUgYWRkZWQgYmlhcyBpbmNyZWFzZXMgdGhlIGNvbHVtbnMgZm9yIHNob3J0IGVudHJpZXMuXG5cdCAgICAgIE1hdGhSb3VuZChcblx0ICAgICAgICBNYXRoU3FydChcblx0ICAgICAgICAgIGFwcHJveENoYXJIZWlnaHRzICogYmlhc2VkTWF4ICogb3V0cHV0TGVuZ3RoLFxuXHQgICAgICAgICkgLyBiaWFzZWRNYXgsXG5cdCAgICAgICksXG5cdCAgICAgIC8vIERvIG5vdCBleGNlZWQgdGhlIGJyZWFrTGVuZ3RoLlxuXHQgICAgICBNYXRoRmxvb3IoKGN0eC5icmVha0xlbmd0aCAtIGN0eC5pbmRlbnRhdGlvbkx2bCkgLyBhY3R1YWxNYXgpLFxuXHQgICAgICAvLyBMaW1pdCBhcnJheSBncm91cGluZyBmb3Igc21hbGwgYGNvbXBhY3RgIG1vZGVzIGFzIHRoZSB1c2VyIHJlcXVlc3RlZFxuXHQgICAgICAvLyBtaW5pbWFsIGdyb3VwaW5nLlxuXHQgICAgICBjdHguY29tcGFjdCAqIDQsXG5cdCAgICAgIC8vIExpbWl0IHRoZSBjb2x1bW5zIHRvIGEgbWF4aW11bSBvZiBmaWZ0ZWVuLlxuXHQgICAgICAxNSxcblx0ICAgICk7XG5cdCAgICAvLyBSZXR1cm4gd2l0aCB0aGUgb3JpZ2luYWwgb3V0cHV0IGlmIG5vIGdyb3VwaW5nIHNob3VsZCBoYXBwZW4uXG5cdCAgICBpZiAoY29sdW1ucyA8PSAxKSB7XG5cdCAgICAgIHJldHVybiBvdXRwdXQ7XG5cdCAgICB9XG5cdCAgICBjb25zdCB0bXAgPSBbXTtcblx0ICAgIGNvbnN0IG1heExpbmVMZW5ndGggPSBbXTtcblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG5cdCAgICAgIGxldCBsaW5lTWF4TGVuZ3RoID0gMDtcblx0ICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBvdXRwdXQubGVuZ3RoOyBqICs9IGNvbHVtbnMpIHtcblx0ICAgICAgICBpZiAoZGF0YUxlbltqXSA+IGxpbmVNYXhMZW5ndGgpXG5cdCAgICAgICAgICBsaW5lTWF4TGVuZ3RoID0gZGF0YUxlbltqXTtcblx0ICAgICAgfVxuXHQgICAgICBsaW5lTWF4TGVuZ3RoICs9IHNlcGFyYXRvclNwYWNlO1xuXHQgICAgICBtYXhMaW5lTGVuZ3RoW2ldID0gbGluZU1heExlbmd0aDtcblx0ICAgIH1cblx0ICAgIGxldCBvcmRlciA9IFN0cmluZ1Byb3RvdHlwZVBhZFN0YXJ0O1xuXHQgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAodHlwZW9mIHZhbHVlW2ldICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWVbaV0gIT09ICdiaWdpbnQnKSB7XG5cdCAgICAgICAgICBvcmRlciA9IFN0cmluZ1Byb3RvdHlwZVBhZEVuZDtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy8gRWFjaCBpdGVyYXRpb24gY3JlYXRlcyBhIHNpbmdsZSBsaW5lIG9mIGdyb3VwZWQgZW50cmllcy5cblx0ICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoOyBpICs9IGNvbHVtbnMpIHtcblx0ICAgICAgLy8gVGhlIGxhc3QgbGluZXMgbWF5IGNvbnRhaW4gbGVzcyBlbnRyaWVzIHRoYW4gY29sdW1ucy5cblx0ICAgICAgY29uc3QgbWF4ID0gTWF0aE1pbihpICsgY29sdW1ucywgb3V0cHV0TGVuZ3RoKTtcblx0ICAgICAgbGV0IHN0ciA9ICcnO1xuXHQgICAgICBsZXQgaiA9IGk7XG5cdCAgICAgIGZvciAoOyBqIDwgbWF4IC0gMTsgaisrKSB7XG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIGV4dHJhIGNvbG9yIHBhZGRpbmcgaW4gY2FzZSBpdCdzIGFjdGl2ZS4gVGhpcyBoYXMgdG8gYmVcblx0ICAgICAgICAvLyBkb25lIGxpbmUgYnkgbGluZSBhcyBzb21lIGxpbmVzIG1pZ2h0IGNvbnRhaW4gbW9yZSBjb2xvcnMgdGhhblxuXHQgICAgICAgIC8vIG90aGVycy5cblx0ICAgICAgICBjb25zdCBwYWRkaW5nID0gbWF4TGluZUxlbmd0aFtqIC0gaV0gKyBvdXRwdXRbal0ubGVuZ3RoIC0gZGF0YUxlbltqXTtcblx0ICAgICAgICBzdHIgKz0gb3JkZXIoYCR7b3V0cHV0W2pdfSwgYCwgcGFkZGluZywgJyAnKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAob3JkZXIgPT09IFN0cmluZ1Byb3RvdHlwZVBhZFN0YXJ0KSB7XG5cdCAgICAgICAgY29uc3QgcGFkZGluZyA9IG1heExpbmVMZW5ndGhbaiAtIGldICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2pdLmxlbmd0aCAtXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFMZW5bal0gLVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JTcGFjZTtcblx0ICAgICAgICBzdHIgKz0gU3RyaW5nUHJvdG90eXBlUGFkU3RhcnQob3V0cHV0W2pdLCBwYWRkaW5nLCAnICcpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0ciArPSBvdXRwdXRbal07XG5cdCAgICAgIH1cblx0ICAgICAgQXJyYXlQcm90b3R5cGVQdXNoKHRtcCwgc3RyKTtcblx0ICAgIH1cblx0ICAgIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPCBvdXRwdXQubGVuZ3RoKSB7XG5cdCAgICAgIEFycmF5UHJvdG90eXBlUHVzaCh0bXAsIG91dHB1dFtvdXRwdXRMZW5ndGhdKTtcblx0ICAgIH1cblx0ICAgIG91dHB1dCA9IHRtcDtcblx0ICB9XG5cdCAgcmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1heENhbGxTdGFja1NpemUoY3R4LCBlcnIsIGNvbnN0cnVjdG9yTmFtZSwgaW5kZW50YXRpb25MdmwpIHtcblx0ICBpZiAoaXNTdGFja092ZXJmbG93RXJyb3IoZXJyKSkge1xuXHQgICAgY3R4LnNlZW4ucG9wKCk7XG5cdCAgICBjdHguaW5kZW50YXRpb25MdmwgPSBpbmRlbnRhdGlvbkx2bDtcblx0ICAgIHJldHVybiBjdHguc3R5bGl6ZShcblx0ICAgICAgYFske2NvbnN0cnVjdG9yTmFtZX06IEluc3BlY3Rpb24gaW50ZXJydXB0ZWQgYCArXG5cdCAgICAgICAgJ3ByZW1hdHVyZWx5LiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZC5dJyxcblx0ICAgICAgJ3NwZWNpYWwnLFxuXHQgICAgKTtcblx0ICB9XG5cdCAgYXNzZXJ0LmZhaWwoZXJyLnN0YWNrKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZE51bWVyaWNTZXBhcmF0b3IoaW50ZWdlclN0cmluZykge1xuXHQgIGxldCByZXN1bHQgPSAnJztcblx0ICBsZXQgaSA9IGludGVnZXJTdHJpbmcubGVuZ3RoO1xuXHQgIGNvbnN0IHN0YXJ0ID0gU3RyaW5nUHJvdG90eXBlU3RhcnRzV2l0aChpbnRlZ2VyU3RyaW5nLCAnLScpID8gMSA6IDA7XG5cdCAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcblx0ICAgIHJlc3VsdCA9IGBfJHtTdHJpbmdQcm90b3R5cGVTbGljZShpbnRlZ2VyU3RyaW5nLCBpIC0gMywgaSl9JHtyZXN1bHR9YDtcblx0ICB9XG5cdCAgcmV0dXJuIGkgPT09IGludGVnZXJTdHJpbmcubGVuZ3RoID9cblx0ICAgIGludGVnZXJTdHJpbmcgOlxuXHQgICAgYCR7U3RyaW5nUHJvdG90eXBlU2xpY2UoaW50ZWdlclN0cmluZywgMCwgaSl9JHtyZXN1bHR9YDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZE51bWVyaWNTZXBhcmF0b3JFbmQoaW50ZWdlclN0cmluZykge1xuXHQgIGxldCByZXN1bHQgPSAnJztcblx0ICBsZXQgaSA9IDA7XG5cdCAgZm9yICg7IGkgPCBpbnRlZ2VyU3RyaW5nLmxlbmd0aCAtIDM7IGkgKz0gMykge1xuXHQgICAgcmVzdWx0ICs9IGAke1N0cmluZ1Byb3RvdHlwZVNsaWNlKGludGVnZXJTdHJpbmcsIGksIGkgKyAzKX1fYDtcblx0ICB9XG5cdCAgcmV0dXJuIGkgPT09IDAgP1xuXHQgICAgaW50ZWdlclN0cmluZyA6XG5cdCAgICBgJHtyZXN1bHR9JHtTdHJpbmdQcm90b3R5cGVTbGljZShpbnRlZ2VyU3RyaW5nLCBpKX1gO1xuXHR9XG5cblx0Y29uc3QgcmVtYWluaW5nVGV4dCA9IChyZW1haW5pbmcpID0+IGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWA7XG5cblx0ZnVuY3Rpb24gZm9ybWF0TnVtYmVyKGZuLCBudW1iZXIsIG51bWVyaWNTZXBhcmF0b3IpIHtcblx0ICBpZiAoIW51bWVyaWNTZXBhcmF0b3IpIHtcblx0ICAgIC8vIEZvcm1hdCAtMCBhcyAnLTAnLiBDaGVja2luZyBgbnVtYmVyID09PSAtMGAgd29uJ3QgZGlzdGluZ3Vpc2ggMCBmcm9tIC0wLlxuXHQgICAgaWYgKE9iamVjdElzKG51bWJlciwgLTApKSB7XG5cdCAgICAgIHJldHVybiBmbignLTAnLCAnbnVtYmVyJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZm4oYCR7bnVtYmVyfWAsICdudW1iZXInKTtcblx0ICB9XG5cdCAgY29uc3QgaW50ZWdlciA9IE1hdGhUcnVuYyhudW1iZXIpO1xuXHQgIGNvbnN0IHN0cmluZyA9IFN0cmluZyhpbnRlZ2VyKTtcblx0ICBpZiAoaW50ZWdlciA9PT0gbnVtYmVyKSB7XG5cdCAgICBpZiAoIU51bWJlcklzRmluaXRlKG51bWJlcikgfHwgU3RyaW5nUHJvdG90eXBlSW5jbHVkZXMoc3RyaW5nLCAnZScpKSB7XG5cdCAgICAgIHJldHVybiBmbihzdHJpbmcsICdudW1iZXInKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmbihgJHthZGROdW1lcmljU2VwYXJhdG9yKHN0cmluZyl9YCwgJ251bWJlcicpO1xuXHQgIH1cblx0ICBpZiAoTnVtYmVySXNOYU4obnVtYmVyKSkge1xuXHQgICAgcmV0dXJuIGZuKHN0cmluZywgJ251bWJlcicpO1xuXHQgIH1cblx0ICByZXR1cm4gZm4oYCR7XG5cdCAgICBhZGROdW1lcmljU2VwYXJhdG9yKHN0cmluZylcblx0ICB9LiR7XG5cdCAgICBhZGROdW1lcmljU2VwYXJhdG9yRW5kKFxuXHQgICAgICBTdHJpbmdQcm90b3R5cGVTbGljZShTdHJpbmcobnVtYmVyKSwgc3RyaW5nLmxlbmd0aCArIDEpLFxuXHQgICAgKVxuXHQgIH1gLCAnbnVtYmVyJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRCaWdJbnQoZm4sIGJpZ2ludCwgbnVtZXJpY1NlcGFyYXRvcikge1xuXHQgIGNvbnN0IHN0cmluZyA9IFN0cmluZyhiaWdpbnQpO1xuXHQgIGlmICghbnVtZXJpY1NlcGFyYXRvcikge1xuXHQgICAgcmV0dXJuIGZuKGAke3N0cmluZ31uYCwgJ2JpZ2ludCcpO1xuXHQgIH1cblx0ICByZXR1cm4gZm4oYCR7YWRkTnVtZXJpY1NlcGFyYXRvcihzdHJpbmcpfW5gLCAnYmlnaW50Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoZm4sIHZhbHVlLCBjdHgpIHtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgbGV0IHRyYWlsZXIgPSAnJztcblx0ICAgIGlmICh2YWx1ZS5sZW5ndGggPiBjdHgubWF4U3RyaW5nTGVuZ3RoKSB7XG5cdCAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHZhbHVlLmxlbmd0aCAtIGN0eC5tYXhTdHJpbmdMZW5ndGg7XG5cdCAgICAgIHZhbHVlID0gU3RyaW5nUHJvdG90eXBlU2xpY2UodmFsdWUsIDAsIGN0eC5tYXhTdHJpbmdMZW5ndGgpO1xuXHQgICAgICB0cmFpbGVyID0gYC4uLiAke3JlbWFpbmluZ30gbW9yZSBjaGFyYWN0ZXIke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gO1xuXHQgICAgfVxuXHQgICAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlICYmXG5cdCAgICAgICAgLy8gV2UgZG8gbm90IHN1cHBvcnQgaGFuZGxpbmcgdW5pY29kZSBjaGFyYWN0ZXJzIHdpZHRoIHdpdGhcblx0ICAgICAgICAvLyB0aGUgcmVhZGxpbmUgZ2V0U3RyaW5nV2lkdGggZnVuY3Rpb24gYXMgdGhlcmUgYXJlXG5cdCAgICAgICAgLy8gcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zLlxuXHQgICAgICAgIHZhbHVlLmxlbmd0aCA+IGtNaW5MaW5lTGVuZ3RoICYmXG5cdCAgICAgICAgdmFsdWUubGVuZ3RoID4gY3R4LmJyZWFrTGVuZ3RoIC0gY3R4LmluZGVudGF0aW9uTHZsIC0gNCkge1xuXHQgICAgICByZXR1cm4gQXJyYXlQcm90b3R5cGVKb2luKFxuXHQgICAgICAgIEFycmF5UHJvdG90eXBlTWFwKFxuXHQgICAgICAgICAgZXh0cmFjdGVkU3BsaXROZXdMaW5lcyh2YWx1ZSksXG5cdCAgICAgICAgICAobGluZSkgPT4gZm4oc3RyRXNjYXBlKGxpbmUpLCAnc3RyaW5nJyksXG5cdCAgICAgICAgKSxcblx0ICAgICAgICBgICtcXG4ke1N0cmluZ1Byb3RvdHlwZVJlcGVhdCgnICcsIGN0eC5pbmRlbnRhdGlvbkx2bCArIDIpfWAsXG5cdCAgICAgICkgKyB0cmFpbGVyO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZuKHN0ckVzY2FwZSh2YWx1ZSksICdzdHJpbmcnKSArIHRyYWlsZXI7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuXHQgICAgcmV0dXJuIGZvcm1hdE51bWJlcihmbiwgdmFsdWUsIGN0eC5udW1lcmljU2VwYXJhdG9yKTtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jylcblx0ICAgIHJldHVybiBmb3JtYXRCaWdJbnQoZm4sIHZhbHVlLCBjdHgubnVtZXJpY1NlcGFyYXRvcik7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKVxuXHQgICAgcmV0dXJuIGZuKGAke3ZhbHVlfWAsICdib29sZWFuJyk7XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG5cdCAgICByZXR1cm4gZm4oJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblx0ICAvLyBlczYgc3ltYm9sIHByaW1pdGl2ZVxuXHQgIHJldHVybiBmbihTeW1ib2xQcm90b3R5cGVUb1N0cmluZyh2YWx1ZSksICdzeW1ib2wnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdE5hbWVzcGFjZU9iamVjdChrZXlzLCBjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcblx0ICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuXHQgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgb3V0cHV0W2ldID0gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXlzW2ldLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrT2JqZWN0VHlwZSk7XG5cdCAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgYXNzZXJ0KGlzTmF0aXZlRXJyb3IoZXJyKSAmJiBlcnIubmFtZSA9PT0gJ1JlZmVyZW5jZUVycm9yJyk7XG5cdCAgICAgIC8vIFVzZSB0aGUgZXhpc3RpbmcgZnVuY3Rpb25hbGl0eS4gVGhpcyBtYWtlcyBzdXJlIHRoZSBpbmRlbnRhdGlvbiBhbmRcblx0ICAgICAgLy8gbGluZSBicmVha3MgYXJlIGFsd2F5cyBjb3JyZWN0LiBPdGhlcndpc2UgaXQgaXMgdmVyeSBkaWZmaWN1bHQgdG8ga2VlcFxuXHQgICAgICAvLyB0aGlzIGFsaWduZWQsIGV2ZW4gdGhvdWdoIHRoaXMgaXMgYSBoYWNreSB3YXkgb2YgZGVhbGluZyB3aXRoIHRoaXMuXG5cdCAgICAgIGNvbnN0IHRtcCA9IHsgW2tleXNbaV1dOiAnJyB9O1xuXHQgICAgICBvdXRwdXRbaV0gPSBmb3JtYXRQcm9wZXJ0eShjdHgsIHRtcCwgcmVjdXJzZVRpbWVzLCBrZXlzW2ldLCBrT2JqZWN0VHlwZSk7XG5cdCAgICAgIGNvbnN0IHBvcyA9IFN0cmluZ1Byb3RvdHlwZUxhc3RJbmRleE9mKG91dHB1dFtpXSwgJyAnKTtcblx0ICAgICAgLy8gV2UgaGF2ZSB0byBmaW5kIHRoZSBsYXN0IHdoaXRlc3BhY2UgYW5kIGhhdmUgdG8gcmVwbGFjZSB0aGF0IHZhbHVlIGFzXG5cdCAgICAgIC8vIGl0IHdpbGwgYmUgdmlzdWFsaXplZCBhcyBhIHJlZ3VsYXIgc3RyaW5nLlxuXHQgICAgICBvdXRwdXRbaV0gPSBTdHJpbmdQcm90b3R5cGVTbGljZShvdXRwdXRbaV0sIDAsIHBvcyArIDEpICtcblx0ICAgICAgICAgICAgICAgICAgY3R4LnN0eWxpemUoJzx1bmluaXRpYWxpemVkPicsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8vIFJlc2V0IHRoZSBrZXlzIHRvIGFuIGVtcHR5IGFycmF5LiBUaGlzIHByZXZlbnRzIGR1cGxpY2F0ZWQgaW5zcGVjdGlvbi5cblx0ICBrZXlzLmxlbmd0aCA9IDA7XG5cdCAgcmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRoZSBhcnJheSBpcyBzcGFyc2UgYW5kL29yIGhhcyBleHRyYSBrZXlzXG5cdGZ1bmN0aW9uIGZvcm1hdFNwZWNpYWxBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIG1heExlbmd0aCwgb3V0cHV0LCBpKSB7XG5cdCAgY29uc3Qga2V5cyA9IE9iamVjdEtleXModmFsdWUpO1xuXHQgIGxldCBpbmRleCA9IGk7XG5cdCAgZm9yICg7IGkgPCBrZXlzLmxlbmd0aCAmJiBvdXRwdXQubGVuZ3RoIDwgbWF4TGVuZ3RoOyBpKyspIHtcblx0ICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG5cdCAgICBjb25zdCB0bXAgPSAra2V5O1xuXHQgICAgLy8gQXJyYXlzIGNhbiBvbmx5IGhhdmUgdXAgdG8gMl4zMiAtIDEgZW50cmllc1xuXHQgICAgaWYgKHRtcCA+IDIgKiogMzIgLSAyKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgaWYgKGAke2luZGV4fWAgIT09IGtleSkge1xuXHQgICAgICBpZiAoUmVnRXhwUHJvdG90eXBlRXhlYyhudW1iZXJSZWdFeHAsIGtleSkgPT09IG51bGwpIHtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgICBjb25zdCBlbXB0eUl0ZW1zID0gdG1wIC0gaW5kZXg7XG5cdCAgICAgIGNvbnN0IGVuZGluZyA9IGVtcHR5SXRlbXMgPiAxID8gJ3MnIDogJyc7XG5cdCAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgPCR7ZW1wdHlJdGVtc30gZW1wdHkgaXRlbSR7ZW5kaW5nfT5gO1xuXHQgICAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCBjdHguc3R5bGl6ZShtZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuXHQgICAgICBpbmRleCA9IHRtcDtcblx0ICAgICAgaWYgKG91dHB1dC5sZW5ndGggPT09IG1heExlbmd0aCkge1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleSwga0FycmF5VHlwZSkpO1xuXHQgICAgaW5kZXgrKztcblx0ICB9XG5cdCAgY29uc3QgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gaW5kZXg7XG5cdCAgaWYgKG91dHB1dC5sZW5ndGggIT09IG1heExlbmd0aCkge1xuXHQgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcblx0ICAgICAgY29uc3QgZW5kaW5nID0gcmVtYWluaW5nID4gMSA/ICdzJyA6ICcnO1xuXHQgICAgICBjb25zdCBtZXNzYWdlID0gYDwke3JlbWFpbmluZ30gZW1wdHkgaXRlbSR7ZW5kaW5nfT5gO1xuXHQgICAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCBjdHguc3R5bGl6ZShtZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAocmVtYWluaW5nID4gMCkge1xuXHQgICAgQXJyYXlQcm90b3R5cGVQdXNoKG91dHB1dCwgcmVtYWluaW5nVGV4dChyZW1haW5pbmcpKTtcblx0ICB9XG5cdCAgcmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEFycmF5QnVmZmVyKGN0eCwgdmFsdWUpIHtcblx0ICBsZXQgYnVmZmVyO1xuXHQgIHRyeSB7XG5cdCAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG5cdCAgfSBjYXRjaCB7XG5cdCAgICByZXR1cm4gW2N0eC5zdHlsaXplKCcoZGV0YWNoZWQpJywgJ3NwZWNpYWwnKV07XG5cdCAgfVxuXHQgIGlmIChoZXhTbGljZSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgaGV4U2xpY2UgPSB1bmN1cnJ5VGhpcyhyZXF1aXJlQnVmZmVyKCkuQnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSk7XG5cdCAgbGV0IHN0ciA9IFN0cmluZ1Byb3RvdHlwZVRyaW0oUmVnRXhwUHJvdG90eXBlU3ltYm9sUmVwbGFjZShcblx0ICAgIC8oLnsyfSkvZyxcblx0ICAgIGhleFNsaWNlKGJ1ZmZlciwgMCwgTWF0aE1pbihjdHgubWF4QXJyYXlMZW5ndGgsIGJ1ZmZlci5sZW5ndGgpKSxcblx0ICAgICckMSAnLFxuXHQgICkpO1xuXHQgIGNvbnN0IHJlbWFpbmluZyA9IGJ1ZmZlci5sZW5ndGggLSBjdHgubWF4QXJyYXlMZW5ndGg7XG5cdCAgaWYgKHJlbWFpbmluZyA+IDApXG5cdCAgICBzdHIgKz0gYCAuLi4gJHtyZW1haW5pbmd9IG1vcmUgYnl0ZSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWA7XG5cdCAgcmV0dXJuIFtgJHtjdHguc3R5bGl6ZSgnW1VpbnQ4Q29udGVudHNdJywgJ3NwZWNpYWwnKX06IDwke3N0cn0+YF07XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcblx0ICBjb25zdCB2YWxMZW4gPSB2YWx1ZS5sZW5ndGg7XG5cdCAgY29uc3QgbGVuID0gTWF0aE1pbihNYXRoTWF4KDAsIGN0eC5tYXhBcnJheUxlbmd0aCksIHZhbExlbik7XG5cblx0ICBjb25zdCByZW1haW5pbmcgPSB2YWxMZW4gLSBsZW47XG5cdCAgY29uc3Qgb3V0cHV0ID0gW107XG5cdCAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgLy8gU3BlY2lhbCBoYW5kbGUgc3BhcnNlIGFycmF5cy5cblx0ICAgIGlmICghT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkodmFsdWUsIGkpKSB7XG5cdCAgICAgIHJldHVybiBmb3JtYXRTcGVjaWFsQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBsZW4sIG91dHB1dCwgaSk7XG5cdCAgICB9XG5cdCAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGksIGtBcnJheVR5cGUpKTtcblx0ICB9XG5cdCAgaWYgKHJlbWFpbmluZyA+IDApIHtcblx0ICAgIEFycmF5UHJvdG90eXBlUHVzaChvdXRwdXQsIHJlbWFpbmluZ1RleHQocmVtYWluaW5nKSk7XG5cdCAgfVxuXHQgIHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRUeXBlZEFycmF5KHZhbHVlLCBsZW5ndGgsIGN0eCwgaWdub3JlZCwgcmVjdXJzZVRpbWVzKSB7XG5cdCAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aE1pbihNYXRoTWF4KDAsIGN0eC5tYXhBcnJheUxlbmd0aCksIGxlbmd0aCk7XG5cdCAgY29uc3QgcmVtYWluaW5nID0gdmFsdWUubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuXHQgIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuXHQgIGNvbnN0IGVsZW1lbnRGb3JtYXR0ZXIgPSB2YWx1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicgP1xuXHQgICAgZm9ybWF0TnVtYmVyIDpcblx0ICAgIGZvcm1hdEJpZ0ludDtcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgKytpKSB7XG5cdCAgICBvdXRwdXRbaV0gPSBlbGVtZW50Rm9ybWF0dGVyKGN0eC5zdHlsaXplLCB2YWx1ZVtpXSwgY3R4Lm51bWVyaWNTZXBhcmF0b3IpO1xuXHQgIH1cblx0ICBpZiAocmVtYWluaW5nID4gMCkge1xuXHQgICAgb3V0cHV0W21heExlbmd0aF0gPSByZW1haW5pbmdUZXh0KHJlbWFpbmluZyk7XG5cdCAgfVxuXHQgIGlmIChjdHguc2hvd0hpZGRlbikge1xuXHQgICAgLy8gLmJ1ZmZlciBnb2VzIGxhc3QsIGl0J3Mgbm90IGEgcHJpbWl0aXZlIGxpa2UgdGhlIG90aGVycy5cblx0ICAgIC8vIEFsbCBiZXNpZGVzIGBCWVRFU19QRVJfRUxFTUVOVGAgYXJlIGFjdHVhbGx5IGdldHRlcnMuXG5cdCAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblx0ICAgIGZvciAoY29uc3Qga2V5IG9mIFtcblx0ICAgICAgJ0JZVEVTX1BFUl9FTEVNRU5UJyxcblx0ICAgICAgJ2xlbmd0aCcsXG5cdCAgICAgICdieXRlTGVuZ3RoJyxcblx0ICAgICAgJ2J5dGVPZmZzZXQnLFxuXHQgICAgICAnYnVmZmVyJyxcblx0ICAgIF0pIHtcblx0ICAgICAgY29uc3Qgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMsIHRydWUpO1xuXHQgICAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCBgWyR7a2V5fV06ICR7c3RyfWApO1xuXHQgICAgfVxuXHQgICAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG5cdCAgfVxuXHQgIHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRTZXQodmFsdWUsIGN0eCwgaWdub3JlZCwgcmVjdXJzZVRpbWVzKSB7XG5cdCAgY29uc3QgbGVuZ3RoID0gdmFsdWUuc2l6ZTtcblx0ICBjb25zdCBtYXhMZW5ndGggPSBNYXRoTWluKE1hdGhNYXgoMCwgY3R4Lm1heEFycmF5TGVuZ3RoKSwgbGVuZ3RoKTtcblx0ICBjb25zdCByZW1haW5pbmcgPSBsZW5ndGggLSBtYXhMZW5ndGg7XG5cdCAgY29uc3Qgb3V0cHV0ID0gW107XG5cdCAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cdCAgbGV0IGkgPSAwO1xuXHQgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuXHQgICAgaWYgKGkgPj0gbWF4TGVuZ3RoKSBicmVhaztcblx0ICAgIEFycmF5UHJvdG90eXBlUHVzaChvdXRwdXQsIGZvcm1hdFZhbHVlKGN0eCwgdiwgcmVjdXJzZVRpbWVzKSk7XG5cdCAgICBpKys7XG5cdCAgfVxuXHQgIGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdCAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCByZW1haW5pbmdUZXh0KHJlbWFpbmluZykpO1xuXHQgIH1cblx0ICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcblx0ICByZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0TWFwKHZhbHVlLCBjdHgsIGlnbm9yZWQsIHJlY3Vyc2VUaW1lcykge1xuXHQgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLnNpemU7XG5cdCAgY29uc3QgbWF4TGVuZ3RoID0gTWF0aE1pbihNYXRoTWF4KDAsIGN0eC5tYXhBcnJheUxlbmd0aCksIGxlbmd0aCk7XG5cdCAgY29uc3QgcmVtYWluaW5nID0gbGVuZ3RoIC0gbWF4TGVuZ3RoO1xuXHQgIGNvbnN0IG91dHB1dCA9IFtdO1xuXHQgIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXHQgIGxldCBpID0gMDtcblx0ICBmb3IgKGNvbnN0IHsgMDogaywgMTogdiB9IG9mIHZhbHVlKSB7XG5cdCAgICBpZiAoaSA+PSBtYXhMZW5ndGgpIGJyZWFrO1xuXHQgICAgQXJyYXlQcm90b3R5cGVQdXNoKFxuXHQgICAgICBvdXRwdXQsXG5cdCAgICAgIGAke2Zvcm1hdFZhbHVlKGN0eCwgaywgcmVjdXJzZVRpbWVzKX0gPT4gJHtmb3JtYXRWYWx1ZShjdHgsIHYsIHJlY3Vyc2VUaW1lcyl9YCxcblx0ICAgICk7XG5cdCAgICBpKys7XG5cdCAgfVxuXHQgIGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdCAgICBBcnJheVByb3RvdHlwZVB1c2gob3V0cHV0LCByZW1haW5pbmdUZXh0KHJlbWFpbmluZykpO1xuXHQgIH1cblx0ICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcblx0ICByZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0U2V0SXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBzdGF0ZSkge1xuXHQgIGNvbnN0IG1heEFycmF5TGVuZ3RoID0gTWF0aE1heChjdHgubWF4QXJyYXlMZW5ndGgsIDApO1xuXHQgIGNvbnN0IG1heExlbmd0aCA9IE1hdGhNaW4obWF4QXJyYXlMZW5ndGgsIGVudHJpZXMubGVuZ3RoKTtcblx0ICBjb25zdCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcblx0ICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblx0ICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG5cdCAgICBvdXRwdXRbaV0gPSBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbaV0sIHJlY3Vyc2VUaW1lcyk7XG5cdCAgfVxuXHQgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuXHQgIGlmIChzdGF0ZSA9PT0ga1dlYWsgJiYgIWN0eC5zb3J0ZWQpIHtcblx0ICAgIC8vIFNvcnQgYWxsIGVudHJpZXMgdG8gaGF2ZSBhIGhhbGZ3YXkgcmVsaWFibGUgb3V0cHV0IChpZiBtb3JlIGVudHJpZXMgdGhhblxuXHQgICAgLy8gcmV0cmlldmVkIG9uZXMgZXhpc3QsIHdlIGNhbiBub3QgcmVsaWFibHkgcmV0dXJuIHRoZSBzYW1lIG91dHB1dCkgaWYgdGhlXG5cdCAgICAvLyBvdXRwdXQgaXMgbm90IHNvcnRlZCBhbnl3YXkuXG5cdCAgICBBcnJheVByb3RvdHlwZVNvcnQob3V0cHV0KTtcblx0ICB9XG5cdCAgY29uc3QgcmVtYWluaW5nID0gZW50cmllcy5sZW5ndGggLSBtYXhMZW5ndGg7XG5cdCAgaWYgKHJlbWFpbmluZyA+IDApIHtcblx0ICAgIEFycmF5UHJvdG90eXBlUHVzaChvdXRwdXQsIHJlbWFpbmluZ1RleHQocmVtYWluaW5nKSk7XG5cdCAgfVxuXHQgIHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRNYXBJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIHN0YXRlKSB7XG5cdCAgY29uc3QgbWF4QXJyYXlMZW5ndGggPSBNYXRoTWF4KGN0eC5tYXhBcnJheUxlbmd0aCwgMCk7XG5cdCAgLy8gRW50cmllcyBleGlzdCBhcyBba2V5MSwgdmFsMSwga2V5MiwgdmFsMiwgLi4uXVxuXHQgIGNvbnN0IGxlbiA9IGVudHJpZXMubGVuZ3RoIC8gMjtcblx0ICBjb25zdCByZW1haW5pbmcgPSBsZW4gLSBtYXhBcnJheUxlbmd0aDtcblx0ICBjb25zdCBtYXhMZW5ndGggPSBNYXRoTWluKG1heEFycmF5TGVuZ3RoLCBsZW4pO1xuXHQgIGNvbnN0IG91dHB1dCA9IG5ldyBBcnJheShtYXhMZW5ndGgpO1xuXHQgIGxldCBpID0gMDtcblx0ICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblx0ICBpZiAoc3RhdGUgPT09IGtXZWFrKSB7XG5cdCAgICBmb3IgKDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGNvbnN0IHBvcyA9IGkgKiAyO1xuXHQgICAgICBvdXRwdXRbaV0gPVxuXHQgICAgICAgIGAke2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3NdLCByZWN1cnNlVGltZXMpfSA9PiAke2Zvcm1hdFZhbHVlKGN0eCwgZW50cmllc1twb3MgKyAxXSwgcmVjdXJzZVRpbWVzKX1gO1xuXHQgICAgfVxuXHQgICAgLy8gU29ydCBhbGwgZW50cmllcyB0byBoYXZlIGEgaGFsZndheSByZWxpYWJsZSBvdXRwdXQgKGlmIG1vcmUgZW50cmllcyB0aGFuXG5cdCAgICAvLyByZXRyaWV2ZWQgb25lcyBleGlzdCwgd2UgY2FuIG5vdCByZWxpYWJseSByZXR1cm4gdGhlIHNhbWUgb3V0cHV0KSBpZiB0aGVcblx0ICAgIC8vIG91dHB1dCBpcyBub3Qgc29ydGVkIGFueXdheS5cblx0ICAgIGlmICghY3R4LnNvcnRlZClcblx0ICAgICAgQXJyYXlQcm90b3R5cGVTb3J0KG91dHB1dCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAoOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcblx0ICAgICAgY29uc3QgcG9zID0gaSAqIDI7XG5cdCAgICAgIGNvbnN0IHJlcyA9IFtcblx0ICAgICAgICBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zXSwgcmVjdXJzZVRpbWVzKSxcblx0ICAgICAgICBmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zICsgMV0sIHJlY3Vyc2VUaW1lcyksXG5cdCAgICAgIF07XG5cdCAgICAgIG91dHB1dFtpXSA9IHJlZHVjZVRvU2luZ2xlU3RyaW5nKFxuXHQgICAgICAgIGN0eCwgcmVzLCAnJywgWydbJywgJ10nXSwga0FycmF5RXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG5cdCAgaWYgKHJlbWFpbmluZyA+IDApIHtcblx0ICAgIEFycmF5UHJvdG90eXBlUHVzaChvdXRwdXQsIHJlbWFpbmluZ1RleHQocmVtYWluaW5nKSk7XG5cdCAgfVxuXHQgIHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpIHtcblx0ICByZXR1cm4gW2N0eC5zdHlsaXplKCc8aXRlbXMgdW5rbm93bj4nLCAnc3BlY2lhbCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFdlYWtTZXQoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG5cdCAgY29uc3QgZW50cmllcyA9IHByZXZpZXdFbnRyaWVzKHZhbHVlKTtcblx0ICByZXR1cm4gZm9ybWF0U2V0SXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBrV2Vhayk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRXZWFrTWFwKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuXHQgIGNvbnN0IGVudHJpZXMgPSBwcmV2aWV3RW50cmllcyh2YWx1ZSk7XG5cdCAgcmV0dXJuIGZvcm1hdE1hcEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga1dlYWspO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0SXRlcmF0b3IoYnJhY2VzLCBjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcblx0ICBjb25zdCB7IDA6IGVudHJpZXMsIDE6IGlzS2V5VmFsdWUgfSA9IHByZXZpZXdFbnRyaWVzKHZhbHVlLCB0cnVlKTtcblx0ICBpZiAoaXNLZXlWYWx1ZSkge1xuXHQgICAgLy8gTWFyayBlbnRyeSBpdGVyYXRvcnMgYXMgc3VjaC5cblx0ICAgIGJyYWNlc1swXSA9IFJlZ0V4cFByb3RvdHlwZVN5bWJvbFJlcGxhY2UoLyBJdGVyYXRvcl0geyQvLCBicmFjZXNbMF0sICcgRW50cmllc10geycpO1xuXHQgICAgcmV0dXJuIGZvcm1hdE1hcEl0ZXJJbm5lcihjdHgsIHJlY3Vyc2VUaW1lcywgZW50cmllcywga01hcEVudHJpZXMpO1xuXHQgIH1cblxuXHQgIHJldHVybiBmb3JtYXRTZXRJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIGtJdGVyYXRvcik7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQcm9taXNlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuXHQgIGxldCBvdXRwdXQ7XG5cdCAgY29uc3QgeyAwOiBzdGF0ZSwgMTogcmVzdWx0IH0gPSBnZXRQcm9taXNlRGV0YWlscyh2YWx1ZSk7XG5cdCAgaWYgKHN0YXRlID09PSBrUGVuZGluZykge1xuXHQgICAgb3V0cHV0ID0gW2N0eC5zdHlsaXplKCc8cGVuZGluZz4nLCAnc3BlY2lhbCcpXTtcblx0ICB9IGVsc2Uge1xuXHQgICAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cdCAgICBjb25zdCBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHJlc3VsdCwgcmVjdXJzZVRpbWVzKTtcblx0ICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuXHQgICAgb3V0cHV0ID0gW1xuXHQgICAgICBzdGF0ZSA9PT0ga1JlamVjdGVkID9cblx0ICAgICAgICBgJHtjdHguc3R5bGl6ZSgnPHJlamVjdGVkPicsICdzcGVjaWFsJyl9ICR7c3RyfWAgOlxuXHQgICAgICAgIHN0cixcblx0ICAgIF07XG5cdCAgfVxuXHQgIHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleSwgdHlwZSwgZGVzYyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwgPSB2YWx1ZSkge1xuXHQgIGxldCBuYW1lLCBzdHI7XG5cdCAgbGV0IGV4dHJhID0gJyAnO1xuXHQgIGRlc2MgPSBkZXNjIHx8IE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fFxuXHQgICAgeyB2YWx1ZTogdmFsdWVba2V5XSwgZW51bWVyYWJsZTogdHJ1ZSB9O1xuXHQgIGlmIChkZXNjLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGNvbnN0IGRpZmYgPSAoY3R4LmNvbXBhY3QgIT09IHRydWUgfHwgdHlwZSAhPT0ga09iamVjdFR5cGUpID8gMiA6IDM7XG5cdCAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gZGlmZjtcblx0ICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzKTtcblx0ICAgIGlmIChkaWZmID09PSAzICYmIGN0eC5icmVha0xlbmd0aCA8IGdldFN0cmluZ1dpZHRoKHN0ciwgY3R4LmNvbG9ycykpIHtcblx0ICAgICAgZXh0cmEgPSBgXFxuJHtTdHJpbmdQcm90b3R5cGVSZXBlYXQoJyAnLCBjdHguaW5kZW50YXRpb25MdmwpfWA7XG5cdCAgICB9XG5cdCAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gZGlmZjtcblx0ICB9IGVsc2UgaWYgKGRlc2MuZ2V0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGNvbnN0IGxhYmVsID0gZGVzYy5zZXQgIT09IHVuZGVmaW5lZCA/ICdHZXR0ZXIvU2V0dGVyJyA6ICdHZXR0ZXInO1xuXHQgICAgY29uc3QgcyA9IGN0eC5zdHlsaXplO1xuXHQgICAgY29uc3Qgc3AgPSAnc3BlY2lhbCc7XG5cdCAgICBpZiAoY3R4LmdldHRlcnMgJiYgKGN0eC5nZXR0ZXJzID09PSB0cnVlIHx8XG5cdCAgICAgICAgICAoY3R4LmdldHRlcnMgPT09ICdnZXQnICYmIGRlc2Muc2V0ID09PSB1bmRlZmluZWQpIHx8XG5cdCAgICAgICAgICAoY3R4LmdldHRlcnMgPT09ICdzZXQnICYmIGRlc2Muc2V0ICE9PSB1bmRlZmluZWQpKSkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIGNvbnN0IHRtcCA9IEZ1bmN0aW9uUHJvdG90eXBlQ2FsbChkZXNjLmdldCwgb3JpZ2luYWwpO1xuXHQgICAgICAgIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXHQgICAgICAgIGlmICh0bXAgPT09IG51bGwpIHtcblx0ICAgICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfTpgLCBzcCl9ICR7cygnbnVsbCcsICdudWxsJyl9JHtzKCddJywgc3ApfWA7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG1wID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9XWAsIHNwKX0gJHtmb3JtYXRWYWx1ZShjdHgsIHRtcCwgcmVjdXJzZVRpbWVzKX1gO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUocywgdG1wLCBjdHgpO1xuXHQgICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9OmAsIHNwKX0gJHtwcmltaXRpdmV9JHtzKCddJywgc3ApfWA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuXHQgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICBjb25zdCBtZXNzYWdlID0gYDxJbnNwZWN0aW9uIHRocmV3ICgke2Vyci5tZXNzYWdlfSk+YDtcblx0ICAgICAgICBzdHIgPSBgJHtzKGBbJHtsYWJlbH06YCwgc3ApfSAke21lc3NhZ2V9JHtzKCddJywgc3ApfWA7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0ciA9IGN0eC5zdHlsaXplKGBbJHtsYWJlbH1dYCwgc3ApO1xuXHQgICAgfVxuXHQgIH0gZWxzZSBpZiAoZGVzYy5zZXQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgc3RyID0gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcblx0ICB9XG5cdCAgaWYgKHR5cGUgPT09IGtBcnJheVR5cGUpIHtcblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfVxuXHQgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuXHQgICAgY29uc3QgdG1wID0gUmVnRXhwUHJvdG90eXBlU3ltYm9sUmVwbGFjZShcblx0ICAgICAgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIsXG5cdCAgICAgIFN5bWJvbFByb3RvdHlwZVRvU3RyaW5nKGtleSksXG5cdCAgICAgIGVzY2FwZUZuLFxuXHQgICAgKTtcblx0ICAgIG5hbWUgPSBgWyR7Y3R4LnN0eWxpemUodG1wLCAnc3ltYm9sJyl9XWA7XG5cdCAgfSBlbHNlIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG5cdCAgICBuYW1lID0gXCJbJ19fcHJvdG9fXyddXCI7XG5cdCAgfSBlbHNlIGlmIChkZXNjLmVudW1lcmFibGUgPT09IGZhbHNlKSB7XG5cdCAgICBjb25zdCB0bXAgPSBSZWdFeHBQcm90b3R5cGVTeW1ib2xSZXBsYWNlKFxuXHQgICAgICBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlcixcblx0ICAgICAga2V5LFxuXHQgICAgICBlc2NhcGVGbixcblx0ICAgICk7XG5cdCAgICBuYW1lID0gYFske3RtcH1dYDtcblx0ICB9IGVsc2UgaWYgKFJlZ0V4cFByb3RvdHlwZUV4ZWMoa2V5U3RyUmVnRXhwLCBrZXkpICE9PSBudWxsKSB7XG5cdCAgICBuYW1lID0gY3R4LnN0eWxpemUoa2V5LCAnbmFtZScpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBuYW1lID0gY3R4LnN0eWxpemUoc3RyRXNjYXBlKGtleSksICdzdHJpbmcnKTtcblx0ICB9XG5cdCAgcmV0dXJuIGAke25hbWV9OiR7ZXh0cmF9JHtzdHJ9YDtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgc3RhcnQsIGJhc2UpIHtcblx0ICAvLyBFYWNoIGVudHJ5IGlzIHNlcGFyYXRlZCBieSBhdCBsZWFzdCBhIGNvbW1hLiBUaHVzLCB3ZSBzdGFydCB3aXRoIGEgdG90YWxcblx0ICAvLyBsZW5ndGggb2YgYXQgbGVhc3QgYG91dHB1dC5sZW5ndGhgLiBJbiBhZGRpdGlvbiwgc29tZSBjYXNlcyBoYXZlIGFcblx0ICAvLyB3aGl0ZXNwYWNlIGluLWJldHdlZW4gZWFjaCBvdGhlciB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0b3RhbCBhcyB3ZWxsLlxuXHQgIC8vIFRPRE8oQnJpZGdlQVIpOiBBZGQgdW5pY29kZSBzdXBwb3J0LiBVc2UgdGhlIHJlYWRsaW5lIGdldFN0cmluZ1dpZHRoXG5cdCAgLy8gZnVuY3Rpb24uIENoZWNrIHRoZSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBhbmQgbWFrZSBpdCBhbiBvcHQtaW4gaW4gY2FzZSBpdCdzXG5cdCAgLy8gc2lnbmlmaWNhbnQuXG5cdCAgbGV0IHRvdGFsTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aCArIHN0YXJ0O1xuXHQgIGlmICh0b3RhbExlbmd0aCArIG91dHB1dC5sZW5ndGggPiBjdHguYnJlYWtMZW5ndGgpXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspIHtcblx0ICAgIGlmIChjdHguY29sb3JzKSB7XG5cdCAgICAgIHRvdGFsTGVuZ3RoICs9IHJlbW92ZUNvbG9ycyhvdXRwdXRbaV0pLmxlbmd0aDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRvdGFsTGVuZ3RoICs9IG91dHB1dFtpXS5sZW5ndGg7XG5cdCAgICB9XG5cdCAgICBpZiAodG90YWxMZW5ndGggPiBjdHguYnJlYWtMZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH1cblx0ICAvLyBEbyBub3QgbGluZSB1cCBwcm9wZXJ0aWVzIG9uIHRoZSBzYW1lIGxpbmUgaWYgYGJhc2VgIGNvbnRhaW5zIGxpbmUgYnJlYWtzLlxuXHQgIHJldHVybiBiYXNlID09PSAnJyB8fCAhU3RyaW5nUHJvdG90eXBlSW5jbHVkZXMoYmFzZSwgJ1xcbicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcoXG5cdCAgY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSkge1xuXHQgIGlmIChjdHguY29tcGFjdCAhPT0gdHJ1ZSkge1xuXHQgICAgaWYgKHR5cGVvZiBjdHguY29tcGFjdCA9PT0gJ251bWJlcicgJiYgY3R4LmNvbXBhY3QgPj0gMSkge1xuXHQgICAgICAvLyBNZW1vcml6ZSB0aGUgb3JpZ2luYWwgb3V0cHV0IGxlbmd0aC4gSW4gY2FzZSB0aGUgb3V0cHV0IGlzIGdyb3VwZWQsXG5cdCAgICAgIC8vIHByZXZlbnQgbGluaW5nIHVwIHRoZSBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUuXG5cdCAgICAgIGNvbnN0IGVudHJpZXMgPSBvdXRwdXQubGVuZ3RoO1xuXHQgICAgICAvLyBHcm91cCBhcnJheSBlbGVtZW50cyB0b2dldGhlciBpZiB0aGUgYXJyYXkgY29udGFpbnMgYXQgbGVhc3Qgc2l4XG5cdCAgICAgIC8vIHNlcGFyYXRlIGVudHJpZXMuXG5cdCAgICAgIGlmIChleHRyYXNUeXBlID09PSBrQXJyYXlFeHRyYXNUeXBlICYmIGVudHJpZXMgPiA2KSB7XG5cdCAgICAgICAgb3V0cHV0ID0gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gYGN0eC5jdXJyZW50RGVwdGhgIGlzIHNldCB0byB0aGUgbW9zdCBpbm5lciBkZXB0aCBvZiB0aGUgY3VycmVudGx5XG5cdCAgICAgIC8vIGluc3BlY3RlZCBvYmplY3QgcGFydCB3aGlsZSBgcmVjdXJzZVRpbWVzYCBpcyB0aGUgYWN0dWFsIGN1cnJlbnQgZGVwdGhcblx0ICAgICAgLy8gdGhhdCBpcyBpbnNwZWN0ZWQuXG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIEV4YW1wbGU6XG5cdCAgICAgIC8vXG5cdCAgICAgIC8vIGNvbnN0IGEgPSB7IGZpcnN0OiBbIDEsIDIsIDMgXSwgc2Vjb25kOiB7IGlubmVyOiBbIDEsIDIsIDMgXSB9IH1cblx0ICAgICAgLy9cblx0ICAgICAgLy8gVGhlIGRlZXBlc3QgZGVwdGggb2YgYGFgIGlzIDIgKGEuc2Vjb25kLmlubmVyKSBhbmQgYGEuZmlyc3RgIGhhcyBhIG1heFxuXHQgICAgICAvLyBkZXB0aCBvZiAxLlxuXHQgICAgICAvL1xuXHQgICAgICAvLyBDb25zb2xpZGF0ZSBhbGwgZW50cmllcyBvZiB0aGUgbG9jYWwgbW9zdCBpbm5lciBkZXB0aCB1cCB0b1xuXHQgICAgICAvLyBgY3R4LmNvbXBhY3RgLCBhcyBsb25nIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZSBzbWFsbGVyIHRoYW5cblx0ICAgICAgLy8gYGN0eC5icmVha0xlbmd0aGAuXG5cdCAgICAgIGlmIChjdHguY3VycmVudERlcHRoIC0gcmVjdXJzZVRpbWVzIDwgY3R4LmNvbXBhY3QgJiZcblx0ICAgICAgICAgIGVudHJpZXMgPT09IG91dHB1dC5sZW5ndGgpIHtcblx0ICAgICAgICAvLyBMaW5lIHVwIGFsbCBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUgaW4gY2FzZSB0aGUgZW50cmllcyBkbyBub3Rcblx0ICAgICAgICAvLyBleGNlZWQgYGJyZWFrTGVuZ3RoYC4gQWRkIDEwIGFzIGNvbnN0YW50IHRvIHN0YXJ0IG5leHQgdG8gYWxsIG90aGVyXG5cdCAgICAgICAgLy8gZmFjdG9ycyB0aGF0IG1heSByZWR1Y2UgYGJyZWFrTGVuZ3RoYC5cblx0ICAgICAgICBjb25zdCBzdGFydCA9IG91dHB1dC5sZW5ndGggKyBjdHguaW5kZW50YXRpb25MdmwgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgYnJhY2VzWzBdLmxlbmd0aCArIGJhc2UubGVuZ3RoICsgMTA7XG5cdCAgICAgICAgaWYgKGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgc3RhcnQsIGJhc2UpKSB7XG5cdCAgICAgICAgICBjb25zdCBqb2luZWRPdXRwdXQgPSBqb2luKG91dHB1dCwgJywgJyk7XG5cdCAgICAgICAgICBpZiAoIVN0cmluZ1Byb3RvdHlwZUluY2x1ZGVzKGpvaW5lZE91dHB1dCwgJ1xcbicpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBgJHtiYXNlID8gYCR7YmFzZX0gYCA6ICcnfSR7YnJhY2VzWzBdfSAke2pvaW5lZE91dHB1dH1gICtcblx0ICAgICAgICAgICAgICBgICR7YnJhY2VzWzFdfWA7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBMaW5lIHVwIGVhY2ggZW50cnkgb24gYW4gaW5kaXZpZHVhbCBsaW5lLlxuXHQgICAgY29uc3QgaW5kZW50YXRpb24gPSBgXFxuJHtTdHJpbmdQcm90b3R5cGVSZXBlYXQoJyAnLCBjdHguaW5kZW50YXRpb25MdmwpfWA7XG5cdCAgICByZXR1cm4gYCR7YmFzZSA/IGAke2Jhc2V9IGAgOiAnJ30ke2JyYWNlc1swXX0ke2luZGVudGF0aW9ufSAgYCArXG5cdCAgICAgIGAke2pvaW4ob3V0cHV0LCBgLCR7aW5kZW50YXRpb259ICBgKX0ke2luZGVudGF0aW9ufSR7YnJhY2VzWzFdfWA7XG5cdCAgfVxuXHQgIC8vIExpbmUgdXAgYWxsIGVudHJpZXMgb24gYSBzaW5nbGUgbGluZSBpbiBjYXNlIHRoZSBlbnRyaWVzIGRvIG5vdCBleGNlZWRcblx0ICAvLyBgYnJlYWtMZW5ndGhgLlxuXHQgIGlmIChpc0JlbG93QnJlYWtMZW5ndGgoY3R4LCBvdXRwdXQsIDAsIGJhc2UpKSB7XG5cdCAgICByZXR1cm4gYCR7YnJhY2VzWzBdfSR7YmFzZSA/IGAgJHtiYXNlfWAgOiAnJ30gJHtqb2luKG91dHB1dCwgJywgJyl9IGAgK1xuXHQgICAgICBicmFjZXNbMV07XG5cdCAgfVxuXHQgIGNvbnN0IGluZGVudGF0aW9uID0gU3RyaW5nUHJvdG90eXBlUmVwZWF0KCcgJywgY3R4LmluZGVudGF0aW9uTHZsKTtcblx0ICAvLyBJZiB0aGUgb3BlbmluZyBcImJyYWNlXCIgaXMgdG9vIGxhcmdlLCBsaWtlIGluIHRoZSBjYXNlIG9mIFwiU2V0IHtcIixcblx0ICAvLyB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIG9uIHRoZSBuZXh0IGxpbmUgb3IgdGhlXG5cdCAgLy8gaXRlbXMgd2lsbCBub3QgbGluZSB1cCBjb3JyZWN0bHkuXG5cdCAgY29uc3QgbG4gPSBiYXNlID09PSAnJyAmJiBicmFjZXNbMF0ubGVuZ3RoID09PSAxID9cblx0ICAgICcgJyA6IGAke2Jhc2UgPyBgICR7YmFzZX1gIDogJyd9XFxuJHtpbmRlbnRhdGlvbn0gIGA7XG5cdCAgLy8gTGluZSB1cCBlYWNoIGVudHJ5IG9uIGFuIGluZGl2aWR1YWwgbGluZS5cblx0ICByZXR1cm4gYCR7YnJhY2VzWzBdfSR7bG59JHtqb2luKG91dHB1dCwgYCxcXG4ke2luZGVudGF0aW9ufSAgYCl9ICR7YnJhY2VzWzFdfWA7XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNCdWlsdEluVG9TdHJpbmcodmFsdWUpIHtcblx0ICAvLyBQcmV2ZW50IHRyaWdnZXJpbmcgcHJveHkgdHJhcHMuXG5cdCAgY29uc3QgZ2V0RnVsbFByb3h5ID0gZmFsc2U7XG5cdCAgY29uc3QgcHJveHlUYXJnZXQgPSBnZXRQcm94eURldGFpbHModmFsdWUsIGdldEZ1bGxQcm94eSk7XG5cdCAgaWYgKHByb3h5VGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgIGlmIChwcm94eVRhcmdldCA9PT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHZhbHVlID0gcHJveHlUYXJnZXQ7XG5cdCAgfVxuXG5cdCAgLy8gQ291bnQgb2JqZWN0cyB0aGF0IGhhdmUgbm8gYHRvU3RyaW5nYCBmdW5jdGlvbiBhcyBidWlsdC1pbi5cblx0ICBpZiAodHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cblx0ICAvLyBUaGUgb2JqZWN0IGhhcyBhIG93biBgdG9TdHJpbmdgIHByb3BlcnR5LiBUaHVzIGl0J3Mgbm90IG5vdCBhIGJ1aWx0LWluIG9uZS5cblx0ICBpZiAoT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkodmFsdWUsICd0b1N0cmluZycpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgLy8gRmluZCB0aGUgb2JqZWN0IHRoYXQgaGFzIHRoZSBgdG9TdHJpbmdgIHByb3BlcnR5IGFzIG93biBwcm9wZXJ0eSBpbiB0aGVcblx0ICAvLyBwcm90b3R5cGUgY2hhaW4uXG5cdCAgbGV0IHBvaW50ZXIgPSB2YWx1ZTtcblx0ICBkbyB7XG5cdCAgICBwb2ludGVyID0gT2JqZWN0R2V0UHJvdG90eXBlT2YocG9pbnRlcik7XG5cdCAgfSB3aGlsZSAoIU9iamVjdFByb3RvdHlwZUhhc093blByb3BlcnR5KHBvaW50ZXIsICd0b1N0cmluZycpKTtcblxuXHQgIC8vIENoZWNrIGNsb3NlciBpZiB0aGUgb2JqZWN0IGlzIGEgYnVpbHQtaW4uXG5cdCAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihwb2ludGVyLCAnY29uc3RydWN0b3InKTtcblx0ICByZXR1cm4gZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkICYmXG5cdCAgICB0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHQgICAgYnVpbHRJbk9iamVjdHMuaGFzKGRlc2NyaXB0b3IudmFsdWUubmFtZSk7XG5cdH1cblxuXHRjb25zdCBmaXJzdEVycm9yTGluZSA9IChlcnJvcikgPT4gU3RyaW5nUHJvdG90eXBlU3BsaXQoZXJyb3IubWVzc2FnZSwgJ1xcbicsIDEpWzBdO1xuXHRsZXQgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRTtcblx0ZnVuY3Rpb24gdHJ5U3RyaW5naWZ5KGFyZykge1xuXHQgIHRyeSB7XG5cdCAgICByZXR1cm4gSlNPTlN0cmluZ2lmeShhcmcpO1xuXHQgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgLy8gUG9wdWxhdGUgdGhlIGNpcmN1bGFyIGVycm9yIG1lc3NhZ2UgbGF6aWx5XG5cdCAgICBpZiAoIUNJUkNVTEFSX0VSUk9SX01FU1NBR0UpIHtcblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICBjb25zdCBhID0ge307XG5cdCAgICAgICAgYS5hID0gYTtcblx0ICAgICAgICBKU09OU3RyaW5naWZ5KGEpO1xuXHQgICAgICB9IGNhdGNoIChjaXJjdWxhckVycm9yKSB7XG5cdCAgICAgICAgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSA9IGZpcnN0RXJyb3JMaW5lKGNpcmN1bGFyRXJyb3IpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoZXJyLm5hbWUgPT09ICdUeXBlRXJyb3InICYmXG5cdCAgICAgICAgZmlyc3RFcnJvckxpbmUoZXJyKSA9PT0gQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuXHQgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgZXJyO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdCguLi5hcmdzKSB7XG5cdCAgcmV0dXJuIGZvcm1hdFdpdGhPcHRpb25zSW50ZXJuYWwodW5kZWZpbmVkLCBhcmdzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdFdpdGhPcHRpb25zKGluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSB7XG5cdCAgdmFsaWRhdGVPYmplY3QoaW5zcGVjdE9wdGlvbnMsICdpbnNwZWN0T3B0aW9ucycsIHsgYWxsb3dBcnJheTogdHJ1ZSB9KTtcblx0ICByZXR1cm4gZm9ybWF0V2l0aE9wdGlvbnNJbnRlcm5hbChpbnNwZWN0T3B0aW9ucywgYXJncyk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXROdW1iZXJOb0NvbG9yKG51bWJlciwgb3B0aW9ucykge1xuXHQgIHJldHVybiBmb3JtYXROdW1iZXIoXG5cdCAgICBzdHlsaXplTm9Db2xvcixcblx0ICAgIG51bWJlcixcblx0ICAgIG9wdGlvbnM/Lm51bWVyaWNTZXBhcmF0b3IgPz8gaW5zcGVjdERlZmF1bHRPcHRpb25zLm51bWVyaWNTZXBhcmF0b3IsXG5cdCAgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGZvcm1hdEJpZ0ludE5vQ29sb3IoYmlnaW50LCBvcHRpb25zKSB7XG5cdCAgcmV0dXJuIGZvcm1hdEJpZ0ludChcblx0ICAgIHN0eWxpemVOb0NvbG9yLFxuXHQgICAgYmlnaW50LFxuXHQgICAgb3B0aW9ucz8ubnVtZXJpY1NlcGFyYXRvciA/PyBpbnNwZWN0RGVmYXVsdE9wdGlvbnMubnVtZXJpY1NlcGFyYXRvcixcblx0ICApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZm9ybWF0V2l0aE9wdGlvbnNJbnRlcm5hbChpbnNwZWN0T3B0aW9ucywgYXJncykge1xuXHQgIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcblx0ICBsZXQgYSA9IDA7XG5cdCAgbGV0IHN0ciA9ICcnO1xuXHQgIGxldCBqb2luID0gJyc7XG5cblx0ICBpZiAodHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJykge1xuXHQgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgIHJldHVybiBmaXJzdDtcblx0ICAgIH1cblx0ICAgIGxldCB0ZW1wU3RyO1xuXHQgICAgbGV0IGxhc3RQb3MgPSAwO1xuXG5cdCAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aCAtIDE7IGkrKykge1xuXHQgICAgICBpZiAoU3RyaW5nUHJvdG90eXBlQ2hhckNvZGVBdChmaXJzdCwgaSkgPT09IDM3KSB7IC8vICclJ1xuXHQgICAgICAgIGNvbnN0IG5leHRDaGFyID0gU3RyaW5nUHJvdG90eXBlQ2hhckNvZGVBdChmaXJzdCwgKytpKTtcblx0ICAgICAgICBpZiAoYSArIDEgIT09IGFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG5cdCAgICAgICAgICAgIGNhc2UgMTE1OiB7IC8vICdzJ1xuXHQgICAgICAgICAgICAgIGNvbnN0IHRlbXBBcmcgPSBhcmdzWysrYV07XG5cdCAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wQXJnID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGZvcm1hdE51bWJlck5vQ29sb3IodGVtcEFyZywgaW5zcGVjdE9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRlbXBBcmcgPT09ICdiaWdpbnQnKSB7XG5cdCAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0QmlnSW50Tm9Db2xvcih0ZW1wQXJnLCBpbnNwZWN0T3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGVtcEFyZyAhPT0gJ29iamVjdCcgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBBcmcgPT09IG51bGwgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICFoYXNCdWlsdEluVG9TdHJpbmcodGVtcEFyZykpIHtcblx0ICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBTdHJpbmcodGVtcEFyZyk7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KHRlbXBBcmcsIHtcblx0ICAgICAgICAgICAgICAgICAgLi4uaW5zcGVjdE9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgICAgIGNvbXBhY3Q6IDMsXG5cdCAgICAgICAgICAgICAgICAgIGNvbG9yczogZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgIGRlcHRoOiAwLFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2UgMTA2OiAvLyAnaidcblx0ICAgICAgICAgICAgICB0ZW1wU3RyID0gdHJ5U3RyaW5naWZ5KGFyZ3NbKythXSk7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgMTAwOiB7IC8vICdkJ1xuXHQgICAgICAgICAgICAgIGNvbnN0IHRlbXBOdW0gPSBhcmdzWysrYV07XG5cdCAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnYmlnaW50Jykge1xuXHQgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGZvcm1hdEJpZ0ludE5vQ29sb3IodGVtcE51bSwgaW5zcGVjdE9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRlbXBOdW0gPT09ICdzeW1ib2wnKSB7XG5cdCAgICAgICAgICAgICAgICB0ZW1wU3RyID0gJ05hTic7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBmb3JtYXROdW1iZXJOb0NvbG9yKE51bWJlcih0ZW1wTnVtKSwgaW5zcGVjdE9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIDc5OiAvLyAnTydcblx0ICAgICAgICAgICAgICB0ZW1wU3RyID0gaW5zcGVjdChhcmdzWysrYV0sIGluc3BlY3RPcHRpb25zKTtcblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSAxMTE6IC8vICdvJ1xuXHQgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwge1xuXHQgICAgICAgICAgICAgICAgLi4uaW5zcGVjdE9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgICBzaG93SGlkZGVuOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgc2hvd1Byb3h5OiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgZGVwdGg6IDQsXG5cdCAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgMTA1OiB7IC8vICdpJ1xuXHQgICAgICAgICAgICAgIGNvbnN0IHRlbXBJbnRlZ2VyID0gYXJnc1srK2FdO1xuXHQgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEludGVnZXIgPT09ICdiaWdpbnQnKSB7XG5cdCAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0QmlnSW50Tm9Db2xvcih0ZW1wSW50ZWdlciwgaW5zcGVjdE9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRlbXBJbnRlZ2VyID09PSAnc3ltYm9sJykge1xuXHQgICAgICAgICAgICAgICAgdGVtcFN0ciA9ICdOYU4nO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyTm9Db2xvcihcblx0ICAgICAgICAgICAgICAgICAgTnVtYmVyUGFyc2VJbnQodGVtcEludGVnZXIpLCBpbnNwZWN0T3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhc2UgMTAyOiB7IC8vICdmJ1xuXHQgICAgICAgICAgICAgIGNvbnN0IHRlbXBGbG9hdCA9IGFyZ3NbKythXTtcblx0ICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBGbG9hdCA9PT0gJ3N5bWJvbCcpIHtcblx0ICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcblx0ICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGZvcm1hdE51bWJlck5vQ29sb3IoXG5cdCAgICAgICAgICAgICAgICAgIE51bWJlclBhcnNlRmxvYXQodGVtcEZsb2F0KSwgaW5zcGVjdE9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIDk5OiAvLyAnYydcblx0ICAgICAgICAgICAgICBhICs9IDE7XG5cdCAgICAgICAgICAgICAgdGVtcFN0ciA9ICcnO1xuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIDM3OiAvLyAnJSdcblx0ICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nUHJvdG90eXBlU2xpY2UoZmlyc3QsIGxhc3RQb3MsIGkpO1xuXHQgICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcblx0ICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgZGVmYXVsdDogLy8gQW55IG90aGVyIGNoYXJhY3RlciBpcyBub3QgYSBjb3JyZWN0IHBsYWNlaG9sZGVyXG5cdCAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gaSAtIDEpIHtcblx0ICAgICAgICAgICAgc3RyICs9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKGZpcnN0LCBsYXN0UG9zLCBpIC0gMSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBzdHIgKz0gdGVtcFN0cjtcblx0ICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcblx0ICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAzNykge1xuXHQgICAgICAgICAgc3RyICs9IFN0cmluZ1Byb3RvdHlwZVNsaWNlKGZpcnN0LCBsYXN0UG9zLCBpKTtcblx0ICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChsYXN0UG9zICE9PSAwKSB7XG5cdCAgICAgIGErKztcblx0ICAgICAgam9pbiA9ICcgJztcblx0ICAgICAgaWYgKGxhc3RQb3MgPCBmaXJzdC5sZW5ndGgpIHtcblx0ICAgICAgICBzdHIgKz0gU3RyaW5nUHJvdG90eXBlU2xpY2UoZmlyc3QsIGxhc3RQb3MpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgd2hpbGUgKGEgPCBhcmdzLmxlbmd0aCkge1xuXHQgICAgY29uc3QgdmFsdWUgPSBhcmdzW2FdO1xuXHQgICAgc3RyICs9IGpvaW47XG5cdCAgICBzdHIgKz0gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyA/IGluc3BlY3QodmFsdWUsIGluc3BlY3RPcHRpb25zKSA6IHZhbHVlO1xuXHQgICAgam9pbiA9ICcgJztcblx0ICAgIGErKztcblx0ICB9XG5cdCAgcmV0dXJuIHN0cjtcblx0fVxuXG5cdGZ1bmN0aW9uIGlzWmVyb1dpZHRoQ29kZVBvaW50KGNvZGUpIHtcblx0ICByZXR1cm4gY29kZSA8PSAweDFGIHx8IC8vIEMwIGNvbnRyb2wgY29kZXNcblx0ICAgIChjb2RlID49IDB4N0YgJiYgY29kZSA8PSAweDlGKSB8fCAvLyBDMSBjb250cm9sIGNvZGVzXG5cdCAgICAoY29kZSA+PSAweDMwMCAmJiBjb2RlIDw9IDB4MzZGKSB8fCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3Ncblx0ICAgIChjb2RlID49IDB4MjAwQiAmJiBjb2RlIDw9IDB4MjAwRikgfHwgLy8gTW9kaWZ5aW5nIEludmlzaWJsZSBDaGFyYWN0ZXJzXG5cdCAgICAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgZm9yIFN5bWJvbHNcblx0ICAgIChjb2RlID49IDB4MjBEMCAmJiBjb2RlIDw9IDB4MjBGRikgfHxcblx0ICAgIChjb2RlID49IDB4RkUwMCAmJiBjb2RlIDw9IDB4RkUwRikgfHwgLy8gVmFyaWF0aW9uIFNlbGVjdG9yc1xuXHQgICAgKGNvZGUgPj0gMHhGRTIwICYmIGNvZGUgPD0gMHhGRTJGKSB8fCAvLyBDb21iaW5pbmcgSGFsZiBNYXJrc1xuXHQgICAgKGNvZGUgPj0gMHhFMDEwMCAmJiBjb2RlIDw9IDB4RTAxRUYpOyAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG5cdH1cblxuXHQvKiBjOCBpZ25vcmUgc3RhcnQgKi9cblx0aWYgKGludGVybmFsQmluZGluZygnY29uZmlnJykuaGFzSW50bCkge1xuXHQgIGFzc2VydChmYWxzZSk7XG5cdCAgLy8gQ2FuJ3QgdXNlIG5vZGUgaW50ZXJuYWxzXG5cdCAgLy8gY29uc3QgaWN1ID0gaW50ZXJuYWxCaW5kaW5nKCdpY3UnKTtcblx0ICAvLyAvLyBpY3UuZ2V0U3RyaW5nV2lkdGgoc3RyaW5nLCBhbWJpZ3VvdXNBc0Z1bGxXaWR0aCwgZXhwYW5kRW1vamlTZXF1ZW5jZSlcblx0ICAvLyAvLyBEZWZhdWx0czogYW1iaWd1b3VzQXNGdWxsV2lkdGggPSBmYWxzZTsgZXhwYW5kRW1vamlTZXF1ZW5jZSA9IHRydWU7XG5cdCAgLy8gLy8gVE9ETyhCcmlkZ2VBUik6IEV4cG9zZSB0aGUgb3B0aW9ucyB0byB0aGUgdXNlci4gVGhhdCBpcyBwcm9iYWJseSB0aGVcblx0ICAvLyAvLyBiZXN0IHRoaW5nIHBvc3NpYmxlIGF0IHRoZSBtb21lbnQsIHNpbmNlIGl0J3MgZGlmZmljdWx0IHRvIGtub3cgd2hhdFxuXHQgIC8vIC8vIHRoZSByZWNlaXZpbmcgZW5kIHN1cHBvcnRzLlxuXHQgIC8vIGdldFN0cmluZ1dpZHRoID0gZnVuY3Rpb24gZ2V0U3RyaW5nV2lkdGgoc3RyLCByZW1vdmVDb250cm9sQ2hhcnMgPSB0cnVlKSB7XG5cdCAgLy8gICBsZXQgd2lkdGggPSAwO1xuXG5cdCAgLy8gICBpZiAocmVtb3ZlQ29udHJvbENoYXJzKSB7XG5cdCAgLy8gICAgIHN0ciA9IHN0cmlwVlRDb250cm9sQ2hhcmFjdGVycyhzdHIpO1xuXHQgIC8vICAgfVxuXHQgIC8vICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0ICAvLyAgICAgLy8gVHJ5IHRvIGF2b2lkIGNhbGxpbmcgaW50byBDKysgYnkgZmlyc3QgaGFuZGxpbmcgdGhlIEFTQ0lJIHBvcnRpb24gb2Zcblx0ICAvLyAgICAgLy8gdGhlIHN0cmluZy4gSWYgaXQgaXMgZnVsbHkgQVNDSUksIHdlIHNraXAgdGhlIEMrKyBwYXJ0LlxuXHQgIC8vICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdCAgLy8gICAgIGlmIChjb2RlID49IDEyNykge1xuXHQgIC8vICAgICAgIHdpZHRoICs9IGljdS5nZXRTdHJpbmdXaWR0aChTdHJpbmdQcm90b3R5cGVOb3JtYWxpemUoU3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RyLCBpKSwgJ05GQycpKTtcblx0ICAvLyAgICAgICBicmVhaztcblx0ICAvLyAgICAgfVxuXHQgIC8vICAgICB3aWR0aCArPSBjb2RlID49IDMyID8gMSA6IDA7XG5cdCAgLy8gICB9XG5cdCAgLy8gICByZXR1cm4gd2lkdGg7XG5cdCAgLy8gfTtcblx0ICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuXHR9IGVsc2Uge1xuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIHJlcXVpcmVkIHRvIGRpc3BsYXkgdGhlIGdpdmVuIHN0cmluZy5cblx0ICAgKi9cblx0ICBnZXRTdHJpbmdXaWR0aCA9IGZ1bmN0aW9uIGdldFN0cmluZ1dpZHRoKHN0ciwgcmVtb3ZlQ29udHJvbENoYXJzID0gdHJ1ZSkge1xuXHQgICAgbGV0IHdpZHRoID0gMDtcblxuXHQgICAgaWYgKHJlbW92ZUNvbnRyb2xDaGFycylcblx0ICAgICAgc3RyID0gc3RyaXBWVENvbnRyb2xDaGFyYWN0ZXJzKHN0cik7XG5cdCAgICBzdHIgPSBTdHJpbmdQcm90b3R5cGVOb3JtYWxpemUoc3RyLCAnTkZDJyk7XG5cdCAgICBmb3IgKGNvbnN0IGNoYXIgb2YgbmV3IFNhZmVTdHJpbmdJdGVyYXRvcihzdHIpKSB7XG5cdCAgICAgIGNvbnN0IGNvZGUgPSBTdHJpbmdQcm90b3R5cGVDb2RlUG9pbnRBdChjaGFyLCAwKTtcblx0ICAgICAgaWYgKGlzRnVsbFdpZHRoQ29kZVBvaW50KGNvZGUpKSB7XG5cdCAgICAgICAgd2lkdGggKz0gMjtcblx0ICAgICAgfSBlbHNlIGlmICghaXNaZXJvV2lkdGhDb2RlUG9pbnQoY29kZSkpIHtcblx0ICAgICAgICB3aWR0aCsrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB3aWR0aDtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgcmVwcmVzZW50ZWQgYnkgYSBnaXZlblxuXHQgICAqIFVuaWNvZGUgY29kZSBwb2ludCBpcyBmdWxsLXdpZHRoLiBPdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cblx0ICAgKi9cblx0ICBjb25zdCBpc0Z1bGxXaWR0aENvZGVQb2ludCA9IChjb2RlKSA9PiB7XG5cdCAgICAvLyBDb2RlIHBvaW50cyBhcmUgcGFydGlhbGx5IGRlcml2ZWQgZnJvbTpcblx0ICAgIC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VTklEQVRBL0Vhc3RBc2lhbldpZHRoLnR4dFxuXHQgICAgcmV0dXJuIGNvZGUgPj0gMHgxMTAwICYmIChcblx0ICAgICAgY29kZSA8PSAweDExNWYgfHwgIC8vIEhhbmd1bCBKYW1vXG5cdCAgICAgIGNvZGUgPT09IDB4MjMyOSB8fCAvLyBMRUZULVBPSU5USU5HIEFOR0xFIEJSQUNLRVRcblx0ICAgICAgY29kZSA9PT0gMHgyMzJhIHx8IC8vIFJJR0hULVBPSU5USU5HIEFOR0xFIEJSQUNLRVRcblx0ICAgICAgLy8gQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnQgLi4gRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1xuXHQgICAgICAoY29kZSA+PSAweDJlODAgJiYgY29kZSA8PSAweDMyNDcgJiYgY29kZSAhPT0gMHgzMDNmKSB8fFxuXHQgICAgICAvLyBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzIC4uIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcblx0ICAgICAgKGNvZGUgPj0gMHgzMjUwICYmIGNvZGUgPD0gMHg0ZGJmKSB8fFxuXHQgICAgICAvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIC4uIFlpIFJhZGljYWxzXG5cdCAgICAgIChjb2RlID49IDB4NGUwMCAmJiBjb2RlIDw9IDB4YTRjNikgfHxcblx0ICAgICAgLy8gSGFuZ3VsIEphbW8gRXh0ZW5kZWQtQVxuXHQgICAgICAoY29kZSA+PSAweGE5NjAgJiYgY29kZSA8PSAweGE5N2MpIHx8XG5cdCAgICAgIC8vIEhhbmd1bCBTeWxsYWJsZXNcblx0ICAgICAgKGNvZGUgPj0gMHhhYzAwICYmIGNvZGUgPD0gMHhkN2EzKSB8fFxuXHQgICAgICAvLyBDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXG5cdCAgICAgIChjb2RlID49IDB4ZjkwMCAmJiBjb2RlIDw9IDB4ZmFmZikgfHxcblx0ICAgICAgLy8gVmVydGljYWwgRm9ybXNcblx0ICAgICAgKGNvZGUgPj0gMHhmZTEwICYmIGNvZGUgPD0gMHhmZTE5KSB8fFxuXHQgICAgICAvLyBDSksgQ29tcGF0aWJpbGl0eSBGb3JtcyAuLiBTbWFsbCBGb3JtIFZhcmlhbnRzXG5cdCAgICAgIChjb2RlID49IDB4ZmUzMCAmJiBjb2RlIDw9IDB4ZmU2YikgfHxcblx0ICAgICAgLy8gSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcblx0ICAgICAgKGNvZGUgPj0gMHhmZjAxICYmIGNvZGUgPD0gMHhmZjYwKSB8fFxuXHQgICAgICAoY29kZSA+PSAweGZmZTAgJiYgY29kZSA8PSAweGZmZTYpIHx8XG5cdCAgICAgIC8vIEthbmEgU3VwcGxlbWVudFxuXHQgICAgICAoY29kZSA+PSAweDFiMDAwICYmIGNvZGUgPD0gMHgxYjAwMSkgfHxcblx0ICAgICAgLy8gRW5jbG9zZWQgSWRlb2dyYXBoaWMgU3VwcGxlbWVudFxuXHQgICAgICAoY29kZSA+PSAweDFmMjAwICYmIGNvZGUgPD0gMHgxZjI1MSkgfHxcblx0ICAgICAgLy8gTWlzY2VsbGFuZW91cyBTeW1ib2xzIGFuZCBQaWN0b2dyYXBocyAweDFmMzAwIC0gMHgxZjVmZlxuXHQgICAgICAvLyBFbW90aWNvbnMgMHgxZjYwMCAtIDB4MWY2NGZcblx0ICAgICAgKGNvZGUgPj0gMHgxZjMwMCAmJiBjb2RlIDw9IDB4MWY2NGYpIHx8XG5cdCAgICAgIC8vIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEIgLi4gVGVydGlhcnkgSWRlb2dyYXBoaWMgUGxhbmVcblx0ICAgICAgKGNvZGUgPj0gMHgyMDAwMCAmJiBjb2RlIDw9IDB4M2ZmZmQpXG5cdCAgICApO1xuXHQgIH07XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIFZUIGNvbnRyb2wgY2hhcmFjdGVycy4gVXNlIHRvIGVzdGltYXRlIGRpc3BsYXllZCBzdHJpbmcgd2lkdGguXG5cdCAqL1xuXHRmdW5jdGlvbiBzdHJpcFZUQ29udHJvbENoYXJhY3RlcnMoc3RyKSB7XG5cdCAgdmFsaWRhdGVTdHJpbmcoc3RyLCAnc3RyJyk7XG5cdCAgcmV0dXJuIFJlZ0V4cFByb3RvdHlwZVN5bWJvbFJlcGxhY2UoYW5zaSwgc3RyLCAnJyk7XG5cdH1cblxuXHRjb25zdCBlbnRpdGllcyA9IHtcblx0ICAzNDogJyZxdW90OycsXG5cdCAgMzg6ICcmYW1wOycsXG5cdCAgMzk6ICcmYXBvczsnLFxuXHQgIDYwOiAnJmx0OycsXG5cdCAgNjI6ICcmZ3Q7Jyxcblx0ICAxNjA6ICcmbmJzcDsnLFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGVzY2FwZUhUTUwoc3RyKSB7XG5cdCAgcmV0dXJuIHN0ci5yZXBsYWNlKFxuXHQgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblx0ICAgIC9bXFx1MDAwMC1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDYwXFx1MDA3Qi1cXHUwMEZGXS9nLFxuXHQgICAgKGMpID0+IHtcblx0ICAgICAgY29uc3QgY29kZSA9IFN0cmluZyhjLmNoYXJDb2RlQXQoMCkpO1xuXHQgICAgICBjb25zdCBlbnQgPSBlbnRpdGllc1tjb2RlXTtcblx0ICAgICAgcmV0dXJuIGVudCB8fCAoJyYjJyArIGNvZGUgKyAnOycpO1xuXHQgICAgfSxcblx0ICApO1xuXHR9XG5cblx0aW5zcGVjdF8xID0ge1xuXHQgIGlkZW50aWNhbFNlcXVlbmNlUmFuZ2UsXG5cdCAgaW5zcGVjdCxcblx0ICBpbnNwZWN0RGVmYXVsdE9wdGlvbnMsXG5cdCAgZm9ybWF0LFxuXHQgIGZvcm1hdFdpdGhPcHRpb25zLFxuXHQgIGdldFN0cmluZ1dpZHRoLFxuXHQgIHN0cmlwVlRDb250cm9sQ2hhcmFjdGVycyxcblx0ICBpc1plcm9XaWR0aENvZGVQb2ludCxcblx0ICBzdHlsaXplV2l0aENvbG9yLFxuXHQgIHN0eWxpemVXaXRoSFRNTChzdHIsIHN0eWxlVHlwZSkge1xuXHQgICAgY29uc3Qgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXHQgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgcmV0dXJuIGA8c3BhbiBzdHlsZT1cImNvbG9yOiR7c3R5bGV9O1wiPiR7ZXNjYXBlSFRNTChzdHIpfTwvc3Bhbj5gO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGVzY2FwZUhUTUwoc3RyKTtcblx0ICB9LFxuXHQgIFByb3h5LFxuXHR9O1xuXHRyZXR1cm4gaW5zcGVjdF8xO1xufVxuXG52YXIgaW5zcGVjdEV4cG9ydHMgPSByZXF1aXJlSW5zcGVjdCgpO1xudmFyIGluc3BlY3QgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaW5zcGVjdEV4cG9ydHMpO1xuXG5leHBvcnQgeyBpbnNwZWN0IGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB1dGlsIGZyb20gJy4vZGlzdC9pbnNwZWN0LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgdXRpbDtcblxuZXhwb3J0IGNvbnN0IHtcbiAgLy8gVGhlIGNvbW1lbnRlZCBvdXQgdGhpbmdzIGFyZSBub3QgdmlzaWJsZSBmcm9tIG5vcm1hbCBub2RlJ3MgdXRpbC5cbiAgLy8gaWRlbnRpY2FsU2VxdWVuY2VSYW5nZSxcbiAgaW5zcGVjdCxcbiAgLy8gaW5zcGVjdERlZmF1bHRPcHRpb25zLFxuICBmb3JtYXQsXG4gIGZvcm1hdFdpdGhPcHRpb25zLFxuICAvLyBnZXRTdHJpbmdXaWR0aCxcbiAgc3RyaXBWVENvbnRyb2xDaGFyYWN0ZXJzLFxuICAvLyBpc1plcm9XaWR0aENvZGVQb2ludCxcbiAgc3R5bGl6ZVdpdGhDb2xvcixcbiAgc3R5bGl6ZVdpdGhIVE1MLFxuICBQcm94eSxcbn0gPSB1dGlsO1xuIiwiaW1wb3J0IHsgaW5zcGVjdCwgZm9ybWF0IH0gZnJvbSAnbm9kZS1pbnNwZWN0LWV4dHJhY3RlZCdcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiAoXG4gICAgYXJnICYmXG4gICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8vIGJvcnJvdyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvaW5oZXJpdHNcbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCB7IGluaGVyaXRzLCBpbnNwZWN0LCBmb3JtYXQsIGlzQnVmZmVyIH1cbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBleHBvcnRzLlJhbmdlRXJyb3IgPSBleHBvcnRzLlR5cGVFcnJvciA9IGV4cG9ydHMuRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuZXhwb3J0cy5FID0gRTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBrQ29kZSA9IHR5cGVvZiBTeW1ib2wgPT09ICd1bmRlZmluZWQnID8gJ19rQ29kZScgOiBTeW1ib2woJ2NvZGUnKTtcbmNvbnN0IG1lc3NhZ2VzID0ge307IC8vIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIG1ha2VOb2RlRXJyb3IoQmFzZSkge1xuICAgIHJldHVybiBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICAgICAgY29uc3RydWN0b3Ioa2V5LCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlKGtleSwgYXJncykpO1xuICAgICAgICAgICAgdGhpcy5jb2RlID0ga2V5O1xuICAgICAgICAgICAgdGhpc1trQ29kZV0gPSBrZXk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBgJHtzdXBlci5uYW1lfSBbJHt0aGlzW2tDb2RlXX1dYDtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBnID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbDtcbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgZy5FcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlR5cGVFcnJvcignRVJSX0lOVkFMSURfQVJHX1RZUEUnLCAnb3B0aW9ucycsICdvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgICAgICAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoYCR7dXRpbC5pbnNwZWN0KG9wdGlvbnMuYWN0dWFsKS5zbGljZSgwLCAxMjgpfSBgICtcbiAgICAgICAgICAgICAgICBgJHtvcHRpb25zLm9wZXJhdG9yfSAke3V0aWwuaW5zcGVjdChvcHRpb25zLmV4cGVjdGVkKS5zbGljZSgwLCAxMjgpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgICAgIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgICAgICAgZXhwb3J0cy5FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuZnVuY3Rpb24gbWVzc2FnZShrZXksIGFyZ3MpIHtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGtleSwgJ3N0cmluZycpO1xuICAgIC8vIGNvbnN0IG1zZyA9IG1lc3NhZ2VzLmdldChrZXkpO1xuICAgIGNvbnN0IG1zZyA9IG1lc3NhZ2VzW2tleV07XG4gICAgYXNzZXJ0KG1zZywgYEFuIGludmFsaWQgZXJyb3IgbWVzc2FnZSBrZXkgd2FzIHVzZWQ6ICR7a2V5fS5gKTtcbiAgICBsZXQgZm10O1xuICAgIGlmICh0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZtdCA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZtdCA9IHV0aWwuZm9ybWF0O1xuICAgICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgYXJncy51bnNoaWZ0KG1zZyk7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoZm10LmFwcGx5KG51bGwsIGFyZ3MpKTtcbn1cbi8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIHRoZSBlcnJvciBjb2Rlcy4gT25seSB1c2VkIGhlcmUuIEV4cG9ydGVkXG4vLyAqb25seSogdG8gYWxsb3cgZm9yIHRlc3RpbmcuXG5mdW5jdGlvbiBFKHN5bSwgdmFsKSB7XG4gICAgbWVzc2FnZXNbc3ltXSA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgPyB2YWwgOiBTdHJpbmcodmFsKTtcbn1cbmV4cG9ydHMuRXJyb3IgPSBtYWtlTm9kZUVycm9yKGcuRXJyb3IpO1xuZXhwb3J0cy5UeXBlRXJyb3IgPSBtYWtlTm9kZUVycm9yKGcuVHlwZUVycm9yKTtcbmV4cG9ydHMuUmFuZ2VFcnJvciA9IG1ha2VOb2RlRXJyb3IoZy5SYW5nZUVycm9yKTtcbi8vIFRvIGRlY2xhcmUgYW4gZXJyb3IgbWVzc2FnZSwgdXNlIHRoZSBFKHN5bSwgdmFsKSBmdW5jdGlvbiBhYm92ZS4gVGhlIHN5bVxuLy8gbXVzdCBiZSBhbiB1cHBlciBjYXNlIHN0cmluZy4gVGhlIHZhbCBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuXG4vLyBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGEgc3RyaW5nLlxuLy8gRXhhbXBsZXM6XG4vLyBFKCdFWEFNUExFX0tFWTEnLCAnVGhpcyBpcyB0aGUgZXJyb3IgdmFsdWUnKTtcbi8vIEUoJ0VYQU1QTEVfS0VZMicsIChhLCBiKSA9PiByZXR1cm4gYCR7YX0gJHtifWApO1xuLy9cbi8vIE9uY2UgYW4gZXJyb3IgY29kZSBoYXMgYmVlbiBhc3NpZ25lZCwgdGhlIGNvZGUgaXRzZWxmIE1VU1QgTk9UIGNoYW5nZSBhbmRcbi8vIGFueSBnaXZlbiBlcnJvciBjb2RlIG11c3QgbmV2ZXIgYmUgcmV1c2VkIHRvIGlkZW50aWZ5IGEgZGlmZmVyZW50IGVycm9yLlxuLy9cbi8vIEFueSBlcnJvciBjb2RlIGFkZGVkIGhlcmUgc2hvdWxkIGFsc28gYmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50YXRpb25cbi8vXG4vLyBOb3RlOiBQbGVhc2UgdHJ5IHRvIGtlZXAgdGhlc2UgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG5FKCdFUlJfQVJHX05PVF9JVEVSQUJMRScsICclcyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5FKCdFUlJfQVNTRVJUSU9OJywgJyVzJyk7XG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLCBidWZmZXJPdXRPZkJvdW5kcyk7XG5FKCdFUlJfQ0hJTERfQ0xPU0VEX0JFRk9SRV9SRVBMWScsICdDaGlsZCBjbG9zZWQgYmVmb3JlIHJlcGx5IHJlY2VpdmVkJyk7XG5FKCdFUlJfQ09OU09MRV9XUklUQUJMRV9TVFJFQU0nLCAnQ29uc29sZSBleHBlY3RzIGEgd3JpdGFibGUgc3RyZWFtIGluc3RhbmNlIGZvciAlcycpO1xuRSgnRVJSX0NQVV9VU0FHRScsICdVbmFibGUgdG8gb2J0YWluIGNwdSB1c2FnZSAlcycpO1xuRSgnRVJSX0ROU19TRVRfU0VSVkVSU19GQUlMRUQnLCAoZXJyLCBzZXJ2ZXJzKSA9PiBgYy1hcmVzIGZhaWxlZCB0byBzZXQgc2VydmVyczogXCIke2Vycn1cIiBbJHtzZXJ2ZXJzfV1gKTtcbkUoJ0VSUl9GQUxTWV9WQUxVRV9SRUpFQ1RJT04nLCAnUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBmYWxzeSB2YWx1ZScpO1xuRSgnRVJSX0VOQ09ESU5HX05PVF9TVVBQT1JURUQnLCBlbmMgPT4gYFRoZSBcIiR7ZW5jfVwiIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbkUoJ0VSUl9FTkNPRElOR19JTlZBTElEX0VOQ09ERURfREFUQScsIGVuYyA9PiBgVGhlIGVuY29kZWQgZGF0YSB3YXMgbm90IHZhbGlkIGZvciBlbmNvZGluZyAke2VuY31gKTtcbkUoJ0VSUl9IVFRQX0hFQURFUlNfU0VOVCcsICdDYW5ub3QgcmVuZGVyIGhlYWRlcnMgYWZ0ZXIgdGhleSBhcmUgc2VudCB0byB0aGUgY2xpZW50Jyk7XG5FKCdFUlJfSFRUUF9JTlZBTElEX1NUQVRVU19DT0RFJywgJ0ludmFsaWQgc3RhdHVzIGNvZGU6ICVzJyk7XG5FKCdFUlJfSFRUUF9UUkFJTEVSX0lOVkFMSUQnLCAnVHJhaWxlcnMgYXJlIGludmFsaWQgd2l0aCB0aGlzIHRyYW5zZmVyIGVuY29kaW5nJyk7XG5FKCdFUlJfSU5ERVhfT1VUX09GX1JBTkdFJywgJ0luZGV4IG91dCBvZiByYW5nZScpO1xuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBpbnZhbGlkQXJnVHlwZSk7XG5FKCdFUlJfSU5WQUxJRF9BUlJBWV9MRU5HVEgnLCAobmFtZSwgbGVuLCBhY3R1YWwpID0+IHtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGFjdHVhbCwgJ251bWJlcicpO1xuICAgIHJldHVybiBgVGhlIGFycmF5IFwiJHtuYW1lfVwiIChsZW5ndGggJHthY3R1YWx9KSBtdXN0IGJlIG9mIGxlbmd0aCAke2xlbn0uYDtcbn0pO1xuRSgnRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUnLCAnQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9DQUxMQkFDSycsICdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbkUoJ0VSUl9JTlZBTElEX0NIQVInLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gJXMnKTtcbkUoJ0VSUl9JTlZBTElEX0NVUlNPUl9QT1MnLCAnQ2Fubm90IHNldCBjdXJzb3Igcm93IHdpdGhvdXQgc2V0dGluZyBpdHMgY29sdW1uJyk7XG5FKCdFUlJfSU5WQUxJRF9GRCcsICdcImZkXCIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXI6ICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9GSUxFX1VSTF9IT1NUJywgJ0ZpbGUgVVJMIGhvc3QgbXVzdCBiZSBcImxvY2FsaG9zdFwiIG9yIGVtcHR5IG9uICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9GSUxFX1VSTF9QQVRIJywgJ0ZpbGUgVVJMIHBhdGggJXMnKTtcbkUoJ0VSUl9JTlZBTElEX0hBTkRMRV9UWVBFJywgJ1RoaXMgaGFuZGxlIHR5cGUgY2Fubm90IGJlIHNlbnQnKTtcbkUoJ0VSUl9JTlZBTElEX0lQX0FERFJFU1MnLCAnSW52YWxpZCBJUCBhZGRyZXNzOiAlcycpO1xuRSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGBUaGUgdmFsdWUgXCIke1N0cmluZyh2YWx1ZSl9XCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiJHtuYW1lfVwiYDtcbn0pO1xuRSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFX0VOQ09ESU5HJywgdmFsdWUgPT4gYFRoZSB2YWx1ZSBcIiR7U3RyaW5nKHZhbHVlKX1cIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJlbmNvZGluZ1wiYCk7XG5FKCdFUlJfSU5WQUxJRF9SRVBMX0VWQUxfQ09ORklHJywgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggXCJicmVha0V2YWxPblNpZ2ludFwiIGFuZCBcImV2YWxcIiBmb3IgUkVQTCcpO1xuRSgnRVJSX0lOVkFMSURfU1lOQ19GT1JLX0lOUFVUJywgJ0FzeW5jaHJvbm91cyBmb3JrcyBkbyBub3Qgc3VwcG9ydCBCdWZmZXIsIFVpbnQ4QXJyYXkgb3Igc3RyaW5nIGlucHV0OiAlcycpO1xuRSgnRVJSX0lOVkFMSURfVEhJUycsICdWYWx1ZSBvZiBcInRoaXNcIiBtdXN0IGJlIG9mIHR5cGUgJXMnKTtcbkUoJ0VSUl9JTlZBTElEX1RVUExFJywgJyVzIG11c3QgYmUgYW4gaXRlcmFibGUgJXMgdHVwbGUnKTtcbkUoJ0VSUl9JTlZBTElEX1VSTCcsICdJbnZhbGlkIFVSTDogJXMnKTtcbkUoJ0VSUl9JTlZBTElEX1VSTF9TQ0hFTUUnLCBleHBlY3RlZCA9PiBgVGhlIFVSTCBtdXN0IGJlICR7b25lT2YoZXhwZWN0ZWQsICdzY2hlbWUnKX1gKTtcbkUoJ0VSUl9JUENfQ0hBTk5FTF9DTE9TRUQnLCAnQ2hhbm5lbCBjbG9zZWQnKTtcbkUoJ0VSUl9JUENfRElTQ09OTkVDVEVEJywgJ0lQQyBjaGFubmVsIGlzIGFscmVhZHkgZGlzY29ubmVjdGVkJyk7XG5FKCdFUlJfSVBDX09ORV9QSVBFJywgJ0NoaWxkIHByb2Nlc3MgY2FuIGhhdmUgb25seSBvbmUgSVBDIHBpcGUnKTtcbkUoJ0VSUl9JUENfU1lOQ19GT1JLJywgJ0lQQyBjYW5ub3QgYmUgdXNlZCB3aXRoIHN5bmNocm9ub3VzIGZvcmtzJyk7XG5FKCdFUlJfTUlTU0lOR19BUkdTJywgbWlzc2luZ0FyZ3MpO1xuRSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuRSgnRVJSX05BUElfQ09OU19GVU5DVElPTicsICdDb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbkUoJ0VSUl9OQVBJX0NPTlNfUFJPVE9UWVBFX09CSkVDVCcsICdDb25zdHJ1Y3Rvci5wcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3QnKTtcbkUoJ0VSUl9OT19DUllQVE8nLCAnTm9kZS5qcyBpcyBub3QgY29tcGlsZWQgd2l0aCBPcGVuU1NMIGNyeXB0byBzdXBwb3J0Jyk7XG5FKCdFUlJfTk9fTE9OR0VSX1NVUFBPUlRFRCcsICclcyBpcyBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG5FKCdFUlJfUEFSU0VfSElTVE9SWV9EQVRBJywgJ0NvdWxkIG5vdCBwYXJzZSBoaXN0b3J5IGRhdGEgaW4gJXMnKTtcbkUoJ0VSUl9TT0NLRVRfQUxSRUFEWV9CT1VORCcsICdTb2NrZXQgaXMgYWxyZWFkeSBib3VuZCcpO1xuRSgnRVJSX1NPQ0tFVF9CQURfUE9SVCcsICdQb3J0IHNob3VsZCBiZSA+IDAgYW5kIDwgNjU1MzYnKTtcbkUoJ0VSUl9TT0NLRVRfQkFEX1RZUEUnLCAnQmFkIHNvY2tldCB0eXBlIHNwZWNpZmllZC4gVmFsaWQgdHlwZXMgYXJlOiB1ZHA0LCB1ZHA2Jyk7XG5FKCdFUlJfU09DS0VUX0NBTk5PVF9TRU5EJywgJ1VuYWJsZSB0byBzZW5kIGRhdGEnKTtcbkUoJ0VSUl9TT0NLRVRfQ0xPU0VEJywgJ1NvY2tldCBpcyBjbG9zZWQnKTtcbkUoJ0VSUl9TT0NLRVRfREdSQU1fTk9UX1JVTk5JTkcnLCAnTm90IHJ1bm5pbmcnKTtcbkUoJ0VSUl9TVERFUlJfQ0xPU0UnLCAncHJvY2Vzcy5zdGRlcnIgY2Fubm90IGJlIGNsb3NlZCcpO1xuRSgnRVJSX1NURE9VVF9DTE9TRScsICdwcm9jZXNzLnN0ZG91dCBjYW5ub3QgYmUgY2xvc2VkJyk7XG5FKCdFUlJfU1RSRUFNX1dSQVAnLCAnU3RyZWFtIGhhcyBTdHJpbmdEZWNvZGVyIHNldCBvciBpcyBpbiBvYmplY3RNb2RlJyk7XG5FKCdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJywgXCJIb3N0bmFtZS9JUCBkb2VzIG5vdCBtYXRjaCBjZXJ0aWZpY2F0ZSdzIGFsdG5hbWVzOiAlc1wiKTtcbkUoJ0VSUl9UTFNfREhfUEFSQU1fU0laRScsIHNpemUgPT4gYERIIHBhcmFtZXRlciBzaXplICR7c2l6ZX0gaXMgbGVzcyB0aGFuIDIwNDhgKTtcbkUoJ0VSUl9UTFNfSEFORFNIQUtFX1RJTUVPVVQnLCAnVExTIGhhbmRzaGFrZSB0aW1lb3V0Jyk7XG5FKCdFUlJfVExTX1JFTkVHT1RJQVRJT05fRkFJTEVEJywgJ0ZhaWxlZCB0byByZW5lZ290aWF0ZScpO1xuRSgnRVJSX1RMU19SRVFVSVJFRF9TRVJWRVJfTkFNRScsICdcInNlcnZlcm5hbWVcIiBpcyByZXF1aXJlZCBwYXJhbWV0ZXIgZm9yIFNlcnZlci5hZGRDb250ZXh0Jyk7XG5FKCdFUlJfVExTX1NFU1NJT05fQVRUQUNLJywgJ1RTTCBzZXNzaW9uIHJlbmVnb3RpYXRpb24gYXR0YWNrIGRldGVjdGVkJyk7XG5FKCdFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HJywgJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcbkUoJ0VSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCcsICdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3JpdGFibGVTdGF0ZS5sZW5ndGggIT0gMCcpO1xuRSgnRVJSX1VOS05PV05fRU5DT0RJTkcnLCAnVW5rbm93biBlbmNvZGluZzogJXMnKTtcbkUoJ0VSUl9VTktOT1dOX1NJR05BTCcsICdVbmtub3duIHNpZ25hbDogJXMnKTtcbkUoJ0VSUl9VTktOT1dOX1NURElOX1RZUEUnLCAnVW5rbm93biBzdGRpbiBmaWxlIHR5cGUnKTtcbkUoJ0VSUl9VTktOT1dOX1NUUkVBTV9UWVBFJywgJ1Vua25vd24gc3RyZWFtIGZpbGUgdHlwZScpO1xuRSgnRVJSX1Y4QlJFQUtJVEVSQVRPUicsICdGdWxsIElDVSBkYXRhIG5vdCBpbnN0YWxsZWQuICcgKyAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS93aWtpL0ludGwnKTtcbmZ1bmN0aW9uIGludmFsaWRBcmdUeXBlKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICBhc3NlcnQobmFtZSwgJ25hbWUgaXMgcmVxdWlyZWQnKTtcbiAgICAvLyBkZXRlcm1pbmVyOiAnbXVzdCBiZScgb3IgJ211c3Qgbm90IGJlJ1xuICAgIGxldCBkZXRlcm1pbmVyO1xuICAgIGlmIChleHBlY3RlZC5pbmNsdWRlcygnbm90ICcpKSB7XG4gICAgICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnNwbGl0KCdub3QgJylbMV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICAgIH1cbiAgICBsZXQgbXNnO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gbmFtZS5tYXAodmFsID0+IGBcIiR7dmFsfVwiYCkuam9pbignLCAnKTtcbiAgICAgICAgbXNnID0gYFRoZSAke25hbWVzfSBhcmd1bWVudHMgJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5jbHVkZXMoJyBhcmd1bWVudCcpKSB7XG4gICAgICAgIC8vIGZvciB0aGUgY2FzZSBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICAgICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG5hbWUuaW5jbHVkZXMoJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgICAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gICAgfVxuICAgIC8vIGlmIGFjdHVhbCB2YWx1ZSByZWNlaXZlZCwgb3V0cHV0IGl0XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICBtc2cgKz0gYC4gUmVjZWl2ZWQgdHlwZSAke2FjdHVhbCAhPT0gbnVsbCA/IHR5cGVvZiBhY3R1YWwgOiAnbnVsbCd9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIG1pc3NpbmdBcmdzKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoYXJncy5sZW5ndGggPiAwLCAnQXQgbGVhc3Qgb25lIGFyZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICBsZXQgbXNnID0gJ1RoZSAnO1xuICAgIGNvbnN0IGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIGFyZ3MgPSBhcmdzLm1hcChhID0+IGBcIiR7YX1cImApO1xuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIG1zZyArPSBgJHthcmdzWzBdfSBhcmd1bWVudGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbXNnICs9IGAke2FyZ3NbMF19IGFuZCAke2FyZ3NbMV19IGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICBtc2cgKz0gYCwgYW5kICR7YXJnc1tsZW4gLSAxXX0gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXNnfSBtdXN0IGJlIHNwZWNpZmllZGA7XG59XG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgICBhc3NlcnQoZXhwZWN0ZWQsICdleHBlY3RlZCBpcyByZXF1aXJlZCcpO1xuICAgIGFzc2VydCh0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnLCAndGhpbmcgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgICAgICBhc3NlcnQobGVuID4gMCwgJ0F0IGxlYXN0IG9uZSBleHBlY3RlZCB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGkgPT4gU3RyaW5nKGkpKTtcbiAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKX0sIG9yIGAgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19IG9yICR7ZXhwZWN0ZWRbMV19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtleHBlY3RlZFswXX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYG9mICR7dGhpbmd9ICR7U3RyaW5nKGV4cGVjdGVkKX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1ZmZlck91dE9mQm91bmRzKG5hbWUsIGlzV3JpdGluZykge1xuICAgIGlmIChpc1dyaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuICdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYFwiJHtuYW1lfVwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FTkNPRElOR19VVEY4ID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnRFbmNvZGluZyA9IGFzc2VydEVuY29kaW5nO1xuZXhwb3J0cy5zdHJUb0VuY29kaW5nID0gc3RyVG9FbmNvZGluZztcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnVmZmVyXCIpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvZXJyb3JzXCIpO1xuZXhwb3J0cy5FTkNPRElOR19VVEY4ID0gJ3V0ZjgnO1xuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgJiYgIWJ1ZmZlcl8xLkJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSlcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UeXBlRXJyb3IoJ0VSUl9JTlZBTElEX09QVF9WQUxVRV9FTkNPRElORycsIGVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIHN0clRvRW5jb2Rpbmcoc3RyLCBlbmNvZGluZykge1xuICAgIGlmICghZW5jb2RpbmcgfHwgZW5jb2RpbmcgPT09IGV4cG9ydHMuRU5DT0RJTkdfVVRGOClcbiAgICAgICAgcmV0dXJuIHN0cjsgLy8gVVRGLThcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKVxuICAgICAgICByZXR1cm4gbmV3IGJ1ZmZlcl8xLkJ1ZmZlcihzdHIpOyAvLyBgYnVmZmVyYCBlbmNvZGluZ1xuICAgIHJldHVybiBuZXcgYnVmZmVyXzEuQnVmZmVyKHN0cikudG9TdHJpbmcoZW5jb2RpbmcpOyAvLyBDdXN0b20gZW5jb2Rpbmdcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY29kaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXJlbnQgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbmNvbnN0IHsgU19JRk1ULCBTX0lGRElSLCBTX0lGUkVHLCBTX0lGQkxLLCBTX0lGQ0hSLCBTX0lGTE5LLCBTX0lGSUZPLCBTX0lGU09DSyB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuLyoqXG4gKiBBIGRpcmVjdG9yeSBlbnRyeSwgbGlrZSBgZnMuRGlyZW50YC5cbiAqL1xuY2xhc3MgRGlyZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIHRoaXMucGF0aCA9ICcnO1xuICAgICAgICB0aGlzLnBhcmVudFBhdGggPSAnJztcbiAgICAgICAgdGhpcy5tb2RlID0gMDtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKGxpbmssIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IGRpcmVudCA9IG5ldyBEaXJlbnQoKTtcbiAgICAgICAgY29uc3QgeyBtb2RlIH0gPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgZGlyZW50Lm5hbWUgPSAoMCwgZW5jb2RpbmdfMS5zdHJUb0VuY29kaW5nKShsaW5rLmdldE5hbWUoKSwgZW5jb2RpbmcpO1xuICAgICAgICBkaXJlbnQubW9kZSA9IG1vZGU7XG4gICAgICAgIGRpcmVudC5wYXRoID0gbGluay5nZXRQYXJlbnRQYXRoKCk7XG4gICAgICAgIGRpcmVudC5wYXJlbnRQYXRoID0gZGlyZW50LnBhdGg7XG4gICAgICAgIHJldHVybiBkaXJlbnQ7XG4gICAgfVxuICAgIF9jaGVja01vZGVQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIFNfSUZNVCkgPT09IHByb3BlcnR5O1xuICAgIH1cbiAgICBpc0RpcmVjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZESVIpO1xuICAgIH1cbiAgICBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGUkVHKTtcbiAgICB9XG4gICAgaXNCbG9ja0RldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZCTEspO1xuICAgIH1cbiAgICBpc0NoYXJhY3RlckRldmljZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZDSFIpO1xuICAgIH1cbiAgICBpc1N5bWJvbGljTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZMTkspO1xuICAgIH1cbiAgICBpc0ZJRk8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGSUZPKTtcbiAgICB9XG4gICAgaXNTb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGU09DSyk7XG4gICAgfVxufVxuZXhwb3J0cy5EaXJlbnQgPSBEaXJlbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBEaXJlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXJlbnQuanMubWFwIiwiLy8gJ3BhdGgnIG1vZHVsZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEgKG9ubHkgdGhlIHBvc2l4IHBhcnQpXG4vLyB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAnICsgSlNPTi5zdHJpbmdpZnkocGF0aCkpO1xuICB9XG59XG5cbi8vIFJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCB3aXRoIGRpcmVjdG9yeSBuYW1lc1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nUG9zaXgocGF0aCwgYWxsb3dBYm92ZVJvb3QpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICB2YXIgbGFzdFNsYXNoID0gLTE7XG4gIHZhciBkb3RzID0gMDtcbiAgdmFyIGNvZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA8IHBhdGgubGVuZ3RoKVxuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBlbHNlIGlmIChjb2RlID09PSA0NyAvKi8qLylcbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGNvZGUgPSA0NyAvKi8qLztcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgIGlmIChsYXN0U2xhc2ggPT09IGkgLSAxIHx8IGRvdHMgPT09IDEpIHtcbiAgICAgICAgLy8gTk9PUFxuICAgICAgfSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGkgLSAxICYmIGRvdHMgPT09IDIpIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPCAyIHx8IGxhc3RTZWdtZW50TGVuZ3RoICE9PSAyIHx8IHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAxKSAhPT0gNDYgLyouKi8gfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDIpICE9PSA0NiAvKi4qLykge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGxhc3RTbGFzaEluZGV4ID0gcmVzLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggIT09IHJlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IHJlcy5sZW5ndGggLSAxIC0gcmVzLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA9PT0gMiB8fCByZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXMgPSAnJztcbiAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXMgKz0gJy8uLic7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzID0gJy4uJztcbiAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICByZXMgKz0gJy8nICsgcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJlcyA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICB9XG4gICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgZG90cyA9IDA7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSA0NiAvKi4qLyAmJiBkb3RzICE9PSAtMSkge1xuICAgICAgKytkb3RzO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb3RzID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIF9mb3JtYXQoc2VwLCBwYXRoT2JqZWN0KSB7XG4gIHZhciBkaXIgPSBwYXRoT2JqZWN0LmRpciB8fCBwYXRoT2JqZWN0LnJvb3Q7XG4gIHZhciBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8IChwYXRoT2JqZWN0Lm5hbWUgfHwgJycpICsgKHBhdGhPYmplY3QuZXh0IHx8ICcnKTtcbiAgaWYgKCFkaXIpIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBpZiAoZGlyID09PSBwYXRoT2JqZWN0LnJvb3QpIHtcbiAgICByZXR1cm4gZGlyICsgYmFzZTtcbiAgfVxuICByZXR1cm4gZGlyICsgc2VwICsgYmFzZTtcbn1cblxudmFyIHBvc2l4ID0ge1xuICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnO1xuICAgIHZhciByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG4gICAgdmFyIGN3ZDtcblxuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIGlmIChpID49IDApXG4gICAgICAgIHBhdGggPSBhcmd1bWVudHNbaV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGN3ZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGN3ZCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICAgIHBhdGggPSBjd2Q7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICAgIC8vIFNraXAgZW1wdHkgZW50cmllc1xuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAgIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplU3RyaW5nUG9zaXgocmVzb2x2ZWRQYXRoLCAhcmVzb2x2ZWRBYnNvbHV0ZSk7XG5cbiAgICBpZiAocmVzb2x2ZWRBYnNvbHV0ZSkge1xuICAgICAgaWYgKHJlc29sdmVkUGF0aC5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gJy8nO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiByZXNvbHZlZFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnLic7XG4gICAgfVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuXG4gICAgdmFyIGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qLyovO1xuICAgIHZhciB0cmFpbGluZ1NlcGFyYXRvciA9IHBhdGguY2hhckNvZGVBdChwYXRoLmxlbmd0aCAtIDEpID09PSA0NyAvKi8qLztcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCAhaXNBYnNvbHV0ZSk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgJiYgIWlzQWJzb2x1dGUpIHBhdGggPSAnLic7XG4gICAgaWYgKHBhdGgubGVuZ3RoID4gMCAmJiB0cmFpbGluZ1NlcGFyYXRvcikgcGF0aCArPSAnLyc7XG5cbiAgICBpZiAoaXNBYnNvbHV0ZSkgcmV0dXJuICcvJyArIHBhdGg7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gIH0sXG5cbiAgam9pbjogZnVuY3Rpb24gam9pbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiAnLic7XG4gICAgdmFyIGpvaW5lZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGFzc2VydFBhdGgoYXJnKTtcbiAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgam9pbmVkID0gYXJnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgam9pbmVkICs9ICcvJyArIGFyZztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuICcuJztcbiAgICByZXR1cm4gcG9zaXgubm9ybWFsaXplKGpvaW5lZCk7XG4gIH0sXG5cbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgYXNzZXJ0UGF0aChmcm9tKTtcbiAgICBhc3NlcnRQYXRoKHRvKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuICcnO1xuXG4gICAgZnJvbSA9IHBvc2l4LnJlc29sdmUoZnJvbSk7XG4gICAgdG8gPSBwb3NpeC5yZXNvbHZlKHRvKTtcblxuICAgIGlmIChmcm9tID09PSB0bykgcmV0dXJuICcnO1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciBmcm9tU3RhcnQgPSAxO1xuICAgIGZvciAoOyBmcm9tU3RhcnQgPCBmcm9tLmxlbmd0aDsgKytmcm9tU3RhcnQpIHtcbiAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgIHZhciBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcblxuICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICB2YXIgdG9TdGFydCA9IDE7XG4gICAgZm9yICg7IHRvU3RhcnQgPCB0by5sZW5ndGg7ICsrdG9TdGFydCkge1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgIT09IDQ3IC8qLyovKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHRvRW5kID0gdG8ubGVuZ3RoO1xuICAgIHZhciB0b0xlbiA9IHRvRW5kIC0gdG9TdGFydDtcblxuICAgIC8vIENvbXBhcmUgcGF0aHMgdG8gZmluZCB0aGUgbG9uZ2VzdCBjb21tb24gcGF0aCBmcm9tIHJvb3RcbiAgICB2YXIgbGVuZ3RoID0gZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuO1xuICAgIHZhciBsYXN0Q29tbW9uU2VwID0gLTE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDw9IGxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xuICAgICAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgdG9gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy9mb28vYmFyL2JheidcbiAgICAgICAgICAgIHJldHVybiB0by5zbGljZSh0b1N0YXJ0ICsgaSArIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSByb290XG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbUxlbiA+IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhci9iYXonOyB0bz0nL2Zvby9iYXInXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIHJvb3QuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvbyc7IHRvPScvJ1xuICAgICAgICAgICAgbGFzdENvbW1vblNlcCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmFyIGZyb21Db2RlID0gZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpO1xuICAgICAgdmFyIHRvQ29kZSA9IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpO1xuICAgICAgaWYgKGZyb21Db2RlICE9PSB0b0NvZGUpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZWxzZSBpZiAoZnJvbUNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgLy8gR2VuZXJhdGUgdGhlIHJlbGF0aXZlIHBhdGggYmFzZWQgb24gdGhlIHBhdGggZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b2BcbiAgICAvLyBhbmQgYGZyb21gXG4gICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gZnJvbUVuZCB8fCBmcm9tLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgIG91dCArPSAnLi4nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgb3V0ICs9ICcvLi4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyXG4gICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzXG4gICAgaWYgKG91dC5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIG91dCArIHRvLnNsaWNlKHRvU3RhcnQgKyBsYXN0Q29tbW9uU2VwKTtcbiAgICBlbHNlIHtcbiAgICAgIHRvU3RhcnQgKz0gbGFzdENvbW1vblNlcDtcbiAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSA0NyAvKi8qLylcbiAgICAgICAgKyt0b1N0YXJ0O1xuICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQpO1xuICAgIH1cbiAgfSxcblxuICBfbWFrZUxvbmc6IGZ1bmN0aW9uIF9tYWtlTG9uZyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH0sXG5cbiAgZGlybmFtZTogZnVuY3Rpb24gZGlybmFtZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkgcmV0dXJuICcvLyc7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbiAgfSxcblxuICBiYXNlbmFtZTogZnVuY3Rpb24gYmFzZW5hbWUocGF0aCwgZXh0KSB7XG4gICAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBleHQgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuXG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKGV4dC5sZW5ndGggPT09IHBhdGgubGVuZ3RoICYmIGV4dCA9PT0gcGF0aCkgcmV0dXJuICcnO1xuICAgICAgdmFyIGV4dElkeCA9IGV4dC5sZW5ndGggLSAxO1xuICAgICAgdmFyIGZpcnN0Tm9uU2xhc2hFbmQgPSAtMTtcbiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb25cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgIGlmICgtLWV4dElkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgZXh0SWR4ID0gLTE7XG4gICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO2Vsc2UgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IHBhdGgubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgZXh0bmFtZTogZnVuY3Rpb24gZXh0bmFtZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcbiAgICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gIH0sXG5cbiAgZm9ybWF0OiBmdW5jdGlvbiBmb3JtYXQocGF0aE9iamVjdCkge1xuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBwYXRoT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIF9mb3JtYXQoJy8nLCBwYXRoT2JqZWN0KTtcbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgcmV0ID0geyByb290OiAnJywgZGlyOiAnJywgYmFzZTogJycsIGV4dDogJycsIG5hbWU6ICcnIH07XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gcmV0O1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBpc0Fic29sdXRlID0gY29kZSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHN0YXJ0O1xuICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICByZXQucm9vdCA9ICcvJztcbiAgICAgIHN0YXJ0ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgICB2YXIgZW5kID0gLTE7XG4gICAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7XG5cbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuXG4gICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xuICAgIGZvciAoOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSkgc3RhcnREb3QgPSBpO2Vsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKSBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHN0YXJ0UGFydCA9PT0gMCAmJiBpc0Fic29sdXRlKSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZSgxLCBlbmQpO2Vsc2UgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHtcbiAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKDEsIGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBzdGFydERvdCk7XG4gICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICByZXQuZXh0ID0gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRQYXJ0ID4gMCkgcmV0LmRpciA9IHBhdGguc2xpY2UoMCwgc3RhcnRQYXJ0IC0gMSk7ZWxzZSBpZiAoaXNBYnNvbHV0ZSkgcmV0LmRpciA9ICcvJztcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgc2VwOiAnLycsXG4gIGRlbGltaXRlcjogJzonLFxuICB3aW4zMjogbnVsbCxcbiAgcG9zaXg6IG51bGxcbn07XG5cbnBvc2l4LnBvc2l4ID0gcG9zaXg7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIEhlcmUgd2UgbW9jayB0aGUgZ2xvYmFsIGBwcm9jZXNzYCB2YXJpYWJsZSBpbiBjYXNlIHdlIGFyZSBub3QgaW4gTm9kZSdzIGVudmlyb25tZW50LlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVQcm9jZXNzID0gY3JlYXRlUHJvY2Vzcztcbi8qKlxuICogTG9va3MgdG8gcmV0dXJuIGEgYHByb2Nlc3NgIG9iamVjdCwgaWYgb25lIGlzIGF2YWlsYWJsZS5cbiAqXG4gKiBUaGUgZ2xvYmFsIGBwcm9jZXNzYCBpcyByZXR1cm5lZCBpZiBkZWZpbmVkO1xuICogb3RoZXJ3aXNlIGByZXF1aXJlKCdwcm9jZXNzJylgIGlzIGF0dGVtcHRlZC5cbiAqXG4gKiBJZiB0aGF0IGZhaWxzLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcmV0dXJuIHtJUHJvY2VzcyB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgbWF5YmVSZXR1cm5Qcm9jZXNzID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3M7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdwcm9jZXNzJyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQcm9jZXNzKCkge1xuICAgIGNvbnN0IHAgPSBtYXliZVJldHVyblByb2Nlc3MoKSB8fCB7fTtcbiAgICBpZiAoIXAuY3dkKVxuICAgICAgICBwLmN3ZCA9ICgpID0+ICcvJztcbiAgICBpZiAoIXAuZW1pdFdhcm5pbmcpXG4gICAgICAgIHAuZW1pdFdhcm5pbmcgPSAobWVzc2FnZSwgdHlwZSkgPT4ge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHt0eXBlfSR7dHlwZSA/ICc6ICcgOiAnJ30ke21lc3NhZ2V9YCk7XG4gICAgICAgIH07XG4gICAgaWYgKCFwLmVudilcbiAgICAgICAgcC5lbnYgPSB7fTtcbiAgICByZXR1cm4gcDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVByb2Nlc3MoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb2Nlc3MuanMubWFwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlID0gZXhwb3J0cy5MaW5rID0gZXhwb3J0cy5Ob2RlID0gZXhwb3J0cy5TRVAgPSB2b2lkIDA7XG5jb25zdCBwcm9jZXNzXzEgPSByZXF1aXJlKFwiLi9wcm9jZXNzXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9idWZmZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IFN0YXRzXzEgPSByZXF1aXJlKFwiLi9TdGF0c1wiKTtcbmNvbnN0IHsgU19JRk1ULCBTX0lGRElSLCBTX0lGUkVHLCBTX0lGTE5LLCBTX0lGQ0hSLCBPX0FQUEVORCB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuY29uc3QgZ2V0dWlkID0gKCkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gcHJvY2Vzc18xLmRlZmF1bHQuZ2V0dWlkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9jZXNzXzEuZGVmYXVsdCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7IH07XG5jb25zdCBnZXRnaWQgPSAoKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBwcm9jZXNzXzEuZGVmYXVsdC5nZXRnaWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHByb2Nlc3NfMS5kZWZhdWx0KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDsgfTtcbmV4cG9ydHMuU0VQID0gJy8nO1xuLyoqXG4gKiBOb2RlIGluIGEgZmlsZSBzeXN0ZW0gKGxpa2UgaS1ub2RlLCB2LW5vZGUpLlxuICovXG5jbGFzcyBOb2RlIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm8sIG1vZGUgPSAwbzY2Nikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBVc2VyIElEIGFuZCBncm91cCBJRC5cbiAgICAgICAgdGhpcy5fdWlkID0gZ2V0dWlkKCk7XG4gICAgICAgIHRoaXMuX2dpZCA9IGdldGdpZCgpO1xuICAgICAgICB0aGlzLl9hdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuX210aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5fY3RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnJkZXYgPSAwO1xuICAgICAgICAvLyBOdW1iZXIgb2YgaGFyZCBsaW5rcyBwb2ludGluZyBhdCB0aGlzIE5vZGUuXG4gICAgICAgIHRoaXMuX25saW5rID0gMTtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5pbm8gPSBpbm87XG4gICAgfVxuICAgIHNldCBjdGltZShjdGltZSkge1xuICAgICAgICB0aGlzLl9jdGltZSA9IGN0aW1lO1xuICAgIH1cbiAgICBnZXQgY3RpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdGltZTtcbiAgICB9XG4gICAgc2V0IHVpZCh1aWQpIHtcbiAgICAgICAgdGhpcy5fdWlkID0gdWlkO1xuICAgICAgICB0aGlzLmN0aW1lID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZ2V0IHVpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpZDtcbiAgICB9XG4gICAgc2V0IGdpZChnaWQpIHtcbiAgICAgICAgdGhpcy5fZ2lkID0gZ2lkO1xuICAgICAgICB0aGlzLmN0aW1lID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZ2V0IGdpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dpZDtcbiAgICB9XG4gICAgc2V0IGF0aW1lKGF0aW1lKSB7XG4gICAgICAgIHRoaXMuX2F0aW1lID0gYXRpbWU7XG4gICAgICAgIHRoaXMuY3RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgYXRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdGltZTtcbiAgICB9XG4gICAgc2V0IG10aW1lKG10aW1lKSB7XG4gICAgICAgIHRoaXMuX210aW1lID0gbXRpbWU7XG4gICAgICAgIHRoaXMuY3RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBnZXQgbXRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdGltZTtcbiAgICB9XG4gICAgZ2V0IHBlcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgJiB+U19JRk1UO1xuICAgIH1cbiAgICBzZXQgcGVybShwZXJtKSB7XG4gICAgICAgIHRoaXMubW9kZSA9ICh0aGlzLm1vZGUgJiBTX0lGTVQpIHwgKHBlcm0gJiB+U19JRk1UKTtcbiAgICAgICAgdGhpcy5jdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIHNldCBubGluayhubGluaykge1xuICAgICAgICB0aGlzLl9ubGluayA9IG5saW5rO1xuICAgICAgICB0aGlzLmN0aW1lID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZ2V0IG5saW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmxpbms7XG4gICAgfVxuICAgIGdldFN0cmluZyhlbmNvZGluZyA9ICd1dGY4Jykge1xuICAgICAgICB0aGlzLmF0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCkudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH1cbiAgICBzZXRTdHJpbmcoc3RyKSB7XG4gICAgICAgIC8vIHRoaXMuc2V0QnVmZmVyKGJ1ZmZlckZyb20oc3RyLCAndXRmOCcpKTtcbiAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyRnJvbSkoc3RyLCAndXRmOCcpO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcigpIHtcbiAgICAgICAgdGhpcy5hdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmICghdGhpcy5idWYpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcigoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApKTtcbiAgICAgICAgcmV0dXJuICgwLCBidWZmZXJfMS5idWZmZXJGcm9tKSh0aGlzLmJ1Zik7IC8vIFJldHVybiBhIGNvcHkuXG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWYpIHtcbiAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyRnJvbSkoYnVmKTsgLy8gQ3JlYXRlcyBhIGNvcHkgb2YgZGF0YS5cbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH1cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYgPyB0aGlzLmJ1Zi5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBzZXRNb2RlUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgdGhpcy5tb2RlID0gcHJvcGVydHk7XG4gICAgfVxuICAgIGlzRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBTX0lGUkVHO1xuICAgIH1cbiAgICBpc0RpcmVjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBTX0lGRElSO1xuICAgIH1cbiAgICBpc1N5bWxpbmsoKSB7XG4gICAgICAgIC8vIHJldHVybiAhIXRoaXMuc3ltbGluaztcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBTX0lGTE5LO1xuICAgIH1cbiAgICBpc0NoYXJhY3RlckRldmljZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBTX0lGQ0hSO1xuICAgIH1cbiAgICBtYWtlU3ltbGluayhzeW1saW5rKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IFNfSUZMTksgfCAwbzY2NjtcbiAgICAgICAgdGhpcy5zeW1saW5rID0gc3ltbGluaztcbiAgICB9XG4gICAgd3JpdGUoYnVmLCBvZmYgPSAwLCBsZW4gPSBidWYubGVuZ3RoLCBwb3MgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5idWYpXG4gICAgICAgICAgICB0aGlzLmJ1ZiA9ICgwLCBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZSkoMCk7XG4gICAgICAgIGlmIChwb3MgKyBsZW4gPiB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0J1ZiA9ICgwLCBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZSkocG9zICsgbGVuKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLmNvcHkobmV3QnVmLCAwLCAwLCB0aGlzLmJ1Zi5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWYgPSBuZXdCdWY7XG4gICAgICAgIH1cbiAgICAgICAgYnVmLmNvcHkodGhpcy5idWYsIHBvcywgb2ZmLCBvZmYgKyBsZW4pO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgIHJlYWQoYnVmLCBvZmYgPSAwLCBsZW4gPSBidWYuYnl0ZUxlbmd0aCwgcG9zID0gMCkge1xuICAgICAgICB0aGlzLmF0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgIHRoaXMuYnVmID0gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckFsbG9jVW5zYWZlKSgwKTtcbiAgICAgICAgbGV0IGFjdHVhbExlbiA9IGxlbjtcbiAgICAgICAgaWYgKGFjdHVhbExlbiA+IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3R1YWxMZW4gPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0dWFsTGVuICsgcG9zID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3R1YWxMZW4gPSB0aGlzLmJ1Zi5sZW5ndGggLSBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmMiA9IGJ1ZiBpbnN0YW5jZW9mIGJ1ZmZlcl8xLkJ1ZmZlciA/IGJ1ZiA6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGJ1Zi5idWZmZXIpO1xuICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1ZjIsIG9mZiwgcG9zLCBwb3MgKyBhY3R1YWxMZW4pO1xuICAgICAgICByZXR1cm4gYWN0dWFsTGVuO1xuICAgIH1cbiAgICB0cnVuY2F0ZShsZW4gPSAwKSB7XG4gICAgICAgIGlmICghbGVuKVxuICAgICAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5idWYpXG4gICAgICAgICAgICAgICAgdGhpcy5idWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKDApO1xuICAgICAgICAgICAgaWYgKGxlbiA8PSB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZiA9IHRoaXMuYnVmLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBidWYgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKGxlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYuY29weShidWYpO1xuICAgICAgICAgICAgICAgIGJ1Zi5maWxsKDAsIHRoaXMuYnVmLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH1cbiAgICBjaG1vZChwZXJtKSB7XG4gICAgICAgIHRoaXMubW9kZSA9ICh0aGlzLm1vZGUgJiBTX0lGTVQpIHwgKHBlcm0gJiB+U19JRk1UKTtcbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH1cbiAgICBjaG93bih1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLnVpZCA9IHVpZDtcbiAgICAgICAgdGhpcy5naWQgPSBnaWQ7XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9XG4gICAgdG91Y2goKSB7XG4gICAgICAgIHRoaXMubXRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHRoaXMpO1xuICAgIH1cbiAgICBjYW5SZWFkKHVpZCA9IGdldHVpZCgpLCBnaWQgPSBnZXRnaWQoKSkge1xuICAgICAgICBpZiAodGhpcy5wZXJtICYgNCAvKiBTLklST1RIICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2lkID09PSB0aGlzLmdpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDMyIC8qIFMuSVJHUlAgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDI1NiAvKiBTLklSVVNSICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjYW5Xcml0ZSh1aWQgPSBnZXR1aWQoKSwgZ2lkID0gZ2V0Z2lkKCkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVybSAmIDIgLyogUy5JV09USCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdGhpcy5naWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAxNiAvKiBTLklXR1JQICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAxMjggLyogUy5JV1VTUiAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2FuRXhlY3V0ZSh1aWQgPSBnZXR1aWQoKSwgZ2lkID0gZ2V0Z2lkKCkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVybSAmIDEgLyogUy5JWE9USCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdGhpcy5naWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiA4IC8qIFMuSVhHUlAgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWlkID09PSB0aGlzLnVpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDY0IC8qIFMuSVhVU1IgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbCgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWxldGUnLCB0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5vOiB0aGlzLmlubyxcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgYXRpbWU6IHRoaXMuYXRpbWUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbXRpbWU6IHRoaXMubXRpbWUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgY3RpbWU6IHRoaXMuY3RpbWUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgcGVybTogdGhpcy5wZXJtLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgbmxpbms6IHRoaXMubmxpbmssXG4gICAgICAgICAgICBzeW1saW5rOiB0aGlzLnN5bWxpbmssXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmdldFN0cmluZygpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTm9kZSA9IE5vZGU7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBoYXJkIGxpbmsgdGhhdCBwb2ludHMgdG8gYW4gaS1ub2RlIGBub2RlYC5cbiAqL1xuY2xhc3MgTGluayBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcHM7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHN5bmMgY2hpbGRyZW4gc3RlcHMsIGUuZy4gaW4gY2FzZSBvZiBkaXIgcmVuYW1lXG4gICAgc2V0IHN0ZXBzKHZhbCkge1xuICAgICAgICB0aGlzLl9zdGVwcyA9IHZhbDtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGxpbmtdIG9mIHRoaXMuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09ICcuJyB8fCBjaGlsZCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluayA9PT0gbnVsbCB8fCBsaW5rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5rLnN5bmNTdGVwcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZvbCwgcGFyZW50LCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFBhdGggdG8gdGhpcyBub2RlIGFzIEFycmF5OiBbJ3VzcicsICdiaW4nLCAnbm9kZSddLlxuICAgICAgICB0aGlzLl9zdGVwcyA9IFtdO1xuICAgICAgICAvLyBcImktbm9kZVwiIG51bWJlciBvZiB0aGUgbm9kZS5cbiAgICAgICAgdGhpcy5pbm8gPSAwO1xuICAgICAgICAvLyBOdW1iZXIgb2YgY2hpbGRyZW4uXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy52b2wgPSB2b2w7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN5bmNTdGVwcygpO1xuICAgIH1cbiAgICBzZXROb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbm8gPSBub2RlLmlubztcbiAgICB9XG4gICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQobmFtZSwgbm9kZSA9IHRoaXMudm9sLmNyZWF0ZU5vZGUoU19JRlJFRyB8IDBvNjY2KSkge1xuICAgICAgICBjb25zdCBsaW5rID0gbmV3IExpbmsodGhpcy52b2wsIHRoaXMsIG5hbWUpO1xuICAgICAgICBsaW5rLnNldE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIGxpbmsuY2hpbGRyZW4uc2V0KCcuJywgbGluayk7XG4gICAgICAgICAgICBsaW5rLmdldE5vZGUoKS5ubGluaysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q2hpbGQobmFtZSwgbGluayk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH1cbiAgICBzZXRDaGlsZChuYW1lLCBsaW5rID0gbmV3IExpbmsodGhpcy52b2wsIHRoaXMsIG5hbWUpKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KG5hbWUsIGxpbmspO1xuICAgICAgICBsaW5rLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgbGluay5jaGlsZHJlbi5zZXQoJy4uJywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmdldE5vZGUoKS5ubGluaysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0Tm9kZSgpLm10aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGlsZDphZGQnLCBsaW5rLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfVxuICAgIGRlbGV0ZUNoaWxkKGxpbmspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBsaW5rLmNoaWxkcmVuLmRlbGV0ZSgnLi4nKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0Tm9kZSgpLm5saW5rLS07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5kZWxldGUobGluay5nZXROYW1lKCkpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICB0aGlzLmdldE5vZGUoKS5tdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hpbGQ6ZGVsZXRlJywgbGluaywgdGhpcyk7XG4gICAgfVxuICAgIGdldENoaWxkKG5hbWUpIHtcbiAgICAgICAgdGhpcy5nZXROb2RlKCkubXRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5nZXQobmFtZSk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmpvaW4oZXhwb3J0cy5TRVApO1xuICAgIH1cbiAgICBnZXRQYXJlbnRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy5zbGljZSgwLCAtMSkuam9pbihleHBvcnRzLlNFUCk7XG4gICAgfVxuICAgIGdldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzW3RoaXMuc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIC8vIGRlbCgpIHtcbiAgICAvLyAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgLy8gICAgIGlmKHBhcmVudCkge1xuICAgIC8vICAgICAgICAgcGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAvLyAgICAgdGhpcy52b2wgPSBudWxsO1xuICAgIC8vIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwczogdGhpcy5zdGVwcyxcbiAgICAgICAgICAgIGlubzogdGhpcy5pbm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSh0aGlzLmNoaWxkcmVuLmtleXMoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN5bmNTdGVwcygpIHtcbiAgICAgICAgdGhpcy5zdGVwcyA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuc3RlcHMuY29uY2F0KFt0aGlzLm5hbWVdKSA6IFt0aGlzLm5hbWVdO1xuICAgIH1cbn1cbmV4cG9ydHMuTGluayA9IExpbms7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb3BlbiBmaWxlIChmaWxlIGRlc2NyaXB0b3IpIHRoYXQgcG9pbnRzIHRvIGEgYExpbmtgIChIYXJkLWxpbmspIGFuZCBhIGBOb2RlYC5cbiAqL1xuY2xhc3MgRmlsZSB7XG4gICAgLyoqXG4gICAgICogT3BlbiBhIExpbmstTm9kZSBwYWlyLiBgbm9kZWAgaXMgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyB0aGF0IG1pZ2h0IGJlIGEgZGlmZmVyZW50IG5vZGVcbiAgICAgKiByYXRoZXIgdGhlIG9uZSBgbGlua2AgcG9pbnRzIHRvLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGEgc3ltbGluay5cbiAgICAgKiBAcGFyYW0gbGlua1xuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICogQHBhcmFtIGZsYWdzXG4gICAgICogQHBhcmFtIGZkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobGluaywgbm9kZSwgZmxhZ3MsIGZkKSB7XG4gICAgICAgIHRoaXMubGluayA9IGxpbms7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5mZCA9IGZkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiBPX0FQUEVORClcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmdldFNpemUoKTtcbiAgICB9XG4gICAgZ2V0U3RyaW5nKGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0U3RyaW5nKCk7XG4gICAgfVxuICAgIHNldFN0cmluZyhzdHIpIHtcbiAgICAgICAgdGhpcy5ub2RlLnNldFN0cmluZyhzdHIpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0QnVmZmVyKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWYpIHtcbiAgICAgICAgdGhpcy5ub2RlLnNldEJ1ZmZlcihidWYpO1xuICAgIH1cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFNpemUoKTtcbiAgICB9XG4gICAgdHJ1bmNhdGUobGVuKSB7XG4gICAgICAgIHRoaXMubm9kZS50cnVuY2F0ZShsZW4pO1xuICAgIH1cbiAgICBzZWVrVG8ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRzXzEuZGVmYXVsdC5idWlsZCh0aGlzLm5vZGUpO1xuICAgIH1cbiAgICB3cml0ZShidWYsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1Zi5sZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInKVxuICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMubm9kZS53cml0ZShidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiArIGJ5dGVzO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIHJlYWQoYnVmLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWYuYnl0ZUxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5ub2RlLnJlYWQoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gKyBieXRlcztcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBjaG1vZChwZXJtKSB7XG4gICAgICAgIHRoaXMubm9kZS5jaG1vZChwZXJtKTtcbiAgICB9XG4gICAgY2hvd24odWlkLCBnaWQpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNob3duKHVpZCwgZ2lkKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGUgPSBGaWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJyA/IHF1ZXVlTWljcm90YXNrIDogKGNiID0+IFByb21pc2UucmVzb2x2ZSgpXG4gICAgLnRoZW4oKCkgPT4gY2IoKSlcbiAgICAuY2F0Y2goKCkgPT4geyB9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZU1pY3JvdGFzay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogYHNldFRpbWVvdXRVbnJlZmAgaXMganVzdCBsaWtlIGBzZXRUaW1lb3V0YCxcbiAqIG9ubHkgaW4gTm9kZSdzIGVudmlyb25tZW50IGl0IHdpbGwgXCJ1bnJlZlwiIGl0cyBtYWNybyB0YXNrLlxuICovXG5mdW5jdGlvbiBzZXRUaW1lb3V0VW5yZWYoY2FsbGJhY2ssIHRpbWUsIGFyZ3MpIHtcbiAgICBjb25zdCByZWYgPSBzZXRUaW1lb3V0LmFwcGx5KHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlZiAmJiB0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVmLnVucmVmID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZWYudW5yZWYoKTtcbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc2V0VGltZW91dFVucmVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0VGltZW91dFVucmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0J1xuXG4vKlxuICBUaGlzIGZpbGUgaXMgYSByZWR1Y2VkIGFuZCBhZGFwdGVkIHZlcnNpb24gb2YgdGhlIG1haW4gbGliL2ludGVybmFsL3Blcl9jb250ZXh0L3ByaW1vcmRpYWxzLmpzIGZpbGUgZGVmaW5lZCBhdFxuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL21haW4vbGliL2ludGVybmFsL3Blcl9jb250ZXh0L3ByaW1vcmRpYWxzLmpzXG5cbiAgRG9uJ3QgdHJ5IHRvIHJlcGxhY2Ugd2l0aCB0aGUgb3JpZ2luYWwgZmlsZSBhbmQga2VlcCBpdCB1cCB0byBkYXRlIHdpdGggdGhlIHVwc3RyZWFtIGZpbGUuXG4qL1xuXG4vLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIEFnZ3JlZ2F0ZUVycm9yXG5jbGFzcyBBZ2dyZWdhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVycm9ycykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHRvIGJlIGFuIEFycmF5LCBnb3QgJHt0eXBlb2YgZXJyb3JzfWApXG4gICAgfVxuICAgIGxldCBtZXNzYWdlID0gJydcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbWVzc2FnZSArPSBgICAgICR7ZXJyb3JzW2ldLnN0YWNrfVxcbmBcbiAgICB9XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQWdncmVnYXRlRXJyb3InXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFnZ3JlZ2F0ZUVycm9yLFxuICBBcnJheUlzQXJyYXkoc2VsZikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNlbGYpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlSW5jbHVkZXMoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5pbmNsdWRlcyhlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVJbmRleE9mKHNlbGYsIGVsKSB7XG4gICAgcmV0dXJuIHNlbGYuaW5kZXhPZihlbClcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVKb2luKHNlbGYsIHNlcCkge1xuICAgIHJldHVybiBzZWxmLmpvaW4oc2VwKVxuICB9LFxuICBBcnJheVByb3RvdHlwZU1hcChzZWxmLCBmbikge1xuICAgIHJldHVybiBzZWxmLm1hcChmbilcbiAgfSxcbiAgQXJyYXlQcm90b3R5cGVQb3Aoc2VsZiwgZWwpIHtcbiAgICByZXR1cm4gc2VsZi5wb3AoZWwpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlUHVzaChzZWxmLCBlbCkge1xuICAgIHJldHVybiBzZWxmLnB1c2goZWwpXG4gIH0sXG4gIEFycmF5UHJvdG90eXBlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzZWxmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH0sXG4gIEVycm9yLFxuICBGdW5jdGlvblByb3RvdHlwZUNhbGwoZm4sIHRoaXNBcmdzLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpc0FyZ3MsIC4uLmFyZ3MpXG4gIH0sXG4gIEZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2Uoc2VsZiwgaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0uY2FsbChzZWxmLCBpbnN0YW5jZSlcbiAgfSxcbiAgTWF0aEZsb29yOiBNYXRoLmZsb29yLFxuICBOdW1iZXIsXG4gIE51bWJlcklzSW50ZWdlcjogTnVtYmVyLmlzSW50ZWdlcixcbiAgTnVtYmVySXNOYU46IE51bWJlci5pc05hTixcbiAgTnVtYmVyTUFYX1NBRkVfSU5URUdFUjogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gIE51bWJlck1JTl9TQUZFX0lOVEVHRVI6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJQYXJzZUludDogTnVtYmVyLnBhcnNlSW50LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHByb3BzKVxuICB9LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShzZWxmLCBuYW1lLCBwcm9wKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBuYW1lLCBwcm9wKVxuICB9LFxuICBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZiwgbmFtZSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNlbGYsIG5hbWUpXG4gIH0sXG4gIE9iamVjdEtleXMob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgfSxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbiAgfSxcbiAgUHJvbWlzZSxcbiAgUHJvbWlzZVByb3RvdHlwZUNhdGNoKHNlbGYsIGZuKSB7XG4gICAgcmV0dXJuIHNlbGYuY2F0Y2goZm4pXG4gIH0sXG4gIFByb21pc2VQcm90b3R5cGVUaGVuKHNlbGYsIHRoZW5GbiwgY2F0Y2hGbikge1xuICAgIHJldHVybiBzZWxmLnRoZW4odGhlbkZuLCBjYXRjaEZuKVxuICB9LFxuICBQcm9taXNlUmVqZWN0KGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpXG4gIH0sXG4gIFByb21pc2VSZXNvbHZlKHZhbCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsKVxuICB9LFxuICBSZWZsZWN0QXBwbHk6IFJlZmxlY3QuYXBwbHksXG4gIFJlZ0V4cFByb3RvdHlwZVRlc3Qoc2VsZiwgdmFsdWUpIHtcbiAgICByZXR1cm4gc2VsZi50ZXN0KHZhbHVlKVxuICB9LFxuICBTYWZlU2V0OiBTZXQsXG4gIFN0cmluZyxcbiAgU3RyaW5nUHJvdG90eXBlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBzZWxmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi50b0xvd2VyQ2FzZSgpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRvVXBwZXJDYXNlKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZi50b1VwcGVyQ2FzZSgpXG4gIH0sXG4gIFN0cmluZ1Byb3RvdHlwZVRyaW0oc2VsZikge1xuICAgIHJldHVybiBzZWxmLnRyaW0oKVxuICB9LFxuICBTeW1ib2wsXG4gIFN5bWJvbEZvcjogU3ltYm9sLmZvcixcbiAgU3ltYm9sQXN5bmNJdGVyYXRvcjogU3ltYm9sLmFzeW5jSXRlcmF0b3IsXG4gIFN5bWJvbEhhc0luc3RhbmNlOiBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gIFN5bWJvbEl0ZXJhdG9yOiBTeW1ib2wuaXRlcmF0b3IsXG4gIFN5bWJvbERpc3Bvc2U6IFN5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbCgnU3ltYm9sLmRpc3Bvc2UnKSxcbiAgU3ltYm9sQXN5bmNEaXNwb3NlOiBTeW1ib2wuYXN5bmNEaXNwb3NlIHx8IFN5bWJvbCgnU3ltYm9sLmFzeW5jRGlzcG9zZScpLFxuICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHNlbGYsIGJ1ZiwgbGVuKSB7XG4gICAgcmV0dXJuIHNlbGYuc2V0KGJ1ZiwgbGVuKVxuICB9LFxuICBCb29sZWFuLFxuICBVaW50OEFycmF5XG59XG4iLCIndXNlIHN0cmljdCdcblxuLypcbiAgVGhpcyBmaWxlIGlzIGEgcmVkdWNlZCBhbmQgYWRhcHRlZCB2ZXJzaW9uIG9mIHRoZSBtYWluIGxpYi9pbnRlcm5hbC91dGlsL2luc3BlY3QuanMgZmlsZSBkZWZpbmVkIGF0XG5cbiAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvaW50ZXJuYWwvdXRpbC9pbnNwZWN0LmpzXG5cbiAgRG9uJ3QgdHJ5IHRvIHJlcGxhY2Ugd2l0aCB0aGUgb3JpZ2luYWwgZmlsZSBhbmQga2VlcCBpdCB1cCB0byBkYXRlIHdpdGggdGhlIHVwc3RyZWFtIGZpbGUuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZvcm1hdChmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgICAvLyBTaW1wbGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS91dGlsLmh0bWwjdXRpbGZvcm1hdGZvcm1hdC1hcmdzXG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lKFtzZGlmal0pL2csIGZ1bmN0aW9uICguLi5bX3VudXNlZCwgdHlwZV0pIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gYXJncy5zaGlmdCgpXG4gICAgICBpZiAodHlwZSA9PT0gJ2YnKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudC50b0ZpeGVkKDYpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdqJykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVwbGFjZW1lbnQpXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzJyAmJiB0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGN0b3IgPSByZXBsYWNlbWVudC5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0ID8gcmVwbGFjZW1lbnQuY29uc3RydWN0b3IubmFtZSA6ICcnXG4gICAgICAgIHJldHVybiBgJHtjdG9yfSB7fWAudHJpbSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGluc3BlY3QodmFsdWUpIHtcbiAgICAvLyBWYXN0bHkgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdXRpbC5odG1sI3V0aWxpbnNwZWN0b2JqZWN0LW9wdGlvbnNcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiJ1wiKSkge1xuICAgICAgICAgIGlmICghdmFsdWUuaW5jbHVkZXMoJ1wiJykpIHtcbiAgICAgICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYFxuICAgICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlLmluY2x1ZGVzKCdgJykgJiYgIXZhbHVlLmluY2x1ZGVzKCckeycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxcYCR7dmFsdWV9XFxgYFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSdgXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdOYU4nXG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgcmV0dXJuIGAke1N0cmluZyh2YWx1ZSl9bmBcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAne30nXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBmb3JtYXQsIGluc3BlY3QgfSA9IHJlcXVpcmUoJy4vdXRpbC9pbnNwZWN0JylcbmNvbnN0IHsgQWdncmVnYXRlRXJyb3I6IEN1c3RvbUFnZ3JlZ2F0ZUVycm9yIH0gPSByZXF1aXJlKCcuL3ByaW1vcmRpYWxzJylcblxuLypcbiAgVGhpcyBmaWxlIGlzIGEgcmVkdWNlZCBhbmQgYWRhcHRlZCB2ZXJzaW9uIG9mIHRoZSBtYWluIGxpYi9pbnRlcm5hbC9lcnJvcnMuanMgZmlsZSBkZWZpbmVkIGF0XG5cbiAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cbiAgRG9uJ3QgdHJ5IHRvIHJlcGxhY2Ugd2l0aCB0aGUgb3JpZ2luYWwgZmlsZSBhbmQga2VlcCBpdCB1cCB0byBkYXRlIChzdGFydGluZyBmcm9tIEUoLi4uKSBkZWZpbml0aW9ucylcbiAgd2l0aCB0aGUgdXBzdHJlYW0gZmlsZS5cbiovXG5cbmNvbnN0IEFnZ3JlZ2F0ZUVycm9yID0gZ2xvYmFsVGhpcy5BZ2dyZWdhdGVFcnJvciB8fCBDdXN0b21BZ2dyZWdhdGVFcnJvclxuY29uc3Qga0lzTm9kZUVycm9yID0gU3ltYm9sKCdrSXNOb2RlRXJyb3InKVxuY29uc3Qga1R5cGVzID0gW1xuICAnc3RyaW5nJyxcbiAgJ2Z1bmN0aW9uJyxcbiAgJ251bWJlcicsXG4gICdvYmplY3QnLFxuICAvLyBBY2NlcHQgJ0Z1bmN0aW9uJyBhbmQgJ09iamVjdCcgYXMgYWx0ZXJuYXRpdmUgdG8gdGhlIGxvd2VyIGNhc2VkIHZlcnNpb24uXG4gICdGdW5jdGlvbicsXG4gICdPYmplY3QnLFxuICAnYm9vbGVhbicsXG4gICdiaWdpbnQnLFxuICAnc3ltYm9sJ1xuXVxuY29uc3QgY2xhc3NSZWdFeHAgPSAvXihbQS1aXVthLXowLTldKikrJC9cbmNvbnN0IG5vZGVJbnRlcm5hbFByZWZpeCA9ICdfX25vZGVfaW50ZXJuYWxfJ1xuY29uc3QgY29kZXMgPSB7fVxuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgY29kZXMuRVJSX0lOVEVSTkFMX0FTU0VSVElPTihtZXNzYWdlKVxuICB9XG59XG5cbi8vIE9ubHkgdXNlIHRoaXMgZm9yIGludGVnZXJzISBEZWNpbWFsIG51bWJlcnMgZG8gbm90IHdvcmsgd2l0aCB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoa2V5LCBtc2csIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NlcnQoXG4gICAgICBtc2cubGVuZ3RoIDw9IGFyZ3MubGVuZ3RoLFxuICAgICAgLy8gRGVmYXVsdCBvcHRpb25zIGRvIG5vdCBjb3VudC5cbiAgICAgIGBDb2RlOiAke2tleX07IFRoZSBwcm92aWRlZCBhcmd1bWVudHMgbGVuZ3RoICgke2FyZ3MubGVuZ3RofSkgZG9lcyBub3QgbWF0Y2ggdGhlIHJlcXVpcmVkIG9uZXMgKCR7bXNnLmxlbmd0aH0pLmBcbiAgICApXG4gICAgcmV0dXJuIG1zZyguLi5hcmdzKVxuICB9XG4gIGNvbnN0IGV4cGVjdGVkTGVuZ3RoID0gKG1zZy5tYXRjaCgvJVtkZmlqb09zXS9nKSB8fCBbXSkubGVuZ3RoXG4gIGFzc2VydChcbiAgICBleHBlY3RlZExlbmd0aCA9PT0gYXJncy5sZW5ndGgsXG4gICAgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHtleHBlY3RlZExlbmd0aH0pLmBcbiAgKVxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbXNnXG4gIH1cbiAgcmV0dXJuIGZvcm1hdChtc2csIC4uLmFyZ3MpXG59XG5mdW5jdGlvbiBFKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yXG4gIH1cbiAgY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoZ2V0TWVzc2FnZShjb2RlLCBtZXNzYWdlLCBhcmdzKSlcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtjb2RlfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTm9kZUVycm9yLnByb3RvdHlwZSwge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbHVlOiBCYXNlLm5hbWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICB0b1N0cmluZzoge1xuICAgICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2NvZGV9XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pXG4gIE5vZGVFcnJvci5wcm90b3R5cGUuY29kZSA9IGNvZGVcbiAgTm9kZUVycm9yLnByb3RvdHlwZVtrSXNOb2RlRXJyb3JdID0gdHJ1ZVxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvclxufVxuZnVuY3Rpb24gaGlkZVN0YWNrRnJhbWVzKGZuKSB7XG4gIC8vIFdlIHJlbmFtZSB0aGUgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBoaWRkZW4gdG8gY3V0IG9mZiB0aGUgc3RhY2t0cmFjZVxuICAvLyBhdCB0aGUgb3V0ZXJtb3N0IG9uZVxuICBjb25zdCBoaWRkZW4gPSBub2RlSW50ZXJuYWxQcmVmaXggKyBmbi5uYW1lXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgdmFsdWU6IGhpZGRlblxuICB9KVxuICByZXR1cm4gZm5cbn1cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVR3b0Vycm9ycyhpbm5lckVycm9yLCBvdXRlckVycm9yKSB7XG4gIGlmIChpbm5lckVycm9yICYmIG91dGVyRXJyb3IgJiYgaW5uZXJFcnJvciAhPT0gb3V0ZXJFcnJvcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG91dGVyRXJyb3IuZXJyb3JzKSkge1xuICAgICAgLy8gSWYgYG91dGVyRXJyb3JgIGlzIGFscmVhZHkgYW4gYEFnZ3JlZ2F0ZUVycm9yYC5cbiAgICAgIG91dGVyRXJyb3IuZXJyb3JzLnB1c2goaW5uZXJFcnJvcilcbiAgICAgIHJldHVybiBvdXRlckVycm9yXG4gICAgfVxuICAgIGNvbnN0IGVyciA9IG5ldyBBZ2dyZWdhdGVFcnJvcihbb3V0ZXJFcnJvciwgaW5uZXJFcnJvcl0sIG91dGVyRXJyb3IubWVzc2FnZSlcbiAgICBlcnIuY29kZSA9IG91dGVyRXJyb3IuY29kZVxuICAgIHJldHVybiBlcnJcbiAgfVxuICByZXR1cm4gaW5uZXJFcnJvciB8fCBvdXRlckVycm9yXG59XG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSgnb3B0aW9ucycsICdPYmplY3QnLCBvcHRpb25zKVxuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKVxuICAgIHRoaXMuY29kZSA9ICdBQk9SVF9FUlInXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gIH1cbn1cbkUoJ0VSUl9BU1NFUlRJT04nLCAnJXMnLCBFcnJvcilcbkUoXG4gICdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSA9PiB7XG4gICAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKVxuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgIGV4cGVjdGVkID0gW2V4cGVjdGVkXVxuICAgIH1cbiAgICBsZXQgbXNnID0gJ1RoZSAnXG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJyBhcmd1bWVudCcpKSB7XG4gICAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgICBtc2cgKz0gYCR7bmFtZX0gYFxuICAgIH0gZWxzZSB7XG4gICAgICBtc2cgKz0gYFwiJHtuYW1lfVwiICR7bmFtZS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCd9IGBcbiAgICB9XG4gICAgbXNnICs9ICdtdXN0IGJlICdcbiAgICBjb25zdCB0eXBlcyA9IFtdXG4gICAgY29uc3QgaW5zdGFuY2VzID0gW11cbiAgICBjb25zdCBvdGhlciA9IFtdXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBleHBlY3RlZCkge1xuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdBbGwgZXhwZWN0ZWQgZW50cmllcyBoYXZlIHRvIGJlIG9mIHR5cGUgc3RyaW5nJylcbiAgICAgIGlmIChrVHlwZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHR5cGVzLnB1c2godmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIH0gZWxzZSBpZiAoY2xhc3NSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc3NlcnQodmFsdWUgIT09ICdvYmplY3QnLCAnVGhlIHZhbHVlIFwib2JqZWN0XCIgc2hvdWxkIGJlIHdyaXR0ZW4gYXMgXCJPYmplY3RcIicpXG4gICAgICAgIG90aGVyLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBoYW5kbGUgYG9iamVjdGAgaW4gY2FzZSBvdGhlciBpbnN0YW5jZXMgYXJlIGFsbG93ZWQgdG8gb3V0bGluZVxuICAgIC8vIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGVhY2ggb3RoZXIuXG4gICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwb3MgPSB0eXBlcy5pbmRleE9mKCdvYmplY3QnKVxuICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgdHlwZXMuc3BsaWNlKHR5cGVzLCBwb3MsIDEpXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKCdPYmplY3QnKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3dpdGNoICh0eXBlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1zZyArPSBgb2YgdHlwZSAke3R5cGVzWzBdfWBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbXNnICs9IGBvbmUgb2YgdHlwZSAke3R5cGVzWzBdfSBvciAke3R5cGVzWzFdfWBcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgbGFzdCA9IHR5cGVzLnBvcCgpXG4gICAgICAgICAgbXNnICs9IGBvbmUgb2YgdHlwZSAke3R5cGVzLmpvaW4oJywgJyl9LCBvciAke2xhc3R9YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA+IDAgfHwgb3RoZXIubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gJyBvciAnXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3dpdGNoIChpbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtc2cgKz0gYGFuIGluc3RhbmNlIG9mICR7aW5zdGFuY2VzWzBdfWBcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbXNnICs9IGBhbiBpbnN0YW5jZSBvZiAke2luc3RhbmNlc1swXX0gb3IgJHtpbnN0YW5jZXNbMV19YFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gaW5zdGFuY2VzLnBvcCgpXG4gICAgICAgICAgbXNnICs9IGBhbiBpbnN0YW5jZSBvZiAke2luc3RhbmNlcy5qb2luKCcsICcpfSwgb3IgJHtsYXN0fWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG90aGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXNnICs9ICcgb3IgJ1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKG90aGVyLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAob3RoZXJbMF0udG9Mb3dlckNhc2UoKSAhPT0gb3RoZXJbMF0pIHtcbiAgICAgICAgICBtc2cgKz0gJ2FuICdcbiAgICAgICAgfVxuICAgICAgICBtc2cgKz0gYCR7b3RoZXJbMF19YFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtc2cgKz0gYG9uZSBvZiAke290aGVyWzBdfSBvciAke290aGVyWzFdfWBcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgbGFzdCA9IG90aGVyLnBvcCgpXG4gICAgICAgIG1zZyArPSBgb25lIG9mICR7b3RoZXIuam9pbignLCAnKX0sIG9yICR7bGFzdH1gXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhY3R1YWwgPT0gbnVsbCkge1xuICAgICAgbXNnICs9IGAuIFJlY2VpdmVkICR7YWN0dWFsfWBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICdmdW5jdGlvbicgJiYgYWN0dWFsLm5hbWUpIHtcbiAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCBmdW5jdGlvbiAke2FjdHVhbC5uYW1lfWBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgX2FjdHVhbCRjb25zdHJ1Y3RvclxuICAgICAgaWYgKFxuICAgICAgICAoX2FjdHVhbCRjb25zdHJ1Y3RvciA9IGFjdHVhbC5jb25zdHJ1Y3RvcikgIT09IG51bGwgJiZcbiAgICAgICAgX2FjdHVhbCRjb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIF9hY3R1YWwkY29uc3RydWN0b3IubmFtZVxuICAgICAgKSB7XG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCBhbiBpbnN0YW5jZSBvZiAke2FjdHVhbC5jb25zdHJ1Y3Rvci5uYW1lfWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3BlY3RlZCA9IGluc3BlY3QoYWN0dWFsLCB7XG4gICAgICAgICAgZGVwdGg6IC0xXG4gICAgICAgIH0pXG4gICAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCAke2luc3BlY3RlZH1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpbnNwZWN0ZWQgPSBpbnNwZWN0KGFjdHVhbCwge1xuICAgICAgICBjb2xvcnM6IGZhbHNlXG4gICAgICB9KVxuICAgICAgaWYgKGluc3BlY3RlZC5sZW5ndGggPiAyNSkge1xuICAgICAgICBpbnNwZWN0ZWQgPSBgJHtpbnNwZWN0ZWQuc2xpY2UoMCwgMjUpfS4uLmBcbiAgICAgIH1cbiAgICAgIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH0gKCR7aW5zcGVjdGVkfSlgXG4gICAgfVxuICAgIHJldHVybiBtc2dcbiAgfSxcbiAgVHlwZUVycm9yXG4pXG5FKFxuICAnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJyxcbiAgKG5hbWUsIHZhbHVlLCByZWFzb24gPSAnaXMgaW52YWxpZCcpID0+IHtcbiAgICBsZXQgaW5zcGVjdGVkID0gaW5zcGVjdCh2YWx1ZSlcbiAgICBpZiAoaW5zcGVjdGVkLmxlbmd0aCA+IDEyOCkge1xuICAgICAgaW5zcGVjdGVkID0gaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCkgKyAnLi4uJ1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gbmFtZS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCdcbiAgICByZXR1cm4gYFRoZSAke3R5cGV9ICcke25hbWV9JyAke3JlYXNvbn0uIFJlY2VpdmVkICR7aW5zcGVjdGVkfWBcbiAgfSxcbiAgVHlwZUVycm9yXG4pXG5FKFxuICAnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJyxcbiAgKGlucHV0LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIHZhciBfdmFsdWUkY29uc3RydWN0b3JcbiAgICBjb25zdCB0eXBlID1cbiAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAoX3ZhbHVlJGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3IpICE9PSBudWxsICYmXG4gICAgICBfdmFsdWUkY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgX3ZhbHVlJGNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgPyBgaW5zdGFuY2Ugb2YgJHt2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lfWBcbiAgICAgICAgOiBgdHlwZSAke3R5cGVvZiB2YWx1ZX1gXG4gICAgcmV0dXJuIGBFeHBlY3RlZCAke2lucHV0fSB0byBiZSByZXR1cm5lZCBmcm9tIHRoZSBcIiR7bmFtZX1cImAgKyBgIGZ1bmN0aW9uIGJ1dCBnb3QgJHt0eXBlfS5gXG4gIH0sXG4gIFR5cGVFcnJvclxuKVxuRShcbiAgJ0VSUl9NSVNTSU5HX0FSR1MnLFxuICAoLi4uYXJncykgPT4ge1xuICAgIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpXG4gICAgbGV0IG1zZ1xuICAgIGNvbnN0IGxlbiA9IGFyZ3MubGVuZ3RoXG4gICAgYXJncyA9IChBcnJheS5pc0FycmF5KGFyZ3MpID8gYXJncyA6IFthcmdzXSkubWFwKChhKSA9PiBgXCIke2F9XCJgKS5qb2luKCcgb3IgJylcbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBtc2cgKz0gYFRoZSAke2FyZ3NbMF19IGFyZ3VtZW50YFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyOlxuICAgICAgICBtc2cgKz0gYFRoZSAke2FyZ3NbMF19IGFuZCAke2FyZ3NbMV19IGFyZ3VtZW50c2BcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gYXJncy5wb3AoKVxuICAgICAgICAgIG1zZyArPSBgVGhlICR7YXJncy5qb2luKCcsICcpfSwgYW5kICR7bGFzdH0gYXJndW1lbnRzYFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBgJHttc2d9IG11c3QgYmUgc3BlY2lmaWVkYFxuICB9LFxuICBUeXBlRXJyb3JcbilcbkUoXG4gICdFUlJfT1VUX09GX1JBTkdFJyxcbiAgKHN0ciwgcmFuZ2UsIGlucHV0KSA9PiB7XG4gICAgYXNzZXJ0KHJhbmdlLCAnTWlzc2luZyBcInJhbmdlXCIgYXJndW1lbnQnKVxuICAgIGxldCByZWNlaXZlZFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBjb25zdCBsaW1pdCA9IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpXG4gICAgICBpZiAoaW5wdXQgPiBsaW1pdCB8fCBpbnB1dCA8IC1saW1pdCkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlaXZlZCA9IGluc3BlY3QoaW5wdXQpXG4gICAgfVxuICAgIHJldHVybiBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgfSxcbiAgUmFuZ2VFcnJvclxuKVxuRSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycsIEVycm9yKVxuRSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCAnVGhlICVzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fQUxSRUFEWV9GSU5JU0hFRCcsICdDYW5ub3QgY2FsbCAlcyBhZnRlciBhIHN0cmVhbSB3YXMgZmluaXNoZWQnLCBFcnJvcilcbkUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCAnQ2Fubm90IGNhbGwgJXMgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCcsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcilcbkUoJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJywgJ1ByZW1hdHVyZSBjbG9zZScsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcsIEVycm9yKVxuRSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJywgRXJyb3IpXG5FKCdFUlJfVU5LTk9XTl9FTkNPRElORycsICdVbmtub3duIGVuY29kaW5nOiAlcycsIFR5cGVFcnJvcilcbm1vZHVsZS5leHBvcnRzID0ge1xuICBBYm9ydEVycm9yLFxuICBhZ2dyZWdhdGVUd29FcnJvcnM6IGhpZGVTdGFja0ZyYW1lcyhhZ2dyZWdhdGVUd29FcnJvcnMpLFxuICBoaWRlU3RhY2tGcmFtZXMsXG4gIGNvZGVzXG59XG4iLCIvKmdsb2JhbHMgc2VsZiwgd2luZG93ICovXG5cInVzZSBzdHJpY3RcIlxuXG4vKmVzbGludC1kaXNhYmxlIEBteXN0aWNhdGVhL3ByZXR0aWVyICovXG5jb25zdCB7IEFib3J0Q29udHJvbGxlciwgQWJvcnRTaWduYWwgfSA9XG4gICAgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDpcbiAgICAvKiBvdGhlcndpc2UgKi8gdW5kZWZpbmVkXG4vKmVzbGludC1lbmFibGUgQG15c3RpY2F0ZWEvcHJldHRpZXIgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBYm9ydENvbnRyb2xsZXJcbm1vZHVsZS5leHBvcnRzLkFib3J0U2lnbmFsID0gQWJvcnRTaWduYWxcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBYm9ydENvbnRyb2xsZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBidWZmZXJNb2R1bGUgPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBmb3JtYXQsIGluc3BlY3QgfSA9IHJlcXVpcmUoJy4vdXRpbC9pbnNwZWN0JylcbmNvbnN0IHtcbiAgY29kZXM6IHsgRVJSX0lOVkFMSURfQVJHX1RZUEUgfVxufSA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbmNvbnN0IHsga1Jlc2lzdFN0b3BQcm9wYWdhdGlvbiwgQWdncmVnYXRlRXJyb3IsIFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4vcHJpbW9yZGlhbHMnKVxuY29uc3QgQWJvcnRTaWduYWwgPSBnbG9iYWxUaGlzLkFib3J0U2lnbmFsIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydFNpZ25hbFxuY29uc3QgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgfHwgcmVxdWlyZSgnYWJvcnQtY29udHJvbGxlcicpLkFib3J0Q29udHJvbGxlclxuY29uc3QgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiAoKSB7fSkuY29uc3RydWN0b3JcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYnVmZmVyTW9kdWxlLkJsb2Jcbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuY29uc3QgaXNCbG9iID1cbiAgdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnXG4gICAgPyBmdW5jdGlvbiBpc0Jsb2IoYikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW5kZW50XG4gICAgICAgIHJldHVybiBiIGluc3RhbmNlb2YgQmxvYlxuICAgICAgfVxuICAgIDogZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4vKiBlc2xpbnQtZW5hYmxlIGluZGVudCAqL1xuXG5jb25zdCB2YWxpZGF0ZUFib3J0U2lnbmFsID0gKHNpZ25hbCwgbmFtZSkgPT4ge1xuICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQgJiYgKHNpZ25hbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gIH1cbn1cbmNvbnN0IHZhbGlkYXRlRnVuY3Rpb24gPSAodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnRnVuY3Rpb24nLCB2YWx1ZSlcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFnZ3JlZ2F0ZUVycm9yLFxuICBrRW1wdHlPYmplY3Q6IE9iamVjdC5mcmVlemUoe30pLFxuICBvbmNlKGNhbGxiYWNrKSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncylcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZURlZmVycmVkUHJvbWlzZTogZnVuY3Rpb24gKCkge1xuICAgIGxldCByZXNvbHZlXG4gICAgbGV0IHJlamVjdFxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2UvcGFyYW0tbmFtZXNcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICByZXNvbHZlID0gcmVzXG4gICAgICByZWplY3QgPSByZWpcbiAgICB9KVxuICAgIHJldHVybiB7XG4gICAgICBwcm9taXNlLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdFxuICAgIH1cbiAgfSxcbiAgcHJvbWlzaWZ5KGZuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZuKChlcnIsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKC4uLmFyZ3MpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIGRlYnVnbG9nKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fVxuICB9LFxuICBmb3JtYXQsXG4gIGluc3BlY3QsXG4gIHR5cGVzOiB7XG4gICAgaXNBc3luY0Z1bmN0aW9uKGZuKSB7XG4gICAgICByZXR1cm4gZm4gaW5zdGFuY2VvZiBBc3luY0Z1bmN0aW9uXG4gICAgfSxcbiAgICBpc0FycmF5QnVmZmVyVmlldyhhcnIpIHtcbiAgICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyKVxuICAgIH1cbiAgfSxcbiAgaXNCbG9iLFxuICBkZXByZWNhdGUoZm4sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZm5cbiAgfSxcbiAgYWRkQWJvcnRMaXN0ZW5lcjpcbiAgICByZXF1aXJlKCdldmVudHMnKS5hZGRBYm9ydExpc3RlbmVyIHx8XG4gICAgZnVuY3Rpb24gYWRkQWJvcnRMaXN0ZW5lcihzaWduYWwsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAoc2lnbmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdzaWduYWwnLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gICAgICB9XG4gICAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKHNpZ25hbCwgJ3NpZ25hbCcpXG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uKGxpc3RlbmVyLCAnbGlzdGVuZXInKVxuICAgICAgbGV0IHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBsaXN0ZW5lcigpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIsIHtcbiAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICBba1Jlc2lzdFN0b3BQcm9wYWdhdGlvbl06IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBbU3ltYm9sRGlzcG9zZV0oKSB7XG4gICAgICAgICAgdmFyIF9yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICAgICAgOyhfcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXIpID09PSBudWxsIHx8IF9yZW1vdmVFdmVudExpc3RlbmVyID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IF9yZW1vdmVFdmVudExpc3RlbmVyKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gIEFib3J0U2lnbmFsQW55OlxuICAgIEFib3J0U2lnbmFsLmFueSB8fFxuICAgIGZ1bmN0aW9uIEFib3J0U2lnbmFsQW55KHNpZ25hbHMpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzaWduYWwuXG4gICAgICBpZiAoc2lnbmFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25hbHNbMF1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICBjb25zdCBhYm9ydCA9ICgpID0+IGFjLmFib3J0KClcbiAgICAgIHNpZ25hbHMuZm9yRWFjaCgoc2lnbmFsKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlQWJvcnRTaWduYWwoc2lnbmFsLCAnc2lnbmFscycpXG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0LCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnYWJvcnQnLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgc2lnbmFscy5mb3JFYWNoKChzaWduYWwpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgcmV0dXJuIGFjLnNpZ25hbFxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5wcm9taXNpZnkuY3VzdG9tJylcbiIsIi8qIGVzbGludCBqc2RvYy9yZXF1aXJlLWpzZG9jOiBcImVycm9yXCIgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQXJyYXlJc0FycmF5LFxuICBBcnJheVByb3RvdHlwZUluY2x1ZGVzLFxuICBBcnJheVByb3RvdHlwZUpvaW4sXG4gIEFycmF5UHJvdG90eXBlTWFwLFxuICBOdW1iZXJJc0ludGVnZXIsXG4gIE51bWJlcklzTmFOLFxuICBOdW1iZXJNQVhfU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJNSU5fU0FGRV9JTlRFR0VSLFxuICBOdW1iZXJQYXJzZUludCxcbiAgT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHksXG4gIFJlZ0V4cFByb3RvdHlwZUV4ZWMsXG4gIFN0cmluZyxcbiAgU3RyaW5nUHJvdG90eXBlVG9VcHBlckNhc2UsXG4gIFN0cmluZ1Byb3RvdHlwZVRyaW1cbn0gPSByZXF1aXJlKCcuLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHtcbiAgaGlkZVN0YWNrRnJhbWVzLFxuICBjb2RlczogeyBFUlJfU09DS0VUX0JBRF9QT1JULCBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX0lOVkFMSURfQVJHX1ZBTFVFLCBFUlJfT1VUX09GX1JBTkdFLCBFUlJfVU5LTk9XTl9TSUdOQUwgfVxufSA9IHJlcXVpcmUoJy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgbm9ybWFsaXplRW5jb2RpbmcgfSA9IHJlcXVpcmUoJy4uL291cnMvdXRpbCcpXG5jb25zdCB7IGlzQXN5bmNGdW5jdGlvbiwgaXNBcnJheUJ1ZmZlclZpZXcgfSA9IHJlcXVpcmUoJy4uL291cnMvdXRpbCcpLnR5cGVzXG5jb25zdCBzaWduYWxzID0ge31cblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJbnQzMih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICh2YWx1ZSB8IDApXG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVWludDMyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPj4+IDBcbn1cbmNvbnN0IG9jdGFsUmVnID0gL15bMC03XSskL1xuY29uc3QgbW9kZURlc2MgPSAnbXVzdCBiZSBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIG9yIGFuIG9jdGFsIHN0cmluZydcblxuLyoqXG4gKiBQYXJzZSBhbmQgdmFsaWRhdGUgdmFsdWVzIHRoYXQgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byBtb2RlX3QgKHRoZSBTXypcbiAqIGNvbnN0YW50cykuIE9ubHkgdmFsaWQgbnVtYmVycyBhbmQgb2N0YWwgc3RyaW5ncyBhcmUgYWxsb3dlZC4gVGhleSBjb3VsZCBiZVxuICogY29udmVydGVkIHRvIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VycyBvciBub24tbmVnYXRpdmUgc2lnbmVkIGludGVnZXJzIGluIHRoZVxuICogQysrIGxhbmQsIGJ1dCBhbnkgdmFsdWUgaGlnaGVyIHRoYW4gMG83Nzcgd2lsbCByZXN1bHQgaW4gcGxhdGZvcm0tc3BlY2lmaWNcbiAqIGJlaGF2aW9ycy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWVzIHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZGVmXSBJZiBzcGVjaWZpZWQsIHdpbGwgYmUgcmV0dXJuZWQgZm9yIGludmFsaWQgdmFsdWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGVNb2RlKHZhbHVlLCBuYW1lLCBkZWYpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YWx1ZSA9IGRlZlxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKFJlZ0V4cFByb3RvdHlwZUV4ZWMob2N0YWxSZWcsIHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShuYW1lLCB2YWx1ZSwgbW9kZURlc2MpXG4gICAgfVxuICAgIHZhbHVlID0gTnVtYmVyUGFyc2VJbnQodmFsdWUsIDgpXG4gIH1cbiAgdmFsaWRhdGVVaW50MzIodmFsdWUsIG5hbWUpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUludGVnZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgbnVtYmVyfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVJbnRlZ2VyfSAqL1xuY29uc3QgdmFsaWRhdGVJbnRlZ2VyID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgbWluID0gTnVtYmVyTUlOX1NBRkVfSU5URUdFUiwgbWF4ID0gTnVtYmVyTUFYX1NBRkVfSU5URUdFUikgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgaWYgKCFOdW1iZXJJc0ludGVnZXIodmFsdWUpKSB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsIGA+PSAke21pbn0gJiYgPD0gJHttYXh9YCwgdmFsdWUpXG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUludDMyXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IFttaW5dXG4gKiBAcGFyYW0ge251bWJlcn0gW21heF1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIG51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlSW50MzJ9ICovXG5jb25zdCB2YWxpZGF0ZUludDMyID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgbWluID0gLTIxNDc0ODM2NDgsIG1heCA9IDIxNDc0ODM2NDcpID0+IHtcbiAgLy8gVGhlIGRlZmF1bHRzIGZvciBtaW4gYW5kIG1heCBjb3JyZXNwb25kIHRvIHRoZSBsaW1pdHMgb2YgMzItYml0IGludGVnZXJzLlxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbiAgaWYgKCFOdW1iZXJJc0ludGVnZXIodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UobmFtZSwgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCBgPj0gJHttaW59ICYmIDw9ICR7bWF4fWAsIHZhbHVlKVxuICB9XG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVVpbnQzMlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfGJvb2xlYW59IFtwb3NpdGl2ZT1mYWxzZV1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIG51bWJlcn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlVWludDMyfSAqL1xuY29uc3QgdmFsaWRhdGVVaW50MzIgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBwb3NpdGl2ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxuICBpZiAoIU51bWJlcklzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRVJSX09VVF9PRl9SQU5HRShuYW1lLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG4gIGNvbnN0IG1pbiA9IHBvc2l0aXZlID8gMSA6IDBcbiAgLy8gMiAqKiAzMiA9PT0gNDI5NDk2NzI5NlxuICBjb25zdCBtYXggPSA0Mjk0OTY3Mjk1XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKG5hbWUsIGA+PSAke21pbn0gJiYgPD0gJHttYXh9YCwgdmFsdWUpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgc3RyaW5nfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVTdHJpbmd9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdzdHJpbmcnLCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4XVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgbnVtYmVyfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVOdW1iZXJ9ICovXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgbmFtZSwgbWluID0gdW5kZWZpbmVkLCBtYXgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIGlmIChcbiAgICAobWluICE9IG51bGwgJiYgdmFsdWUgPCBtaW4pIHx8XG4gICAgKG1heCAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB8fFxuICAgICgobWluICE9IG51bGwgfHwgbWF4ICE9IG51bGwpICYmIE51bWJlcklzTmFOKHZhbHVlKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UoXG4gICAgICBuYW1lLFxuICAgICAgYCR7bWluICE9IG51bGwgPyBgPj0gJHttaW59YCA6ICcnfSR7bWluICE9IG51bGwgJiYgbWF4ICE9IG51bGwgPyAnICYmICcgOiAnJ30ke21heCAhPSBudWxsID8gYDw9ICR7bWF4fWAgOiAnJ31gLFxuICAgICAgdmFsdWVcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVPbmVPZlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1RbXX0gb25lT2ZcbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlT25lT2Z9ICovXG5jb25zdCB2YWxpZGF0ZU9uZU9mID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgb25lT2YpID0+IHtcbiAgaWYgKCFBcnJheVByb3RvdHlwZUluY2x1ZGVzKG9uZU9mLCB2YWx1ZSkpIHtcbiAgICBjb25zdCBhbGxvd2VkID0gQXJyYXlQcm90b3R5cGVKb2luKFxuICAgICAgQXJyYXlQcm90b3R5cGVNYXAob25lT2YsICh2KSA9PiAodHlwZW9mIHYgPT09ICdzdHJpbmcnID8gYCcke3Z9J2AgOiBTdHJpbmcodikpKSxcbiAgICAgICcsICdcbiAgICApXG4gICAgY29uc3QgcmVhc29uID0gJ211c3QgYmUgb25lIG9mOiAnICsgYWxsb3dlZFxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgdmFsdWUsIHJlYXNvbilcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVCb29sZWFuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge2Fzc2VydHMgdmFsdWUgaXMgYm9vbGVhbn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlQm9vbGVhbn0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbih2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnYm9vbGVhbicsIHZhbHVlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlZmF1bHRWYWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT0gbnVsbCB8fCAhT2JqZWN0UHJvdG90eXBlSGFzT3duUHJvcGVydHkob3B0aW9ucywga2V5KSA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbnNba2V5XVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZU9iamVjdFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7e1xuICogICBhbGxvd0FycmF5PzogYm9vbGVhbixcbiAqICAgYWxsb3dGdW5jdGlvbj86IGJvb2xlYW4sXG4gKiAgIG51bGxhYmxlPzogYm9vbGVhblxuICogfX0gW29wdGlvbnNdXG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZU9iamVjdH0gKi9cbmNvbnN0IHZhbGlkYXRlT2JqZWN0ID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSwgb3B0aW9ucyA9IG51bGwpID0+IHtcbiAgY29uc3QgYWxsb3dBcnJheSA9IGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywgJ2FsbG93QXJyYXknLCBmYWxzZSlcbiAgY29uc3QgYWxsb3dGdW5jdGlvbiA9IGdldE93blByb3BlcnR5VmFsdWVPckRlZmF1bHQob3B0aW9ucywgJ2FsbG93RnVuY3Rpb24nLCBmYWxzZSlcbiAgY29uc3QgbnVsbGFibGUgPSBnZXRPd25Qcm9wZXJ0eVZhbHVlT3JEZWZhdWx0KG9wdGlvbnMsICdudWxsYWJsZScsIGZhbHNlKVxuICBpZiAoXG4gICAgKCFudWxsYWJsZSAmJiB2YWx1ZSA9PT0gbnVsbCkgfHxcbiAgICAoIWFsbG93QXJyYXkgJiYgQXJyYXlJc0FycmF5KHZhbHVlKSkgfHxcbiAgICAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiAoIWFsbG93RnVuY3Rpb24gfHwgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdPYmplY3QnLCB2YWx1ZSlcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVEaWN0aW9uYXJ5IC0gV2UgYXJlIHVzaW5nIHRoZSBXZWIgSURMIFN0YW5kYXJkIGRlZmluaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBcImRpY3Rpb25hcnlcIiBoZXJlLCB3aGljaCBtZWFucyBhbnkgdmFsdWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9zZSBUeXBlIGlzIGVpdGhlciBVbmRlZmluZWQsIE51bGwsIG9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0ICh3aGljaCBpbmNsdWRlcyBmdW5jdGlvbnMpLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBzZWUgaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1kaWN0aW9uYXJ5XG4gKiBAc2VlIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyN0YWJsZS10eXBlb2Ytb3BlcmF0b3ItcmVzdWx0c1xuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVEaWN0aW9uYXJ5fSAqL1xuY29uc3QgdmFsaWRhdGVEaWN0aW9uYXJ5ID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnYSBkaWN0aW9uYXJ5JywgdmFsdWUpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gW21pbkxlbmd0aF1cbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIGFueVtdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVBcnJheX0gKi9cbmNvbnN0IHZhbGlkYXRlQXJyYXkgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lLCBtaW5MZW5ndGggPSAwKSA9PiB7XG4gIGlmICghQXJyYXlJc0FycmF5KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQXJyYXknLCB2YWx1ZSlcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgY29uc3QgcmVhc29uID0gYG11c3QgYmUgbG9uZ2VyIHRoYW4gJHttaW5MZW5ndGh9YFxuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgdmFsdWUsIHJlYXNvbilcbiAgfVxufSlcblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVTdHJpbmdBcnJheVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIHN0cmluZ1tdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVTdHJpbmdBcnJheX0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nQXJyYXkodmFsdWUsIG5hbWUpIHtcbiAgdmFsaWRhdGVBcnJheSh2YWx1ZSwgbmFtZSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlU3RyaW5nKHZhbHVlW2ldLCBgJHtuYW1lfVske2l9XWApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgdmFsaWRhdGVCb29sZWFuQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBib29sZWFuW119XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUJvb2xlYW5BcnJheX0gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQm9vbGVhbkFycmF5KHZhbHVlLCBuYW1lKSB7XG4gIHZhbGlkYXRlQXJyYXkodmFsdWUsIG5hbWUpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUJvb2xlYW4odmFsdWVbaV0sIGAke25hbWV9WyR7aX1dYClcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUFib3J0U2lnbmFsQXJyYXlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBBYm9ydFNpZ25hbFtdfVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5fSAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5KHZhbHVlLCBuYW1lKSB7XG4gIHZhbGlkYXRlQXJyYXkodmFsdWUsIG5hbWUpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaWduYWwgPSB2YWx1ZVtpXVxuICAgIGNvbnN0IGluZGV4ZWROYW1lID0gYCR7bmFtZX1bJHtpfV1gXG4gICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoaW5kZXhlZE5hbWUsICdBYm9ydFNpZ25hbCcsIHNpZ25hbClcbiAgICB9XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwsIGluZGV4ZWROYW1lKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBzaWduYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nc2lnbmFsJ11cbiAqIEByZXR1cm5zIHthc3NlcnRzIHNpZ25hbCBpcyBrZXlvZiBzaWduYWxzfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25hbE5hbWUoc2lnbmFsLCBuYW1lID0gJ3NpZ25hbCcpIHtcbiAgdmFsaWRhdGVTdHJpbmcoc2lnbmFsLCBuYW1lKVxuICBpZiAoc2lnbmFsc1tzaWduYWxdID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc2lnbmFsc1tTdHJpbmdQcm90b3R5cGVUb1VwcGVyQ2FzZShzaWduYWwpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX1VOS05PV05fU0lHTkFMKHNpZ25hbCArICcgKHNpZ25hbHMgbXVzdCB1c2UgYWxsIGNhcGl0YWwgbGV0dGVycyknKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRVJSX1VOS05PV05fU0lHTkFMKHNpZ25hbClcbiAgfVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZUJ1ZmZlclxuICogQHBhcmFtIHsqfSBidWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nYnVmZmVyJ11cbiAqIEByZXR1cm5zIHthc3NlcnRzIGJ1ZmZlciBpcyBBcnJheUJ1ZmZlclZpZXd9XG4gKi9cblxuLyoqIEB0eXBlIHt2YWxpZGF0ZUJ1ZmZlcn0gKi9cbmNvbnN0IHZhbGlkYXRlQnVmZmVyID0gaGlkZVN0YWNrRnJhbWVzKChidWZmZXIsIG5hbWUgPSAnYnVmZmVyJykgPT4ge1xuICBpZiAoIWlzQXJyYXlCdWZmZXJWaWV3KGJ1ZmZlcikpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgWydCdWZmZXInLCAnVHlwZWRBcnJheScsICdEYXRhVmlldyddLCBidWZmZXIpXG4gIH1cbn0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUVuY29kaW5nKGRhdGEsIGVuY29kaW5nKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRFbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKVxuICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICBpZiAobm9ybWFsaXplZEVuY29kaW5nID09PSAnaGV4JyAmJiBsZW5ndGggJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRSgnZW5jb2RpbmcnLCBlbmNvZGluZywgYGlzIGludmFsaWQgZm9yIGRhdGEgb2YgbGVuZ3RoICR7bGVuZ3RofWApXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB0aGF0IHRoZSBwb3J0IG51bWJlciBpcyBub3QgTmFOIHdoZW4gY29lcmNlZCB0byBhIG51bWJlcixcbiAqIGlzIGFuIGludGVnZXIgYW5kIHRoYXQgaXQgZmFsbHMgd2l0aGluIHRoZSBsZWdhbCByYW5nZSBvZiBwb3J0IG51bWJlcnMuXG4gKiBAcGFyYW0geyp9IHBvcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nUG9ydCddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxvd1plcm89dHJ1ZV1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUG9ydChwb3J0LCBuYW1lID0gJ1BvcnQnLCBhbGxvd1plcm8gPSB0cnVlKSB7XG4gIGlmIChcbiAgICAodHlwZW9mIHBvcnQgIT09ICdudW1iZXInICYmIHR5cGVvZiBwb3J0ICE9PSAnc3RyaW5nJykgfHxcbiAgICAodHlwZW9mIHBvcnQgPT09ICdzdHJpbmcnICYmIFN0cmluZ1Byb3RvdHlwZVRyaW0ocG9ydCkubGVuZ3RoID09PSAwKSB8fFxuICAgICtwb3J0ICE9PSArcG9ydCA+Pj4gMCB8fFxuICAgIHBvcnQgPiAweGZmZmYgfHxcbiAgICAocG9ydCA9PT0gMCAmJiAhYWxsb3daZXJvKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRVJSX1NPQ0tFVF9CQURfUE9SVChuYW1lLCBwb3J0LCBhbGxvd1plcm8pXG4gIH1cbiAgcmV0dXJuIHBvcnQgfCAwXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlQWJvcnRTaWduYWxcbiAqIEBwYXJhbSB7Kn0gc2lnbmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5cbi8qKiBAdHlwZSB7dmFsaWRhdGVBYm9ydFNpZ25hbH0gKi9cbmNvbnN0IHZhbGlkYXRlQWJvcnRTaWduYWwgPSBoaWRlU3RhY2tGcmFtZXMoKHNpZ25hbCwgbmFtZSkgPT4ge1xuICBpZiAoc2lnbmFsICE9PSB1bmRlZmluZWQgJiYgKHNpZ25hbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc2lnbmFsICE9PSAnb2JqZWN0JyB8fCAhKCdhYm9ydGVkJyBpbiBzaWduYWwpKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gIH1cbn0pXG5cbi8qKlxuICogQGNhbGxiYWNrIHZhbGlkYXRlRnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBGdW5jdGlvbn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlRnVuY3Rpb259ICovXG5jb25zdCB2YWxpZGF0ZUZ1bmN0aW9uID0gaGlkZVN0YWNrRnJhbWVzKCh2YWx1ZSwgbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Z1bmN0aW9uJywgdmFsdWUpXG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVBsYWluRnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7YXNzZXJ0cyB2YWx1ZSBpcyBGdW5jdGlvbn1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlUGxhaW5GdW5jdGlvbn0gKi9cbmNvbnN0IHZhbGlkYXRlUGxhaW5GdW5jdGlvbiA9IGhpZGVTdGFja0ZyYW1lcygodmFsdWUsIG5hbWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCBpc0FzeW5jRnVuY3Rpb24odmFsdWUpKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ0Z1bmN0aW9uJywgdmFsdWUpXG59KVxuXG4vKipcbiAqIEBjYWxsYmFjayB2YWxpZGF0ZVVuZGVmaW5lZFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHthc3NlcnRzIHZhbHVlIGlzIHVuZGVmaW5lZH1cbiAqL1xuXG4vKiogQHR5cGUge3ZhbGlkYXRlVW5kZWZpbmVkfSAqL1xuY29uc3QgdmFsaWRhdGVVbmRlZmluZWQgPSBoaWRlU3RhY2tGcmFtZXMoKHZhbHVlLCBuYW1lKSA9PiB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ3VuZGVmaW5lZCcsIHZhbHVlKVxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7VFtdfSB1bmlvblxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVVuaW9uKHZhbHVlLCBuYW1lLCB1bmlvbikge1xuICBpZiAoIUFycmF5UHJvdG90eXBlSW5jbHVkZXModW5pb24sIHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCBgKCcke0FycmF5UHJvdG90eXBlSm9pbih1bmlvbiwgJ3wnKX0nKWAsIHZhbHVlKVxuICB9XG59XG5cbi8qXG4gIFRoZSBydWxlcyBmb3IgdGhlIExpbmsgaGVhZGVyIGZpZWxkIGFyZSBkZXNjcmliZWQgaGVyZTpcbiAgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzgyODguaHRtbCNzZWN0aW9uLTNcblxuICBUaGlzIHJlZ2V4IHZhbGlkYXRlcyBhbnkgc3RyaW5nIHN1cnJvdW5kZWQgYnkgYW5nbGUgYnJhY2tldHNcbiAgKG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIFVSSSByZWZlcmVuY2UpIGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZVxuICBsaW5rLXBhcmFtcyBzZXBhcmF0ZWQgYnkgc2VtaWNvbG9ucy5cbiovXG5jb25zdCBsaW5rVmFsdWVSZWdFeHAgPSAvXig/OjxbXj5dKj4pKD86XFxzKjtcXHMqW147XCJcXHNdKyg/Oj0oXCIpP1teO1wiXFxzXSpcXDEpPykqJC9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGlua0hlYWRlckZvcm1hdCh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCAhUmVnRXhwUHJvdG90eXBlRXhlYyhsaW5rVmFsdWVSZWdFeHAsIHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWUsXG4gICAgICAnbXVzdCBiZSBhbiBhcnJheSBvciBzdHJpbmcgb2YgZm9ybWF0IFwiPC9zdHlsZXMuY3NzPjsgcmVsPXByZWxvYWQ7IGFzPXN0eWxlXCInXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGhpbnRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGlua0hlYWRlclZhbHVlKGhpbnRzKSB7XG4gIGlmICh0eXBlb2YgaGludHMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsaWRhdGVMaW5rSGVhZGVyRm9ybWF0KGhpbnRzLCAnaGludHMnKVxuICAgIHJldHVybiBoaW50c1xuICB9IGVsc2UgaWYgKEFycmF5SXNBcnJheShoaW50cykpIHtcbiAgICBjb25zdCBoaW50c0xlbmd0aCA9IGhpbnRzLmxlbmd0aFxuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIGlmIChoaW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmsgPSBoaW50c1tpXVxuICAgICAgdmFsaWRhdGVMaW5rSGVhZGVyRm9ybWF0KGxpbmssICdoaW50cycpXG4gICAgICByZXN1bHQgKz0gbGlua1xuICAgICAgaWYgKGkgIT09IGhpbnRzTGVuZ3RoIC0gMSkge1xuICAgICAgICByZXN1bHQgKz0gJywgJ1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShcbiAgICAnaGludHMnLFxuICAgIGhpbnRzLFxuICAgICdtdXN0IGJlIGFuIGFycmF5IG9yIHN0cmluZyBvZiBmb3JtYXQgXCI8L3N0eWxlcy5jc3M+OyByZWw9cHJlbG9hZDsgYXM9c3R5bGVcIidcbiAgKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzSW50MzIsXG4gIGlzVWludDMyLFxuICBwYXJzZUZpbGVNb2RlLFxuICB2YWxpZGF0ZUFycmF5LFxuICB2YWxpZGF0ZVN0cmluZ0FycmF5LFxuICB2YWxpZGF0ZUJvb2xlYW5BcnJheSxcbiAgdmFsaWRhdGVBYm9ydFNpZ25hbEFycmF5LFxuICB2YWxpZGF0ZUJvb2xlYW4sXG4gIHZhbGlkYXRlQnVmZmVyLFxuICB2YWxpZGF0ZURpY3Rpb25hcnksXG4gIHZhbGlkYXRlRW5jb2RpbmcsXG4gIHZhbGlkYXRlRnVuY3Rpb24sXG4gIHZhbGlkYXRlSW50MzIsXG4gIHZhbGlkYXRlSW50ZWdlcixcbiAgdmFsaWRhdGVOdW1iZXIsXG4gIHZhbGlkYXRlT2JqZWN0LFxuICB2YWxpZGF0ZU9uZU9mLFxuICB2YWxpZGF0ZVBsYWluRnVuY3Rpb24sXG4gIHZhbGlkYXRlUG9ydCxcbiAgdmFsaWRhdGVTaWduYWxOYW1lLFxuICB2YWxpZGF0ZVN0cmluZyxcbiAgdmFsaWRhdGVVaW50MzIsXG4gIHZhbGlkYXRlVW5kZWZpbmVkLFxuICB2YWxpZGF0ZVVuaW9uLFxuICB2YWxpZGF0ZUFib3J0U2lnbmFsLFxuICB2YWxpZGF0ZUxpbmtIZWFkZXJWYWx1ZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgU3ltYm9sQXN5bmNJdGVyYXRvciwgU3ltYm9sSXRlcmF0b3IsIFN5bWJvbEZvciB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5cbi8vIFdlIG5lZWQgdG8gdXNlIFN5bWJvbEZvciB0byBtYWtlIHRoZXNlIGdsb2JhbGx5IGF2YWlsYWJsZVxuLy8gZm9yIGludGVyb3B0IHdpdGggcmVhZGFibGUtc3RyZWFtLCBpLmUuIHJlYWRhYmxlLXN0cmVhbVxuLy8gYW5kIG5vZGUgY29yZSBuZWVkcyB0byBiZSBhYmxlIHRvIHJlYWQvd3JpdGUgcHJpdmF0ZSBzdGF0ZVxuLy8gZnJvbSBlYWNoIG90aGVyIGZvciBwcm9wZXIgaW50ZXJvcGVyYWJpbGl0eS5cbmNvbnN0IGtJc0Rlc3Ryb3llZCA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS5kZXN0cm95ZWQnKVxuY29uc3Qga0lzRXJyb3JlZCA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS5lcnJvcmVkJylcbmNvbnN0IGtJc1JlYWRhYmxlID0gU3ltYm9sRm9yKCdub2RlanMuc3RyZWFtLnJlYWRhYmxlJylcbmNvbnN0IGtJc1dyaXRhYmxlID0gU3ltYm9sRm9yKCdub2RlanMuc3RyZWFtLndyaXRhYmxlJylcbmNvbnN0IGtJc0Rpc3R1cmJlZCA9IFN5bWJvbEZvcignbm9kZWpzLnN0cmVhbS5kaXN0dXJiZWQnKVxuY29uc3Qga0lzQ2xvc2VkUHJvbWlzZSA9IFN5bWJvbEZvcignbm9kZWpzLndlYnN0cmVhbS5pc0Nsb3NlZFByb21pc2UnKVxuY29uc3Qga0NvbnRyb2xsZXJFcnJvckZ1bmN0aW9uID0gU3ltYm9sRm9yKCdub2RlanMud2Vic3RyZWFtLmNvbnRyb2xsZXJFcnJvckZ1bmN0aW9uJylcbmZ1bmN0aW9uIGlzUmVhZGFibGVOb2RlU3RyZWFtKG9iaiwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgdmFyIF9vYmokX3JlYWRhYmxlU3RhdGVcbiAgcmV0dXJuICEhKFxuICAgIChcbiAgICAgIG9iaiAmJlxuICAgICAgdHlwZW9mIG9iai5waXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoIXN0cmljdCB8fCAodHlwZW9mIG9iai5wYXVzZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnJlc3VtZSA9PT0gJ2Z1bmN0aW9uJykpICYmXG4gICAgICAoIW9iai5fd3JpdGFibGVTdGF0ZSB8fFxuICAgICAgICAoKF9vYmokX3JlYWRhYmxlU3RhdGUgPSBvYmouX3JlYWRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9vYmokX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBfb2JqJF9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlKSAhPT0gZmFsc2UpICYmXG4gICAgICAvLyBEdXBsZXhcbiAgICAgICghb2JqLl93cml0YWJsZVN0YXRlIHx8IG9iai5fcmVhZGFibGVTdGF0ZSlcbiAgICApIC8vIFdyaXRhYmxlIGhhcyAucGlwZS5cbiAgKVxufVxuZnVuY3Rpb24gaXNXcml0YWJsZU5vZGVTdHJlYW0ob2JqKSB7XG4gIHZhciBfb2JqJF93cml0YWJsZVN0YXRlXG4gIHJldHVybiAhIShcbiAgICAoXG4gICAgICBvYmogJiZcbiAgICAgIHR5cGVvZiBvYmoud3JpdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBvYmoub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICghb2JqLl9yZWFkYWJsZVN0YXRlIHx8XG4gICAgICAgICgoX29iaiRfd3JpdGFibGVTdGF0ZSA9IG9iai5fd3JpdGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX29iaiRfd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IF9vYmokX3dyaXRhYmxlU3RhdGUud3JpdGFibGUpICE9PSBmYWxzZSlcbiAgICApIC8vIER1cGxleFxuICApXG59XG5mdW5jdGlvbiBpc0R1cGxleE5vZGVTdHJlYW0ob2JqKSB7XG4gIHJldHVybiAhIShcbiAgICBvYmogJiZcbiAgICB0eXBlb2Ygb2JqLnBpcGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICBvYmouX3JlYWRhYmxlU3RhdGUgJiZcbiAgICB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iai53cml0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5mdW5jdGlvbiBpc05vZGVTdHJlYW0ob2JqKSB7XG4gIHJldHVybiAoXG4gICAgb2JqICYmXG4gICAgKG9iai5fcmVhZGFibGVTdGF0ZSB8fFxuICAgICAgb2JqLl93cml0YWJsZVN0YXRlIHx8XG4gICAgICAodHlwZW9mIG9iai53cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgKHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nKSlcbiAgKVxufVxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKFxuICAgIG9iaiAmJlxuICAgICFpc05vZGVTdHJlYW0ob2JqKSAmJlxuICAgIHR5cGVvZiBvYmoucGlwZVRocm91Z2ggPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqLmdldFJlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouY2FuY2VsID09PSAnZnVuY3Rpb24nXG4gIClcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGVTdHJlYW0ob2JqKSB7XG4gIHJldHVybiAhIShvYmogJiYgIWlzTm9kZVN0cmVhbShvYmopICYmIHR5cGVvZiBvYmouZ2V0V3JpdGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouYWJvcnQgPT09ICdmdW5jdGlvbicpXG59XG5mdW5jdGlvbiBpc1RyYW5zZm9ybVN0cmVhbShvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAmJiAhaXNOb2RlU3RyZWFtKG9iaikgJiYgdHlwZW9mIG9iai5yZWFkYWJsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai53cml0YWJsZSA9PT0gJ29iamVjdCcpXG59XG5mdW5jdGlvbiBpc1dlYlN0cmVhbShvYmopIHtcbiAgcmV0dXJuIGlzUmVhZGFibGVTdHJlYW0ob2JqKSB8fCBpc1dyaXRhYmxlU3RyZWFtKG9iaikgfHwgaXNUcmFuc2Zvcm1TdHJlYW0ob2JqKVxufVxuZnVuY3Rpb24gaXNJdGVyYWJsZShvYmosIGlzQXN5bmMpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgaWYgKGlzQXN5bmMgPT09IHRydWUpIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbEFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG4gIGlmIChpc0FzeW5jID09PSBmYWxzZSkgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG4gIHJldHVybiB0eXBlb2Ygb2JqW1N5bWJvbEFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmpbU3ltYm9sSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nXG59XG5mdW5jdGlvbiBpc0Rlc3Ryb3llZChzdHJlYW0pIHtcbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkgcmV0dXJuIG51bGxcbiAgY29uc3Qgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCBzdGF0ZSA9IHdTdGF0ZSB8fCByU3RhdGVcbiAgcmV0dXJuICEhKHN0cmVhbS5kZXN0cm95ZWQgfHwgc3RyZWFtW2tJc0Rlc3Ryb3llZF0gfHwgKHN0YXRlICE9PSBudWxsICYmIHN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUuZGVzdHJveWVkKSlcbn1cblxuLy8gSGF2ZSBiZWVuIGVuZCgpOmQuXG5mdW5jdGlvbiBpc1dyaXRhYmxlRW5kZWQoc3RyZWFtKSB7XG4gIGlmICghaXNXcml0YWJsZU5vZGVTdHJlYW0oc3RyZWFtKSkgcmV0dXJuIG51bGxcbiAgaWYgKHN0cmVhbS53cml0YWJsZUVuZGVkID09PSB0cnVlKSByZXR1cm4gdHJ1ZVxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHdTdGF0ZSAhPT0gbnVsbCAmJiB3U3RhdGUgIT09IHVuZGVmaW5lZCAmJiB3U3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgKHdTdGF0ZSA9PT0gbnVsbCB8fCB3U3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHdTdGF0ZS5lbmRlZCkgIT09ICdib29sZWFuJykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHdTdGF0ZS5lbmRlZFxufVxuXG4vLyBIYXZlIGVtaXR0ZWQgJ2ZpbmlzaCcuXG5mdW5jdGlvbiBpc1dyaXRhYmxlRmluaXNoZWQoc3RyZWFtLCBzdHJpY3QpIHtcbiAgaWYgKCFpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBpZiAoc3RyZWFtLndyaXRhYmxlRmluaXNoZWQgPT09IHRydWUpIHJldHVybiB0cnVlXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAod1N0YXRlICE9PSBudWxsICYmIHdTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHdTdGF0ZS5lcnJvcmVkKSByZXR1cm4gZmFsc2VcbiAgaWYgKHR5cGVvZiAod1N0YXRlID09PSBudWxsIHx8IHdTdGF0ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogd1N0YXRlLmZpbmlzaGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gISEod1N0YXRlLmZpbmlzaGVkIHx8IChzdHJpY3QgPT09IGZhbHNlICYmIHdTdGF0ZS5lbmRlZCA9PT0gdHJ1ZSAmJiB3U3RhdGUubGVuZ3RoID09PSAwKSlcbn1cblxuLy8gSGF2ZSBiZWVuIHB1c2gobnVsbCk6ZC5cbmZ1bmN0aW9uIGlzUmVhZGFibGVFbmRlZChzdHJlYW0pIHtcbiAgaWYgKCFpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBpZiAoc3RyZWFtLnJlYWRhYmxlRW5kZWQgPT09IHRydWUpIHJldHVybiB0cnVlXG4gIGNvbnN0IHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5lbmRlZCkgIT09ICdib29sZWFuJykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHJTdGF0ZS5lbmRlZFxufVxuXG4vLyBIYXZlIGVtaXR0ZWQgJ2VuZCcuXG5mdW5jdGlvbiBpc1JlYWRhYmxlRmluaXNoZWQoc3RyZWFtLCBzdHJpY3QpIHtcbiAgaWYgKCFpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pKSByZXR1cm4gbnVsbFxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgaWYgKHJTdGF0ZSAhPT0gbnVsbCAmJiByU3RhdGUgIT09IHVuZGVmaW5lZCAmJiByU3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0eXBlb2YgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5lbmRFbWl0dGVkKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICByZXR1cm4gISEoclN0YXRlLmVuZEVtaXR0ZWQgfHwgKHN0cmljdCA9PT0gZmFsc2UgJiYgclN0YXRlLmVuZGVkID09PSB0cnVlICYmIHJTdGF0ZS5sZW5ndGggPT09IDApKVxufVxuZnVuY3Rpb24gaXNSZWFkYWJsZShzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbSAmJiBzdHJlYW1ba0lzUmVhZGFibGVdICE9IG51bGwpIHJldHVybiBzdHJlYW1ba0lzUmVhZGFibGVdXG4gIGlmICh0eXBlb2YgKHN0cmVhbSA9PT0gbnVsbCB8fCBzdHJlYW0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHN0cmVhbS5yZWFkYWJsZSkgIT09ICdib29sZWFuJykgcmV0dXJuIG51bGxcbiAgaWYgKGlzRGVzdHJveWVkKHN0cmVhbSkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtKSAmJiBzdHJlYW0ucmVhZGFibGUgJiYgIWlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0pXG59XG5mdW5jdGlvbiBpc1dyaXRhYmxlKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtICYmIHN0cmVhbVtrSXNXcml0YWJsZV0gIT0gbnVsbCkgcmV0dXJuIHN0cmVhbVtrSXNXcml0YWJsZV1cbiAgaWYgKHR5cGVvZiAoc3RyZWFtID09PSBudWxsIHx8IHN0cmVhbSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc3RyZWFtLndyaXRhYmxlKSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gbnVsbFxuICBpZiAoaXNEZXN0cm95ZWQoc3RyZWFtKSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pICYmIHN0cmVhbS53cml0YWJsZSAmJiAhaXNXcml0YWJsZUVuZGVkKHN0cmVhbSlcbn1cbmZ1bmN0aW9uIGlzRmluaXNoZWQoc3RyZWFtLCBvcHRzKSB7XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChpc0Rlc3Ryb3llZChzdHJlYW0pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0cy5yZWFkYWJsZSkgIT09IGZhbHNlICYmIGlzUmVhZGFibGUoc3RyZWFtKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmICgob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRzLndyaXRhYmxlKSAhPT0gZmFsc2UgJiYgaXNXcml0YWJsZShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbmZ1bmN0aW9uIGlzV3JpdGFibGVFcnJvcmVkKHN0cmVhbSkge1xuICB2YXIgX3N0cmVhbSRfd3JpdGFibGVTdGF0LCBfc3RyZWFtJF93cml0YWJsZVN0YXQyXG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChzdHJlYW0ud3JpdGFibGVFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHN0cmVhbS53cml0YWJsZUVycm9yZWRcbiAgfVxuICByZXR1cm4gKF9zdHJlYW0kX3dyaXRhYmxlU3RhdCA9XG4gICAgKF9zdHJlYW0kX3dyaXRhYmxlU3RhdDIgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDIgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogX3N0cmVhbSRfd3JpdGFibGVTdGF0Mi5lcnJvcmVkKSAhPT0gbnVsbCAmJiBfc3RyZWFtJF93cml0YWJsZVN0YXQgIT09IHVuZGVmaW5lZFxuICAgID8gX3N0cmVhbSRfd3JpdGFibGVTdGF0XG4gICAgOiBudWxsXG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlRXJyb3JlZChzdHJlYW0pIHtcbiAgdmFyIF9zdHJlYW0kX3JlYWRhYmxlU3RhdCwgX3N0cmVhbSRfcmVhZGFibGVTdGF0MlxuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAoc3RyZWFtLnJlYWRhYmxlRXJyb3JlZCkge1xuICAgIHJldHVybiBzdHJlYW0ucmVhZGFibGVFcnJvcmVkXG4gIH1cbiAgcmV0dXJuIChfc3RyZWFtJF9yZWFkYWJsZVN0YXQgPVxuICAgIChfc3RyZWFtJF9yZWFkYWJsZVN0YXQyID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQyID09PSB1bmRlZmluZWRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IF9zdHJlYW0kX3JlYWRhYmxlU3RhdDIuZXJyb3JlZCkgIT09IG51bGwgJiYgX3N0cmVhbSRfcmVhZGFibGVTdGF0ICE9PSB1bmRlZmluZWRcbiAgICA/IF9zdHJlYW0kX3JlYWRhYmxlU3RhdFxuICAgIDogbnVsbFxufVxuZnVuY3Rpb24gaXNDbG9zZWQoc3RyZWFtKSB7XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyZWFtLmNsb3NlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5jbG9zZWRcbiAgfVxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGlmIChcbiAgICB0eXBlb2YgKHdTdGF0ZSA9PT0gbnVsbCB8fCB3U3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHdTdGF0ZS5jbG9zZWQpID09PSAnYm9vbGVhbicgfHxcbiAgICB0eXBlb2YgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5jbG9zZWQpID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICh3U3RhdGUgPT09IG51bGwgfHwgd1N0YXRlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB3U3RhdGUuY2xvc2VkKSB8fFxuICAgICAgKHJTdGF0ZSA9PT0gbnVsbCB8fCByU3RhdGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJTdGF0ZS5jbG9zZWQpXG4gICAgKVxuICB9XG4gIGlmICh0eXBlb2Ygc3RyZWFtLl9jbG9zZWQgPT09ICdib29sZWFuJyAmJiBpc091dGdvaW5nTWVzc2FnZShzdHJlYW0pKSB7XG4gICAgcmV0dXJuIHN0cmVhbS5fY2xvc2VkXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cbmZ1bmN0aW9uIGlzT3V0Z29pbmdNZXNzYWdlKHN0cmVhbSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBzdHJlYW0uX2Nsb3NlZCA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fZGVmYXVsdEtlZXBBbGl2ZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fcmVtb3ZlZENvbm5lY3Rpb24gPT09ICdib29sZWFuJyAmJlxuICAgIHR5cGVvZiBzdHJlYW0uX3JlbW92ZWRDb250TGVuID09PSAnYm9vbGVhbidcbiAgKVxufVxuZnVuY3Rpb24gaXNTZXJ2ZXJSZXNwb25zZShzdHJlYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHJlYW0uX3NlbnQxMDAgPT09ICdib29sZWFuJyAmJiBpc091dGdvaW5nTWVzc2FnZShzdHJlYW0pXG59XG5mdW5jdGlvbiBpc1NlcnZlclJlcXVlc3Qoc3RyZWFtKSB7XG4gIHZhciBfc3RyZWFtJHJlcVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiBzdHJlYW0uX2NvbnN1bWluZyA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgdHlwZW9mIHN0cmVhbS5fZHVtcGVkID09PSAnYm9vbGVhbicgJiZcbiAgICAoKF9zdHJlYW0kcmVxID0gc3RyZWFtLnJlcSkgPT09IG51bGwgfHwgX3N0cmVhbSRyZXEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9zdHJlYW0kcmVxLnVwZ3JhZGVPckNvbm5lY3QpID09PVxuICAgICAgdW5kZWZpbmVkXG4gIClcbn1cbmZ1bmN0aW9uIHdpbGxFbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIGlmICghaXNOb2RlU3RyZWFtKHN0cmVhbSkpIHJldHVybiBudWxsXG4gIGNvbnN0IHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3Qgc3RhdGUgPSB3U3RhdGUgfHwgclN0YXRlXG4gIHJldHVybiAoXG4gICAgKCFzdGF0ZSAmJiBpc1NlcnZlclJlc3BvbnNlKHN0cmVhbSkpIHx8ICEhKHN0YXRlICYmIHN0YXRlLmF1dG9EZXN0cm95ICYmIHN0YXRlLmVtaXRDbG9zZSAmJiBzdGF0ZS5jbG9zZWQgPT09IGZhbHNlKVxuICApXG59XG5mdW5jdGlvbiBpc0Rpc3R1cmJlZChzdHJlYW0pIHtcbiAgdmFyIF9zdHJlYW0ka0lzRGlzdHVyYmVkXG4gIHJldHVybiAhIShcbiAgICBzdHJlYW0gJiZcbiAgICAoKF9zdHJlYW0ka0lzRGlzdHVyYmVkID0gc3RyZWFtW2tJc0Rpc3R1cmJlZF0pICE9PSBudWxsICYmIF9zdHJlYW0ka0lzRGlzdHVyYmVkICE9PSB1bmRlZmluZWRcbiAgICAgID8gX3N0cmVhbSRrSXNEaXN0dXJiZWRcbiAgICAgIDogc3RyZWFtLnJlYWRhYmxlRGlkUmVhZCB8fCBzdHJlYW0ucmVhZGFibGVBYm9ydGVkKVxuICApXG59XG5mdW5jdGlvbiBpc0Vycm9yZWQoc3RyZWFtKSB7XG4gIHZhciBfcmVmLFxuICAgIF9yZWYyLFxuICAgIF9yZWYzLFxuICAgIF9yZWY0LFxuICAgIF9yZWY1LFxuICAgIF9zdHJlYW0ka0lzRXJyb3JlZCxcbiAgICBfc3RyZWFtJF9yZWFkYWJsZVN0YXQzLFxuICAgIF9zdHJlYW0kX3dyaXRhYmxlU3RhdDMsXG4gICAgX3N0cmVhbSRfcmVhZGFibGVTdGF0NCxcbiAgICBfc3RyZWFtJF93cml0YWJsZVN0YXQ0XG4gIHJldHVybiAhIShcbiAgICBzdHJlYW0gJiZcbiAgICAoKF9yZWYgPVxuICAgICAgKF9yZWYyID1cbiAgICAgICAgKF9yZWYzID1cbiAgICAgICAgICAoX3JlZjQgPVxuICAgICAgICAgICAgKF9yZWY1ID1cbiAgICAgICAgICAgICAgKF9zdHJlYW0ka0lzRXJyb3JlZCA9IHN0cmVhbVtrSXNFcnJvcmVkXSkgIT09IG51bGwgJiYgX3N0cmVhbSRrSXNFcnJvcmVkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IF9zdHJlYW0ka0lzRXJyb3JlZFxuICAgICAgICAgICAgICAgIDogc3RyZWFtLnJlYWRhYmxlRXJyb3JlZCkgIT09IG51bGwgJiYgX3JlZjUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IF9yZWY1XG4gICAgICAgICAgICAgIDogc3RyZWFtLndyaXRhYmxlRXJyb3JlZCkgIT09IG51bGwgJiYgX3JlZjQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBfcmVmNFxuICAgICAgICAgICAgOiAoX3N0cmVhbSRfcmVhZGFibGVTdGF0MyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSkgPT09IG51bGwgfHwgX3N0cmVhbSRfcmVhZGFibGVTdGF0MyA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBfc3RyZWFtJF9yZWFkYWJsZVN0YXQzLmVycm9yRW1pdHRlZCkgIT09IG51bGwgJiYgX3JlZjMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gX3JlZjNcbiAgICAgICAgICA6IChfc3RyZWFtJF93cml0YWJsZVN0YXQzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF93cml0YWJsZVN0YXQzID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogX3N0cmVhbSRfd3JpdGFibGVTdGF0My5lcnJvckVtaXR0ZWQpICE9PSBudWxsICYmIF9yZWYyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfcmVmMlxuICAgICAgICA6IChfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0ID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBfc3RyZWFtJF9yZWFkYWJsZVN0YXQ0LmVycm9yZWQpICE9PSBudWxsICYmIF9yZWYgIT09IHVuZGVmaW5lZFxuICAgICAgPyBfcmVmXG4gICAgICA6IChfc3RyZWFtJF93cml0YWJsZVN0YXQ0ID0gc3RyZWFtLl93cml0YWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfc3RyZWFtJF93cml0YWJsZVN0YXQ0ID09PSB1bmRlZmluZWRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IF9zdHJlYW0kX3dyaXRhYmxlU3RhdDQuZXJyb3JlZClcbiAgKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzRGVzdHJveWVkLFxuICBrSXNEZXN0cm95ZWQsXG4gIGlzRGlzdHVyYmVkLFxuICBrSXNEaXN0dXJiZWQsXG4gIGlzRXJyb3JlZCxcbiAga0lzRXJyb3JlZCxcbiAgaXNSZWFkYWJsZSxcbiAga0lzUmVhZGFibGUsXG4gIGtJc0Nsb3NlZFByb21pc2UsXG4gIGtDb250cm9sbGVyRXJyb3JGdW5jdGlvbixcbiAga0lzV3JpdGFibGUsXG4gIGlzQ2xvc2VkLFxuICBpc0R1cGxleE5vZGVTdHJlYW0sXG4gIGlzRmluaXNoZWQsXG4gIGlzSXRlcmFibGUsXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1JlYWRhYmxlRW5kZWQsXG4gIGlzUmVhZGFibGVGaW5pc2hlZCxcbiAgaXNSZWFkYWJsZUVycm9yZWQsXG4gIGlzTm9kZVN0cmVhbSxcbiAgaXNXZWJTdHJlYW0sXG4gIGlzV3JpdGFibGUsXG4gIGlzV3JpdGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlRW5kZWQsXG4gIGlzV3JpdGFibGVGaW5pc2hlZCxcbiAgaXNXcml0YWJsZUVycm9yZWQsXG4gIGlzU2VydmVyUmVxdWVzdCxcbiAgaXNTZXJ2ZXJSZXNwb25zZSxcbiAgd2lsbEVtaXRDbG9zZSxcbiAgaXNUcmFuc2Zvcm1TdHJlYW1cbn1cbiIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cblxuJ3VzZSBzdHJpY3QnXG5cbi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuXG5jb25zdCB7IEFib3J0RXJyb3IsIGNvZGVzIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSB9ID0gY29kZXNcbmNvbnN0IHsga0VtcHR5T2JqZWN0LCBvbmNlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKVxuY29uc3QgeyB2YWxpZGF0ZUFib3J0U2lnbmFsLCB2YWxpZGF0ZUZ1bmN0aW9uLCB2YWxpZGF0ZU9iamVjdCwgdmFsaWRhdGVCb29sZWFuIH0gPSByZXF1aXJlKCcuLi92YWxpZGF0b3JzJylcbmNvbnN0IHsgUHJvbWlzZSwgUHJvbWlzZVByb3RvdHlwZVRoZW4sIFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3Qge1xuICBpc0Nsb3NlZCxcbiAgaXNSZWFkYWJsZSxcbiAgaXNSZWFkYWJsZU5vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVGaW5pc2hlZCxcbiAgaXNSZWFkYWJsZUVycm9yZWQsXG4gIGlzV3JpdGFibGUsXG4gIGlzV3JpdGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlRmluaXNoZWQsXG4gIGlzV3JpdGFibGVFcnJvcmVkLFxuICBpc05vZGVTdHJlYW0sXG4gIHdpbGxFbWl0Q2xvc2U6IF93aWxsRW1pdENsb3NlLFxuICBrSXNDbG9zZWRQcm9taXNlXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5sZXQgYWRkQWJvcnRMaXN0ZW5lclxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nXG59XG5jb25zdCBub3AgPSAoKSA9PiB7fVxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIF9vcHRpb25zJHJlYWRhYmxlLCBfb3B0aW9ucyR3cml0YWJsZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGNhbGxiYWNrID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBrRW1wdHlPYmplY3RcbiAgfSBlbHNlIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ga0VtcHR5T2JqZWN0XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIHZhbGlkYXRlRnVuY3Rpb24oY2FsbGJhY2ssICdjYWxsYmFjaycpXG4gIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB8fCBpc1dyaXRhYmxlU3RyZWFtKHN0cmVhbSkpIHtcbiAgICByZXR1cm4gZW9zV2ViKHN0cmVhbSwgb3B0aW9ucywgY2FsbGJhY2spXG4gIH1cbiAgaWYgKCFpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnc3RyZWFtJywgWydSZWFkYWJsZVN0cmVhbScsICdXcml0YWJsZVN0cmVhbScsICdTdHJlYW0nXSwgc3RyZWFtKVxuICB9XG4gIGNvbnN0IHJlYWRhYmxlID1cbiAgICAoX29wdGlvbnMkcmVhZGFibGUgPSBvcHRpb25zLnJlYWRhYmxlKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRyZWFkYWJsZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IF9vcHRpb25zJHJlYWRhYmxlXG4gICAgICA6IGlzUmVhZGFibGVOb2RlU3RyZWFtKHN0cmVhbSlcbiAgY29uc3Qgd3JpdGFibGUgPVxuICAgIChfb3B0aW9ucyR3cml0YWJsZSA9IG9wdGlvbnMud3JpdGFibGUpICE9PSBudWxsICYmIF9vcHRpb25zJHdyaXRhYmxlICE9PSB1bmRlZmluZWRcbiAgICAgID8gX29wdGlvbnMkd3JpdGFibGVcbiAgICAgIDogaXNXcml0YWJsZU5vZGVTdHJlYW0oc3RyZWFtKVxuICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IG9ubGVnYWN5ZmluaXNoID0gKCkgPT4ge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSB7XG4gICAgICBvbmZpbmlzaCgpXG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETyAocm9uYWcpOiBJbXByb3ZlIHNvZnQgZGV0ZWN0aW9uIHRvIGluY2x1ZGUgY29yZSBtb2R1bGVzIGFuZFxuICAvLyBjb21tb24gZWNvc3lzdGVtIG1vZHVsZXMgdGhhdCBkbyBwcm9wZXJseSBlbWl0ICdjbG9zZScgYnV0IGZhaWxcbiAgLy8gdGhpcyBnZW5lcmljIGNoZWNrLlxuICBsZXQgd2lsbEVtaXRDbG9zZSA9XG4gICAgX3dpbGxFbWl0Q2xvc2Uoc3RyZWFtKSAmJiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0pID09PSByZWFkYWJsZSAmJiBpc1dyaXRhYmxlTm9kZVN0cmVhbShzdHJlYW0pID09PSB3cml0YWJsZVxuICBsZXQgd3JpdGFibGVGaW5pc2hlZCA9IGlzV3JpdGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKVxuICBjb25zdCBvbmZpbmlzaCA9ICgpID0+IHtcbiAgICB3cml0YWJsZUZpbmlzaGVkID0gdHJ1ZVxuICAgIC8vIFN0cmVhbSBzaG91bGQgbm90IGJlIGRlc3Ryb3llZCBoZXJlLiBJZiBpdCBpcyB0aGF0XG4gICAgLy8gbWVhbnMgdGhhdCB1c2VyIHNwYWNlIGlzIGRvaW5nIHNvbWV0aGluZyBkaWZmZXJlbnRseSBhbmRcbiAgICAvLyB3ZSBjYW5ub3QgdHJ1c3Qgd2lsbEVtaXRDbG9zZS5cbiAgICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgd2lsbEVtaXRDbG9zZSA9IGZhbHNlXG4gICAgfVxuICAgIGlmICh3aWxsRW1pdENsb3NlICYmICghc3RyZWFtLnJlYWRhYmxlIHx8IHJlYWRhYmxlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcmVhZGFibGUgfHwgcmVhZGFibGVGaW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2suY2FsbChzdHJlYW0pXG4gICAgfVxuICB9XG4gIGxldCByZWFkYWJsZUZpbmlzaGVkID0gaXNSZWFkYWJsZUZpbmlzaGVkKHN0cmVhbSwgZmFsc2UpXG4gIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgIHJlYWRhYmxlRmluaXNoZWQgPSB0cnVlXG4gICAgLy8gU3RyZWFtIHNob3VsZCBub3QgYmUgZGVzdHJveWVkIGhlcmUuIElmIGl0IGlzIHRoYXRcbiAgICAvLyBtZWFucyB0aGF0IHVzZXIgc3BhY2UgaXMgZG9pbmcgc29tZXRoaW5nIGRpZmZlcmVudGx5IGFuZFxuICAgIC8vIHdlIGNhbm5vdCB0cnVzdCB3aWxsRW1pdENsb3NlLlxuICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICB3aWxsRW1pdENsb3NlID0gZmFsc2VcbiAgICB9XG4gICAgaWYgKHdpbGxFbWl0Q2xvc2UgJiYgKCFzdHJlYW0ud3JpdGFibGUgfHwgd3JpdGFibGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCF3cml0YWJsZSB8fCB3cml0YWJsZUZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25lcnJvciA9IChlcnIpID0+IHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKVxuICB9XG4gIGxldCBjbG9zZWQgPSBpc0Nsb3NlZChzdHJlYW0pXG4gIGNvbnN0IG9uY2xvc2UgPSAoKSA9PiB7XG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNvbnN0IGVycm9yZWQgPSBpc1dyaXRhYmxlRXJyb3JlZChzdHJlYW0pIHx8IGlzUmVhZGFibGVFcnJvcmVkKHN0cmVhbSlcbiAgICBpZiAoZXJyb3JlZCAmJiB0eXBlb2YgZXJyb3JlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycm9yZWQpXG4gICAgfVxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVGaW5pc2hlZCAmJiBpc1JlYWRhYmxlTm9kZVN0cmVhbShzdHJlYW0sIHRydWUpKSB7XG4gICAgICBpZiAoIWlzUmVhZGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKSlcbiAgICB9XG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUZpbmlzaGVkKSB7XG4gICAgICBpZiAoIWlzV3JpdGFibGVGaW5pc2hlZChzdHJlYW0sIGZhbHNlKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKSlcbiAgICB9XG4gICAgY2FsbGJhY2suY2FsbChzdHJlYW0pXG4gIH1cbiAgY29uc3Qgb25jbG9zZWQgPSAoKSA9PiB7XG4gICAgY2xvc2VkID0gdHJ1ZVxuICAgIGNvbnN0IGVycm9yZWQgPSBpc1dyaXRhYmxlRXJyb3JlZChzdHJlYW0pIHx8IGlzUmVhZGFibGVFcnJvcmVkKHN0cmVhbSlcbiAgICBpZiAoZXJyb3JlZCAmJiB0eXBlb2YgZXJyb3JlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycm9yZWQpXG4gICAgfVxuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtKVxuICB9XG4gIGNvbnN0IG9ucmVxdWVzdCA9ICgpID0+IHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgfVxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpXG4gICAgaWYgKCF3aWxsRW1pdENsb3NlKSB7XG4gICAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSlcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5yZXEpIHtcbiAgICAgIG9ucmVxdWVzdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdClcbiAgICB9XG4gIH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdTdGF0ZSkge1xuICAgIC8vIGxlZ2FjeSBzdHJlYW1zXG4gICAgc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaClcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpXG4gIH1cblxuICAvLyBOb3QgYWxsIHN0cmVhbXMgd2lsbCBlbWl0ICdjbG9zZScgYWZ0ZXIgJ2Fib3J0ZWQnLlxuICBpZiAoIXdpbGxFbWl0Q2xvc2UgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICBzdHJlYW0ub24oJ2Fib3J0ZWQnLCBvbmNsb3NlKVxuICB9XG4gIHN0cmVhbS5vbignZW5kJywgb25lbmQpXG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpXG4gIGlmIChvcHRpb25zLmVycm9yICE9PSBmYWxzZSkge1xuICAgIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKVxuICB9XG4gIHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKVxuICBpZiAoY2xvc2VkKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlKVxuICB9IGVsc2UgaWYgKFxuICAgICh3U3RhdGUgIT09IG51bGwgJiYgd1N0YXRlICE9PSB1bmRlZmluZWQgJiYgd1N0YXRlLmVycm9yRW1pdHRlZCkgfHxcbiAgICAoclN0YXRlICE9PSBudWxsICYmIHJTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHJTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICkge1xuICAgIGlmICghd2lsbEVtaXRDbG9zZSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlZClcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgIXJlYWRhYmxlICYmXG4gICAgKCF3aWxsRW1pdENsb3NlIHx8IGlzUmVhZGFibGUoc3RyZWFtKSkgJiZcbiAgICAod3JpdGFibGVGaW5pc2hlZCB8fCBpc1dyaXRhYmxlKHN0cmVhbSkgPT09IGZhbHNlKVxuICApIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG9uY2xvc2VkKVxuICB9IGVsc2UgaWYgKFxuICAgICF3cml0YWJsZSAmJlxuICAgICghd2lsbEVtaXRDbG9zZSB8fCBpc1dyaXRhYmxlKHN0cmVhbSkpICYmXG4gICAgKHJlYWRhYmxlRmluaXNoZWQgfHwgaXNSZWFkYWJsZShzdHJlYW0pID09PSBmYWxzZSlcbiAgKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhvbmNsb3NlZClcbiAgfSBlbHNlIGlmIChyU3RhdGUgJiYgc3RyZWFtLnJlcSAmJiBzdHJlYW0uYWJvcnRlZCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25jbG9zZWQpXG4gIH1cbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICBjYWxsYmFjayA9IG5vcFxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnRlZCcsIG9uY2xvc2UpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdClcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpXG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICB9XG4gIGlmIChvcHRpb25zLnNpZ25hbCAmJiAhY2xvc2VkKSB7XG4gICAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgICAvLyBLZWVwIGl0IGJlY2F1c2UgY2xlYW51cCByZW1vdmVzIGl0LlxuICAgICAgY29uc3QgZW5kQ2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgY2xlYW51cCgpXG4gICAgICBlbmRDYWxsYmFjay5jYWxsKFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG5ldyBBYm9ydEVycm9yKHVuZGVmaW5lZCwge1xuICAgICAgICAgIGNhdXNlOiBvcHRpb25zLnNpZ25hbC5yZWFzb25cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soYWJvcnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZEFib3J0TGlzdGVuZXIgPSBhZGRBYm9ydExpc3RlbmVyIHx8IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLmFkZEFib3J0TGlzdGVuZXJcbiAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBhZGRBYm9ydExpc3RlbmVyKG9wdGlvbnMuc2lnbmFsLCBhYm9ydClcbiAgICAgIGNvbnN0IG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFja1xuICAgICAgY2FsbGJhY2sgPSBvbmNlKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGRpc3Bvc2FibGVbU3ltYm9sRGlzcG9zZV0oKVxuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmFwcGx5KHN0cmVhbSwgYXJncylcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIHJldHVybiBjbGVhbnVwXG59XG5mdW5jdGlvbiBlb3NXZWIoc3RyZWFtLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBsZXQgaXNBYm9ydGVkID0gZmFsc2VcbiAgbGV0IGFib3J0ID0gbm9wXG4gIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgIGFib3J0ID0gKCkgPT4ge1xuICAgICAgaXNBYm9ydGVkID0gdHJ1ZVxuICAgICAgY2FsbGJhY2suY2FsbChcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFib3J0KVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRBYm9ydExpc3RlbmVyID0gYWRkQWJvcnRMaXN0ZW5lciB8fCByZXF1aXJlKCcuLi8uLi9vdXJzL3V0aWwnKS5hZGRBYm9ydExpc3RlbmVyXG4gICAgICBjb25zdCBkaXNwb3NhYmxlID0gYWRkQWJvcnRMaXN0ZW5lcihvcHRpb25zLnNpZ25hbCwgYWJvcnQpXG4gICAgICBjb25zdCBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gb25jZSgoLi4uYXJncykgPT4ge1xuICAgICAgICBkaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKClcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5hcHBseShzdHJlYW0sIGFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBjb25zdCByZXNvbHZlckZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoIWlzQWJvcnRlZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBjYWxsYmFjay5hcHBseShzdHJlYW0sIGFyZ3MpKVxuICAgIH1cbiAgfVxuICBQcm9taXNlUHJvdG90eXBlVGhlbihzdHJlYW1ba0lzQ2xvc2VkUHJvbWlzZV0ucHJvbWlzZSwgcmVzb2x2ZXJGbiwgcmVzb2x2ZXJGbilcbiAgcmV0dXJuIG5vcFxufVxuZnVuY3Rpb24gZmluaXNoZWQoc3RyZWFtLCBvcHRzKSB7XG4gIHZhciBfb3B0c1xuICBsZXQgYXV0b0NsZWFudXAgPSBmYWxzZVxuICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgIG9wdHMgPSBrRW1wdHlPYmplY3RcbiAgfVxuICBpZiAoKF9vcHRzID0gb3B0cykgIT09IG51bGwgJiYgX29wdHMgIT09IHVuZGVmaW5lZCAmJiBfb3B0cy5jbGVhbnVwKSB7XG4gICAgdmFsaWRhdGVCb29sZWFuKG9wdHMuY2xlYW51cCwgJ2NsZWFudXAnKVxuICAgIGF1dG9DbGVhbnVwID0gb3B0cy5jbGVhbnVwXG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwID0gZW9zKHN0cmVhbSwgb3B0cywgKGVycikgPT4ge1xuICAgICAgaWYgKGF1dG9DbGVhbnVwKSB7XG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfVxuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0gZW9zXG5tb2R1bGUuZXhwb3J0cy5maW5pc2hlZCA9IGZpbmlzaGVkXG4iLCIndXNlIHN0cmljdCdcblxuLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG5cbmNvbnN0IHtcbiAgYWdncmVnYXRlVHdvRXJyb3JzLFxuICBjb2RlczogeyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgfSxcbiAgQWJvcnRFcnJvclxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgU3ltYm9sIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsga0lzRGVzdHJveWVkLCBpc0Rlc3Ryb3llZCwgaXNGaW5pc2hlZCwgaXNTZXJ2ZXJSZXF1ZXN0IH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGtEZXN0cm95ID0gU3ltYm9sKCdrRGVzdHJveScpXG5jb25zdCBrQ29uc3RydWN0ID0gU3ltYm9sKCdrQ29uc3RydWN0JylcbmZ1bmN0aW9uIGNoZWNrRXJyb3IoZXJyLCB3LCByKSB7XG4gIGlmIChlcnIpIHtcbiAgICAvLyBBdm9pZCBWOCBsZWFrLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDEwMyNpc3N1ZWNvbW1lbnQtNjUyMDAyMzY0XG4gICAgZXJyLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICBpZiAodyAmJiAhdy5lcnJvcmVkKSB7XG4gICAgICB3LmVycm9yZWQgPSBlcnJcbiAgICB9XG4gICAgaWYgKHIgJiYgIXIuZXJyb3JlZCkge1xuICAgICAgci5lcnJvcmVkID0gZXJyXG4gICAgfVxuICB9XG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXQuIGNiKCkgaXMgdW5kb2N1bWVudGVkIGFuZCB1bnVzZWQgaW4gY29yZSBidXRcbi8vIHVuZm9ydHVuYXRlbHkgbWlnaHQgYmUgdXNlZCBieSBtb2R1bGVzLlxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIGNvbnN0IHIgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIC8vIFdpdGggZHVwbGV4IHN0cmVhbXMgd2UgdXNlIHRoZSB3cml0YWJsZSBzaWRlIGZvciBzdGF0ZS5cbiAgY29uc3QgcyA9IHcgfHwgclxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZGVzdHJveWVkKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5kZXN0cm95ZWQpKSB7XG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gV2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuICBjaGVja0Vycm9yKGVyciwgdywgcilcbiAgaWYgKHcpIHtcbiAgICB3LmRlc3Ryb3llZCA9IHRydWVcbiAgfVxuICBpZiAocikge1xuICAgIHIuZGVzdHJveWVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc3RpbGwgY29uc3RydWN0aW5nIHRoZW4gZGVmZXIgY2FsbGluZyBfZGVzdHJveS5cbiAgaWYgKCFzLmNvbnN0cnVjdGVkKSB7XG4gICAgdGhpcy5vbmNlKGtEZXN0cm95LCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIF9kZXN0cm95KHRoaXMsIGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlciwgZXJyKSwgY2IpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBfZGVzdHJveSh0aGlzLCBlcnIsIGNiKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5mdW5jdGlvbiBfZGVzdHJveShzZWxmLCBlcnIsIGNiKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbkRlc3Ryb3koZXJyKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWVcbiAgICBjb25zdCByID0gc2VsZi5fcmVhZGFibGVTdGF0ZVxuICAgIGNvbnN0IHcgPSBzZWxmLl93cml0YWJsZVN0YXRlXG4gICAgY2hlY2tFcnJvcihlcnIsIHcsIHIpXG4gICAgaWYgKHcpIHtcbiAgICAgIHcuY2xvc2VkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAocikge1xuICAgICAgci5jbG9zZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gICAgaWYgKGVycikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JDbG9zZU5ULCBzZWxmLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIHNlbGYpXG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIgfHwgbnVsbCwgb25EZXN0cm95KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBvbkRlc3Ryb3koZXJyKVxuICB9XG59XG5mdW5jdGlvbiBlbWl0RXJyb3JDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpXG4gIGVtaXRDbG9zZU5UKHNlbGYpXG59XG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGNvbnN0IHIgPSBzZWxmLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSBzZWxmLl93cml0YWJsZVN0YXRlXG4gIGlmICh3KSB7XG4gICAgdy5jbG9zZUVtaXR0ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKHIpIHtcbiAgICByLmNsb3NlRW1pdHRlZCA9IHRydWVcbiAgfVxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZW1pdENsb3NlKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5lbWl0Q2xvc2UpKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBjb25zdCByID0gc2VsZi5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gc2VsZi5fd3JpdGFibGVTdGF0ZVxuICBpZiAoKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuZXJyb3JFbWl0dGVkKSB8fCAociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5lcnJvckVtaXR0ZWQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHcpIHtcbiAgICB3LmVycm9yRW1pdHRlZCA9IHRydWVcbiAgfVxuICBpZiAocikge1xuICAgIHIuZXJyb3JFbWl0dGVkID0gdHJ1ZVxuICB9XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG59XG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGNvbnN0IHIgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IHcgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIGlmIChyKSB7XG4gICAgci5jb25zdHJ1Y3RlZCA9IHRydWVcbiAgICByLmNsb3NlZCA9IGZhbHNlXG4gICAgci5jbG9zZUVtaXR0ZWQgPSBmYWxzZVxuICAgIHIuZGVzdHJveWVkID0gZmFsc2VcbiAgICByLmVycm9yZWQgPSBudWxsXG4gICAgci5lcnJvckVtaXR0ZWQgPSBmYWxzZVxuICAgIHIucmVhZGluZyA9IGZhbHNlXG4gICAgci5lbmRlZCA9IHIucmVhZGFibGUgPT09IGZhbHNlXG4gICAgci5lbmRFbWl0dGVkID0gci5yZWFkYWJsZSA9PT0gZmFsc2VcbiAgfVxuICBpZiAodykge1xuICAgIHcuY29uc3RydWN0ZWQgPSB0cnVlXG4gICAgdy5kZXN0cm95ZWQgPSBmYWxzZVxuICAgIHcuY2xvc2VkID0gZmFsc2VcbiAgICB3LmNsb3NlRW1pdHRlZCA9IGZhbHNlXG4gICAgdy5lcnJvcmVkID0gbnVsbFxuICAgIHcuZXJyb3JFbWl0dGVkID0gZmFsc2VcbiAgICB3LmZpbmFsQ2FsbGVkID0gZmFsc2VcbiAgICB3LnByZWZpbmlzaGVkID0gZmFsc2VcbiAgICB3LmVuZGVkID0gdy53cml0YWJsZSA9PT0gZmFsc2VcbiAgICB3LmVuZGluZyA9IHcud3JpdGFibGUgPT09IGZhbHNlXG4gICAgdy5maW5pc2hlZCA9IHcud3JpdGFibGUgPT09IGZhbHNlXG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyLCBzeW5jKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG5cbiAgY29uc3QgciA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3ID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGlmICgodyAhPT0gbnVsbCAmJiB3ICE9PSB1bmRlZmluZWQgJiYgdy5kZXN0cm95ZWQpIHx8IChyICE9PSBudWxsICYmIHIgIT09IHVuZGVmaW5lZCAmJiByLmRlc3Ryb3llZCkpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGlmICgociAhPT0gbnVsbCAmJiByICE9PSB1bmRlZmluZWQgJiYgci5hdXRvRGVzdHJveSkgfHwgKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcuYXV0b0Rlc3Ryb3kpKVxuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgZWxzZSBpZiAoZXJyKSB7XG4gICAgLy8gQXZvaWQgVjggbGVhaywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzQxMDMjaXNzdWVjb21tZW50LTY1MjAwMjM2NFxuICAgIGVyci5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgaWYgKHcgJiYgIXcuZXJyb3JlZCkge1xuICAgICAgdy5lcnJvcmVkID0gZXJyXG4gICAgfVxuICAgIGlmIChyICYmICFyLmVycm9yZWQpIHtcbiAgICAgIHIuZXJyb3JlZCA9IGVyclxuICAgIH1cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgc3RyZWFtLCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvck5UKHN0cmVhbSwgZXJyKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29uc3RydWN0KHN0cmVhbSwgY2IpIHtcbiAgaWYgKHR5cGVvZiBzdHJlYW0uX2NvbnN0cnVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHIgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgY29uc3QgdyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAocikge1xuICAgIHIuY29uc3RydWN0ZWQgPSBmYWxzZVxuICB9XG4gIGlmICh3KSB7XG4gICAgdy5jb25zdHJ1Y3RlZCA9IGZhbHNlXG4gIH1cbiAgc3RyZWFtLm9uY2Uoa0NvbnN0cnVjdCwgY2IpXG4gIGlmIChzdHJlYW0ubGlzdGVuZXJDb3VudChrQ29uc3RydWN0KSA+IDEpIHtcbiAgICAvLyBEdXBsZXhcbiAgICByZXR1cm5cbiAgfVxuICBwcm9jZXNzLm5leHRUaWNrKGNvbnN0cnVjdE5ULCBzdHJlYW0pXG59XG5mdW5jdGlvbiBjb25zdHJ1Y3ROVChzdHJlYW0pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gIGZ1bmN0aW9uIG9uQ29uc3RydWN0KGVycikge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkID8gZXJyIDogbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWVcbiAgICBjb25zdCByID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gICAgY29uc3QgdyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICAgIGNvbnN0IHMgPSB3IHx8IHJcbiAgICBpZiAocikge1xuICAgICAgci5jb25zdHJ1Y3RlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKHcpIHtcbiAgICAgIHcuY29uc3RydWN0ZWQgPSB0cnVlXG4gICAgfVxuICAgIGlmIChzLmRlc3Ryb3llZCkge1xuICAgICAgc3RyZWFtLmVtaXQoa0Rlc3Ryb3ksIGVycilcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENvbnN0cnVjdE5ULCBzdHJlYW0pXG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgc3RyZWFtLl9jb25zdHJ1Y3QoKGVycikgPT4ge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkNvbnN0cnVjdCwgZXJyKVxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHByb2Nlc3MubmV4dFRpY2sob25Db25zdHJ1Y3QsIGVycilcbiAgfVxufVxuZnVuY3Rpb24gZW1pdENvbnN0cnVjdE5UKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdChrQ29uc3RydWN0KVxufVxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gKHN0cmVhbSA9PT0gbnVsbCB8fCBzdHJlYW0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHN0cmVhbS5zZXRIZWFkZXIpICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbidcbn1cbmZ1bmN0aW9uIGVtaXRDbG9zZUxlZ2FjeShzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbn1cbmZ1bmN0aW9uIGVtaXRFcnJvckNsb3NlTGVnYWN5KHN0cmVhbSwgZXJyKSB7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VMZWdhY3ksIHN0cmVhbSlcbn1cblxuLy8gTm9ybWFsaXplIGRlc3Ryb3kgZm9yIGxlZ2FjeS5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIGVycikge1xuICBpZiAoIXN0cmVhbSB8fCBpc0Rlc3Ryb3llZChzdHJlYW0pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFlcnIgJiYgIWlzRmluaXNoZWQoc3RyZWFtKSkge1xuICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgfVxuXG4gIC8vIFRPRE86IFJlbW92ZSBpc1JlcXVlc3QgYnJhbmNoZXMuXG4gIGlmIChpc1NlcnZlclJlcXVlc3Qoc3RyZWFtKSkge1xuICAgIHN0cmVhbS5zb2NrZXQgPSBudWxsXG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9IGVsc2UgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLmFib3J0KClcbiAgfSBlbHNlIGlmIChpc1JlcXVlc3Qoc3RyZWFtLnJlcSkpIHtcbiAgICBzdHJlYW0ucmVxLmFib3J0KClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbS5jbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRPRE86IERvbid0IGxvc2UgZXJyP1xuICAgIHN0cmVhbS5jbG9zZSgpXG4gIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JDbG9zZUxlZ2FjeSwgc3RyZWFtLCBlcnIpXG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VMZWdhY3ksIHN0cmVhbSlcbiAgfVxuICBpZiAoIXN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICBzdHJlYW1ba0lzRGVzdHJveWVkXSA9IHRydWVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnN0cnVjdCxcbiAgZGVzdHJveWVyLFxuICBkZXN0cm95LFxuICB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95XG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBBcnJheUlzQXJyYXksIE9iamVjdFNldFByb3RvdHlwZU9mIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmZ1bmN0aW9uIFN0cmVhbShvcHRzKSB7XG4gIEVFLmNhbGwodGhpcywgb3B0cylcbn1cbk9iamVjdFNldFByb3RvdHlwZU9mKFN0cmVhbS5wcm90b3R5cGUsIEVFLnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKFN0cmVhbSwgRUUpXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2UgPSB0aGlzXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlICYmIGRlc3Qud3JpdGUoY2h1bmspID09PSBmYWxzZSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgIHNvdXJjZS5wYXVzZSgpXG4gICAgfVxuICB9XG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSlcbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pXG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZClcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSlcbiAgfVxuICBsZXQgZGlkT25FbmQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVyblxuICAgIGRpZE9uRW5kID0gdHJ1ZVxuICAgIGRlc3QuZW5kKClcbiAgfVxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuXG4gICAgZGlkT25FbmQgPSB0cnVlXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpXG4gIH1cblxuICAvLyBEb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKClcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxuICBwcmVwZW5kTGlzdGVuZXIoc291cmNlLCAnZXJyb3InLCBvbmVycm9yKVxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcilcblxuICAvLyBSZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKVxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cClcbiAgfVxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApXG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKVxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSlcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdFxufVxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbilcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKVxuICBlbHNlIGlmIChBcnJheUlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbilcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN0cmVhbSxcbiAgcHJlcGVuZExpc3RlbmVyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBTeW1ib2xEaXNwb3NlIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbmNvbnN0IHsgQWJvcnRFcnJvciwgY29kZXMgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IHsgaXNOb2RlU3RyZWFtLCBpc1dlYlN0cmVhbSwga0NvbnRyb2xsZXJFcnJvckZ1bmN0aW9uIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpXG5jb25zdCB7IEVSUl9JTlZBTElEX0FSR19UWVBFIH0gPSBjb2Rlc1xubGV0IGFkZEFib3J0TGlzdGVuZXJcblxuLy8gVGhpcyBtZXRob2QgaXMgaW5saW5lZCBoZXJlIGZvciByZWFkYWJsZS1zdHJlYW1cbi8vIEl0IGFsc28gZG9lcyBub3QgYWxsb3cgZm9yIHNpZ25hbCB0byBub3QgZXhpc3Qgb24gdGhlIHN0cmVhbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzYwNjEjZGlzY3Vzc2lvbl9yNTMzNzE4MDI5XG5jb25zdCB2YWxpZGF0ZUFib3J0U2lnbmFsID0gKHNpZ25hbCwgbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnQWJvcnRTaWduYWwnLCBzaWduYWwpXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsID0gZnVuY3Rpb24gYWRkQWJvcnRTaWduYWwoc2lnbmFsLCBzdHJlYW0pIHtcbiAgdmFsaWRhdGVBYm9ydFNpZ25hbChzaWduYWwsICdzaWduYWwnKVxuICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW0pICYmICFpc1dlYlN0cmVhbShzdHJlYW0pKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdzdHJlYW0nLCBbJ1JlYWRhYmxlU3RyZWFtJywgJ1dyaXRhYmxlU3RyZWFtJywgJ1N0cmVhbSddLCBzdHJlYW0pXG4gIH1cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsTm9WYWxpZGF0ZShzaWduYWwsIHN0cmVhbSlcbn1cbm1vZHVsZS5leHBvcnRzLmFkZEFib3J0U2lnbmFsTm9WYWxpZGF0ZSA9IGZ1bmN0aW9uIChzaWduYWwsIHN0cmVhbSkge1xuICBpZiAodHlwZW9mIHNpZ25hbCAhPT0gJ29iamVjdCcgfHwgISgnYWJvcnRlZCcgaW4gc2lnbmFsKSkge1xuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICBjb25zdCBvbkFib3J0ID0gaXNOb2RlU3RyZWFtKHN0cmVhbSlcbiAgICA/ICgpID0+IHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koXG4gICAgICAgICAgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBjYXVzZTogc2lnbmFsLnJlYXNvblxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA6ICgpID0+IHtcbiAgICAgICAgc3RyZWFtW2tDb250cm9sbGVyRXJyb3JGdW5jdGlvbl0oXG4gICAgICAgICAgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBjYXVzZTogc2lnbmFsLnJlYXNvblxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgb25BYm9ydCgpXG4gIH0gZWxzZSB7XG4gICAgYWRkQWJvcnRMaXN0ZW5lciA9IGFkZEFib3J0TGlzdGVuZXIgfHwgcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuYWRkQWJvcnRMaXN0ZW5lclxuICAgIGNvbnN0IGRpc3Bvc2FibGUgPSBhZGRBYm9ydExpc3RlbmVyKHNpZ25hbCwgb25BYm9ydClcbiAgICBlb3Moc3RyZWFtLCBkaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFN0cmluZ1Byb3RvdHlwZVNsaWNlLCBTeW1ib2xJdGVyYXRvciwgVHlwZWRBcnJheVByb3RvdHlwZVNldCwgVWludDhBcnJheSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJylcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQnVmZmVyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgICB0aGlzLnRhaWwgPSBudWxsXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgcHVzaCh2KSB7XG4gICAgY29uc3QgZW50cnkgPSB7XG4gICAgICBkYXRhOiB2LFxuICAgICAgbmV4dDogbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5XG4gICAgZWxzZSB0aGlzLmhlYWQgPSBlbnRyeVxuICAgIHRoaXMudGFpbCA9IGVudHJ5XG4gICAgKyt0aGlzLmxlbmd0aFxuICB9XG4gIHVuc2hpZnQodikge1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgZGF0YTogdixcbiAgICAgIG5leHQ6IHRoaXMuaGVhZFxuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5XG4gICAgdGhpcy5oZWFkID0gZW50cnlcbiAgICArK3RoaXMubGVuZ3RoXG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCByZXQgPSB0aGlzLmhlYWQuZGF0YVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICAgIGVsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgICAtLXRoaXMubGVuZ3RoXG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgfVxuICBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJ1xuICAgIGxldCBwID0gdGhpcy5oZWFkXG4gICAgbGV0IHJldCA9ICcnICsgcC5kYXRhXG4gICAgd2hpbGUgKChwID0gcC5uZXh0KSAhPT0gbnVsbCkgcmV0ICs9IHMgKyBwLmRhdGFcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICBjb25zdCByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMClcbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChwKSB7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHJldCwgcC5kYXRhLCBpKVxuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoXG4gICAgICBwID0gcC5uZXh0XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmhlYWQuZGF0YVxuICAgIGlmIChuIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICBjb25zdCBzbGljZSA9IGRhdGEuc2xpY2UoMCwgbilcbiAgICAgIHRoaXMuaGVhZC5kYXRhID0gZGF0YS5zbGljZShuKVxuICAgICAgcmV0dXJuIHNsaWNlXG4gICAgfVxuICAgIGlmIChuID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgcmV0dXJuIHRoaXMuc2hpZnQoKVxuICAgIH1cbiAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgcmV0dXJuIGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobilcbiAgfVxuICBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGFcbiAgfVxuICAqW1N5bWJvbEl0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGxldCBwID0gdGhpcy5oZWFkOyBwOyBwID0gcC5uZXh0KSB7XG4gICAgICB5aWVsZCBwLmRhdGFcbiAgICB9XG4gIH1cblxuICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICBfZ2V0U3RyaW5nKG4pIHtcbiAgICBsZXQgcmV0ID0gJydcbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCBjID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ciA9IHAuZGF0YVxuICAgICAgaWYgKG4gPiBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldCArPSBzdHJcbiAgICAgICAgbiAtPSBzdHIubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgIHJldCArPSBzdHJcbiAgICAgICAgICArK2NcbiAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHRcbiAgICAgICAgICBlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgKz0gU3RyaW5nUHJvdG90eXBlU2xpY2Uoc3RyLCAwLCBuKVxuICAgICAgICAgIHRoaXMuaGVhZCA9IHBcbiAgICAgICAgICBwLmRhdGEgPSBTdHJpbmdQcm90b3R5cGVTbGljZShzdHIsIG4pXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgICsrY1xuICAgIH0gd2hpbGUgKChwID0gcC5uZXh0KSAhPT0gbnVsbClcbiAgICB0aGlzLmxlbmd0aCAtPSBjXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gIF9nZXRCdWZmZXIobikge1xuICAgIGNvbnN0IHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKVxuICAgIGNvbnN0IHJldExlbiA9IG5cbiAgICBsZXQgcCA9IHRoaXMuaGVhZFxuICAgIGxldCBjID0gMFxuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHAuZGF0YVxuICAgICAgaWYgKG4gPiBidWYubGVuZ3RoKSB7XG4gICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQocmV0LCBidWYsIHJldExlbiAtIG4pXG4gICAgICAgIG4gLT0gYnVmLmxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG4gPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICBUeXBlZEFycmF5UHJvdG90eXBlU2V0KHJldCwgYnVmLCByZXRMZW4gLSBuKVxuICAgICAgICAgICsrY1xuICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dFxuICAgICAgICAgIGVsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGVTZXQocmV0LCBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIHJldExlbiAtIG4pXG4gICAgICAgICAgdGhpcy5oZWFkID0gcFxuICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICArK2NcbiAgICB9IHdoaWxlICgocCA9IHAubmV4dCkgIT09IG51bGwpXG4gICAgdGhpcy5sZW5ndGggLT0gY1xuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG4gIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXShfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3BlY3QodGhpcywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICBkZXB0aDogMCxcbiAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgTWF0aEZsb29yLCBOdW1iZXJJc0ludGVnZXIgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyB2YWxpZGF0ZUludGVnZXIgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3QgeyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJykuY29kZXNcbmxldCBkZWZhdWx0SGlnaFdhdGVyTWFya0J5dGVzID0gMTYgKiAxMDI0XG5sZXQgZGVmYXVsdEhpZ2hXYXRlck1hcmtPYmplY3RNb2RlID0gMTZcbmZ1bmN0aW9uIGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpIHtcbiAgcmV0dXJuIG9wdGlvbnMuaGlnaFdhdGVyTWFyayAhPSBudWxsID8gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrIDogaXNEdXBsZXggPyBvcHRpb25zW2R1cGxleEtleV0gOiBudWxsXG59XG5mdW5jdGlvbiBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayhvYmplY3RNb2RlKSB7XG4gIHJldHVybiBvYmplY3RNb2RlID8gZGVmYXVsdEhpZ2hXYXRlck1hcmtPYmplY3RNb2RlIDogZGVmYXVsdEhpZ2hXYXRlck1hcmtCeXRlc1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsob2JqZWN0TW9kZSwgdmFsdWUpIHtcbiAgdmFsaWRhdGVJbnRlZ2VyKHZhbHVlLCAndmFsdWUnLCAwKVxuICBpZiAob2JqZWN0TW9kZSkge1xuICAgIGRlZmF1bHRIaWdoV2F0ZXJNYXJrT2JqZWN0TW9kZSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgZGVmYXVsdEhpZ2hXYXRlck1hcmtCeXRlcyA9IHZhbHVlXG4gIH1cbn1cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgY29uc3QgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSlcbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXJJc0ludGVnZXIoaHdtKSB8fCBod20gPCAwKSB7XG4gICAgICBjb25zdCBuYW1lID0gaXNEdXBsZXggPyBgb3B0aW9ucy4ke2R1cGxleEtleX1gIDogJ29wdGlvbnMuaGlnaFdhdGVyTWFyaydcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUobmFtZSwgaHdtKVxuICAgIH1cbiAgICByZXR1cm4gTWF0aEZsb29yKGh3bSlcbiAgfVxuXG4gIC8vIERlZmF1bHQgdmFsdWVcbiAgcmV0dXJuIGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKHN0YXRlLm9iamVjdE1vZGUpXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyayxcbiAgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmssXG4gIHNldERlZmF1bHRIaWdoV2F0ZXJNYXJrXG59XG4iLCIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwiJ3VzZSBzdHJpY3QnXG5cbi8qIHJlcGxhY2VtZW50IHN0YXJ0ICovXG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzLycpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuXG5jb25zdCB7IFByb21pc2VQcm90b3R5cGVUaGVuLCBTeW1ib2xBc3luY0l0ZXJhdG9yLCBTeW1ib2xJdGVyYXRvciB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgRVJSX0lOVkFMSURfQVJHX1RZUEUsIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJykuY29kZXNcbmZ1bmN0aW9uIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKSB7XG4gIGxldCBpdGVyYXRvclxuICBpZiAodHlwZW9mIGl0ZXJhYmxlID09PSAnc3RyaW5nJyB8fCBpdGVyYWJsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgUmVhZGFibGUoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIC4uLm9wdHMsXG4gICAgICByZWFkKCkge1xuICAgICAgICB0aGlzLnB1c2goaXRlcmFibGUpXG4gICAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgbGV0IGlzQXN5bmNcbiAgaWYgKGl0ZXJhYmxlICYmIGl0ZXJhYmxlW1N5bWJvbEFzeW5jSXRlcmF0b3JdKSB7XG4gICAgaXNBc3luYyA9IHRydWVcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbEFzeW5jSXRlcmF0b3JdKClcbiAgfSBlbHNlIGlmIChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2xJdGVyYXRvcl0pIHtcbiAgICBpc0FzeW5jID0gZmFsc2VcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbEl0ZXJhdG9yXSgpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdpdGVyYWJsZScsIFsnSXRlcmFibGUnXSwgaXRlcmFibGUpXG4gIH1cbiAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGUoe1xuICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgaGlnaFdhdGVyTWFyazogMSxcbiAgICAvLyBUT0RPKHJvbmFnKTogV2hhdCBvcHRpb25zIHNob3VsZCBiZSBhbGxvd2VkP1xuICAgIC4uLm9wdHNcbiAgfSlcblxuICAvLyBGbGFnIHRvIHByb3RlY3QgYWdhaW5zdCBfcmVhZFxuICAvLyBiZWluZyBjYWxsZWQgYmVmb3JlIGxhc3QgaXRlcmF0aW9uIGNvbXBsZXRpb24uXG4gIGxldCByZWFkaW5nID0gZmFsc2VcbiAgcmVhZGFibGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFyZWFkaW5nKSB7XG4gICAgICByZWFkaW5nID0gdHJ1ZVxuICAgICAgbmV4dCgpXG4gICAgfVxuICB9XG4gIHJlYWRhYmxlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVycm9yLCBjYikge1xuICAgIFByb21pc2VQcm90b3R5cGVUaGVuKFxuICAgICAgY2xvc2UoZXJyb3IpLFxuICAgICAgKCkgPT4gcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyb3IpLFxuICAgICAgLy8gbmV4dFRpY2sgaXMgaGVyZSBpbiBjYXNlIGNiIHRocm93c1xuICAgICAgKGUpID0+IHByb2Nlc3MubmV4dFRpY2soY2IsIGUgfHwgZXJyb3IpXG4gICAgKVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNsb3NlKGVycm9yKSB7XG4gICAgY29uc3QgaGFkRXJyb3IgPSBlcnJvciAhPT0gdW5kZWZpbmVkICYmIGVycm9yICE9PSBudWxsXG4gICAgY29uc3QgaGFzVGhyb3cgPSB0eXBlb2YgaXRlcmF0b3IudGhyb3cgPT09ICdmdW5jdGlvbidcbiAgICBpZiAoaGFkRXJyb3IgJiYgaGFzVGhyb3cpIHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGl0ZXJhdG9yLnRocm93KGVycm9yKVxuICAgICAgYXdhaXQgdmFsdWVcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIGF3YWl0IHZhbHVlXG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaXNBc3luYyA/IGF3YWl0IGl0ZXJhdG9yLm5leHQoKSA6IGl0ZXJhdG9yLm5leHQoKVxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIHJlYWRhYmxlLnB1c2gobnVsbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXMgPSB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IGF3YWl0IHZhbHVlIDogdmFsdWVcbiAgICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkaW5nID0gZmFsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKClcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlYWRhYmxlLnB1c2gocmVzKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVhZGFibGUuZGVzdHJveShlcnIpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVhZGFibGVcbn1cbm1vZHVsZS5leHBvcnRzID0gZnJvbVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0J1xuXG4vKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuY29uc3Qge1xuICBBcnJheVByb3RvdHlwZUluZGV4T2YsXG4gIE51bWJlcklzSW50ZWdlcixcbiAgTnVtYmVySXNOYU4sXG4gIE51bWJlclBhcnNlSW50LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzLFxuICBPYmplY3RLZXlzLFxuICBPYmplY3RTZXRQcm90b3R5cGVPZixcbiAgUHJvbWlzZSxcbiAgU2FmZVNldCxcbiAgU3ltYm9sQXN5bmNEaXNwb3NlLFxuICBTeW1ib2xBc3luY0l0ZXJhdG9yLFxuICBTeW1ib2xcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGVcblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlXG5jb25zdCB7IEV2ZW50RW1pdHRlcjogRUUgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCB7IFN0cmVhbSwgcHJlcGVuZExpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2xlZ2FjeScpXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgYWRkQWJvcnRTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWRkLWFib3J0LXNpZ25hbCcpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxubGV0IGRlYnVnID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuZGVidWdsb2coJ3N0cmVhbScsIChmbikgPT4ge1xuICBkZWJ1ZyA9IGZuXG59KVxuY29uc3QgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vYnVmZmVyX2xpc3QnKVxuY29uc3QgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2Rlc3Ryb3knKVxuY29uc3QgeyBnZXRIaWdoV2F0ZXJNYXJrLCBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpXG5jb25zdCB7XG4gIGFnZ3JlZ2F0ZVR3b0Vycm9ycyxcbiAgY29kZXM6IHtcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfT1VUX09GX1JBTkdFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVFxuICB9LFxuICBBYm9ydEVycm9yXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9lcnJvcnMnKVxuY29uc3QgeyB2YWxpZGF0ZU9iamVjdCB9ID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpXG5jb25zdCBrUGF1c2VkID0gU3ltYm9sKCdrUGF1c2VkJylcbmNvbnN0IHsgU3RyaW5nRGVjb2RlciB9ID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJylcbmNvbnN0IGZyb20gPSByZXF1aXJlKCcuL2Zyb20nKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUmVhZGFibGUucHJvdG90eXBlLCBTdHJlYW0ucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoUmVhZGFibGUsIFN0cmVhbSlcbmNvbnN0IG5vcCA9ICgpID0+IHt9XG5jb25zdCB7IGVycm9yT3JEZXN0cm95IH0gPSBkZXN0cm95SW1wbFxuY29uc3Qga09iamVjdE1vZGUgPSAxIDw8IDBcbmNvbnN0IGtFbmRlZCA9IDEgPDwgMVxuY29uc3Qga0VuZEVtaXR0ZWQgPSAxIDw8IDJcbmNvbnN0IGtSZWFkaW5nID0gMSA8PCAzXG5jb25zdCBrQ29uc3RydWN0ZWQgPSAxIDw8IDRcbmNvbnN0IGtTeW5jID0gMSA8PCA1XG5jb25zdCBrTmVlZFJlYWRhYmxlID0gMSA8PCA2XG5jb25zdCBrRW1pdHRlZFJlYWRhYmxlID0gMSA8PCA3XG5jb25zdCBrUmVhZGFibGVMaXN0ZW5pbmcgPSAxIDw8IDhcbmNvbnN0IGtSZXN1bWVTY2hlZHVsZWQgPSAxIDw8IDlcbmNvbnN0IGtFcnJvckVtaXR0ZWQgPSAxIDw8IDEwXG5jb25zdCBrRW1pdENsb3NlID0gMSA8PCAxMVxuY29uc3Qga0F1dG9EZXN0cm95ID0gMSA8PCAxMlxuY29uc3Qga0Rlc3Ryb3llZCA9IDEgPDwgMTNcbmNvbnN0IGtDbG9zZWQgPSAxIDw8IDE0XG5jb25zdCBrQ2xvc2VFbWl0dGVkID0gMSA8PCAxNVxuY29uc3Qga011bHRpQXdhaXREcmFpbiA9IDEgPDwgMTZcbmNvbnN0IGtSZWFkaW5nTW9yZSA9IDEgPDwgMTdcbmNvbnN0IGtEYXRhRW1pdHRlZCA9IDEgPDwgMThcblxuLy8gVE9ETyhiZW5qYW1pbmdyKSBpdCBpcyBsaWtlbHkgc2xvd2VyIHRvIGRvIGl0IHRoaXMgd2F5IHRoYW4gd2l0aCBmcmVlIGZ1bmN0aW9uc1xuZnVuY3Rpb24gbWFrZUJpdE1hcERlc2NyaXB0b3IoYml0KSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLnN0YXRlICYgYml0KSAhPT0gMFxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHRoaXMuc3RhdGUgfD0gYml0XG4gICAgICBlbHNlIHRoaXMuc3RhdGUgJj0gfmJpdFxuICAgIH1cbiAgfVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0YXRlLnByb3RvdHlwZSwge1xuICBvYmplY3RNb2RlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrT2JqZWN0TW9kZSksXG4gIGVuZGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW5kZWQpLFxuICBlbmRFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW5kRW1pdHRlZCksXG4gIHJlYWRpbmc6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkaW5nKSxcbiAgLy8gU3RyZWFtIGlzIHN0aWxsIGJlaW5nIGNvbnN0cnVjdGVkIGFuZCBjYW5ub3QgYmVcbiAgLy8gZGVzdHJveWVkIHVudGlsIGNvbnN0cnVjdGlvbiBmaW5pc2hlZCBvciBmYWlsZWQuXG4gIC8vIEFzeW5jIGNvbnN0cnVjdGlvbiBpcyBvcHQgaW4sIHRoZXJlZm9yZSB3ZSBzdGFydCBhc1xuICAvLyBjb25zdHJ1Y3RlZC5cbiAgY29uc3RydWN0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDb25zdHJ1Y3RlZCksXG4gIC8vIEEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgc3luYzogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1N5bmMpLFxuICAvLyBXaGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgbmVlZFJlYWRhYmxlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrTmVlZFJlYWRhYmxlKSxcbiAgZW1pdHRlZFJlYWRhYmxlOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRW1pdHRlZFJlYWRhYmxlKSxcbiAgcmVhZGFibGVMaXN0ZW5pbmc6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkYWJsZUxpc3RlbmluZyksXG4gIHJlc3VtZVNjaGVkdWxlZDogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa1Jlc3VtZVNjaGVkdWxlZCksXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluLlxuICBlcnJvckVtaXR0ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFcnJvckVtaXR0ZWQpLFxuICBlbWl0Q2xvc2U6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtFbWl0Q2xvc2UpLFxuICBhdXRvRGVzdHJveTogbWFrZUJpdE1hcERlc2NyaXB0b3Ioa0F1dG9EZXN0cm95KSxcbiAgLy8gSGFzIGl0IGJlZW4gZGVzdHJveWVkLlxuICBkZXN0cm95ZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtEZXN0cm95ZWQpLFxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBmaW5pc2hlZCBkZXN0cm95aW5nLlxuICBjbG9zZWQ6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtDbG9zZWQpLFxuICAvLyBUcnVlIGlmIGNsb3NlIGhhcyBiZWVuIGVtaXR0ZWQgb3Igd291bGQgaGF2ZSBiZWVuIGVtaXR0ZWRcbiAgLy8gZGVwZW5kaW5nIG9uIGVtaXRDbG9zZS5cbiAgY2xvc2VFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrQ2xvc2VFbWl0dGVkKSxcbiAgbXVsdGlBd2FpdERyYWluOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrTXVsdGlBd2FpdERyYWluKSxcbiAgLy8gSWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZC5cbiAgcmVhZGluZ01vcmU6IG1ha2VCaXRNYXBEZXNjcmlwdG9yKGtSZWFkaW5nTW9yZSksXG4gIGRhdGFFbWl0dGVkOiBtYWtlQml0TWFwRGVzY3JpcHRvcihrRGF0YUVtaXR0ZWQpXG59KVxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcblxuICAvLyBCaXQgbWFwIGZpZWxkIHRvIHN0b3JlIFJlYWRhYmxlU3RhdGUgbW9yZSBlZmZjaWVudGx5IHdpdGggMSBiaXQgcGVyIGZpZWxkXG4gIC8vIGluc3RlYWQgb2YgYSBWOCBzbG90IHBlciBmaWVsZC5cbiAgdGhpcy5zdGF0ZSA9IGtFbWl0Q2xvc2UgfCBrQXV0b0Rlc3Ryb3kgfCBrQ29uc3RydWN0ZWQgfCBrU3luY1xuICAvLyBPYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheS5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlKSB0aGlzLnN0YXRlIHw9IGtPYmplY3RNb2RlXG4gIGlmIChpc0R1cGxleCAmJiBvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlKSB0aGlzLnN0YXRlIHw9IGtPYmplY3RNb2RlXG5cbiAgLy8gVGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBvcHRpb25zXG4gICAgPyBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleClcbiAgICA6IGdldERlZmF1bHRIaWdoV2F0ZXJNYXJrKGZhbHNlKVxuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KCkuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKVxuICB0aGlzLmxlbmd0aCA9IDBcbiAgdGhpcy5waXBlcyA9IFtdXG4gIHRoaXMuZmxvd2luZyA9IG51bGxcbiAgdGhpc1trUGF1c2VkXSA9IG51bGxcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVtaXRDbG9zZSA9PT0gZmFsc2UpIHRoaXMuc3RhdGUgJj0gfmtFbWl0Q2xvc2VcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJykuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKSB0aGlzLnN0YXRlICY9IH5rQXV0b0Rlc3Ryb3lcblxuICAvLyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3RyZWFtIGhhcyBlcnJvcmVkLiBXaGVuIHRydWUgbm8gZnVydGhlclxuICAvLyBfcmVhZCBjYWxscywgJ2RhdGEnIG9yICdyZWFkYWJsZScgZXZlbnRzIHNob3VsZCBvY2N1ci4gVGhpcyBpcyBuZWVkZWRcbiAgLy8gc2luY2Ugd2hlbiBhdXRvRGVzdHJveSBpcyBkaXNhYmxlZCB3ZSBuZWVkIGEgd2F5IHRvIHRlbGwgd2hldGhlciB0aGVcbiAgLy8gc3RyZWFtIGhhcyBmYWlsZWQuXG4gIHRoaXMuZXJyb3JlZCA9IG51bGxcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKSB8fCAndXRmOCdcblxuICAvLyBSZWYgdGhlIHBpcGVkIGRlc3Qgd2hpY2ggd2UgbmVlZCBhIGRyYWluIGV2ZW50IG9uIGl0XG4gIC8vIHR5cGU6IG51bGwgfCBXcml0YWJsZSB8IFNldDxXcml0YWJsZT4uXG4gIHRoaXMuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gIHRoaXMuZGVjb2RlciA9IG51bGxcbiAgdGhpcy5lbmNvZGluZyA9IG51bGxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpXG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfVxufVxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpXG5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjUuXG4gIGNvbnN0IGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIHJlcXVpcmUoJy4vZHVwbGV4JylcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KVxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3lcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29uc3RydWN0ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9jb25zdHJ1Y3QgPSBvcHRpb25zLmNvbnN0cnVjdFxuICAgIGlmIChvcHRpb25zLnNpZ25hbCAmJiAhaXNEdXBsZXgpIGFkZEFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCB0aGlzKVxuICB9XG4gIFN0cmVhbS5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gIGRlc3Ryb3lJbXBsLmNvbnN0cnVjdCh0aGlzLCAoKSA9PiB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlKSB7XG4gICAgICBtYXliZVJlYWRNb3JlKHRoaXMsIHRoaXMuX3JlYWRhYmxlU3RhdGUpXG4gICAgfVxuICB9KVxufVxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveVxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKVxufVxuUmVhZGFibGUucHJvdG90eXBlW0VFLmNhcHR1cmVSZWplY3Rpb25TeW1ib2xdID0gZnVuY3Rpb24gKGVycikge1xuICB0aGlzLmRlc3Ryb3koZXJyKVxufVxuUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbEFzeW5jRGlzcG9zZV0gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBlcnJvclxuICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgZXJyb3IgPSB0aGlzLnJlYWRhYmxlRW5kZWQgPyBudWxsIDogbmV3IEFib3J0RXJyb3IoKVxuICAgIHRoaXMuZGVzdHJveShlcnJvcilcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gZW9zKHRoaXMsIChlcnIpID0+IChlcnIgJiYgZXJyICE9PSBlcnJvciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShudWxsKSkpKVxufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKCkuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCB0cnVlKVxufVxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKVxuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBsZXQgZXJyXG4gIGlmICgoc3RhdGUuc3RhdGUgJiBrT2JqZWN0TW9kZSkgPT09IDApIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2RpbmdcbiAgICAgIGlmIChzdGF0ZS5lbmNvZGluZyAhPT0gZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQgJiYgc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgICAvLyBXaGVuIHVuc2hpZnRpbmcsIGlmIHN0YXRlLmVuY29kaW5nIGlzIHNldCwgd2UgaGF2ZSB0byBzYXZlXG4gICAgICAgICAgLy8gdGhlIHN0cmluZyBpbiB0aGUgQnVmZmVyTGlzdCB3aXRoIHRoZSBzdGF0ZSBlbmNvZGluZy5cbiAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZykudG9TdHJpbmcoc3RhdGUuZW5jb2RpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHVuayBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgIH0gZWxzZSBpZiAoU3RyZWFtLl9pc1VpbnQ4QXJyYXkoY2h1bmspKSB7XG4gICAgICBjaHVuayA9IFN0cmVhbS5fdWludDhBcnJheVRvQnVmZmVyKGNodW5rKVxuICAgICAgZW5jb2RpbmcgPSAnJ1xuICAgIH0gZWxzZSBpZiAoY2h1bmsgIT0gbnVsbCkge1xuICAgICAgZXJyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKVxuICAgIH1cbiAgfVxuICBpZiAoZXJyKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpXG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5zdGF0ZSAmPSB+a1JlYWRpbmdcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoKHN0YXRlLnN0YXRlICYga09iamVjdE1vZGUpICE9PSAwIHx8IChjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSkge1xuICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICBpZiAoKHN0YXRlLnN0YXRlICYga0VuZEVtaXR0ZWQpICE9PSAwKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpXG4gICAgICBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQgfHwgc3RhdGUuZXJyb3JlZCkgcmV0dXJuIGZhbHNlXG4gICAgICBlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSlcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCB8fCBzdGF0ZS5lcnJvcmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuc3RhdGUgJj0gfmtSZWFkaW5nXG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKVxuICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSlcbiAgICAgICAgZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUuc3RhdGUgJj0gfmtSZWFkaW5nXG4gICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApXG59XG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMgJiYgc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICAvLyBVc2UgdGhlIGd1YXJkIHRvIGF2b2lkIGNyZWF0aW5nIGBTZXQoKWAgcmVwZWF0ZWRseVxuICAgIC8vIHdoZW4gd2UgaGF2ZSBtdWx0aXBsZSBwaXBlcy5cbiAgICBpZiAoKHN0YXRlLnN0YXRlICYga011bHRpQXdhaXREcmFpbikgIT09IDApIHtcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLmNsZWFyKClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPSBudWxsXG4gICAgfVxuICAgIHN0YXRlLmRhdGFFbWl0dGVkID0gdHJ1ZVxuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspXG4gIH0gZWxzZSB7XG4gICAgLy8gVXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspXG4gICAgZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuaylcbiAgICBpZiAoKHN0YXRlLnN0YXRlICYga05lZWRSZWFkYWJsZSkgIT09IDApIGVtaXRSZWFkYWJsZShzdHJlYW0pXG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKVxufVxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGVcbiAgcmV0dXJuIHN0YXRlW2tQYXVzZWRdID09PSB0cnVlIHx8IHN0YXRlLmZsb3dpbmcgPT09IGZhbHNlXG59XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKVxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyXG4gIC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4LlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nXG4gIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIGxldCBjb250ZW50ID0gJydcbiAgZm9yIChjb25zdCBkYXRhIG9mIGJ1ZmZlcikge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShkYXRhKVxuICB9XG4gIGJ1ZmZlci5jbGVhcigpXG4gIGlmIChjb250ZW50ICE9PSAnJykgYnVmZmVyLnB1c2goY29udGVudClcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCLlxuY29uc3QgTUFYX0hXTSA9IDB4NDAwMDAwMDBcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPiBNQVhfSFdNKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9PVVRfT0ZfUkFOR0UoJ3NpemUnLCAnPD0gMUdpQicsIG4pXG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzLlxuICAgIG4tLVxuICAgIG4gfD0gbiA+Pj4gMVxuICAgIG4gfD0gbiA+Pj4gMlxuICAgIG4gfD0gbiA+Pj4gNFxuICAgIG4gfD0gbiA+Pj4gOFxuICAgIG4gfD0gbiA+Pj4gMTZcbiAgICBuKytcbiAgfVxuICByZXR1cm4gblxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSkgcmV0dXJuIDBcbiAgaWYgKChzdGF0ZS5zdGF0ZSAmIGtPYmplY3RNb2RlKSAhPT0gMCkgcmV0dXJuIDFcbiAgaWYgKE51bWJlcklzTmFOKG4pKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lLlxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5maXJzdCgpLmxlbmd0aFxuICAgIHJldHVybiBzdGF0ZS5sZW5ndGhcbiAgfVxuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuXG4gIHJldHVybiBzdGF0ZS5lbmRlZCA/IHN0YXRlLmxlbmd0aCA6IDBcbn1cblxuLy8gWW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKVxuICAvLyBTYW1lIGFzIHBhcnNlSW50KHVuZGVmaW5lZCwgMTApLCBob3dldmVyIFY4IDcuMyBwZXJmb3JtYW5jZSByZWdyZXNzZWRcbiAgLy8gaW4gdGhpcyBzY2VuYXJpbywgc28gd2UgYXJlIGRvaW5nIGl0IG1hbnVhbGx5LlxuICBpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbiA9IE5hTlxuICB9IGVsc2UgaWYgKCFOdW1iZXJJc0ludGVnZXIobikpIHtcbiAgICBuID0gTnVtYmVyUGFyc2VJbnQobiwgMTApXG4gIH1cbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlXG4gIGNvbnN0IG5PcmlnID0gblxuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKVxuICBpZiAobiAhPT0gMCkgc3RhdGUuc3RhdGUgJj0gfmtFbWl0dGVkUmVhZGFibGVcblxuICAvLyBJZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChcbiAgICBuID09PSAwICYmXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZClcbiAgKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcylcbiAgICBlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpXG5cbiAgLy8gSWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICBsZXQgZG9SZWFkID0gKHN0YXRlLnN0YXRlICYga05lZWRSZWFkYWJsZSkgIT09IDBcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpXG5cbiAgLy8gSWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZVxuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZClcbiAgfVxuXG4gIC8vIEhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LCBpZiB3ZSdyZSBjb25zdHJ1Y3Rpbmcgd2UgaGF2ZSB0byB3YWl0LFxuICAvLyBhbmQgaWYgd2UncmUgZGVzdHJveWVkIG9yIGVycm9yZWQsIHRoZW4gaXQncyBub3QgYWxsb3dlZCxcbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcgfHwgc3RhdGUuZGVzdHJveWVkIHx8IHN0YXRlLmVycm9yZWQgfHwgIXN0YXRlLmNvbnN0cnVjdGVkKSB7XG4gICAgZG9SZWFkID0gZmFsc2VcbiAgICBkZWJ1ZygncmVhZGluZywgZW5kZWQgb3IgY29uc3RydWN0aW5nJywgZG9SZWFkKVxuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJylcbiAgICBzdGF0ZS5zdGF0ZSB8PSBrUmVhZGluZyB8IGtTeW5jXG4gICAgLy8gSWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5zdGF0ZSB8PSBrTmVlZFJlYWRhYmxlXG5cbiAgICAvLyBDYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gICAgc3RhdGUuc3RhdGUgJj0gfmtTeW5jXG5cbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSlcbiAgfVxuICBsZXQgcmV0XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpXG4gIGVsc2UgcmV0ID0gbnVsbFxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmtcbiAgICBuID0gMFxuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuXG4gICAgaWYgKHN0YXRlLm11bHRpQXdhaXREcmFpbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuY2xlYXIoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlXG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKVxuICB9XG4gIGlmIChyZXQgIT09IG51bGwgJiYgIXN0YXRlLmVycm9yRW1pdHRlZCAmJiAhc3RhdGUuY2xvc2VFbWl0dGVkKSB7XG4gICAgc3RhdGUuZGF0YUVtaXR0ZWQgPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpXG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgY29uc3QgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gSWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGwuXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSlcbiAgfSBlbHNlIHtcbiAgICAvLyBFbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWVcbiAgICAvLyBXZSBoYXZlIHRvIGVtaXQgcmVhZGFibGUgbm93IHRoYXQgd2UgYXJlIEVPRi4gTW9kdWxlc1xuICAgIC8vIGluIHRoZSBlY29zeXN0ZW0gKGUuZy4gZGljZXIpIHJlbHkgb24gdGhpcyBldmVudCBiZWluZyBzeW5jLlxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKVxuICB9XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2VcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZylcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pXG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKVxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAhc3RhdGUuZXJyb3JlZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2VcbiAgfVxuXG4gIC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZjpcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFya1xuICBmbG93KHN0cmVhbSlcbn1cblxuLy8gQXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSAmJiBzdGF0ZS5jb25zdHJ1Y3RlZCkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZVxuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpXG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoXG4gICAgIXN0YXRlLnJlYWRpbmcgJiZcbiAgICAhc3RhdGUuZW5kZWQgJiZcbiAgICAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKVxuICApIHtcbiAgICBjb25zdCBsZW4gPSBzdGF0ZS5sZW5ndGhcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKVxuICAgIHN0cmVhbS5yZWFkKDApXG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gRGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrXG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZVxufVxuXG4vLyBBYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRocm93IG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpXG59XG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICBjb25zdCBzcmMgPSB0aGlzXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoc3RhdGUucGlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFzdGF0ZS5tdWx0aUF3YWl0RHJhaW4pIHtcbiAgICAgIHN0YXRlLm11bHRpQXdhaXREcmFpbiA9IHRydWVcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbmV3IFNhZmVTZXQoc3RhdGUuYXdhaXREcmFpbldyaXRlcnMgPyBbc3RhdGUuYXdhaXREcmFpbldyaXRlcnNdIDogW10pXG4gICAgfVxuICB9XG4gIHN0YXRlLnBpcGVzLnB1c2goZGVzdClcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzLmxlbmd0aCwgcGlwZU9wdHMpXG4gIGNvbnN0IGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVyclxuICBjb25zdCBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGVcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pXG4gIGVsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKVxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSlcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKVxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWVcbiAgICAgICAgY2xlYW51cCgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpXG4gICAgZGVzdC5lbmQoKVxuICB9XG4gIGxldCBvbmRyYWluXG4gIGxldCBjbGVhbmVkVXAgPSBmYWxzZVxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJylcbiAgICAvLyBDbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuLlxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSlcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgICBpZiAob25kcmFpbikge1xuICAgICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKVxuICAgIH1cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSlcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgY2xlYW5lZFVwID0gdHJ1ZVxuXG4gICAgLy8gSWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAob25kcmFpbiAmJiBzdGF0ZS5hd2FpdERyYWluV3JpdGVycyAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKClcbiAgfVxuICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgaWYgKCFjbGVhbmVkVXApIHtcbiAgICAgIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDEgJiYgc3RhdGUucGlwZXNbMF0gPT09IGRlc3QpIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIDApXG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gZGVzdFxuICAgICAgICBzdGF0ZS5tdWx0aUF3YWl0RHJhaW4gPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPiAxICYmIHN0YXRlLnBpcGVzLmluY2x1ZGVzKGRlc3QpKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5zaXplKVxuICAgICAgICBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5hZGQoZGVzdClcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpXG4gICAgfVxuICAgIGlmICghb25kcmFpbikge1xuICAgICAgLy8gV2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAgICAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gICAgICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAgICAgLy8gdG9vIHNsb3cuXG4gICAgICBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjLCBkZXN0KVxuICAgICAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKVxuICAgIH1cbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKVxuICAgIGNvbnN0IHJldCA9IGRlc3Qud3JpdGUoY2h1bmspXG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIHBhdXNlKClcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gSG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcilcbiAgICB1bnBpcGUoKVxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcilcbiAgICBpZiAoZGVzdC5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgICBjb25zdCBzID0gZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAocyAmJiAhcy5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgLy8gVXNlciBpbmNvcnJlY3RseSBlbWl0dGVkICdlcnJvcicgZGlyZWN0bHkgb24gdGhlIHN0cmVhbS5cbiAgICAgICAgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcilcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKVxuICAgIHVucGlwZSgpXG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKVxuICAgIHVucGlwZSgpXG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaClcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKVxuICAgIHNyYy51bnBpcGUoZGVzdClcbiAgfVxuXG4gIC8vIFRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvLlxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpXG5cbiAgLy8gU3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmIChkZXN0LndyaXRhYmxlTmVlZERyYWluID09PSB0cnVlKSB7XG4gICAgcGF1c2UoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJylcbiAgICBzcmMucmVzdW1lKClcbiAgfVxuICByZXR1cm4gZGVzdFxufVxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjLCBkZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIGNvbnN0IHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlXG5cbiAgICAvLyBgb25kcmFpbmAgd2lsbCBjYWxsIGRpcmVjdGx5LFxuICAgIC8vIGB0aGlzYCBtYXliZSBub3QgYSByZWZlcmVuY2UgdG8gZGVzdCxcbiAgICAvLyBzbyB3ZSB1c2UgdGhlIHJlYWwgZGVzdCBoZXJlLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluV3JpdGVycyA9PT0gZGVzdCkge1xuICAgICAgZGVidWcoJ3BpcGVPbkRyYWluJywgMSlcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoc3RhdGUubXVsdGlBd2FpdERyYWluKSB7XG4gICAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluV3JpdGVycy5zaXplKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbldyaXRlcnMuZGVsZXRlKGRlc3QpXG4gICAgfVxuICAgIGlmICgoIXN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzIHx8IHN0YXRlLmF3YWl0RHJhaW5Xcml0ZXJzLnNpemUgPT09IDApICYmIHNyYy5saXN0ZW5lckNvdW50KCdkYXRhJykpIHtcbiAgICAgIHNyYy5yZXN1bWUoKVxuICAgIH1cbiAgfVxufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH1cblxuICAvLyBJZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgY29uc3QgZGVzdHMgPSBzdGF0ZS5waXBlc1xuICAgIHN0YXRlLnBpcGVzID0gW11cbiAgICB0aGlzLnBhdXNlKClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3RzLmxlbmd0aDsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gVHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgY29uc3QgaW5kZXggPSBBcnJheVByb3RvdHlwZUluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSlcbiAgaWYgKHN0YXRlLnBpcGVzLmxlbmd0aCA9PT0gMCkgdGhpcy5wYXVzZSgpXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbylcbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gU2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmcuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIGNvbnN0IHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pXG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMFxuXG4gICAgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZC5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKClcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZVxuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZVxuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKVxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcylcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub25cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgY29uc3QgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbilcbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuUmVhZGFibGUucHJvdG90eXBlLm9mZiA9IFJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lclxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICBjb25zdCByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICBjb25zdCBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGVcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgc3RhdGVba1BhdXNlZF0gPT09IGZhbHNlKSB7XG4gICAgLy8gRmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZVxuXG4gICAgLy8gQ3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWUuXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBudWxsXG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJylcbiAgc2VsZi5yZWFkKDApXG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJylcbiAgICAvLyBXZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpLlxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmdcbiAgICByZXN1bWUodGhpcywgc3RhdGUpXG4gIH1cbiAgc3RhdGVba1BhdXNlZF0gPSBmYWxzZVxuICByZXR1cm4gdGhpc1xufVxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKVxuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApXG4gIH1cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2VcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gIGZsb3coc3RyZWFtKVxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMClcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZylcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKVxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlXG4gICAgdGhpcy5lbWl0KCdwYXVzZScpXG4gIH1cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZVtrUGF1c2VkXSA9IHRydWVcbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZylcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCk7XG59XG5cbi8vIFdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICBsZXQgcGF1c2VkID0gZmFsc2VcblxuICAvLyBUT0RPIChyb25hZyk6IFNob3VsZCB0aGlzLmRlc3Ryb3koZXJyKSBlbWl0XG4gIC8vICdlcnJvcicgb24gdGhlIHdyYXBwZWQgc3RyZWFtPyBXb3VsZCByZXF1aXJlXG4gIC8vIGEgc3RhdGljIGZhY3RvcnkgbWV0aG9kLCBlLmcuIFJlYWRhYmxlLndyYXAoc3RyZWFtKS5cblxuICBzdHJlYW0ub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICBpZiAoIXRoaXMucHVzaChjaHVuaykgJiYgc3RyZWFtLnBhdXNlKSB7XG4gICAgICBwYXVzZWQgPSB0cnVlXG4gICAgICBzdHJlYW0ucGF1c2UoKVxuICAgIH1cbiAgfSlcbiAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gIH0pXG4gIHN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgZXJyb3JPckRlc3Ryb3kodGhpcywgZXJyKVxuICB9KVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIHRoaXMuZGVzdHJveSgpXG4gIH0pXG4gIHN0cmVhbS5vbignZGVzdHJveScsICgpID0+IHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICB9KVxuICB0aGlzLl9yZWFkID0gKCkgPT4ge1xuICAgIGlmIChwYXVzZWQgJiYgc3RyZWFtLnJlc3VtZSkge1xuICAgICAgcGF1c2VkID0gZmFsc2VcbiAgICAgIHN0cmVhbS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy4gSW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGNvbnN0IHN0cmVhbUtleXMgPSBPYmplY3RLZXlzKHN0cmVhbSlcbiAgZm9yIChsZXQgaiA9IDE7IGogPCBzdHJlYW1LZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgaSA9IHN0cmVhbUtleXNbal1cbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBzdHJlYW1baV0uYmluZChzdHJlYW0pXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5SZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sQXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzdHJlYW1Ub0FzeW5jSXRlcmF0b3IodGhpcylcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVRvQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zKVxufVxuZnVuY3Rpb24gc3RyZWFtVG9Bc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0cmVhbS5yZWFkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RyZWFtID0gUmVhZGFibGUud3JhcChzdHJlYW0sIHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KVxuICB9XG4gIGNvbnN0IGl0ZXIgPSBjcmVhdGVBc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucylcbiAgaXRlci5zdHJlYW0gPSBzdHJlYW1cbiAgcmV0dXJuIGl0ZXJcbn1cbmFzeW5jIGZ1bmN0aW9uKiBjcmVhdGVBc3luY0l0ZXJhdG9yKHN0cmVhbSwgb3B0aW9ucykge1xuICBsZXQgY2FsbGJhY2sgPSBub3BcbiAgZnVuY3Rpb24gbmV4dChyZXNvbHZlKSB7XG4gICAgaWYgKHRoaXMgPT09IHN0cmVhbSkge1xuICAgICAgY2FsbGJhY2soKVxuICAgICAgY2FsbGJhY2sgPSBub3BcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBuZXh0KVxuICBsZXQgZXJyb3JcbiAgY29uc3QgY2xlYW51cCA9IGVvcyhcbiAgICBzdHJlYW0sXG4gICAge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBlcnJvciA9IGVyciA/IGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlcnJvciwgZXJyKSA6IG51bGxcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGNhbGxiYWNrID0gbm9wXG4gICAgfVxuICApXG4gIHRyeSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gc3RyZWFtLmRlc3Ryb3llZCA/IG51bGwgOiBzdHJlYW0ucmVhZCgpXG4gICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgeWllbGQgY2h1bmtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShuZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBhZ2dyZWdhdGVUd29FcnJvcnMoZXJyb3IsIGVycilcbiAgICB0aHJvdyBlcnJvclxuICB9IGZpbmFsbHkge1xuICAgIGlmIChcbiAgICAgIChlcnJvciB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRlc3Ryb3lPblJldHVybikgIT09IGZhbHNlKSAmJlxuICAgICAgKGVycm9yID09PSB1bmRlZmluZWQgfHwgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmF1dG9EZXN0cm95KVxuICAgICkge1xuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHN0cmVhbSwgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm9mZigncmVhZGFibGUnLCBuZXh0KVxuICAgICAgY2xlYW51cCgpXG4gICAgfVxuICB9XG59XG5cbi8vIE1ha2luZyBpdCBleHBsaWNpdCB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgZW51bWVyYWJsZVxuLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4vLyB1c2VybGFuZCB3aWxsIGZhaWwuXG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlLnByb3RvdHlwZSwge1xuICByZWFkYWJsZToge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICAgICAgLy8gci5yZWFkYWJsZSA9PT0gZmFsc2UgbWVhbnMgdGhhdCB0aGlzIGlzIHBhcnQgb2YgYSBEdXBsZXggc3RyZWFtXG4gICAgICAvLyB3aGVyZSB0aGUgcmVhZGFibGUgc2lkZSB3YXMgZGlzYWJsZWQgdXBvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICAvLyBDb21wYXQuIFRoZSB1c2VyIG1pZ2h0IG1hbnVhbGx5IGRpc2FibGUgcmVhZGFibGUgc2lkZSB0aHJvdWdoXG4gICAgICAvLyBkZXByZWNhdGVkIHNldHRlci5cbiAgICAgIHJldHVybiAhIXIgJiYgci5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgIXIuZGVzdHJveWVkICYmICFyLmVycm9yRW1pdHRlZCAmJiAhci5lbmRFbWl0dGVkXG4gICAgfSxcbiAgICBzZXQodmFsKSB7XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0LlxuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9ICEhdmFsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZWFkYWJsZURpZFJlYWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kYXRhRW1pdHRlZFxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVBYm9ydGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRhYmxlICE9PSBmYWxzZSAmJlxuICAgICAgICAodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgfHwgdGhpcy5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkKSAmJlxuICAgICAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkXG4gICAgICApXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUhpZ2hXYXRlck1hcms6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUJ1ZmZlcjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUZsb3dpbmc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlTGVuZ3RoOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aFxuICAgIH1cbiAgfSxcbiAgcmVhZGFibGVPYmplY3RNb2RlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlYWRhYmxlRW5jb2Rpbmc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgPyB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nIDogbnVsbFxuICAgIH1cbiAgfSxcbiAgZXJyb3JlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZXJyb3JlZCA6IG51bGxcbiAgICB9XG4gIH0sXG4gIGNsb3NlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuY2xvc2VkIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3llZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSA/IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkIDogZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgLy8gV2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQuXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlXG4gICAgfVxuICB9LFxuICByZWFkYWJsZUVuZGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlID8gdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkIDogZmFsc2VcbiAgICB9XG4gIH1cbn0pXG5PYmplY3REZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RhdGUucHJvdG90eXBlLCB7XG4gIC8vIExlZ2FjeSBnZXR0ZXIgZm9yIGBwaXBlc0NvdW50YC5cbiAgcGlwZXNDb3VudDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5waXBlcy5sZW5ndGhcbiAgICB9XG4gIH0sXG4gIC8vIExlZ2FjeSBwcm9wZXJ0eSBmb3IgYHBhdXNlZGAuXG4gIHBhdXNlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1trUGF1c2VkXSAhPT0gZmFsc2VcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgdGhpc1trUGF1c2VkXSA9ICEhdmFsdWVcbiAgICB9XG4gIH1cbn0pXG5cbi8vIEV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWQuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gIGxldCByZXRcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpXG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gUmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0LlxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJylcbiAgICBlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKVxuICAgIGVsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKClcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdC5cbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKVxuICB9XG4gIHJldHVybiByZXRcbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZVxuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKVxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWVcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pXG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aClcblxuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lcnJvcmVkICYmICFzdGF0ZS5jbG9zZUVtaXR0ZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWVcbiAgICBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICBpZiAoc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbmRXcml0YWJsZU5ULCBzdHJlYW0pXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGwuXG4gICAgICBjb25zdCB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGVcbiAgICAgIGNvbnN0IGF1dG9EZXN0cm95ID1cbiAgICAgICAgIXdTdGF0ZSB8fFxuICAgICAgICAod1N0YXRlLmF1dG9EZXN0cm95ICYmXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZXhwZWN0IHRoZSB3cml0YWJsZSB0byBldmVyICdmaW5pc2gnXG4gICAgICAgICAgLy8gaWYgd3JpdGFibGUgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgKHdTdGF0ZS5maW5pc2hlZCB8fCB3U3RhdGUud3JpdGFibGUgPT09IGZhbHNlKSlcbiAgICAgIGlmIChhdXRvRGVzdHJveSkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbmRXcml0YWJsZU5UKHN0cmVhbSkge1xuICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS53cml0YWJsZSAmJiAhc3RyZWFtLndyaXRhYmxlRW5kZWQgJiYgIXN0cmVhbS5kZXN0cm95ZWRcbiAgaWYgKHdyaXRhYmxlKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gIH1cbn1cblJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKVxufVxubGV0IHdlYlN0cmVhbXNBZGFwdGVyc1xuXG4vLyBMYXp5IHRvIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZXNcbmZ1bmN0aW9uIGxhenlXZWJTdHJlYW1zKCkge1xuICBpZiAod2ViU3RyZWFtc0FkYXB0ZXJzID09PSB1bmRlZmluZWQpIHdlYlN0cmVhbXNBZGFwdGVycyA9IHt9XG4gIHJldHVybiB3ZWJTdHJlYW1zQWRhcHRlcnNcbn1cblJlYWRhYmxlLmZyb21XZWIgPSBmdW5jdGlvbiAocmVhZGFibGVTdHJlYW0sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3U3RyZWFtUmVhZGFibGVGcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIG9wdGlvbnMpXG59XG5SZWFkYWJsZS50b1dlYiA9IGZ1bmN0aW9uIChzdHJlYW1SZWFkYWJsZSwgb3B0aW9ucykge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdSZWFkYWJsZVN0cmVhbUZyb21TdHJlYW1SZWFkYWJsZShzdHJlYW1SZWFkYWJsZSwgb3B0aW9ucylcbn1cblJlYWRhYmxlLndyYXAgPSBmdW5jdGlvbiAoc3JjLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmLCBfc3JjJHJlYWRhYmxlT2JqZWN0TW9cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZSh7XG4gICAgb2JqZWN0TW9kZTpcbiAgICAgIChfcmVmID1cbiAgICAgICAgKF9zcmMkcmVhZGFibGVPYmplY3RNbyA9IHNyYy5yZWFkYWJsZU9iamVjdE1vZGUpICE9PSBudWxsICYmIF9zcmMkcmVhZGFibGVPYmplY3RNbyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBfc3JjJHJlYWRhYmxlT2JqZWN0TW9cbiAgICAgICAgICA6IHNyYy5vYmplY3RNb2RlKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfcmVmXG4gICAgICAgIDogdHJ1ZSxcbiAgICAuLi5vcHRpb25zLFxuICAgIGRlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgZGVzdHJveUltcGwuZGVzdHJveWVyKHNyYywgZXJyKVxuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgfSkud3JhcChzcmMpXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCdcblxuLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG5cbmNvbnN0IHtcbiAgQXJyYXlQcm90b3R5cGVTbGljZSxcbiAgRXJyb3IsXG4gIEZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2UsXG4gIE9iamVjdERlZmluZVByb3BlcnR5LFxuICBPYmplY3REZWZpbmVQcm9wZXJ0aWVzLFxuICBPYmplY3RTZXRQcm90b3R5cGVPZixcbiAgU3RyaW5nUHJvdG90eXBlVG9Mb3dlckNhc2UsXG4gIFN5bWJvbCxcbiAgU3ltYm9sSGFzSW5zdGFuY2Vcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGVcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlXG5jb25zdCB7IEV2ZW50RW1pdHRlcjogRUUgfSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCcuL2xlZ2FjeScpLlN0cmVhbVxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vZGVzdHJveScpXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuL2FkZC1hYm9ydC1zaWduYWwnKVxuY29uc3QgeyBnZXRIaWdoV2F0ZXJNYXJrLCBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpXG5jb25zdCB7XG4gIEVSUl9JTlZBTElEX0FSR19UWVBFLFxuICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICBFUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICBFUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgRVJSX1NUUkVBTV9BTFJFQURZX0ZJTklTSEVELFxuICBFUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgRVJSX1VOS05PV05fRU5DT0RJTkdcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpLmNvZGVzXG5jb25zdCB7IGVycm9yT3JEZXN0cm95IH0gPSBkZXN0cm95SW1wbFxuT2JqZWN0U2V0UHJvdG90eXBlT2YoV3JpdGFibGUucHJvdG90eXBlLCBTdHJlYW0ucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoV3JpdGFibGUsIFN0cmVhbSlcbmZ1bmN0aW9uIG5vcCgpIHt9XG5jb25zdCBrT25GaW5pc2hlZCA9IFN5bWJvbCgna09uRmluaXNoZWQnKVxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgcmVxdWlyZSgnLi9kdXBsZXgnKVxuXG4gIC8vIE9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlKVxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIShvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlKVxuXG4gIC8vIFRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKS5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gb3B0aW9uc1xuICAgID8gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpXG4gICAgOiBnZXREZWZhdWx0SGlnaFdhdGVyTWFyayhmYWxzZSlcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkLlxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2VcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlXG4gIC8vIEF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2VcbiAgLy8gV2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZC5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlXG4gIC8vIFdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZC5cbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlXG5cbiAgLy8gSGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICAvLyBTaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIGNvbnN0IG5vRGVjb2RlID0gISEob3B0aW9ucyAmJiBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlKVxuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGVcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nKSB8fCAndXRmOCdcblxuICAvLyBOb3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDBcblxuICAvLyBBIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZVxuXG4gIC8vIFdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGwuXG4gIHRoaXMuY29ya2VkID0gMFxuXG4gIC8vIEEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlXG5cbiAgLy8gQSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2VcblxuICAvLyBUaGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssIGNiKS5cbiAgdGhpcy5vbndyaXRlID0gb253cml0ZS5iaW5kKHVuZGVmaW5lZCwgc3RyZWFtKVxuXG4gIC8vIFRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLlxuICB0aGlzLndyaXRlY2IgPSBudWxsXG5cbiAgLy8gVGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMFxuXG4gIC8vIFN0b3JhZ2UgZm9yIGRhdGEgcGFzc2VkIHRvIHRoZSBhZnRlcldyaXRlKCkgY2FsbGJhY2sgaW4gY2FzZSBvZlxuICAvLyBzeW5jaHJvbm91cyBfd3JpdGUoKSBjb21wbGV0aW9uLlxuICB0aGlzLmFmdGVyV3JpdGVUaWNrSW5mbyA9IG51bGxcbiAgcmVzZXRCdWZmZXIodGhpcylcblxuICAvLyBOdW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWQuXG4gIHRoaXMucGVuZGluZ2NiID0gMFxuXG4gIC8vIFN0cmVhbSBpcyBzdGlsbCBiZWluZyBjb25zdHJ1Y3RlZCBhbmQgY2Fubm90IGJlXG4gIC8vIGRlc3Ryb3llZCB1bnRpbCBjb25zdHJ1Y3Rpb24gZmluaXNoZWQgb3IgZmFpbGVkLlxuICAvLyBBc3luYyBjb25zdHJ1Y3Rpb24gaXMgb3B0IGluLCB0aGVyZWZvcmUgd2Ugc3RhcnQgYXNcbiAgLy8gY29uc3RydWN0ZWQuXG4gIHRoaXMuY29uc3RydWN0ZWQgPSB0cnVlXG5cbiAgLy8gRW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtcy5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlXG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW4uXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2VcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICB0aGlzLmVtaXRDbG9zZSA9ICFvcHRpb25zIHx8IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZVxuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKS5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICFvcHRpb25zIHx8IG9wdGlvbnMuYXV0b0Rlc3Ryb3kgIT09IGZhbHNlXG5cbiAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0cmVhbSBoYXMgZXJyb3JlZC4gV2hlbiB0cnVlIGFsbCB3cml0ZSgpIGNhbGxzXG4gIC8vIHNob3VsZCByZXR1cm4gZmFsc2UuIFRoaXMgaXMgbmVlZGVkIHNpbmNlIHdoZW4gYXV0b0Rlc3Ryb3lcbiAgLy8gaXMgZGlzYWJsZWQgd2UgbmVlZCBhIHdheSB0byB0ZWxsIHdoZXRoZXIgdGhlIHN0cmVhbSBoYXMgZmFpbGVkLlxuICB0aGlzLmVycm9yZWQgPSBudWxsXG5cbiAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0cmVhbSBoYXMgZmluaXNoZWQgZGVzdHJveWluZy5cbiAgdGhpcy5jbG9zZWQgPSBmYWxzZVxuXG4gIC8vIFRydWUgaWYgY2xvc2UgaGFzIGJlZW4gZW1pdHRlZCBvciB3b3VsZCBoYXZlIGJlZW4gZW1pdHRlZFxuICAvLyBkZXBlbmRpbmcgb24gZW1pdENsb3NlLlxuICB0aGlzLmNsb3NlRW1pdHRlZCA9IGZhbHNlXG4gIHRoaXNba09uRmluaXNoZWRdID0gW11cbn1cbmZ1bmN0aW9uIHJlc2V0QnVmZmVyKHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlcmVkID0gW11cbiAgc3RhdGUuYnVmZmVyZWRJbmRleCA9IDBcbiAgc3RhdGUuYWxsQnVmZmVycyA9IHRydWVcbiAgc3RhdGUuYWxsTm9vcCA9IHRydWVcbn1cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgcmV0dXJuIEFycmF5UHJvdG90eXBlU2xpY2UodGhpcy5idWZmZXJlZCwgdGhpcy5idWZmZXJlZEluZGV4KVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXJlZFJlcXVlc3RDb3VudCcsIHtcbiAgX19wcm90b19fOiBudWxsLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyZWQubGVuZ3RoIC0gdGhpcy5idWZmZXJlZEluZGV4XG4gIH1cbn0pXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41LlxuICBjb25zdCBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiByZXF1aXJlKCcuL2R1cGxleCcpXG4gIGlmICghaXNEdXBsZXggJiYgIUZ1bmN0aW9uUHJvdG90eXBlU3ltYm9sSGFzSW5zdGFuY2UoV3JpdGFibGUsIHRoaXMpKSByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleClcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3lcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicpIHRoaXMuX2NvbnN0cnVjdCA9IG9wdGlvbnMuY29uc3RydWN0XG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsKSBhZGRBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgdGhpcylcbiAgfVxuICBTdHJlYW0uY2FsbCh0aGlzLCBvcHRpb25zKVxuICBkZXN0cm95SW1wbC5jb25zdHJ1Y3QodGhpcywgKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZVxuICAgIGlmICghc3RhdGUud3JpdGluZykge1xuICAgICAgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpXG4gICAgfVxuICAgIGZpbmlzaE1heWJlKHRoaXMsIHN0YXRlKVxuICB9KVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbEhhc0luc3RhbmNlLCB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBpZiAoRnVuY3Rpb25Qcm90b3R5cGVTeW1ib2xIYXNJbnN0YW5jZSh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZVxuICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlXG4gIH1cbn0pXG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKVxufVxuZnVuY3Rpb24gX3dyaXRlKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2RpbmdcbiAgICBlbHNlIGlmIChlbmNvZGluZyAhPT0gJ2J1ZmZlcicgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKVxuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wXG4gIH1cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKVxuICB9IGVsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSkge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcidcbiAgICB9IGVsc2UgaWYgKFN0cmVhbS5faXNVaW50OEFycmF5KGNodW5rKSkge1xuICAgICAgY2h1bmsgPSBTdHJlYW0uX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaylcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcidcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKVxuICAgIH1cbiAgfVxuICBsZXQgZXJyXG4gIGlmIChzdGF0ZS5lbmRpbmcpIHtcbiAgICBlcnIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKVxuICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgIGVyciA9IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKVxuICB9XG4gIGlmIChlcnIpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcnIpXG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIsIHRydWUpXG4gICAgcmV0dXJuIGVyclxuICB9XG4gIHN0YXRlLnBlbmRpbmdjYisrXG4gIHJldHVybiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpXG59XG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICByZXR1cm4gX3dyaXRlKHRoaXMsIGNodW5rLCBlbmNvZGluZywgY2IpID09PSB0cnVlXG59XG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrK1xufVxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLVxuICAgIGlmICghc3RhdGUud3JpdGluZykgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpXG4gIH1cbn1cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IFN0cmluZ1Byb3RvdHlwZVRvTG93ZXJDYXNlKGVuY29kaW5nKVxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKVxuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIElmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgY29uc3QgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgc3RhdGUubGVuZ3RoICs9IGxlblxuXG4gIC8vIHN0cmVhbS5fd3JpdGUgcmVzZXRzIHN0YXRlLmxlbmd0aFxuICBjb25zdCByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gIC8vIFdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZVxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQgfHwgc3RhdGUuZXJyb3JlZCB8fCAhc3RhdGUuY29uc3RydWN0ZWQpIHtcbiAgICBzdGF0ZS5idWZmZXJlZC5wdXNoKHtcbiAgICAgIGNodW5rLFxuICAgICAgZW5jb2RpbmcsXG4gICAgICBjYWxsYmFja1xuICAgIH0pXG4gICAgaWYgKHN0YXRlLmFsbEJ1ZmZlcnMgJiYgZW5jb2RpbmcgIT09ICdidWZmZXInKSB7XG4gICAgICBzdGF0ZS5hbGxCdWZmZXJzID0gZmFsc2VcbiAgICB9XG4gICAgaWYgKHN0YXRlLmFsbE5vb3AgJiYgY2FsbGJhY2sgIT09IG5vcCkge1xuICAgICAgc3RhdGUuYWxsTm9vcCA9IGZhbHNlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXRlLndyaXRlbGVuID0gbGVuXG4gICAgc3RhdGUud3JpdGVjYiA9IGNhbGxiYWNrXG4gICAgc3RhdGUud3JpdGluZyA9IHRydWVcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZVxuICAgIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKVxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZVxuICB9XG5cbiAgLy8gUmV0dXJuIGZhbHNlIGlmIGVycm9yZWQgb3IgZGVzdHJveWVkIGluIG9yZGVyIHRvIGJyZWFrXG4gIC8vIGFueSBzeW5jaHJvbm91cyB3aGlsZShzdHJlYW0ud3JpdGUoZGF0YSkpIGxvb3BzLlxuICByZXR1cm4gcmV0ICYmICFzdGF0ZS5lcnJvcmVkICYmICFzdGF0ZS5kZXN0cm95ZWRcbn1cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW5cbiAgc3RhdGUud3JpdGVjYiA9IGNiXG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlXG4gIHN0YXRlLnN5bmMgPSB0cnVlXG4gIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHN0YXRlLm9ud3JpdGUobmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCd3cml0ZScpKVxuICBlbHNlIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKVxuICBlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKVxuICBzdGF0ZS5zeW5jID0gZmFsc2Vcbn1cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2JcbiAgY2IoZXIpXG4gIC8vIEVuc3VyZSBjYWxsYmFja3MgYXJlIGludm9rZWQgZXZlbiB3aGVuIGF1dG9EZXN0cm95IGlzXG4gIC8vIG5vdCBlbmFibGVkLiBQYXNzaW5nIGBlcmAgaGVyZSBkb2Vzbid0IG1ha2Ugc2Vuc2Ugc2luY2VcbiAgLy8gaXQncyByZWxhdGVkIHRvIG9uZSBzcGVjaWZpYyB3cml0ZSwgbm90IHRvIHRoZSBidWZmZXJlZFxuICAvLyB3cml0ZXMuXG4gIGVycm9yQnVmZmVyKHN0YXRlKVxuICAvLyBUaGlzIGNhbiBlbWl0IGVycm9yLCBidXQgZXJyb3IgbXVzdCBhbHdheXMgZm9sbG93IGNiLlxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKVxufVxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IHN5bmMgPSBzdGF0ZS5zeW5jXG4gIGNvbnN0IGNiID0gc3RhdGUud3JpdGVjYlxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX01VTFRJUExFX0NBTExCQUNLKCkpXG4gICAgcmV0dXJuXG4gIH1cbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlXG4gIHN0YXRlLndyaXRlY2IgPSBudWxsXG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlblxuICBzdGF0ZS53cml0ZWxlbiA9IDBcbiAgaWYgKGVyKSB7XG4gICAgLy8gQXZvaWQgVjggbGVhaywgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzQxMDMjaXNzdWVjb21tZW50LTY1MjAwMjM2NFxuICAgIGVyLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICBpZiAoIXN0YXRlLmVycm9yZWQpIHtcbiAgICAgIHN0YXRlLmVycm9yZWQgPSBlclxuICAgIH1cblxuICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCB0byBub3RpZnkgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlXG4gICAgLy8gZXJyb3IuXG4gICAgaWYgKHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVycm9yZWQpIHtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lcnJvcmVkID0gZXJcbiAgICB9XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2sob253cml0ZUVycm9yLCBzdHJlYW0sIHN0YXRlLCBlciwgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBlciwgY2IpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdGF0ZS5idWZmZXJlZC5sZW5ndGggPiBzdGF0ZS5idWZmZXJlZEluZGV4KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKVxuICAgIH1cbiAgICBpZiAoc3luYykge1xuICAgICAgLy8gSXQgaXMgYSBjb21tb24gY2FzZSB0aGF0IHRoZSBjYWxsYmFjayBwYXNzZWQgdG8gLndyaXRlKCkgaXMgYWx3YXlzXG4gICAgICAvLyB0aGUgc2FtZS4gSW4gdGhhdCBjYXNlLCB3ZSBkbyBub3Qgc2NoZWR1bGUgYSBuZXcgbmV4dFRpY2soKSwgYnV0XG4gICAgICAvLyByYXRoZXIganVzdCBpbmNyZWFzZSBhIGNvdW50ZXIsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgYW5kIGF2b2lkXG4gICAgICAvLyBtZW1vcnkgYWxsb2NhdGlvbnMuXG4gICAgICBpZiAoc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvICE9PSBudWxsICYmIHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mby5jYiA9PT0gY2IpIHtcbiAgICAgICAgc3RhdGUuYWZ0ZXJXcml0ZVRpY2tJbmZvLmNvdW50KytcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mbyA9IHtcbiAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICBjYixcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgc3RhdGVcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGVUaWNrLCBzdGF0ZS5hZnRlcldyaXRlVGlja0luZm8pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgMSwgY2IpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZnRlcldyaXRlVGljayh7IHN0cmVhbSwgc3RhdGUsIGNvdW50LCBjYiB9KSB7XG4gIHN0YXRlLmFmdGVyV3JpdGVUaWNrSW5mbyA9IG51bGxcbiAgcmV0dXJuIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgY291bnQsIGNiKVxufVxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBjb3VudCwgY2IpIHtcbiAgY29uc3QgbmVlZERyYWluID0gIXN0YXRlLmVuZGluZyAmJiAhc3RyZWFtLmRlc3Ryb3llZCAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluXG4gIGlmIChuZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZVxuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gIH1cbiAgd2hpbGUgKGNvdW50LS0gPiAwKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS1cbiAgICBjYigpXG4gIH1cbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgIGVycm9yQnVmZmVyKHN0YXRlKVxuICB9XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpXG59XG5cbi8vIElmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBpbnZva2UgY2FsbGJhY2tzLlxuZnVuY3Rpb24gZXJyb3JCdWZmZXIoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICByZXR1cm5cbiAgfVxuICBmb3IgKGxldCBuID0gc3RhdGUuYnVmZmVyZWRJbmRleDsgbiA8IHN0YXRlLmJ1ZmZlcmVkLmxlbmd0aDsgKytuKSB7XG4gICAgdmFyIF9zdGF0ZSRlcnJvcmVkXG4gICAgY29uc3QgeyBjaHVuaywgY2FsbGJhY2sgfSA9IHN0YXRlLmJ1ZmZlcmVkW25dXG4gICAgY29uc3QgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICBzdGF0ZS5sZW5ndGggLT0gbGVuXG4gICAgY2FsbGJhY2soXG4gICAgICAoX3N0YXRlJGVycm9yZWQgPSBzdGF0ZS5lcnJvcmVkKSAhPT0gbnVsbCAmJiBfc3RhdGUkZXJyb3JlZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gX3N0YXRlJGVycm9yZWRcbiAgICAgICAgOiBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJylcbiAgICApXG4gIH1cbiAgY29uc3Qgb25maW5pc2hDYWxsYmFja3MgPSBzdGF0ZVtrT25GaW5pc2hlZF0uc3BsaWNlKDApXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb25maW5pc2hDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3N0YXRlJGVycm9yZWQyXG4gICAgb25maW5pc2hDYWxsYmFja3NbaV0oXG4gICAgICAoX3N0YXRlJGVycm9yZWQyID0gc3RhdGUuZXJyb3JlZCkgIT09IG51bGwgJiYgX3N0YXRlJGVycm9yZWQyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBfc3RhdGUkZXJyb3JlZDJcbiAgICAgICAgOiBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ2VuZCcpXG4gICAgKVxuICB9XG4gIHJlc2V0QnVmZmVyKHN0YXRlKVxufVxuXG4vLyBJZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdC5cbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmNvcmtlZCB8fCBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nIHx8IHN0YXRlLmRlc3Ryb3llZCB8fCAhc3RhdGUuY29uc3RydWN0ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB7IGJ1ZmZlcmVkLCBidWZmZXJlZEluZGV4LCBvYmplY3RNb2RlIH0gPSBzdGF0ZVxuICBjb25zdCBidWZmZXJlZExlbmd0aCA9IGJ1ZmZlcmVkLmxlbmd0aCAtIGJ1ZmZlcmVkSW5kZXhcbiAgaWYgKCFidWZmZXJlZExlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBpID0gYnVmZmVyZWRJbmRleFxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZVxuICBpZiAoYnVmZmVyZWRMZW5ndGggPiAxICYmIHN0cmVhbS5fd3JpdGV2KSB7XG4gICAgc3RhdGUucGVuZGluZ2NiIC09IGJ1ZmZlcmVkTGVuZ3RoIC0gMVxuICAgIGNvbnN0IGNhbGxiYWNrID0gc3RhdGUuYWxsTm9vcFxuICAgICAgPyBub3BcbiAgICAgIDogKGVycikgPT4ge1xuICAgICAgICAgIGZvciAobGV0IG4gPSBpOyBuIDwgYnVmZmVyZWQubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkW25dLmNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAvLyBNYWtlIGEgY29weSBvZiBgYnVmZmVyZWRgIGlmIGl0J3MgZ29pbmcgdG8gYmUgdXNlZCBieSBgY2FsbGJhY2tgIGFib3ZlLFxuICAgIC8vIHNpbmNlIGBkb1dyaXRlYCB3aWxsIG11dGF0ZSB0aGUgYXJyYXkuXG4gICAgY29uc3QgY2h1bmtzID0gc3RhdGUuYWxsTm9vcCAmJiBpID09PSAwID8gYnVmZmVyZWQgOiBBcnJheVByb3RvdHlwZVNsaWNlKGJ1ZmZlcmVkLCBpKVxuICAgIGNodW5rcy5hbGxCdWZmZXJzID0gc3RhdGUuYWxsQnVmZmVyc1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBjaHVua3MsICcnLCBjYWxsYmFjaylcbiAgICByZXNldEJ1ZmZlcihzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICBjb25zdCB7IGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2sgfSA9IGJ1ZmZlcmVkW2ldXG4gICAgICBidWZmZXJlZFtpKytdID0gbnVsbFxuICAgICAgY29uc3QgbGVuID0gb2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGhcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaylcbiAgICB9IHdoaWxlIChpIDwgYnVmZmVyZWQubGVuZ3RoICYmICFzdGF0ZS53cml0aW5nKVxuICAgIGlmIChpID09PSBidWZmZXJlZC5sZW5ndGgpIHtcbiAgICAgIHJlc2V0QnVmZmVyKHN0YXRlKVxuICAgIH0gZWxzZSBpZiAoaSA+IDI1Nikge1xuICAgICAgYnVmZmVyZWQuc3BsaWNlKDAsIGkpXG4gICAgICBzdGF0ZS5idWZmZXJlZEluZGV4ID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZEluZGV4ID0gaVxuICAgIH1cbiAgfVxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2Vcbn1cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAodGhpcy5fd3JpdGV2KSB7XG4gICAgdGhpcy5fd3JpdGV2KFxuICAgICAgW1xuICAgICAgICB7XG4gICAgICAgICAgY2h1bmssXG4gICAgICAgICAgZW5jb2RpbmdcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIGNiXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKVxuICB9XG59XG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGxcbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bmtcbiAgICBjaHVuayA9IG51bGxcbiAgICBlbmNvZGluZyA9IG51bGxcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBudWxsXG4gIH1cbiAgbGV0IGVyclxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHJldCA9IF93cml0ZSh0aGlzLCBjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlcnIgPSByZXRcbiAgICB9XG4gIH1cblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrcy5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDFcbiAgICB0aGlzLnVuY29yaygpXG4gIH1cbiAgaWYgKGVycikge1xuICAgIC8vIERvIG5vdGhpbmcuLi5cbiAgfSBlbHNlIGlmICghc3RhdGUuZXJyb3JlZCAmJiAhc3RhdGUuZW5kaW5nKSB7XG4gICAgLy8gVGhpcyBpcyBmb3JnaXZpbmcgaW4gdGVybXMgb2YgdW5uZWNlc3NhcnkgY2FsbHMgdG8gZW5kKCkgYW5kIGNhbiBoaWRlXG4gICAgLy8gbG9naWMgZXJyb3JzLiBIb3dldmVyLCB1c3VhbGx5IHN1Y2ggZXJyb3JzIGFyZSBoYXJtbGVzcyBhbmQgY2F1c2luZyBhXG4gICAgLy8gaGFyZCBlcnJvciBjYW4gYmUgZGlzcHJvcG9ydGlvbmF0ZWx5IGRlc3RydWN0aXZlLiBJdCBpcyBub3QgYWx3YXlzXG4gICAgLy8gdHJpdmlhbCBmb3IgdGhlIHVzZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgZW5kKCkgbmVlZHMgdG8gYmUgY2FsbGVkXG4gICAgLy8gb3Igbm90LlxuXG4gICAgc3RhdGUuZW5kaW5nID0gdHJ1ZVxuICAgIGZpbmlzaE1heWJlKHRoaXMsIHN0YXRlLCB0cnVlKVxuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZVxuICB9IGVsc2UgaWYgKHN0YXRlLmZpbmlzaGVkKSB7XG4gICAgZXJyID0gbmV3IEVSUl9TVFJFQU1fQUxSRUFEWV9GSU5JU0hFRCgnZW5kJylcbiAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICBlcnIgPSBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ2VuZCcpXG4gIH1cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlcnIgfHwgc3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGVba09uRmluaXNoZWRdLnB1c2goY2IpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgc3RhdGUuZW5kaW5nICYmXG4gICAgIXN0YXRlLmRlc3Ryb3llZCAmJlxuICAgIHN0YXRlLmNvbnN0cnVjdGVkICYmXG4gICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgIXN0YXRlLmVycm9yZWQgJiZcbiAgICBzdGF0ZS5idWZmZXJlZC5sZW5ndGggPT09IDAgJiZcbiAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAhc3RhdGUud3JpdGluZyAmJlxuICAgICFzdGF0ZS5lcnJvckVtaXR0ZWQgJiZcbiAgICAhc3RhdGUuY2xvc2VFbWl0dGVkXG4gIClcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZVxuICBmdW5jdGlvbiBvbkZpbmlzaChlcnIpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyciAhPT0gbnVsbCAmJiBlcnIgIT09IHVuZGVmaW5lZCA/IGVyciA6IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWVcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLVxuICAgIGlmIChlcnIpIHtcbiAgICAgIGNvbnN0IG9uZmluaXNoQ2FsbGJhY2tzID0gc3RhdGVba09uRmluaXNoZWRdLnNwbGljZSgwKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmZpbmlzaENhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvbmZpbmlzaENhbGxiYWNrc1tpXShlcnIpXG4gICAgICB9XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyciwgc3RhdGUuc3luYylcbiAgICB9IGVsc2UgaWYgKG5lZWRGaW5pc2goc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWVcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdC4gRG9uJ3QgY2hlY2sgc3RhdGUuc3luYyBoZXJlLlxuICAgICAgLy8gU29tZSBzdHJlYW1zIGFzc3VtZSAnZmluaXNoJyB3aWxsIGJlIGVtaXR0ZWRcbiAgICAgIC8vIGFzeW5jaHJvbm91c2x5IHJlbGF0aXZlIHRvIF9maW5hbCBjYWxsYmFjay5cbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaCwgc3RyZWFtLCBzdGF0ZSlcbiAgICB9XG4gIH1cbiAgc3RhdGUuc3luYyA9IHRydWVcbiAgc3RhdGUucGVuZGluZ2NiKytcbiAgdHJ5IHtcbiAgICBzdHJlYW0uX2ZpbmFsKG9uRmluaXNoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBvbkZpbmlzaChlcnIpXG4gIH1cbiAgc3RhdGUuc3luYyA9IGZhbHNlXG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWVcbiAgICAgIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWVcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSwgc3luYykge1xuICBpZiAobmVlZEZpbmlzaChzdGF0ZSkpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSlcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nY2IrK1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKFxuICAgICAgICAgIChzdHJlYW0sIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAobmVlZEZpbmlzaChzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgZmluaXNoKHN0cmVhbSwgc3RhdGUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nY2ItLVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAobmVlZEZpbmlzaChzdGF0ZSkpIHtcbiAgICAgICAgc3RhdGUucGVuZGluZ2NiKytcbiAgICAgICAgZmluaXNoKHN0cmVhbSwgc3RhdGUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5wZW5kaW5nY2ItLVxuICBzdGF0ZS5maW5pc2hlZCA9IHRydWVcbiAgY29uc3Qgb25maW5pc2hDYWxsYmFja3MgPSBzdGF0ZVtrT25GaW5pc2hlZF0uc3BsaWNlKDApXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb25maW5pc2hDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBvbmZpbmlzaENhbGxiYWNrc1tpXSgpXG4gIH1cbiAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpXG4gIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbC5cbiAgICBjb25zdCByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgICBjb25zdCBhdXRvRGVzdHJveSA9XG4gICAgICAhclN0YXRlIHx8XG4gICAgICAoclN0YXRlLmF1dG9EZXN0cm95ICYmXG4gICAgICAgIC8vIFdlIGRvbid0IGV4cGVjdCB0aGUgcmVhZGFibGUgdG8gZXZlciAnZW5kJ1xuICAgICAgICAvLyBpZiByZWFkYWJsZSBpcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZS5cbiAgICAgICAgKHJTdGF0ZS5lbmRFbWl0dGVkIHx8IHJTdGF0ZS5yZWFkYWJsZSA9PT0gZmFsc2UpKVxuICAgIGlmIChhdXRvRGVzdHJveSkge1xuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydGllcyhXcml0YWJsZS5wcm90b3R5cGUsIHtcbiAgY2xvc2VkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5jbG9zZWQgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZGVzdHJveWVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgOiBmYWxzZVxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5IG1hbmFnaW5nIGRlc3Ryb3llZC5cbiAgICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHcgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gICAgICAvLyB3LndyaXRhYmxlID09PSBmYWxzZSBtZWFucyB0aGF0IHRoaXMgaXMgcGFydCBvZiBhIER1cGxleCBzdHJlYW1cbiAgICAgIC8vIHdoZXJlIHRoZSB3cml0YWJsZSBzaWRlIHdhcyBkaXNhYmxlZCB1cG9uIGNvbnN0cnVjdGlvbi5cbiAgICAgIC8vIENvbXBhdC4gVGhlIHVzZXIgbWlnaHQgbWFudWFsbHkgZGlzYWJsZSB3cml0YWJsZSBzaWRlIHRocm91Z2hcbiAgICAgIC8vIGRlcHJlY2F0ZWQgc2V0dGVyLlxuICAgICAgcmV0dXJuICEhdyAmJiB3LndyaXRhYmxlICE9PSBmYWxzZSAmJiAhdy5kZXN0cm95ZWQgJiYgIXcuZXJyb3JlZCAmJiAhdy5lbmRpbmcgJiYgIXcuZW5kZWRcbiAgICB9LFxuICAgIHNldCh2YWwpIHtcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmxlLlxuICAgICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS53cml0YWJsZSA9ICEhdmFsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3cml0YWJsZUZpbmlzaGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlID8gdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA6IGZhbHNlXG4gICAgfVxuICB9LFxuICB3cml0YWJsZU9iamVjdE1vZGU6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGUgOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVCdWZmZXI6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKVxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVFbmRlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nIDogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdyaXRhYmxlTmVlZERyYWluOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCgpIHtcbiAgICAgIGNvbnN0IHdTdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGVcbiAgICAgIGlmICghd1N0YXRlKSByZXR1cm4gZmFsc2VcbiAgICAgIHJldHVybiAhd1N0YXRlLmRlc3Ryb3llZCAmJiAhd1N0YXRlLmVuZGluZyAmJiB3U3RhdGUubmVlZERyYWluXG4gICAgfVxuICB9LFxuICB3cml0YWJsZUhpZ2hXYXRlck1hcms6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gICAgfVxuICB9LFxuICB3cml0YWJsZUNvcmtlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSA/IHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkIDogMFxuICAgIH1cbiAgfSxcbiAgd3JpdGFibGVMZW5ndGg6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGhcbiAgICB9XG4gIH0sXG4gIGVycm9yZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgPyB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yZWQgOiBudWxsXG4gICAgfVxuICB9LFxuICB3cml0YWJsZUFib3J0ZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gISEoXG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUud3JpdGFibGUgIT09IGZhbHNlICYmXG4gICAgICAgICh0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yZWQpICYmXG4gICAgICAgICF0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkXG4gICAgICApXG4gICAgfVxuICB9XG59KVxuY29uc3QgZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3lcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY29uc3Qgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG5cbiAgLy8gSW52b2tlIHBlbmRpbmcgY2FsbGJhY2tzLlxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUuYnVmZmVyZWRJbmRleCA8IHN0YXRlLmJ1ZmZlcmVkLmxlbmd0aCB8fCBzdGF0ZVtrT25GaW5pc2hlZF0ubGVuZ3RoKSkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZXJyb3JCdWZmZXIsIHN0YXRlKVxuICB9XG4gIGRlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGNiKVxuICByZXR1cm4gdGhpc1xufVxuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3lcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycilcbn1cbldyaXRhYmxlLnByb3RvdHlwZVtFRS5jYXB0dXJlUmVqZWN0aW9uU3ltYm9sXSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgdGhpcy5kZXN0cm95KGVycilcbn1cbmxldCB3ZWJTdHJlYW1zQWRhcHRlcnNcblxuLy8gTGF6eSB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG5mdW5jdGlvbiBsYXp5V2ViU3RyZWFtcygpIHtcbiAgaWYgKHdlYlN0cmVhbXNBZGFwdGVycyA9PT0gdW5kZWZpbmVkKSB3ZWJTdHJlYW1zQWRhcHRlcnMgPSB7fVxuICByZXR1cm4gd2ViU3RyZWFtc0FkYXB0ZXJzXG59XG5Xcml0YWJsZS5mcm9tV2ViID0gZnVuY3Rpb24gKHdyaXRhYmxlU3RyZWFtLCBvcHRpb25zKSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1N0cmVhbVdyaXRhYmxlRnJvbVdyaXRhYmxlU3RyZWFtKHdyaXRhYmxlU3RyZWFtLCBvcHRpb25zKVxufVxuV3JpdGFibGUudG9XZWIgPSBmdW5jdGlvbiAoc3RyZWFtV3JpdGFibGUpIHtcbiAgcmV0dXJuIGxhenlXZWJTdHJlYW1zKCkubmV3V3JpdGFibGVTdHJlYW1Gcm9tU3RyZWFtV3JpdGFibGUoc3RyZWFtV3JpdGFibGUpXG59XG4iLCIvKiByZXBsYWNlbWVudCBzdGFydCAqL1xuXG5jb25zdCBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2Vzcy8nKVxuXG4vKiByZXBsYWNlbWVudCBlbmQgKi9cblxuOygndXNlIHN0cmljdCcpXG5jb25zdCBidWZmZXJNb2R1bGUgPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qge1xuICBpc1JlYWRhYmxlLFxuICBpc1dyaXRhYmxlLFxuICBpc0l0ZXJhYmxlLFxuICBpc05vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGVOb2RlU3RyZWFtLFxuICBpc1dyaXRhYmxlTm9kZVN0cmVhbSxcbiAgaXNEdXBsZXhOb2RlU3RyZWFtLFxuICBpc1JlYWRhYmxlU3RyZWFtLFxuICBpc1dyaXRhYmxlU3RyZWFtXG59ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKVxuY29uc3Qge1xuICBBYm9ydEVycm9yLFxuICBjb2RlczogeyBFUlJfSU5WQUxJRF9BUkdfVFlQRSwgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFIH1cbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IGRlc3Ryb3llciB9ID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpXG5jb25zdCBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUnKVxuY29uc3QgeyBjcmVhdGVEZWZlcnJlZFByb21pc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpXG5jb25zdCBmcm9tID0gcmVxdWlyZSgnLi9mcm9tJylcbmNvbnN0IEJsb2IgPSBnbG9iYWxUaGlzLkJsb2IgfHwgYnVmZmVyTW9kdWxlLkJsb2JcbmNvbnN0IGlzQmxvYiA9XG4gIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJ1xuICAgID8gZnVuY3Rpb24gaXNCbG9iKGIpIHtcbiAgICAgICAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCbG9iXG4gICAgICB9XG4gICAgOiBmdW5jdGlvbiBpc0Jsb2IoYikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbmNvbnN0IEFib3J0Q29udHJvbGxlciA9IGdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyIHx8IHJlcXVpcmUoJ2Fib3J0LWNvbnRyb2xsZXInKS5BYm9ydENvbnRyb2xsZXJcbmNvbnN0IHsgRnVuY3Rpb25Qcm90b3R5cGVDYWxsIH0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcblxuLy8gVGhpcyBpcyBuZWVkZWQgZm9yIHByZSBub2RlIDE3LlxuY2xhc3MgRHVwbGV4aWZ5IGV4dGVuZHMgRHVwbGV4IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zNDM4NVxuXG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucmVhZGFibGUpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy53cml0YWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlID0gZmFsc2VcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gdHJ1ZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSB0cnVlXG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGR1cGxleGlmeShib2R5LCBuYW1lKSB7XG4gIGlmIChpc0R1cGxleE5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gYm9keVxuICB9XG4gIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbShib2R5KSkge1xuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHJlYWRhYmxlOiBib2R5XG4gICAgfSlcbiAgfVxuICBpZiAoaXNXcml0YWJsZU5vZGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogYm9keVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzTm9kZVN0cmVhbShib2R5KSkge1xuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHJlYWRhYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzUmVhZGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICByZWFkYWJsZTogUmVhZGFibGUuZnJvbVdlYihib2R5KVxuICAgIH0pXG4gIH1cbiAgaWYgKGlzV3JpdGFibGVTdHJlYW0oYm9keSkpIHtcbiAgICByZXR1cm4gX2R1cGxleGlmeSh7XG4gICAgICB3cml0YWJsZTogV3JpdGFibGUuZnJvbVdlYihib2R5KVxuICAgIH0pXG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgd3JpdGUsIGZpbmFsLCBkZXN0cm95IH0gPSBmcm9tQXN5bmNHZW4oYm9keSlcbiAgICBpZiAoaXNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tKER1cGxleGlmeSwgdmFsdWUsIHtcbiAgICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB3cml0ZSxcbiAgICAgICAgZmluYWwsXG4gICAgICAgIGRlc3Ryb3lcbiAgICAgIH0pXG4gICAgfVxuICAgIGNvbnN0IHRoZW4gPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdmFsdWUudGhlblxuICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGV0IGRcbiAgICAgIGNvbnN0IHByb21pc2UgPSBGdW5jdGlvblByb3RvdHlwZUNhbGwoXG4gICAgICAgIHRoZW4sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAodmFsKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdudWxseScsICdib2R5JywgdmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIGRlc3Ryb3llcihkLCBlcnIpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiAoZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgICAgICAvLyBUT0RPIChyb25hZyk6IGhpZ2hXYXRlck1hcms/XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGUsXG4gICAgICAgIGZpbmFsKGNiKSB7XG4gICAgICAgICAgZmluYWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgcHJvbWlzZVxuICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95XG4gICAgICB9KSlcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnSXRlcmFibGUsIEFzeW5jSXRlcmFibGUgb3IgQXN5bmNGdW5jdGlvbicsIG5hbWUsIHZhbHVlKVxuICB9XG4gIGlmIChpc0Jsb2IoYm9keSkpIHtcbiAgICByZXR1cm4gZHVwbGV4aWZ5KGJvZHkuYXJyYXlCdWZmZXIoKSlcbiAgfVxuICBpZiAoaXNJdGVyYWJsZShib2R5KSkge1xuICAgIHJldHVybiBmcm9tKER1cGxleGlmeSwgYm9keSwge1xuICAgICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgaWYgKFxuICAgIGlzUmVhZGFibGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnJlYWRhYmxlKSAmJlxuICAgIGlzV3JpdGFibGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKVxuICApIHtcbiAgICByZXR1cm4gRHVwbGV4aWZ5LmZyb21XZWIoYm9keSlcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIChib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkud3JpdGFibGUpID09PSAnb2JqZWN0JyB8fFxuICAgIHR5cGVvZiAoYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LnJlYWRhYmxlKSA9PT0gJ29iamVjdCdcbiAgKSB7XG4gICAgY29uc3QgcmVhZGFibGUgPVxuICAgICAgYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB1bmRlZmluZWQgJiYgYm9keS5yZWFkYWJsZVxuICAgICAgICA/IGlzUmVhZGFibGVOb2RlU3RyZWFtKGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogYm9keS5yZWFkYWJsZSlcbiAgICAgICAgICA/IGJvZHkgPT09IG51bGwgfHwgYm9keSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBib2R5LnJlYWRhYmxlXG4gICAgICAgICAgOiBkdXBsZXhpZnkoYm9keS5yZWFkYWJsZSlcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgICBjb25zdCB3cml0YWJsZSA9XG4gICAgICBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHVuZGVmaW5lZCAmJiBib2R5LndyaXRhYmxlXG4gICAgICAgID8gaXNXcml0YWJsZU5vZGVTdHJlYW0oYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBib2R5LndyaXRhYmxlKVxuICAgICAgICAgID8gYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IGJvZHkud3JpdGFibGVcbiAgICAgICAgICA6IGR1cGxleGlmeShib2R5LndyaXRhYmxlKVxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIHJldHVybiBfZHVwbGV4aWZ5KHtcbiAgICAgIHJlYWRhYmxlLFxuICAgICAgd3JpdGFibGVcbiAgICB9KVxuICB9XG4gIGNvbnN0IHRoZW4gPSBib2R5ID09PSBudWxsIHx8IGJvZHkgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGJvZHkudGhlblxuICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBsZXQgZFxuICAgIEZ1bmN0aW9uUHJvdG90eXBlQ2FsbChcbiAgICAgIHRoZW4sXG4gICAgICBib2R5LFxuICAgICAgKHZhbCkgPT4ge1xuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICBkLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICAgIGQucHVzaChudWxsKVxuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgZGVzdHJveWVyKGQsIGVycilcbiAgICAgIH1cbiAgICApXG4gICAgcmV0dXJuIChkID0gbmV3IER1cGxleGlmeSh7XG4gICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgcmVhZCgpIHt9XG4gICAgfSkpXG4gIH1cbiAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKFxuICAgIG5hbWUsXG4gICAgW1xuICAgICAgJ0Jsb2InLFxuICAgICAgJ1JlYWRhYmxlU3RyZWFtJyxcbiAgICAgICdXcml0YWJsZVN0cmVhbScsXG4gICAgICAnU3RyZWFtJyxcbiAgICAgICdJdGVyYWJsZScsXG4gICAgICAnQXN5bmNJdGVyYWJsZScsXG4gICAgICAnRnVuY3Rpb24nLFxuICAgICAgJ3sgcmVhZGFibGUsIHdyaXRhYmxlIH0gcGFpcicsXG4gICAgICAnUHJvbWlzZSdcbiAgICBdLFxuICAgIGJvZHlcbiAgKVxufVxuZnVuY3Rpb24gZnJvbUFzeW5jR2VuKGZuKSB7XG4gIGxldCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIGNvbnN0IHNpZ25hbCA9IGFjLnNpZ25hbFxuICBjb25zdCB2YWx1ZSA9IGZuKFxuICAgIChhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgX3Byb21pc2UgPSBwcm9taXNlXG4gICAgICAgIHByb21pc2UgPSBudWxsXG4gICAgICAgIGNvbnN0IHsgY2h1bmssIGRvbmUsIGNiIH0gPSBhd2FpdCBfcHJvbWlzZVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKVxuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIGNhdXNlOiBzaWduYWwucmVhc29uXG4gICAgICAgICAgfSlcbiAgICAgICAgOyh7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpKVxuICAgICAgICB5aWVsZCBjaHVua1xuICAgICAgfVxuICAgIH0pKCksXG4gICAge1xuICAgICAgc2lnbmFsXG4gICAgfVxuICApXG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgY29uc3QgX3Jlc29sdmUgPSByZXNvbHZlXG4gICAgICByZXNvbHZlID0gbnVsbFxuICAgICAgX3Jlc29sdmUoe1xuICAgICAgICBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIGNiXG4gICAgICB9KVxuICAgIH0sXG4gICAgZmluYWwoY2IpIHtcbiAgICAgIGNvbnN0IF9yZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgcmVzb2x2ZSA9IG51bGxcbiAgICAgIF9yZXNvbHZlKHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgY2JcbiAgICAgIH0pXG4gICAgfSxcbiAgICBkZXN0cm95KGVyciwgY2IpIHtcbiAgICAgIGFjLmFib3J0KClcbiAgICAgIGNiKGVycilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9kdXBsZXhpZnkocGFpcikge1xuICBjb25zdCByID0gcGFpci5yZWFkYWJsZSAmJiB0eXBlb2YgcGFpci5yZWFkYWJsZS5yZWFkICE9PSAnZnVuY3Rpb24nID8gUmVhZGFibGUud3JhcChwYWlyLnJlYWRhYmxlKSA6IHBhaXIucmVhZGFibGVcbiAgY29uc3QgdyA9IHBhaXIud3JpdGFibGVcbiAgbGV0IHJlYWRhYmxlID0gISFpc1JlYWRhYmxlKHIpXG4gIGxldCB3cml0YWJsZSA9ICEhaXNXcml0YWJsZSh3KVxuICBsZXQgb25kcmFpblxuICBsZXQgb25maW5pc2hcbiAgbGV0IG9ucmVhZGFibGVcbiAgbGV0IG9uY2xvc2VcbiAgbGV0IGRcbiAgZnVuY3Rpb24gb25maW5pc2hlZChlcnIpIHtcbiAgICBjb25zdCBjYiA9IG9uY2xvc2VcbiAgICBvbmNsb3NlID0gbnVsbFxuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKVxuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBkLmRlc3Ryb3koZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8ocm9uYWcpOiBBdm9pZCBkb3VibGUgYnVmZmVyaW5nLlxuICAvLyBJbXBsZW1lbnQgV3JpdGFibGUvUmVhZGFibGUvRHVwbGV4IHRyYWl0cy5cbiAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zMzUxNS5cbiAgZCA9IG5ldyBEdXBsZXhpZnkoe1xuICAgIC8vIFRPRE8gKHJvbmFnKTogaGlnaFdhdGVyTWFyaz9cbiAgICByZWFkYWJsZU9iamVjdE1vZGU6ICEhKHIgIT09IG51bGwgJiYgciAhPT0gdW5kZWZpbmVkICYmIHIucmVhZGFibGVPYmplY3RNb2RlKSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6ICEhKHcgIT09IG51bGwgJiYgdyAhPT0gdW5kZWZpbmVkICYmIHcud3JpdGFibGVPYmplY3RNb2RlKSxcbiAgICByZWFkYWJsZSxcbiAgICB3cml0YWJsZVxuICB9KVxuICBpZiAod3JpdGFibGUpIHtcbiAgICBlb3ModywgKGVycikgPT4ge1xuICAgICAgd3JpdGFibGUgPSBmYWxzZVxuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZXN0cm95ZXIociwgZXJyKVxuICAgICAgfVxuICAgICAgb25maW5pc2hlZChlcnIpXG4gICAgfSlcbiAgICBkLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAody53cml0ZShjaHVuaywgZW5jb2RpbmcpKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uZHJhaW4gPSBjYWxsYmFja1xuICAgICAgfVxuICAgIH1cbiAgICBkLl9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdy5lbmQoKVxuICAgICAgb25maW5pc2ggPSBjYWxsYmFja1xuICAgIH1cbiAgICB3Lm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvbmRyYWluKSB7XG4gICAgICAgIGNvbnN0IGNiID0gb25kcmFpblxuICAgICAgICBvbmRyYWluID0gbnVsbFxuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfSlcbiAgICB3Lm9uKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25maW5pc2gpIHtcbiAgICAgICAgY29uc3QgY2IgPSBvbmZpbmlzaFxuICAgICAgICBvbmZpbmlzaCA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgaWYgKHJlYWRhYmxlKSB7XG4gICAgZW9zKHIsIChlcnIpID0+IHtcbiAgICAgIHJlYWRhYmxlID0gZmFsc2VcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVzdHJveWVyKHIsIGVycilcbiAgICAgIH1cbiAgICAgIG9uZmluaXNoZWQoZXJyKVxuICAgIH0pXG4gICAgci5vbigncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob25yZWFkYWJsZSkge1xuICAgICAgICBjb25zdCBjYiA9IG9ucmVhZGFibGVcbiAgICAgICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gICAgci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgZC5wdXNoKG51bGwpXG4gICAgfSlcbiAgICBkLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYnVmID0gci5yZWFkKClcbiAgICAgICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuICAgICAgICAgIG9ucmVhZGFibGUgPSBkLl9yZWFkXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkLnB1c2goYnVmKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyICYmIG9uY2xvc2UgIT09IG51bGwpIHtcbiAgICAgIGVyciA9IG5ldyBBYm9ydEVycm9yKClcbiAgICB9XG4gICAgb25yZWFkYWJsZSA9IG51bGxcbiAgICBvbmRyYWluID0gbnVsbFxuICAgIG9uZmluaXNoID0gbnVsbFxuICAgIGlmIChvbmNsb3NlID09PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9uY2xvc2UgPSBjYWxsYmFja1xuICAgICAgZGVzdHJveWVyKHcsIGVycilcbiAgICAgIGRlc3Ryb3llcihyLCBlcnIpXG4gICAgfVxuICB9XG4gIHJldHVybiBkXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGUgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwaWNhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7XG4gIE9iamVjdERlZmluZVByb3BlcnRpZXMsXG4gIE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgT2JqZWN0S2V5cyxcbiAgT2JqZWN0U2V0UHJvdG90eXBlT2Zcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL3ByaW1vcmRpYWxzJylcbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4XG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuY29uc3QgV3JpdGFibGUgPSByZXF1aXJlKCcuL3dyaXRhYmxlJylcbk9iamVjdFNldFByb3RvdHlwZU9mKER1cGxleC5wcm90b3R5cGUsIFJlYWRhYmxlLnByb3RvdHlwZSlcbk9iamVjdFNldFByb3RvdHlwZU9mKER1cGxleCwgUmVhZGFibGUpXG57XG4gIGNvbnN0IGtleXMgPSBPYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSlcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGhvZCA9IGtleXNbaV1cbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF1cbiAgfVxufVxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucylcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKVxuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IG9wdGlvbnMuYWxsb3dIYWxmT3BlbiAhPT0gZmFsc2VcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGFibGUgPSBmYWxzZVxuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl93cml0YWJsZVN0YXRlLndyaXRhYmxlID0gZmFsc2VcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gdHJ1ZVxuICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWVcbiAgfVxufVxuT2JqZWN0RGVmaW5lUHJvcGVydGllcyhEdXBsZXgucHJvdG90eXBlLCB7XG4gIHdyaXRhYmxlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZScpXG4gIH0sXG4gIHdyaXRhYmxlSGlnaFdhdGVyTWFyazoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJylcbiAgfSxcbiAgd3JpdGFibGVPYmplY3RNb2RlOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZU9iamVjdE1vZGUnKVxuICB9LFxuICB3cml0YWJsZUJ1ZmZlcjoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInKVxuICB9LFxuICB3cml0YWJsZUxlbmd0aDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnKVxuICB9LFxuICB3cml0YWJsZUZpbmlzaGVkOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUZpbmlzaGVkJylcbiAgfSxcbiAgd3JpdGFibGVDb3JrZWQ6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgLi4uT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQ29ya2VkJylcbiAgfSxcbiAgd3JpdGFibGVFbmRlZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAuLi5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVFbmRlZCcpXG4gIH0sXG4gIHdyaXRhYmxlTmVlZERyYWluOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIC4uLk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcihXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZU5lZWREcmFpbicpXG4gIH0sXG4gIGRlc3Ryb3llZDoge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZFxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQuXG4gICAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWVcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcbmxldCB3ZWJTdHJlYW1zQWRhcHRlcnNcblxuLy8gTGF6eSB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG5mdW5jdGlvbiBsYXp5V2ViU3RyZWFtcygpIHtcbiAgaWYgKHdlYlN0cmVhbXNBZGFwdGVycyA9PT0gdW5kZWZpbmVkKSB3ZWJTdHJlYW1zQWRhcHRlcnMgPSB7fVxuICByZXR1cm4gd2ViU3RyZWFtc0FkYXB0ZXJzXG59XG5EdXBsZXguZnJvbVdlYiA9IGZ1bmN0aW9uIChwYWlyLCBvcHRpb25zKSB7XG4gIHJldHVybiBsYXp5V2ViU3RyZWFtcygpLm5ld1N0cmVhbUR1cGxleEZyb21SZWFkYWJsZVdyaXRhYmxlUGFpcihwYWlyLCBvcHRpb25zKVxufVxuRHVwbGV4LnRvV2ViID0gZnVuY3Rpb24gKGR1cGxleCkge1xuICByZXR1cm4gbGF6eVdlYlN0cmVhbXMoKS5uZXdSZWFkYWJsZVdyaXRhYmxlUGFpckZyb21EdXBsZXgoZHVwbGV4KVxufVxubGV0IGR1cGxleGlmeVxuRHVwbGV4LmZyb20gPSBmdW5jdGlvbiAoYm9keSkge1xuICBpZiAoIWR1cGxleGlmeSkge1xuICAgIGR1cGxleGlmeSA9IHJlcXVpcmUoJy4vZHVwbGV4aWZ5JylcbiAgfVxuICByZXR1cm4gZHVwbGV4aWZ5KGJvZHksICdib2R5Jylcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IE9iamVjdFNldFByb3RvdHlwZU9mLCBTeW1ib2wgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1cbmNvbnN0IHsgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJykuY29kZXNcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IHsgZ2V0SGlnaFdhdGVyTWFyayB9ID0gcmVxdWlyZSgnLi9zdGF0ZScpXG5PYmplY3RTZXRQcm90b3R5cGVPZihUcmFuc2Zvcm0ucHJvdG90eXBlLCBEdXBsZXgucHJvdG90eXBlKVxuT2JqZWN0U2V0UHJvdG90eXBlT2YoVHJhbnNmb3JtLCBEdXBsZXgpXG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2tDYWxsYmFjaycpXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucylcblxuICAvLyBUT0RPIChyb25hZyk6IFRoaXMgc2hvdWxkIHByZWZlcmFibHkgYWx3YXlzIGJlXG4gIC8vIGFwcGxpZWQgYnV0IHdvdWxkIGJlIHNlbXZlci1tYWpvci4gT3IgZXZlbiBiZXR0ZXI7XG4gIC8vIG1ha2UgVHJhbnNmb3JtIGEgUmVhZGFibGUgd2l0aCB0aGUgV3JpdGFibGUgaW50ZXJmYWNlLlxuICBjb25zdCByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zID8gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgdHJ1ZSkgOiBudWxsXG4gIGlmIChyZWFkYWJsZUhpZ2hXYXRlck1hcmsgPT09IDApIHtcbiAgICAvLyBBIER1cGxleCB3aWxsIGJ1ZmZlciBib3RoIG9uIHRoZSB3cml0YWJsZSBhbmQgcmVhZGFibGUgc2lkZSB3aGlsZVxuICAgIC8vIGEgVHJhbnNmb3JtIGp1c3Qgd2FudHMgdG8gYnVmZmVyIGh3bSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIGF2b2lkXG4gICAgLy8gYnVmZmVyaW5nIHR3aWNlIHdlIGRpc2FibGUgYnVmZmVyaW5nIG9uIHRoZSB3cml0YWJsZSBzaWRlLlxuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgaGlnaFdhdGVyTWFyazogbnVsbCxcbiAgICAgIHJlYWRhYmxlSGlnaFdhdGVyTWFyayxcbiAgICAgIC8vIFRPRE8gKHJvbmFnKTogMCBpcyBub3Qgb3B0aW1hbCBzaW5jZSB3ZSBoYXZlXG4gICAgICAvLyBhIFwiYnVnXCIgd2hlcmUgd2UgY2hlY2sgbmVlZERyYWluIGJlZm9yZSBjYWxsaW5nIF93cml0ZSBhbmQgbm90IGFmdGVyLlxuICAgICAgLy8gUmVmczogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMzI4ODdcbiAgICAgIC8vIFJlZnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzM1OTQxXG4gICAgICB3cml0YWJsZUhpZ2hXYXRlck1hcms6IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrIHx8IDBcbiAgICB9XG4gIH1cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucylcblxuICAvLyBXZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlXG4gIHRoaXNba0NhbGxiYWNrXSA9IG51bGxcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoXG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXQuIFNvbWUgVHJhbnNmb3JtIHN0cmVhbXMgaW5jb3JyZWN0bHkgaW1wbGVtZW50IF9maW5hbFxuICAvLyBpbnN0ZWFkIG9mIG9yIGluIGFkZGl0aW9uIHRvIF9mbHVzaC4gQnkgdXNpbmcgJ3ByZWZpbmlzaCcgaW5zdGVhZCBvZlxuICAvLyBpbXBsZW1lbnRpbmcgX2ZpbmFsIHdlIGNvbnRpbnVlIHN1cHBvcnRpbmcgdGhpcyB1bmZvcnR1bmF0ZSB1c2UgY2FzZS5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKVxufVxuZnVuY3Rpb24gZmluYWwoY2IpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaCgoZXIsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihlcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koZXIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHVzaChkYXRhKVxuICAgICAgfVxuICAgICAgdGhpcy5wdXNoKG51bGwpXG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gICAgaWYgKGNiKSB7XG4gICAgICBjYigpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIGlmICh0aGlzLl9maW5hbCAhPT0gZmluYWwpIHtcbiAgICBmaW5hbC5jYWxsKHRoaXMpXG4gIH1cbn1cblRyYW5zZm9ybS5wcm90b3R5cGUuX2ZpbmFsID0gZmluYWxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRocm93IG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJylcbn1cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgY29uc3QgclN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZVxuICBjb25zdCB3U3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlXG4gIGNvbnN0IGxlbmd0aCA9IHJTdGF0ZS5sZW5ndGhcbiAgdGhpcy5fdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgKGVyciwgdmFsKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wdXNoKHZhbClcbiAgICB9XG4gICAgaWYgKFxuICAgICAgd1N0YXRlLmVuZGVkIHx8XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0LlxuICAgICAgbGVuZ3RoID09PSByU3RhdGUubGVuZ3RoIHx8XG4gICAgICAvLyBCYWNrd2FyZHMgY29tcGF0LlxuICAgICAgclN0YXRlLmxlbmd0aCA8IHJTdGF0ZS5oaWdoV2F0ZXJNYXJrXG4gICAgKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0NhbGxiYWNrXSA9IGNhbGxiYWNrXG4gICAgfVxuICB9KVxufVxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXNba0NhbGxiYWNrXSkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpc1trQ2FsbGJhY2tdXG4gICAgdGhpc1trQ2FsbGJhY2tdID0gbnVsbFxuICAgIGNhbGxiYWNrKClcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBPYmplY3RTZXRQcm90b3R5cGVPZiB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpXG5PYmplY3RTZXRQcm90b3R5cGVPZihQYXNzVGhyb3VnaC5wcm90b3R5cGUsIFRyYW5zZm9ybS5wcm90b3R5cGUpXG5PYmplY3RTZXRQcm90b3R5cGVPZihQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKVxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpXG59XG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKVxufVxuIiwiLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgcHJvY2VzcyA9IHJlcXVpcmUoJ3Byb2Nlc3MvJylcblxuLyogcmVwbGFjZW1lbnQgZW5kICovXG4vLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbjsoJ3VzZSBzdHJpY3QnKVxuY29uc3QgeyBBcnJheUlzQXJyYXksIFByb21pc2UsIFN5bWJvbEFzeW5jSXRlcmF0b3IsIFN5bWJvbERpc3Bvc2UgfSA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IHsgb25jZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJylcbmNvbnN0IGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9kZXN0cm95JylcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IHtcbiAgYWdncmVnYXRlVHdvRXJyb3JzLFxuICBjb2Rlczoge1xuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSxcbiAgICBFUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVELFxuICAgIEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXG4gIH0sXG4gIEFib3J0RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IHZhbGlkYXRlRnVuY3Rpb24sIHZhbGlkYXRlQWJvcnRTaWduYWwgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3Qge1xuICBpc0l0ZXJhYmxlLFxuICBpc1JlYWRhYmxlLFxuICBpc1JlYWRhYmxlTm9kZVN0cmVhbSxcbiAgaXNOb2RlU3RyZWFtLFxuICBpc1RyYW5zZm9ybVN0cmVhbSxcbiAgaXNXZWJTdHJlYW0sXG4gIGlzUmVhZGFibGVTdHJlYW0sXG4gIGlzUmVhZGFibGVGaW5pc2hlZFxufSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgfHwgcmVxdWlyZSgnYWJvcnQtY29udHJvbGxlcicpLkFib3J0Q29udHJvbGxlclxubGV0IFBhc3NUaHJvdWdoXG5sZXQgUmVhZGFibGVcbmxldCBhZGRBYm9ydExpc3RlbmVyXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nKSB7XG4gIGxldCBmaW5pc2hlZCA9IGZhbHNlXG4gIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgZmluaXNoZWQgPSB0cnVlXG4gIH0pXG4gIGNvbnN0IGNsZWFudXAgPSBlb3MoXG4gICAgc3RyZWFtLFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgICAgd3JpdGFibGU6IHdyaXRpbmdcbiAgICB9LFxuICAgIChlcnIpID0+IHtcbiAgICAgIGZpbmlzaGVkID0gIWVyclxuICAgIH1cbiAgKVxuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IChlcnIpID0+IHtcbiAgICAgIGlmIChmaW5pc2hlZCkgcmV0dXJuXG4gICAgICBmaW5pc2hlZCA9IHRydWVcbiAgICAgIGRlc3Ryb3lJbXBsLmRlc3Ryb3llcihzdHJlYW0sIGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSlcbiAgICB9LFxuICAgIGNsZWFudXBcbiAgfVxufVxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICAvLyBTdHJlYW1zIHNob3VsZCBuZXZlciBiZSBhbiBlbXB0eSBhcnJheS4gSXQgc2hvdWxkIGFsd2F5cyBjb250YWluIGF0IGxlYXN0XG4gIC8vIGEgc2luZ2xlIHN0cmVhbS4gVGhlcmVmb3JlIG9wdGltaXplIGZvciB0aGUgYXZlcmFnZSBjYXNlIGluc3RlYWQgb2ZcbiAgLy8gY2hlY2tpbmcgZm9yIGxlbmd0aCA9PT0gMCBhcyB3ZWxsLlxuICB2YWxpZGF0ZUZ1bmN0aW9uKHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSwgJ3N0cmVhbXNbc3RyZWFtLmxlbmd0aCAtIDFdJylcbiAgcmV0dXJuIHN0cmVhbXMucG9wKClcbn1cbmZ1bmN0aW9uIG1ha2VBc3luY0l0ZXJhYmxlKHZhbCkge1xuICBpZiAoaXNJdGVyYWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbFxuICB9IGVsc2UgaWYgKGlzUmVhZGFibGVOb2RlU3RyZWFtKHZhbCkpIHtcbiAgICAvLyBMZWdhY3kgc3RyZWFtcyBhcmUgbm90IEl0ZXJhYmxlLlxuICAgIHJldHVybiBmcm9tUmVhZGFibGUodmFsKVxuICB9XG4gIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgndmFsJywgWydSZWFkYWJsZScsICdJdGVyYWJsZScsICdBc3luY0l0ZXJhYmxlJ10sIHZhbClcbn1cbmFzeW5jIGZ1bmN0aW9uKiBmcm9tUmVhZGFibGUodmFsKSB7XG4gIGlmICghUmVhZGFibGUpIHtcbiAgICBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKVxuICB9XG4gIHlpZWxkKiBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sQXN5bmNJdGVyYXRvcl0uY2FsbCh2YWwpXG59XG5hc3luYyBmdW5jdGlvbiBwdW1wVG9Ob2RlKGl0ZXJhYmxlLCB3cml0YWJsZSwgZmluaXNoLCB7IGVuZCB9KSB7XG4gIGxldCBlcnJvclxuICBsZXQgb25yZXNvbHZlID0gbnVsbFxuICBjb25zdCByZXN1bWUgPSAoZXJyKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG4gICAgaWYgKG9ucmVzb2x2ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBvbnJlc29sdmVcbiAgICAgIG9ucmVzb2x2ZSA9IG51bGxcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cbiAgY29uc3Qgd2FpdCA9ICgpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ucmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgd3JpdGFibGUub24oJ2RyYWluJywgcmVzdW1lKVxuICBjb25zdCBjbGVhbnVwID0gZW9zKFxuICAgIHdyaXRhYmxlLFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiBmYWxzZVxuICAgIH0sXG4gICAgcmVzdW1lXG4gIClcbiAgdHJ5IHtcbiAgICBpZiAod3JpdGFibGUud3JpdGFibGVOZWVkRHJhaW4pIHtcbiAgICAgIGF3YWl0IHdhaXQoKVxuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGl0ZXJhYmxlKSB7XG4gICAgICBpZiAoIXdyaXRhYmxlLndyaXRlKGNodW5rKSkge1xuICAgICAgICBhd2FpdCB3YWl0KClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgd3JpdGFibGUuZW5kKClcbiAgICAgIGF3YWl0IHdhaXQoKVxuICAgIH1cbiAgICBmaW5pc2goKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBmaW5pc2goZXJyb3IgIT09IGVyciA/IGFnZ3JlZ2F0ZVR3b0Vycm9ycyhlcnJvciwgZXJyKSA6IGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBjbGVhbnVwKClcbiAgICB3cml0YWJsZS5vZmYoJ2RyYWluJywgcmVzdW1lKVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwdW1wVG9XZWIocmVhZGFibGUsIHdyaXRhYmxlLCBmaW5pc2gsIHsgZW5kIH0pIHtcbiAgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHdyaXRhYmxlKSkge1xuICAgIHdyaXRhYmxlID0gd3JpdGFibGUud3JpdGFibGVcbiAgfVxuICAvLyBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNleGFtcGxlLW1hbnVhbC13cml0ZS13aXRoLWJhY2twcmVzc3VyZVxuICBjb25zdCB3cml0ZXIgPSB3cml0YWJsZS5nZXRXcml0ZXIoKVxuICB0cnkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVhZGFibGUpIHtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeVxuICAgICAgd3JpdGVyLndyaXRlKGNodW5rKS5jYXRjaCgoKSA9PiB7fSlcbiAgICB9XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5XG4gICAgaWYgKGVuZCkge1xuICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKClcbiAgICB9XG4gICAgZmluaXNoKClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHdyaXRlci5hYm9ydChlcnIpXG4gICAgICBmaW5pc2goZXJyKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZmluaXNoKGVycilcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBpcGVsaW5lKC4uLnN0cmVhbXMpIHtcbiAgcmV0dXJuIHBpcGVsaW5lSW1wbChzdHJlYW1zLCBvbmNlKHBvcENhbGxiYWNrKHN0cmVhbXMpKSlcbn1cbmZ1bmN0aW9uIHBpcGVsaW5lSW1wbChzdHJlYW1zLCBjYWxsYmFjaywgb3B0cykge1xuICBpZiAoc3RyZWFtcy5sZW5ndGggPT09IDEgJiYgQXJyYXlJc0FycmF5KHN0cmVhbXNbMF0pKSB7XG4gICAgc3RyZWFtcyA9IHN0cmVhbXNbMF1cbiAgfVxuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKVxuICB9XG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIGNvbnN0IHNpZ25hbCA9IGFjLnNpZ25hbFxuICBjb25zdCBvdXRlclNpZ25hbCA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0cy5zaWduYWxcblxuICAvLyBOZWVkIHRvIGNsZWFudXAgZXZlbnQgbGlzdGVuZXJzIGlmIGxhc3Qgc3RyZWFtIGlzIHJlYWRhYmxlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU0NTJcbiAgY29uc3QgbGFzdFN0cmVhbUNsZWFudXAgPSBbXVxuICB2YWxpZGF0ZUFib3J0U2lnbmFsKG91dGVyU2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBmaW5pc2hJbXBsKG5ldyBBYm9ydEVycm9yKCkpXG4gIH1cbiAgYWRkQWJvcnRMaXN0ZW5lciA9IGFkZEFib3J0TGlzdGVuZXIgfHwgcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJykuYWRkQWJvcnRMaXN0ZW5lclxuICBsZXQgZGlzcG9zYWJsZVxuICBpZiAob3V0ZXJTaWduYWwpIHtcbiAgICBkaXNwb3NhYmxlID0gYWRkQWJvcnRMaXN0ZW5lcihvdXRlclNpZ25hbCwgYWJvcnQpXG4gIH1cbiAgbGV0IGVycm9yXG4gIGxldCB2YWx1ZVxuICBjb25zdCBkZXN0cm95cyA9IFtdXG4gIGxldCBmaW5pc2hDb3VudCA9IDBcbiAgZnVuY3Rpb24gZmluaXNoKGVycikge1xuICAgIGZpbmlzaEltcGwoZXJyLCAtLWZpbmlzaENvdW50ID09PSAwKVxuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaEltcGwoZXJyLCBmaW5hbCkge1xuICAgIHZhciBfZGlzcG9zYWJsZVxuICAgIGlmIChlcnIgJiYgKCFlcnJvciB8fCBlcnJvci5jb2RlID09PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSkge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG4gICAgaWYgKCFlcnJvciAmJiAhZmluYWwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB3aGlsZSAoZGVzdHJveXMubGVuZ3RoKSB7XG4gICAgICBkZXN0cm95cy5zaGlmdCgpKGVycm9yKVxuICAgIH1cbiAgICA7KF9kaXNwb3NhYmxlID0gZGlzcG9zYWJsZSkgPT09IG51bGwgfHwgX2Rpc3Bvc2FibGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9kaXNwb3NhYmxlW1N5bWJvbERpc3Bvc2VdKClcbiAgICBhYy5hYm9ydCgpXG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgIGxhc3RTdHJlYW1DbGVhbnVwLmZvckVhY2goKGZuKSA9PiBmbigpKVxuICAgICAgfVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKVxuICAgIH1cbiAgfVxuICBsZXQgcmV0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN0cmVhbSA9IHN0cmVhbXNbaV1cbiAgICBjb25zdCByZWFkaW5nID0gaSA8IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIGNvbnN0IHdyaXRpbmcgPSBpID4gMFxuICAgIGNvbnN0IGVuZCA9IHJlYWRpbmcgfHwgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0cy5lbmQpICE9PSBmYWxzZVxuICAgIGNvbnN0IGlzTGFzdFN0cmVhbSA9IGkgPT09IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIGlmIChpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBjb25zdCB7IGRlc3Ryb3ksIGNsZWFudXAgfSA9IGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcpXG4gICAgICAgIGRlc3Ryb3lzLnB1c2goZGVzdHJveSlcbiAgICAgICAgaWYgKGlzUmVhZGFibGUoc3RyZWFtKSAmJiBpc0xhc3RTdHJlYW0pIHtcbiAgICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5wdXNoKGNsZWFudXApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2F0Y2ggc3RyZWFtIGVycm9ycyB0aGF0IG9jY3VyIGFmdGVyIHBpcGUvcHVtcCBoYXMgY29tcGxldGVkLlxuICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIubmFtZSAhPT0gJ0Fib3J0RXJyb3InICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICAgICAgZmluaXNoKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pICYmIGlzTGFzdFN0cmVhbSkge1xuICAgICAgICBsYXN0U3RyZWFtQ2xlYW51cC5wdXNoKCgpID0+IHtcbiAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldCA9IHN0cmVhbSh7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pXG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnSXRlcmFibGUsIEFzeW5jSXRlcmFibGUgb3IgU3RyZWFtJywgJ3NvdXJjZScsIHJldClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0l0ZXJhYmxlKHN0cmVhbSkgfHwgaXNSZWFkYWJsZU5vZGVTdHJlYW0oc3RyZWFtKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShzdHJlYW0pKSB7XG4gICAgICAgIHJldCA9IHN0cmVhbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gRHVwbGV4LmZyb20oc3RyZWFtKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHJldCkpIHtcbiAgICAgICAgdmFyIF9yZXRcbiAgICAgICAgcmV0ID0gbWFrZUFzeW5jSXRlcmFibGUoKF9yZXQgPSByZXQpID09PSBudWxsIHx8IF9yZXQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9yZXQucmVhZGFibGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBtYWtlQXN5bmNJdGVyYWJsZShyZXQpXG4gICAgICB9XG4gICAgICByZXQgPSBzdHJlYW0ocmV0LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSlcbiAgICAgIGlmIChyZWFkaW5nKSB7XG4gICAgICAgIGlmICghaXNJdGVyYWJsZShyZXQsIHRydWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnQXN5bmNJdGVyYWJsZScsIGB0cmFuc2Zvcm1bJHtpIC0gMX1dYCwgcmV0KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JldDJcbiAgICAgICAgaWYgKCFQYXNzVGhyb3VnaCkge1xuICAgICAgICAgIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9wYXNzdGhyb3VnaCcpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbGFzdCBhcmd1bWVudCB0byBwaXBlbGluZSBpcyBub3QgYSBzdHJlYW1cbiAgICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgYSBwcm94eSBzdHJlYW0gc28gdGhhdCBwaXBlbGluZSguLi4pXG4gICAgICAgIC8vIGFsd2F5cyByZXR1cm5zIGEgc3RyZWFtIHdoaWNoIGNhbiBiZSBmdXJ0aGVyXG4gICAgICAgIC8vIGNvbXBvc2VkIHRocm91Z2ggYC5waXBlKHN0cmVhbSlgLlxuXG4gICAgICAgIGNvbnN0IHB0ID0gbmV3IFBhc3NUaHJvdWdoKHtcbiAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gSGFuZGxlIFByb21pc2VzL0ErIHNwZWMsIGB0aGVuYCBjb3VsZCBiZSBhIGdldHRlciB0aGF0IHRocm93cyBvblxuICAgICAgICAvLyBzZWNvbmQgdXNlLlxuICAgICAgICBjb25zdCB0aGVuID0gKF9yZXQyID0gcmV0KSA9PT0gbnVsbCB8fCBfcmV0MiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3JldDIudGhlblxuICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBmaW5pc2hDb3VudCsrXG4gICAgICAgICAgdGhlbi5jYWxsKFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgKHZhbCkgPT4ge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbFxuICAgICAgICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdC53cml0ZSh2YWwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgIHB0LmVuZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2gpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwdC5kZXN0cm95KGVycilcbiAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2gsIGVycilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShyZXQsIHRydWUpKSB7XG4gICAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICAgIHB1bXBUb05vZGUocmV0LCBwdCwgZmluaXNoLCB7XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKGlzUmVhZGFibGVTdHJlYW0ocmV0KSB8fCBpc1RyYW5zZm9ybVN0cmVhbShyZXQpKSB7XG4gICAgICAgICAgY29uc3QgdG9SZWFkID0gcmV0LnJlYWRhYmxlIHx8IHJldFxuICAgICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgICBwdW1wVG9Ob2RlKHRvUmVhZCwgcHQsIGZpbmlzaCwge1xuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFKCdBc3luY0l0ZXJhYmxlIG9yIFByb21pc2UnLCAnZGVzdGluYXRpb24nLCByZXQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gcHRcbiAgICAgICAgY29uc3QgeyBkZXN0cm95LCBjbGVhbnVwIH0gPSBkZXN0cm95ZXIocmV0LCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgZGVzdHJveXMucHVzaChkZXN0cm95KVxuICAgICAgICBpZiAoaXNMYXN0U3RyZWFtKSB7XG4gICAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAucHVzaChjbGVhbnVwKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc05vZGVTdHJlYW0oc3RyZWFtKSkge1xuICAgICAgaWYgKGlzUmVhZGFibGVOb2RlU3RyZWFtKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQgKz0gMlxuICAgICAgICBjb25zdCBjbGVhbnVwID0gcGlwZShyZXQsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkgJiYgaXNMYXN0U3RyZWFtKSB7XG4gICAgICAgICAgbGFzdFN0cmVhbUNsZWFudXAucHVzaChjbGVhbnVwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVHJhbnNmb3JtU3RyZWFtKHJldCkgfHwgaXNSZWFkYWJsZVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGNvbnN0IHRvUmVhZCA9IHJldC5yZWFkYWJsZSB8fCByZXRcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9Ob2RlKHRvUmVhZCwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvTm9kZShyZXQsIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoXG4gICAgICAgICAgJ3ZhbCcsXG4gICAgICAgICAgWydSZWFkYWJsZScsICdJdGVyYWJsZScsICdBc3luY0l0ZXJhYmxlJywgJ1JlYWRhYmxlU3RyZWFtJywgJ1RyYW5zZm9ybVN0cmVhbSddLFxuICAgICAgICAgIHJldFxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXQgPSBzdHJlYW1cbiAgICB9IGVsc2UgaWYgKGlzV2ViU3RyZWFtKHN0cmVhbSkpIHtcbiAgICAgIGlmIChpc1JlYWRhYmxlTm9kZVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvV2ViKG1ha2VBc3luY0l0ZXJhYmxlKHJldCksIHN0cmVhbSwgZmluaXNoLCB7XG4gICAgICAgICAgZW5kXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzUmVhZGFibGVTdHJlYW0ocmV0KSB8fCBpc0l0ZXJhYmxlKHJldCkpIHtcbiAgICAgICAgZmluaXNoQ291bnQrK1xuICAgICAgICBwdW1wVG9XZWIocmV0LCBzdHJlYW0sIGZpbmlzaCwge1xuICAgICAgICAgIGVuZFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChpc1RyYW5zZm9ybVN0cmVhbShyZXQpKSB7XG4gICAgICAgIGZpbmlzaENvdW50KytcbiAgICAgICAgcHVtcFRvV2ViKHJldC5yZWFkYWJsZSwgc3RyZWFtLCBmaW5pc2gsIHtcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRShcbiAgICAgICAgICAndmFsJyxcbiAgICAgICAgICBbJ1JlYWRhYmxlJywgJ0l0ZXJhYmxlJywgJ0FzeW5jSXRlcmFibGUnLCAnUmVhZGFibGVTdHJlYW0nLCAnVHJhbnNmb3JtU3RyZWFtJ10sXG4gICAgICAgICAgcmV0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldCA9IHN0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSBEdXBsZXguZnJvbShzdHJlYW0pXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICAoc2lnbmFsICE9PSBudWxsICYmIHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmIHNpZ25hbC5hYm9ydGVkKSB8fFxuICAgIChvdXRlclNpZ25hbCAhPT0gbnVsbCAmJiBvdXRlclNpZ25hbCAhPT0gdW5kZWZpbmVkICYmIG91dGVyU2lnbmFsLmFib3J0ZWQpXG4gICkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soYWJvcnQpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuZnVuY3Rpb24gcGlwZShzcmMsIGRzdCwgZmluaXNoLCB7IGVuZCB9KSB7XG4gIGxldCBlbmRlZCA9IGZhbHNlXG4gIGRzdC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgaWYgKCFlbmRlZCkge1xuICAgICAgLy8gRmluaXNoIGlmIHRoZSBkZXN0aW5hdGlvbiBjbG9zZXMgYmVmb3JlIHRoZSBzb3VyY2UgaGFzIGNvbXBsZXRlZC5cbiAgICAgIGZpbmlzaChuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKSlcbiAgICB9XG4gIH0pXG4gIHNyYy5waXBlKGRzdCwge1xuICAgIGVuZDogZmFsc2VcbiAgfSkgLy8gSWYgZW5kIGlzIHRydWUgd2UgYWxyZWFkeSB3aWxsIGhhdmUgYSBsaXN0ZW5lciB0byBlbmQgZHN0LlxuXG4gIGlmIChlbmQpIHtcbiAgICAvLyBDb21wYXQuIEJlZm9yZSBub2RlIHYxMC4xMi4wIHN0ZGlvIHVzZWQgdG8gdGhyb3cgYW4gZXJyb3Igc29cbiAgICAvLyBwaXBlKCkgZGlkL2RvZXMgbm90IGVuZCgpIHN0ZGlvIGRlc3RpbmF0aW9ucy5cbiAgICAvLyBOb3cgdGhleSBhbGxvdyBpdCBidXQgXCJzZWNyZXRseVwiIGRvbid0IGNsb3NlIHRoZSB1bmRlcmx5aW5nIGZkLlxuXG4gICAgZnVuY3Rpb24gZW5kRm4oKSB7XG4gICAgICBlbmRlZCA9IHRydWVcbiAgICAgIGRzdC5lbmQoKVxuICAgIH1cbiAgICBpZiAoaXNSZWFkYWJsZUZpbmlzaGVkKHNyYykpIHtcbiAgICAgIC8vIEVuZCB0aGUgZGVzdGluYXRpb24gaWYgdGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBlbmRlZC5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoKClcbiAgfVxuICBlb3MoXG4gICAgc3JjLFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBjb25zdCByU3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGVcbiAgICAgIGlmIChcbiAgICAgICAgZXJyICYmXG4gICAgICAgIGVyci5jb2RlID09PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnICYmXG4gICAgICAgIHJTdGF0ZSAmJlxuICAgICAgICByU3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIXJTdGF0ZS5lcnJvcmVkICYmXG4gICAgICAgICFyU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgLy8gU29tZSByZWFkYWJsZSBzdHJlYW1zIHdpbGwgZW1pdCAnY2xvc2UnIGJlZm9yZSAnZW5kJy4gSG93ZXZlciwgc2luY2VcbiAgICAgICAgLy8gdGhpcyBpcyBvbiB0aGUgcmVhZGFibGUgc2lkZSAnZW5kJyBzaG91bGQgc3RpbGwgYmUgZW1pdHRlZCBpZiB0aGVcbiAgICAgICAgLy8gc3RyZWFtIGhhcyBiZWVuIGVuZGVkIGFuZCBubyBlcnJvciBlbWl0dGVkLiBUaGlzIHNob3VsZCBiZSBhbGxvd2VkIGluXG4gICAgICAgIC8vIGZhdm9yIG9mIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBTaW5jZSB0aGUgc3RyZWFtIGlzIHBpcGVkIHRvIGFcbiAgICAgICAgLy8gZGVzdGluYXRpb24gdGhpcyBzaG91bGQgbm90IHJlc3VsdCBpbiBhbnkgb2JzZXJ2YWJsZSBkaWZmZXJlbmNlLlxuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGlmIHRoaXMgaXMgYSB3cml0YWJsZSBwcmVtYXR1cmUgY2xvc2Ugc2luY2VcbiAgICAgICAgLy8gZW9zIHdpbGwgb25seSBmYWlsIHdpdGggcHJlbWF0dXJlIGNsb3NlIG9uIHRoZSByZWFkaW5nIHNpZGUgZm9yXG4gICAgICAgIC8vIGR1cGxleCBzdHJlYW1zLlxuICAgICAgICBzcmMub25jZSgnZW5kJywgZmluaXNoKS5vbmNlKCdlcnJvcicsIGZpbmlzaClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaChlcnIpXG4gICAgICB9XG4gICAgfVxuICApXG4gIHJldHVybiBlb3MoXG4gICAgZHN0LFxuICAgIHtcbiAgICAgIHJlYWRhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBmaW5pc2hcbiAgKVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBpcGVsaW5lSW1wbCxcbiAgcGlwZWxpbmVcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCcuL3BpcGVsaW5lJylcbmNvbnN0IER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4JylcbmNvbnN0IHsgZGVzdHJveWVyIH0gPSByZXF1aXJlKCcuL2Rlc3Ryb3knKVxuY29uc3Qge1xuICBpc05vZGVTdHJlYW0sXG4gIGlzUmVhZGFibGUsXG4gIGlzV3JpdGFibGUsXG4gIGlzV2ViU3RyZWFtLFxuICBpc1RyYW5zZm9ybVN0cmVhbSxcbiAgaXNXcml0YWJsZVN0cmVhbSxcbiAgaXNSZWFkYWJsZVN0cmVhbVxufSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3Qge1xuICBBYm9ydEVycm9yLFxuICBjb2RlczogeyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIEVSUl9NSVNTSU5HX0FSR1MgfVxufSA9IHJlcXVpcmUoJy4uLy4uL291cnMvZXJyb3JzJylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbXBvc2UoLi4uc3RyZWFtcykge1xuICBpZiAoc3RyZWFtcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpXG4gIH1cbiAgaWYgKHN0cmVhbXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIER1cGxleC5mcm9tKHN0cmVhbXNbMF0pXG4gIH1cbiAgY29uc3Qgb3JnU3RyZWFtcyA9IFsuLi5zdHJlYW1zXVxuICBpZiAodHlwZW9mIHN0cmVhbXNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJlYW1zWzBdID0gRHVwbGV4LmZyb20oc3RyZWFtc1swXSlcbiAgfVxuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGlkeCA9IHN0cmVhbXMubGVuZ3RoIC0gMVxuICAgIHN0cmVhbXNbaWR4XSA9IER1cGxleC5mcm9tKHN0cmVhbXNbaWR4XSlcbiAgfVxuICBmb3IgKGxldCBuID0gMDsgbiA8IHN0cmVhbXMubGVuZ3RoOyArK24pIHtcbiAgICBpZiAoIWlzTm9kZVN0cmVhbShzdHJlYW1zW25dKSAmJiAhaXNXZWJTdHJlYW0oc3RyZWFtc1tuXSkpIHtcbiAgICAgIC8vIFRPRE8ocm9uYWcpOiBBZGQgY2hlY2tzIGZvciBub24gc3RyZWFtcy5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChcbiAgICAgIG4gPCBzdHJlYW1zLmxlbmd0aCAtIDEgJiZcbiAgICAgICEoaXNSZWFkYWJsZShzdHJlYW1zW25dKSB8fCBpc1JlYWRhYmxlU3RyZWFtKHN0cmVhbXNbbl0pIHx8IGlzVHJhbnNmb3JtU3RyZWFtKHN0cmVhbXNbbl0pKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShgc3RyZWFtc1ske259XWAsIG9yZ1N0cmVhbXNbbl0sICdtdXN0IGJlIHJlYWRhYmxlJylcbiAgICB9XG4gICAgaWYgKG4gPiAwICYmICEoaXNXcml0YWJsZShzdHJlYW1zW25dKSB8fCBpc1dyaXRhYmxlU3RyZWFtKHN0cmVhbXNbbl0pIHx8IGlzVHJhbnNmb3JtU3RyZWFtKHN0cmVhbXNbbl0pKSkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19WQUxVRShgc3RyZWFtc1ske259XWAsIG9yZ1N0cmVhbXNbbl0sICdtdXN0IGJlIHdyaXRhYmxlJylcbiAgICB9XG4gIH1cbiAgbGV0IG9uZHJhaW5cbiAgbGV0IG9uZmluaXNoXG4gIGxldCBvbnJlYWRhYmxlXG4gIGxldCBvbmNsb3NlXG4gIGxldCBkXG4gIGZ1bmN0aW9uIG9uZmluaXNoZWQoZXJyKSB7XG4gICAgY29uc3QgY2IgPSBvbmNsb3NlXG4gICAgb25jbG9zZSA9IG51bGxcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycilcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgZC5kZXN0cm95KGVycilcbiAgICB9IGVsc2UgaWYgKCFyZWFkYWJsZSAmJiAhd3JpdGFibGUpIHtcbiAgICAgIGQuZGVzdHJveSgpXG4gICAgfVxuICB9XG4gIGNvbnN0IGhlYWQgPSBzdHJlYW1zWzBdXG4gIGNvbnN0IHRhaWwgPSBwaXBlbGluZShzdHJlYW1zLCBvbmZpbmlzaGVkKVxuICBjb25zdCB3cml0YWJsZSA9ICEhKGlzV3JpdGFibGUoaGVhZCkgfHwgaXNXcml0YWJsZVN0cmVhbShoZWFkKSB8fCBpc1RyYW5zZm9ybVN0cmVhbShoZWFkKSlcbiAgY29uc3QgcmVhZGFibGUgPSAhIShpc1JlYWRhYmxlKHRhaWwpIHx8IGlzUmVhZGFibGVTdHJlYW0odGFpbCkgfHwgaXNUcmFuc2Zvcm1TdHJlYW0odGFpbCkpXG5cbiAgLy8gVE9ETyhyb25hZyk6IEF2b2lkIGRvdWJsZSBidWZmZXJpbmcuXG4gIC8vIEltcGxlbWVudCBXcml0YWJsZS9SZWFkYWJsZS9EdXBsZXggdHJhaXRzLlxuICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzMzNTE1LlxuICBkID0gbmV3IER1cGxleCh7XG4gICAgLy8gVE9ETyAocm9uYWcpOiBoaWdoV2F0ZXJNYXJrP1xuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogISEoaGVhZCAhPT0gbnVsbCAmJiBoZWFkICE9PSB1bmRlZmluZWQgJiYgaGVhZC53cml0YWJsZU9iamVjdE1vZGUpLFxuICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogISEodGFpbCAhPT0gbnVsbCAmJiB0YWlsICE9PSB1bmRlZmluZWQgJiYgdGFpbC5yZWFkYWJsZU9iamVjdE1vZGUpLFxuICAgIHdyaXRhYmxlLFxuICAgIHJlYWRhYmxlXG4gIH0pXG4gIGlmICh3cml0YWJsZSkge1xuICAgIGlmIChpc05vZGVTdHJlYW0oaGVhZCkpIHtcbiAgICAgIGQuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGhlYWQud3JpdGUoY2h1bmssIGVuY29kaW5nKSkge1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbmRyYWluID0gY2FsbGJhY2tcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaGVhZC5lbmQoKVxuICAgICAgICBvbmZpbmlzaCA9IGNhbGxiYWNrXG4gICAgICB9XG4gICAgICBoZWFkLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9uZHJhaW4pIHtcbiAgICAgICAgICBjb25zdCBjYiA9IG9uZHJhaW5cbiAgICAgICAgICBvbmRyYWluID0gbnVsbFxuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGlzV2ViU3RyZWFtKGhlYWQpKSB7XG4gICAgICBjb25zdCB3cml0YWJsZSA9IGlzVHJhbnNmb3JtU3RyZWFtKGhlYWQpID8gaGVhZC53cml0YWJsZSA6IGhlYWRcbiAgICAgIGNvbnN0IHdyaXRlciA9IHdyaXRhYmxlLmdldFdyaXRlcigpXG4gICAgICBkLl93cml0ZSA9IGFzeW5jIGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgd3JpdGVyLnJlYWR5XG4gICAgICAgICAgd3JpdGVyLndyaXRlKGNodW5rKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZC5fZmluYWwgPSBhc3luYyBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHlcbiAgICAgICAgICB3cml0ZXIuY2xvc2UoKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgICAgICBvbmZpbmlzaCA9IGNhbGxiYWNrXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0b1JlYWQgPSBpc1RyYW5zZm9ybVN0cmVhbSh0YWlsKSA/IHRhaWwucmVhZGFibGUgOiB0YWlsXG4gICAgZW9zKHRvUmVhZCwgKCkgPT4ge1xuICAgICAgaWYgKG9uZmluaXNoKSB7XG4gICAgICAgIGNvbnN0IGNiID0gb25maW5pc2hcbiAgICAgICAgb25maW5pc2ggPSBudWxsXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGlmIChyZWFkYWJsZSkge1xuICAgIGlmIChpc05vZGVTdHJlYW0odGFpbCkpIHtcbiAgICAgIHRhaWwub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob25yZWFkYWJsZSkge1xuICAgICAgICAgIGNvbnN0IGNiID0gb25yZWFkYWJsZVxuICAgICAgICAgIG9ucmVhZGFibGUgPSBudWxsXG4gICAgICAgICAgY2IoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGFpbC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkLnB1c2gobnVsbClcbiAgICAgIH0pXG4gICAgICBkLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRhaWwucmVhZCgpXG4gICAgICAgICAgaWYgKGJ1ZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb25yZWFkYWJsZSA9IGQuX3JlYWRcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWQucHVzaChidWYpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzV2ViU3RyZWFtKHRhaWwpKSB7XG4gICAgICBjb25zdCByZWFkYWJsZSA9IGlzVHJhbnNmb3JtU3RyZWFtKHRhaWwpID8gdGFpbC5yZWFkYWJsZSA6IHRhaWxcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlLmdldFJlYWRlcigpXG4gICAgICBkLl9yZWFkID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICAgICAgICBpZiAoIWQucHVzaCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBkLnB1c2gobnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFlcnIgJiYgb25jbG9zZSAhPT0gbnVsbCkge1xuICAgICAgZXJyID0gbmV3IEFib3J0RXJyb3IoKVxuICAgIH1cbiAgICBvbnJlYWRhYmxlID0gbnVsbFxuICAgIG9uZHJhaW4gPSBudWxsXG4gICAgb25maW5pc2ggPSBudWxsXG4gICAgaWYgKG9uY2xvc2UgPT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICB9IGVsc2Uge1xuICAgICAgb25jbG9zZSA9IGNhbGxiYWNrXG4gICAgICBpZiAoaXNOb2RlU3RyZWFtKHRhaWwpKSB7XG4gICAgICAgIGRlc3Ryb3llcih0YWlsLCBlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQWJvcnRDb250cm9sbGVyID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIgfHwgcmVxdWlyZSgnYWJvcnQtY29udHJvbGxlcicpLkFib3J0Q29udHJvbGxlclxuY29uc3Qge1xuICBjb2RlczogeyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIEVSUl9JTlZBTElEX0FSR19UWVBFLCBFUlJfTUlTU0lOR19BUkdTLCBFUlJfT1VUX09GX1JBTkdFIH0sXG4gIEFib3J0RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi8uLi9vdXJzL2Vycm9ycycpXG5jb25zdCB7IHZhbGlkYXRlQWJvcnRTaWduYWwsIHZhbGlkYXRlSW50ZWdlciwgdmFsaWRhdGVPYmplY3QgfSA9IHJlcXVpcmUoJy4uL3ZhbGlkYXRvcnMnKVxuY29uc3Qga1dlYWtIYW5kbGVyID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpLlN5bWJvbCgna1dlYWsnKVxuY29uc3Qga1Jlc2lzdFN0b3BQcm9wYWdhdGlvbiA9IHJlcXVpcmUoJy4uLy4uL291cnMvcHJpbW9yZGlhbHMnKS5TeW1ib2woJ2tSZXNpc3RTdG9wUHJvcGFnYXRpb24nKVxuY29uc3QgeyBmaW5pc2hlZCB9ID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IHN0YXRpY0NvbXBvc2UgPSByZXF1aXJlKCcuL2NvbXBvc2UnKVxuY29uc3QgeyBhZGRBYm9ydFNpZ25hbE5vVmFsaWRhdGUgfSA9IHJlcXVpcmUoJy4vYWRkLWFib3J0LXNpZ25hbCcpXG5jb25zdCB7IGlzV3JpdGFibGUsIGlzTm9kZVN0cmVhbSB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCB7IGRlcHJlY2F0ZSB9ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy91dGlsJylcbmNvbnN0IHtcbiAgQXJyYXlQcm90b3R5cGVQdXNoLFxuICBCb29sZWFuLFxuICBNYXRoRmxvb3IsXG4gIE51bWJlcixcbiAgTnVtYmVySXNOYU4sXG4gIFByb21pc2UsXG4gIFByb21pc2VSZWplY3QsXG4gIFByb21pc2VSZXNvbHZlLFxuICBQcm9taXNlUHJvdG90eXBlVGhlbixcbiAgU3ltYm9sXG59ID0gcmVxdWlyZSgnLi4vLi4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCBrRW1wdHkgPSBTeW1ib2woJ2tFbXB0eScpXG5jb25zdCBrRW9mID0gU3ltYm9sKCdrRW9mJylcbmZ1bmN0aW9uIGNvbXBvc2Uoc3RyZWFtLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBpZiAoaXNOb2RlU3RyZWFtKHN0cmVhbSkgJiYgIWlzV3JpdGFibGUoc3RyZWFtKSkge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVkFMVUUoJ3N0cmVhbScsIHN0cmVhbSwgJ211c3QgYmUgd3JpdGFibGUnKVxuICB9XG4gIGNvbnN0IGNvbXBvc2VkU3RyZWFtID0gc3RhdGljQ29tcG9zZSh0aGlzLCBzdHJlYW0pXG4gIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnNpZ25hbCkge1xuICAgIC8vIE5vdCB2YWxpZGF0aW5nIGFzIHdlIGFscmVhZHkgdmFsaWRhdGVkIGJlZm9yZVxuICAgIGFkZEFib3J0U2lnbmFsTm9WYWxpZGF0ZShvcHRpb25zLnNpZ25hbCwgY29tcG9zZWRTdHJlYW0pXG4gIH1cbiAgcmV0dXJuIGNvbXBvc2VkU3RyZWFtXG59XG5mdW5jdGlvbiBtYXAoZm4sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCBbJ0Z1bmN0aW9uJywgJ0FzeW5jRnVuY3Rpb24nXSwgZm4pXG4gIH1cbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIGxldCBjb25jdXJyZW5jeSA9IDFcbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuY29uY3VycmVuY3kpICE9IG51bGwpIHtcbiAgICBjb25jdXJyZW5jeSA9IE1hdGhGbG9vcihvcHRpb25zLmNvbmN1cnJlbmN5KVxuICB9XG4gIGxldCBoaWdoV2F0ZXJNYXJrID0gY29uY3VycmVuY3kgLSAxXG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmhpZ2hXYXRlck1hcmspICE9IG51bGwpIHtcbiAgICBoaWdoV2F0ZXJNYXJrID0gTWF0aEZsb29yKG9wdGlvbnMuaGlnaFdhdGVyTWFyaylcbiAgfVxuICB2YWxpZGF0ZUludGVnZXIoY29uY3VycmVuY3ksICdvcHRpb25zLmNvbmN1cnJlbmN5JywgMSlcbiAgdmFsaWRhdGVJbnRlZ2VyKGhpZ2hXYXRlck1hcmssICdvcHRpb25zLmhpZ2hXYXRlck1hcmsnLCAwKVxuICBoaWdoV2F0ZXJNYXJrICs9IGNvbmN1cnJlbmN5XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiogbWFwKCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHJlcXVpcmUoJy4uLy4uL291cnMvdXRpbCcpLkFib3J0U2lnbmFsQW55KFxuICAgICAgW29wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWxdLmZpbHRlcihCb29sZWFuKVxuICAgIClcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzXG4gICAgY29uc3QgcXVldWUgPSBbXVxuICAgIGNvbnN0IHNpZ25hbE9wdCA9IHtcbiAgICAgIHNpZ25hbFxuICAgIH1cbiAgICBsZXQgbmV4dFxuICAgIGxldCByZXN1bWVcbiAgICBsZXQgZG9uZSA9IGZhbHNlXG4gICAgbGV0IGNudCA9IDBcbiAgICBmdW5jdGlvbiBvbkNhdGNoKCkge1xuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIGFmdGVySXRlbVByb2Nlc3NlZCgpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGFmdGVySXRlbVByb2Nlc3NlZCgpIHtcbiAgICAgIGNudCAtPSAxXG4gICAgICBtYXliZVJlc3VtZSgpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1heWJlUmVzdW1lKCkge1xuICAgICAgaWYgKHJlc3VtZSAmJiAhZG9uZSAmJiBjbnQgPCBjb25jdXJyZW5jeSAmJiBxdWV1ZS5sZW5ndGggPCBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgIHJlc3VtZSgpXG4gICAgICAgIHJlc3VtZSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAobGV0IHZhbCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsID0gZm4odmFsLCBzaWduYWxPcHQpXG4gICAgICAgICAgICBpZiAodmFsID09PSBrRW1wdHkpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IFByb21pc2VSZXNvbHZlKHZhbClcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHZhbCA9IFByb21pc2VSZWplY3QoZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjbnQgKz0gMVxuICAgICAgICAgIFByb21pc2VQcm90b3R5cGVUaGVuKHZhbCwgYWZ0ZXJJdGVtUHJvY2Vzc2VkLCBvbkNhdGNoKVxuICAgICAgICAgIHF1ZXVlLnB1c2godmFsKVxuICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0KClcbiAgICAgICAgICAgIG5leHQgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZG9uZSAmJiAocXVldWUubGVuZ3RoID49IGhpZ2hXYXRlck1hcmsgfHwgY250ID49IGNvbmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgcmVzdW1lID0gcmVzb2x2ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWUucHVzaChrRW9mKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IFByb21pc2VSZWplY3QoZXJyKVxuICAgICAgICBQcm9taXNlUHJvdG90eXBlVGhlbih2YWwsIGFmdGVySXRlbVByb2Nlc3NlZCwgb25DYXRjaClcbiAgICAgICAgcXVldWUucHVzaCh2YWwpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIG5leHQoKVxuICAgICAgICAgIG5leHQgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcHVtcCgpXG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgdmFsID0gYXdhaXQgcXVldWVbMF1cbiAgICAgICAgICBpZiAodmFsID09PSBrRW9mKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWwgIT09IGtFbXB0eSkge1xuICAgICAgICAgICAgeWllbGQgdmFsXG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlLnNoaWZ0KClcbiAgICAgICAgICBtYXliZVJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBuZXh0ID0gcmVzb2x2ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBkb25lID0gdHJ1ZVxuICAgICAgaWYgKHJlc3VtZSkge1xuICAgICAgICByZXN1bWUoKVxuICAgICAgICByZXN1bWUgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LmNhbGwodGhpcylcbn1cbmZ1bmN0aW9uIGFzSW5kZXhlZFBhaXJzKG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiogYXNJbmRleGVkUGFpcnMoKSB7XG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRzaWduYWxcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgKF9vcHRpb25zJHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWwuYWJvcnRlZFxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKHtcbiAgICAgICAgICBjYXVzZTogb3B0aW9ucy5zaWduYWwucmVhc29uXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICB5aWVsZCBbaW5kZXgrKywgdmFsXVxuICAgIH1cbiAgfS5jYWxsKHRoaXMpXG59XG5hc3luYyBmdW5jdGlvbiBzb21lKGZuLCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgdW51c2VkIG9mIGZpbHRlci5jYWxsKHRoaXMsIGZuLCBvcHRpb25zKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5hc3luYyBmdW5jdGlvbiBldmVyeShmbiwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsIFsnRnVuY3Rpb24nLCAnQXN5bmNGdW5jdGlvbiddLCBmbilcbiAgfVxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZV9Nb3JnYW4lMjdzX2xhd3NcbiAgcmV0dXJuICEoYXdhaXQgc29tZS5jYWxsKFxuICAgIHRoaXMsXG4gICAgYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgIHJldHVybiAhKGF3YWl0IGZuKC4uLmFyZ3MpKVxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApKVxufVxuYXN5bmMgZnVuY3Rpb24gZmluZChmbiwgb3B0aW9ucykge1xuICBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiBmaWx0ZXIuY2FsbCh0aGlzLCBmbiwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuYXN5bmMgZnVuY3Rpb24gZm9yRWFjaChmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdmbicsIFsnRnVuY3Rpb24nLCAnQXN5bmNGdW5jdGlvbiddLCBmbilcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmb3JFYWNoRm4odmFsdWUsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCBmbih2YWx1ZSwgb3B0aW9ucylcbiAgICByZXR1cm4ga0VtcHR5XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGZvciBhd2FpdCAoY29uc3QgdW51c2VkIG9mIG1hcC5jYWxsKHRoaXMsIGZvckVhY2hGbiwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gZmlsdGVyKGZuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2ZuJywgWydGdW5jdGlvbicsICdBc3luY0Z1bmN0aW9uJ10sIGZuKVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGZpbHRlckZuKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKGF3YWl0IGZuKHZhbHVlLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIHJldHVybiBrRW1wdHlcbiAgfVxuICByZXR1cm4gbWFwLmNhbGwodGhpcywgZmlsdGVyRm4sIG9wdGlvbnMpXG59XG5cbi8vIFNwZWNpZmljIHRvIHByb3ZpZGUgYmV0dGVyIGVycm9yIHRvIHJlZHVjZSBzaW5jZSB0aGUgYXJndW1lbnQgaXMgb25seVxuLy8gbWlzc2luZyBpZiB0aGUgc3RyZWFtIGhhcyBubyBpdGVtcyBpbiBpdCAtIGJ1dCB0aGUgY29kZSBpcyBzdGlsbCBhcHByb3ByaWF0ZVxuY2xhc3MgUmVkdWNlQXdhcmVFcnJNaXNzaW5nQXJncyBleHRlbmRzIEVSUl9NSVNTSU5HX0FSR1Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigncmVkdWNlJylcbiAgICB0aGlzLm1lc3NhZ2UgPSAnUmVkdWNlIG9mIGFuIGVtcHR5IHN0cmVhbSByZXF1aXJlcyBhbiBpbml0aWFsIHZhbHVlJ1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWR1Y2UocmVkdWNlciwgaW5pdGlhbFZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRzaWduYWwyXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncmVkdWNlcicsIFsnRnVuY3Rpb24nLCAnQXN5bmNGdW5jdGlvbiddLCByZWR1Y2VyKVxuICB9XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBsZXQgaGFzSW5pdGlhbFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgaWYgKFxuICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAoX29wdGlvbnMkc2lnbmFsMiA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgIF9vcHRpb25zJHNpZ25hbDIgIT09IHVuZGVmaW5lZCAmJlxuICAgIF9vcHRpb25zJHNpZ25hbDIuYWJvcnRlZFxuICApIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgQWJvcnRFcnJvcih1bmRlZmluZWQsIHtcbiAgICAgIGNhdXNlOiBvcHRpb25zLnNpZ25hbC5yZWFzb25cbiAgICB9KVxuICAgIHRoaXMub25jZSgnZXJyb3InLCAoKSA9PiB7fSkgLy8gVGhlIGVycm9yIGlzIGFscmVhZHkgcHJvcGFnYXRlZFxuICAgIGF3YWl0IGZpbmlzaGVkKHRoaXMuZGVzdHJveShlcnIpKVxuICAgIHRocm93IGVyclxuICB9XG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIGNvbnN0IHNpZ25hbCA9IGFjLnNpZ25hbFxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zaWduYWwpIHtcbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIFtrV2Vha0hhbmRsZXJdOiB0aGlzLFxuICAgICAgW2tSZXNpc3RTdG9wUHJvcGFnYXRpb25dOiB0cnVlXG4gICAgfVxuICAgIG9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gYWMuYWJvcnQoKSwgb3B0cylcbiAgfVxuICBsZXQgZ290QW55SXRlbUZyb21TdHJlYW0gPSBmYWxzZVxuICB0cnkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcykge1xuICAgICAgdmFyIF9vcHRpb25zJHNpZ25hbDNcbiAgICAgIGdvdEFueUl0ZW1Gcm9tU3RyZWFtID0gdHJ1ZVxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoX29wdGlvbnMkc2lnbmFsMyA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWwzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsMy5hYm9ydGVkXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUpIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gdmFsdWVcbiAgICAgICAgaGFzSW5pdGlhbFZhbHVlID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFZhbHVlID0gYXdhaXQgcmVkdWNlcihpbml0aWFsVmFsdWUsIHZhbHVlLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZ290QW55SXRlbUZyb21TdHJlYW0gJiYgIWhhc0luaXRpYWxWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlZHVjZUF3YXJlRXJyTWlzc2luZ0FyZ3MoKVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBhYy5hYm9ydCgpXG4gIH1cbiAgcmV0dXJuIGluaXRpYWxWYWx1ZVxufVxuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpXG4gIH1cbiAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCwgJ29wdGlvbnMuc2lnbmFsJylcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXVxuICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgdmFyIF9vcHRpb25zJHNpZ25hbDRcbiAgICBpZiAoXG4gICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChfb3B0aW9ucyRzaWduYWw0ID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDQuYWJvcnRlZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IodW5kZWZpbmVkLCB7XG4gICAgICAgIGNhdXNlOiBvcHRpb25zLnNpZ25hbC5yZWFzb25cbiAgICAgIH0pXG4gICAgfVxuICAgIEFycmF5UHJvdG90eXBlUHVzaChyZXN1bHQsIHZhbClcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5mdW5jdGlvbiBmbGF0TWFwKGZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHZhbHVlcyA9IG1hcC5jYWxsKHRoaXMsIGZuLCBvcHRpb25zKVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIGZsYXRNYXAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgdmFsdWVzKSB7XG4gICAgICB5aWVsZCogdmFsXG4gICAgfVxuICB9LmNhbGwodGhpcylcbn1cbmZ1bmN0aW9uIHRvSW50ZWdlck9ySW5maW5pdHkobnVtYmVyKSB7XG4gIC8vIFdlIGNvZXJjZSBoZXJlIHRvIGFsaWduIHdpdGggdGhlIHNwZWNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtaXRlcmF0b3ItaGVscGVycy9pc3N1ZXMvMTY5XG4gIG51bWJlciA9IE51bWJlcihudW1iZXIpXG4gIGlmIChOdW1iZXJJc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAobnVtYmVyIDwgMCkge1xuICAgIHRocm93IG5ldyBFUlJfT1VUX09GX1JBTkdFKCdudW1iZXInLCAnPj0gMCcsIG51bWJlcilcbiAgfVxuICByZXR1cm4gbnVtYmVyXG59XG5mdW5jdGlvbiBkcm9wKG51bWJlciwgb3B0aW9ucyA9IHVuZGVmaW5lZCkge1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKVxuICB9XG4gIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnNpZ25hbCkgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwsICdvcHRpb25zLnNpZ25hbCcpXG4gIH1cbiAgbnVtYmVyID0gdG9JbnRlZ2VyT3JJbmZpbml0eShudW1iZXIpXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiogZHJvcCgpIHtcbiAgICB2YXIgX29wdGlvbnMkc2lnbmFsNVxuICAgIGlmIChcbiAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKF9vcHRpb25zJHNpZ25hbDUgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgX29wdGlvbnMkc2lnbmFsNS5hYm9ydGVkXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgfVxuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHRoaXMpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRzaWduYWw2XG4gICAgICBpZiAoXG4gICAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcbiAgICAgICAgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChfb3B0aW9ucyRzaWduYWw2ID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICAgIF9vcHRpb25zJHNpZ25hbDYgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWw2LmFib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgQWJvcnRFcnJvcigpXG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyLS0gPD0gMCkge1xuICAgICAgICB5aWVsZCB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH0uY2FsbCh0aGlzKVxufVxuZnVuY3Rpb24gdGFrZShudW1iZXIsIG9wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJylcbiAgfVxuICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpICE9IG51bGwpIHtcbiAgICB2YWxpZGF0ZUFib3J0U2lnbmFsKG9wdGlvbnMuc2lnbmFsLCAnb3B0aW9ucy5zaWduYWwnKVxuICB9XG4gIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkobnVtYmVyKVxuICByZXR1cm4gYXN5bmMgZnVuY3Rpb24qIHRha2UoKSB7XG4gICAgdmFyIF9vcHRpb25zJHNpZ25hbDdcbiAgICBpZiAoXG4gICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICBvcHRpb25zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChfb3B0aW9ucyRzaWduYWw3ID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmXG4gICAgICBfb3B0aW9ucyRzaWduYWw3ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIF9vcHRpb25zJHNpZ25hbDcuYWJvcnRlZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgIH1cbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiB0aGlzKSB7XG4gICAgICB2YXIgX29wdGlvbnMkc2lnbmFsOFxuICAgICAgaWYgKFxuICAgICAgICBvcHRpb25zICE9PSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAoX29wdGlvbnMkc2lnbmFsOCA9IG9wdGlvbnMuc2lnbmFsKSAhPT0gbnVsbCAmJlxuICAgICAgICBfb3B0aW9ucyRzaWduYWw4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgX29wdGlvbnMkc2lnbmFsOC5hYm9ydGVkXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoKVxuICAgICAgfVxuICAgICAgaWYgKG51bWJlci0tID4gMCkge1xuICAgICAgICB5aWVsZCB2YWxcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgZ2V0IGFub3RoZXIgaXRlbSBmcm9tIGl0ZXJhdG9yIGluIGNhc2Ugd2UgcmVhY2hlZCB0aGUgZW5kXG4gICAgICBpZiAobnVtYmVyIDw9IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9LmNhbGwodGhpcylcbn1cbm1vZHVsZS5leHBvcnRzLnN0cmVhbVJldHVybmluZ09wZXJhdG9ycyA9IHtcbiAgYXNJbmRleGVkUGFpcnM6IGRlcHJlY2F0ZShhc0luZGV4ZWRQYWlycywgJ3JlYWRhYmxlLmFzSW5kZXhlZFBhaXJzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicpLFxuICBkcm9wLFxuICBmaWx0ZXIsXG4gIGZsYXRNYXAsXG4gIG1hcCxcbiAgdGFrZSxcbiAgY29tcG9zZVxufVxubW9kdWxlLmV4cG9ydHMucHJvbWlzZVJldHVybmluZ09wZXJhdG9ycyA9IHtcbiAgZXZlcnksXG4gIGZvckVhY2gsXG4gIHJlZHVjZSxcbiAgdG9BcnJheSxcbiAgc29tZSxcbiAgZmluZFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQXJyYXlQcm90b3R5cGVQb3AsIFByb21pc2UgfSA9IHJlcXVpcmUoJy4uL291cnMvcHJpbW9yZGlhbHMnKVxuY29uc3QgeyBpc0l0ZXJhYmxlLCBpc05vZGVTdHJlYW0sIGlzV2ViU3RyZWFtIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHJlYW1zL3V0aWxzJylcbmNvbnN0IHsgcGlwZWxpbmVJbXBsOiBwbCB9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZScpXG5jb25zdCB7IGZpbmlzaGVkIH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0nKVxucmVxdWlyZSgnLi4vLi4vbGliL3N0cmVhbS5qcycpXG5mdW5jdGlvbiBwaXBlbGluZSguLi5zdHJlYW1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IHNpZ25hbFxuICAgIGxldCBlbmRcbiAgICBjb25zdCBsYXN0QXJnID0gc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdXG4gICAgaWYgKFxuICAgICAgbGFzdEFyZyAmJlxuICAgICAgdHlwZW9mIGxhc3RBcmcgPT09ICdvYmplY3QnICYmXG4gICAgICAhaXNOb2RlU3RyZWFtKGxhc3RBcmcpICYmXG4gICAgICAhaXNJdGVyYWJsZShsYXN0QXJnKSAmJlxuICAgICAgIWlzV2ViU3RyZWFtKGxhc3RBcmcpXG4gICAgKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gQXJyYXlQcm90b3R5cGVQb3Aoc3RyZWFtcylcbiAgICAgIHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsXG4gICAgICBlbmQgPSBvcHRpb25zLmVuZFxuICAgIH1cbiAgICBwbChcbiAgICAgIHN0cmVhbXMsXG4gICAgICAoZXJyLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgIClcbiAgfSlcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmaW5pc2hlZCxcbiAgcGlwZWxpbmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCdcblxuLyogcmVwbGFjZW1lbnQgc3RhcnQgKi9cblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbi8qIHJlcGxhY2VtZW50IGVuZCAqL1xuXG5jb25zdCB7IE9iamVjdERlZmluZVByb3BlcnR5LCBPYmplY3RLZXlzLCBSZWZsZWN0QXBwbHkgfSA9IHJlcXVpcmUoJy4vb3Vycy9wcmltb3JkaWFscycpXG5jb25zdCB7XG4gIHByb21pc2lmeTogeyBjdXN0b206IGN1c3RvbVByb21pc2lmeSB9XG59ID0gcmVxdWlyZSgnLi9vdXJzL3V0aWwnKVxuY29uc3QgeyBzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnMsIHByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnMgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9vcGVyYXRvcnMnKVxuY29uc3Qge1xuICBjb2RlczogeyBFUlJfSUxMRUdBTF9DT05TVFJVQ1RPUiB9XG59ID0gcmVxdWlyZSgnLi9vdXJzL2Vycm9ycycpXG5jb25zdCBjb21wb3NlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2NvbXBvc2UnKVxuY29uc3QgeyBzZXREZWZhdWx0SGlnaFdhdGVyTWFyaywgZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUnKVxuY29uc3QgeyBkZXN0cm95ZXIgfSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95JylcbmNvbnN0IGVvcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtJylcbmNvbnN0IGludGVybmFsQnVmZmVyID0ge31cbmNvbnN0IHByb21pc2VzID0gcmVxdWlyZSgnLi9zdHJlYW0vcHJvbWlzZXMnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvdXRpbHMnKVxuY29uc3QgU3RyZWFtID0gKG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2xlZ2FjeScpLlN0cmVhbSlcblN0cmVhbS5pc0Rlc3Ryb3llZCA9IHV0aWxzLmlzRGVzdHJveWVkXG5TdHJlYW0uaXNEaXN0dXJiZWQgPSB1dGlscy5pc0Rpc3R1cmJlZFxuU3RyZWFtLmlzRXJyb3JlZCA9IHV0aWxzLmlzRXJyb3JlZFxuU3RyZWFtLmlzUmVhZGFibGUgPSB1dGlscy5pc1JlYWRhYmxlXG5TdHJlYW0uaXNXcml0YWJsZSA9IHV0aWxzLmlzV3JpdGFibGVcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZScpXG5mb3IgKGNvbnN0IGtleSBvZiBPYmplY3RLZXlzKHN0cmVhbVJldHVybmluZ09wZXJhdG9ycykpIHtcbiAgY29uc3Qgb3AgPSBzdHJlYW1SZXR1cm5pbmdPcGVyYXRvcnNba2V5XVxuICBmdW5jdGlvbiBmbiguLi5hcmdzKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IEVSUl9JTExFR0FMX0NPTlNUUlVDVE9SKClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmVhbS5SZWFkYWJsZS5mcm9tKFJlZmxlY3RBcHBseShvcCwgdGhpcywgYXJncykpXG4gIH1cbiAgT2JqZWN0RGVmaW5lUHJvcGVydHkoZm4sICduYW1lJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubmFtZVxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ2xlbmd0aCcsIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IG9wLmxlbmd0aFxuICB9KVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShTdHJlYW0uUmVhZGFibGUucHJvdG90eXBlLCBrZXksIHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdmFsdWU6IGZuLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KVxufVxuZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0S2V5cyhwcm9taXNlUmV0dXJuaW5nT3BlcmF0b3JzKSkge1xuICBjb25zdCBvcCA9IHByb21pc2VSZXR1cm5pbmdPcGVyYXRvcnNba2V5XVxuICBmdW5jdGlvbiBmbiguLi5hcmdzKSB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IEVSUl9JTExFR0FMX0NPTlNUUlVDVE9SKClcbiAgICB9XG4gICAgcmV0dXJuIFJlZmxlY3RBcHBseShvcCwgdGhpcywgYXJncylcbiAgfVxuICBPYmplY3REZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHZhbHVlOiBvcC5uYW1lXG4gIH0pXG4gIE9iamVjdERlZmluZVByb3BlcnR5KGZuLCAnbGVuZ3RoJywge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogb3AubGVuZ3RoXG4gIH0pXG4gIE9iamVjdERlZmluZVByb3BlcnR5KFN0cmVhbS5SZWFkYWJsZS5wcm90b3R5cGUsIGtleSwge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB2YWx1ZTogZm4sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pXG59XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvd3JpdGFibGUnKVxuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kdXBsZXgnKVxuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy90cmFuc2Zvcm0nKVxuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3Bhc3N0aHJvdWdoJylcblN0cmVhbS5waXBlbGluZSA9IHBpcGVsaW5lXG5jb25zdCB7IGFkZEFib3J0U2lnbmFsIH0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYWRkLWFib3J0LXNpZ25hbCcpXG5TdHJlYW0uYWRkQWJvcnRTaWduYWwgPSBhZGRBYm9ydFNpZ25hbFxuU3RyZWFtLmZpbmlzaGVkID0gZW9zXG5TdHJlYW0uZGVzdHJveSA9IGRlc3Ryb3llclxuU3RyZWFtLmNvbXBvc2UgPSBjb21wb3NlXG5TdHJlYW0uc2V0RGVmYXVsdEhpZ2hXYXRlck1hcmsgPSBzZXREZWZhdWx0SGlnaFdhdGVyTWFya1xuU3RyZWFtLmdldERlZmF1bHRIaWdoV2F0ZXJNYXJrID0gZ2V0RGVmYXVsdEhpZ2hXYXRlck1hcmtcbk9iamVjdERlZmluZVByb3BlcnR5KFN0cmVhbSwgJ3Byb21pc2VzJywge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiBwcm9taXNlc1xuICB9XG59KVxuT2JqZWN0RGVmaW5lUHJvcGVydHkocGlwZWxpbmUsIGN1c3RvbVByb21pc2lmeSwge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcHJvbWlzZXMucGlwZWxpbmVcbiAgfVxufSlcbk9iamVjdERlZmluZVByb3BlcnR5KGVvcywgY3VzdG9tUHJvbWlzaWZ5LCB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiBwcm9taXNlcy5maW5pc2hlZFxuICB9XG59KVxuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbVxuU3RyZWFtLl9pc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheVxufVxuU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXIgPSBmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgQ3VzdG9tU3RyZWFtID0gcmVxdWlyZSgnLi4vc3RyZWFtJylcbmNvbnN0IHByb21pc2VzID0gcmVxdWlyZSgnLi4vc3RyZWFtL3Byb21pc2VzJylcbmNvbnN0IG9yaWdpbmFsRGVzdHJveSA9IEN1c3RvbVN0cmVhbS5SZWFkYWJsZS5kZXN0cm95XG5tb2R1bGUuZXhwb3J0cyA9IEN1c3RvbVN0cmVhbS5SZWFkYWJsZVxuXG4vLyBFeHBsaWNpdCBleHBvcnQgbmFtaW5nIGlzIG5lZWRlZCBmb3IgRVNNXG5tb2R1bGUuZXhwb3J0cy5fdWludDhBcnJheVRvQnVmZmVyID0gQ3VzdG9tU3RyZWFtLl91aW50OEFycmF5VG9CdWZmZXJcbm1vZHVsZS5leHBvcnRzLl9pc1VpbnQ4QXJyYXkgPSBDdXN0b21TdHJlYW0uX2lzVWludDhBcnJheVxubW9kdWxlLmV4cG9ydHMuaXNEaXN0dXJiZWQgPSBDdXN0b21TdHJlYW0uaXNEaXN0dXJiZWRcbm1vZHVsZS5leHBvcnRzLmlzRXJyb3JlZCA9IEN1c3RvbVN0cmVhbS5pc0Vycm9yZWRcbm1vZHVsZS5leHBvcnRzLmlzUmVhZGFibGUgPSBDdXN0b21TdHJlYW0uaXNSZWFkYWJsZVxubW9kdWxlLmV4cG9ydHMuUmVhZGFibGUgPSBDdXN0b21TdHJlYW0uUmVhZGFibGVcbm1vZHVsZS5leHBvcnRzLldyaXRhYmxlID0gQ3VzdG9tU3RyZWFtLldyaXRhYmxlXG5tb2R1bGUuZXhwb3J0cy5EdXBsZXggPSBDdXN0b21TdHJlYW0uRHVwbGV4XG5tb2R1bGUuZXhwb3J0cy5UcmFuc2Zvcm0gPSBDdXN0b21TdHJlYW0uVHJhbnNmb3JtXG5tb2R1bGUuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IEN1c3RvbVN0cmVhbS5QYXNzVGhyb3VnaFxubW9kdWxlLmV4cG9ydHMuYWRkQWJvcnRTaWduYWwgPSBDdXN0b21TdHJlYW0uYWRkQWJvcnRTaWduYWxcbm1vZHVsZS5leHBvcnRzLmZpbmlzaGVkID0gQ3VzdG9tU3RyZWFtLmZpbmlzaGVkXG5tb2R1bGUuZXhwb3J0cy5kZXN0cm95ID0gQ3VzdG9tU3RyZWFtLmRlc3Ryb3lcbm1vZHVsZS5leHBvcnRzLmRlc3Ryb3kgPSBvcmlnaW5hbERlc3Ryb3lcbm1vZHVsZS5leHBvcnRzLnBpcGVsaW5lID0gQ3VzdG9tU3RyZWFtLnBpcGVsaW5lXG5tb2R1bGUuZXhwb3J0cy5jb21wb3NlID0gQ3VzdG9tU3RyZWFtLmNvbXBvc2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21TdHJlYW0sICdwcm9taXNlcycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHByb21pc2VzXG4gIH1cbn0pXG5tb2R1bGUuZXhwb3J0cy5TdHJlYW0gPSBDdXN0b21TdHJlYW0uU3RyZWFtXG5cbi8vIEFsbG93IGRlZmF1bHQgaW1wb3J0aW5nXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHNcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GTEFHUyA9IGV4cG9ydHMuRVJSU1RSID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuZXhwb3J0cy5FUlJTVFIgPSB7XG4gICAgUEFUSF9TVFI6ICdwYXRoIG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgb3IgVWludDhBcnJheScsXG4gICAgLy8gRkQ6ICAgICAgICAgICAgICdmaWxlIGRlc2NyaXB0b3IgbXVzdCBiZSBhIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyJyxcbiAgICBGRDogJ2ZkIG11c3QgYmUgYSBmaWxlIGRlc2NyaXB0b3InLFxuICAgIE1PREVfSU5UOiAnbW9kZSBtdXN0IGJlIGFuIGludCcsXG4gICAgQ0I6ICdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICAgIFVJRDogJ3VpZCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludCcsXG4gICAgR0lEOiAnZ2lkIG11c3QgYmUgYW4gdW5zaWduZWQgaW50JyxcbiAgICBMRU46ICdsZW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICBBVElNRTogJ2F0aW1lIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgTVRJTUU6ICdtdGltZSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgIFBSRUZJWDogJ2ZpbGVuYW1lIHByZWZpeCBpcyByZXF1aXJlZCcsXG4gICAgQlVGRkVSOiAnYnVmZmVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQnVmZmVyIG9yIFN0YXRpY0J1ZmZlcicsXG4gICAgT0ZGU0VUOiAnb2Zmc2V0IG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgTEVOR1RIOiAnbGVuZ3RoIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgUE9TSVRJT046ICdwb3NpdGlvbiBtdXN0IGJlIGFuIGludGVnZXInLFxufTtcbmNvbnN0IHsgT19SRE9OTFksIE9fV1JPTkxZLCBPX1JEV1IsIE9fQ1JFQVQsIE9fRVhDTCwgT19UUlVOQywgT19BUFBFTkQsIE9fU1lOQyB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuLy8gTGlzdCBvZiBmaWxlIGBmbGFnc2AgYXMgZGVmaW5lZCBieSBOb2RlLlxudmFyIEZMQUdTO1xuKGZ1bmN0aW9uIChGTEFHUykge1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZy4gQW4gZXhjZXB0aW9uIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcInJcIl0gPSBPX1JET05MWV0gPSBcInJcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcuIEFuIGV4Y2VwdGlvbiBvY2N1cnMgaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QuXG4gICAgRkxBR1NbRkxBR1NbXCJyK1wiXSA9IE9fUkRXUl0gPSBcInIrXCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nIGluIHN5bmNocm9ub3VzIG1vZGUuIEluc3RydWN0cyB0aGUgb3BlcmF0aW5nIHN5c3RlbSB0byBieXBhc3MgdGhlIGxvY2FsIGZpbGUgc3lzdGVtIGNhY2hlLlxuICAgIEZMQUdTW0ZMQUdTW1wicnNcIl0gPSBPX1JET05MWSB8IE9fU1lOQ10gPSBcInJzXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJzclwiXSA9IEZMQUdTLnJzXSA9IFwic3JcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcsIHRlbGxpbmcgdGhlIE9TIHRvIG9wZW4gaXQgc3luY2hyb25vdXNseS4gU2VlIG5vdGVzIGZvciAncnMnIGFib3V0IHVzaW5nIHRoaXMgd2l0aCBjYXV0aW9uLlxuICAgIEZMQUdTW0ZMQUdTW1wicnMrXCJdID0gT19SRFdSIHwgT19TWU5DXSA9IFwicnMrXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJzcitcIl0gPSBGTEFHU1sncnMrJ11dID0gXCJzcitcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHdyaXRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgKGlmIGl0IGRvZXMgbm90IGV4aXN0KSBvciB0cnVuY2F0ZWQgKGlmIGl0IGV4aXN0cykuXG4gICAgRkxBR1NbRkxBR1NbXCJ3XCJdID0gT19XUk9OTFkgfCBPX0NSRUFUIHwgT19UUlVOQ10gPSBcIndcIjtcbiAgICAvLyBMaWtlICd3JyBidXQgZmFpbHMgaWYgcGF0aCBleGlzdHMuXG4gICAgRkxBR1NbRkxBR1NbXCJ3eFwiXSA9IE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fVFJVTkMgfCBPX0VYQ0xdID0gXCJ3eFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wieHdcIl0gPSBGTEFHUy53eF0gPSBcInh3XCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nIGFuZCB3cml0aW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIChpZiBpdCBkb2VzIG5vdCBleGlzdCkgb3IgdHJ1bmNhdGVkIChpZiBpdCBleGlzdHMpLlxuICAgIEZMQUdTW0ZMQUdTW1widytcIl0gPSBPX1JEV1IgfCBPX0NSRUFUIHwgT19UUlVOQ10gPSBcIncrXCI7XG4gICAgLy8gTGlrZSAndysnIGJ1dCBmYWlscyBpZiBwYXRoIGV4aXN0cy5cbiAgICBGTEFHU1tGTEFHU1tcInd4K1wiXSA9IE9fUkRXUiB8IE9fQ1JFQVQgfCBPX1RSVU5DIHwgT19FWENMXSA9IFwid3grXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJ4dytcIl0gPSBGTEFHU1snd3grJ11dID0gXCJ4dytcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIGFwcGVuZGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcImFcIl0gPSBPX1dST05MWSB8IE9fQVBQRU5EIHwgT19DUkVBVF0gPSBcImFcIjtcbiAgICAvLyBMaWtlICdhJyBidXQgZmFpbHMgaWYgcGF0aCBleGlzdHMuXG4gICAgRkxBR1NbRkxBR1NbXCJheFwiXSA9IE9fV1JPTkxZIHwgT19BUFBFTkQgfCBPX0NSRUFUIHwgT19FWENMXSA9IFwiYXhcIjtcbiAgICBGTEFHU1tGTEFHU1tcInhhXCJdID0gRkxBR1MuYXhdID0gXCJ4YVwiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgYXBwZW5kaW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgIEZMQUdTW0ZMQUdTW1wiYStcIl0gPSBPX1JEV1IgfCBPX0FQUEVORCB8IE9fQ1JFQVRdID0gXCJhK1wiO1xuICAgIC8vIExpa2UgJ2ErJyBidXQgZmFpbHMgaWYgcGF0aCBleGlzdHMuXG4gICAgRkxBR1NbRkxBR1NbXCJheCtcIl0gPSBPX1JEV1IgfCBPX0FQUEVORCB8IE9fQ1JFQVQgfCBPX0VYQ0xdID0gXCJheCtcIjtcbiAgICBGTEFHU1tGTEFHU1tcInhhK1wiXSA9IEZMQUdTWydheCsnXV0gPSBcInhhK1wiO1xufSkoRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSBGTEFHUyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlRXJyb3I7XG4iLCJ2YXIgaGFzTWFwID0gdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBNYXAucHJvdG90eXBlO1xudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIG1hcFNpemUgPSBoYXNNYXAgJiYgbWFwU2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIG1hcFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG1hcFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgbWFwRm9yRWFjaCA9IGhhc01hcCAmJiBNYXAucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xudmFyIHNldFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNTZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFNldC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xudmFyIHNldFNpemUgPSBoYXNTZXQgJiYgc2V0U2l6ZURlc2NyaXB0b3IgJiYgdHlwZW9mIHNldFNpemVEZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFNpemVEZXNjcmlwdG9yLmdldCA6IG51bGw7XG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XG52YXIgaGFzV2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIFdlYWtNYXAucHJvdG90eXBlO1xudmFyIHdlYWtNYXBIYXMgPSBoYXNXZWFrTWFwID8gV2Vha01hcC5wcm90b3R5cGUuaGFzIDogbnVsbDtcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XG52YXIgd2Vha1NldEhhcyA9IGhhc1dlYWtTZXQgPyBXZWFrU2V0LnByb3RvdHlwZS5oYXMgOiBudWxsO1xudmFyIGhhc1dlYWtSZWYgPSB0eXBlb2YgV2Vha1JlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrUmVmLnByb3RvdHlwZTtcbnZhciB3ZWFrUmVmRGVyZWYgPSBoYXNXZWFrUmVmID8gV2Vha1JlZi5wcm90b3R5cGUuZGVyZWYgOiBudWxsO1xudmFyIGJvb2xlYW5WYWx1ZU9mID0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZjtcbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciAkbWF0Y2ggPSBTdHJpbmcucHJvdG90eXBlLm1hdGNoO1xudmFyICRzbGljZSA9IFN0cmluZy5wcm90b3R5cGUuc2xpY2U7XG52YXIgJHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgJHRvVXBwZXJDYXNlID0gU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZTtcbnZhciAkdG9Mb3dlckNhc2UgPSBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlO1xudmFyICR0ZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xudmFyICRjb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0O1xudmFyICRqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG52YXIgJGFyclNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyICRmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgYmlnSW50VmFsdWVPZiA9IHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicgPyBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YgOiBudWxsO1xudmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIHN5bVRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiBudWxsO1xudmFyIGhhc1NoYW1tZWRTeW1ib2xzID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnb2JqZWN0Jztcbi8vIGllLCBgaGFzLXRvc3RyaW5ndGFnL3NoYW1zXG52YXIgdG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZyAmJiAodHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gaGFzU2hhbW1lZFN5bWJvbHMgPyAnb2JqZWN0JyA6ICdzeW1ib2wnKVxuICAgID8gU3ltYm9sLnRvU3RyaW5nVGFnXG4gICAgOiBudWxsO1xudmFyIGlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbnZhciBnUE8gPSAodHlwZW9mIFJlZmxlY3QgPT09ICdmdW5jdGlvbicgPyBSZWZsZWN0LmdldFByb3RvdHlwZU9mIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKSB8fCAoXG4gICAgW10uX19wcm90b19fID09PSBBcnJheS5wcm90b3R5cGUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuICAgICAgICA/IGZ1bmN0aW9uIChPKSB7XG4gICAgICAgICAgICByZXR1cm4gTy5fX3Byb3RvX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cbiAgICAgICAgfVxuICAgICAgICA6IG51bGxcbik7XG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNTZXBhcmF0b3IobnVtLCBzdHIpIHtcbiAgICBpZiAoXG4gICAgICAgIG51bSA9PT0gSW5maW5pdHlcbiAgICAgICAgfHwgbnVtID09PSAtSW5maW5pdHlcbiAgICAgICAgfHwgbnVtICE9PSBudW1cbiAgICAgICAgfHwgKG51bSAmJiBudW0gPiAtMTAwMCAmJiBudW0gPCAxMDAwKVxuICAgICAgICB8fCAkdGVzdC5jYWxsKC9lLywgc3RyKVxuICAgICkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB2YXIgc2VwUmVnZXggPSAvWzAtOV0oPz0oPzpbMC05XXszfSkrKD8hWzAtOV0pKS9nO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaW50ID0gbnVtIDwgMCA/IC0kZmxvb3IoLW51bSkgOiAkZmxvb3IobnVtKTsgLy8gdHJ1bmMobnVtKVxuICAgICAgICBpZiAoaW50ICE9PSBudW0pIHtcbiAgICAgICAgICAgIHZhciBpbnRTdHIgPSBTdHJpbmcoaW50KTtcbiAgICAgICAgICAgIHZhciBkZWMgPSAkc2xpY2UuY2FsbChzdHIsIGludFN0ci5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKGludFN0ciwgc2VwUmVnZXgsICckJl8nKSArICcuJyArICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChkZWMsIC8oWzAtOV17M30pL2csICckJl8nKSwgL18kLywgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHN0ciwgc2VwUmVnZXgsICckJl8nKTtcbn1cblxudmFyIHV0aWxJbnNwZWN0ID0gcmVxdWlyZSgnLi91dGlsLmluc3BlY3QnKTtcbnZhciBpbnNwZWN0Q3VzdG9tID0gdXRpbEluc3BlY3QuY3VzdG9tO1xudmFyIGluc3BlY3RTeW1ib2wgPSBpc1N5bWJvbChpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xuXG52YXIgcXVvdGVzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAnZG91YmxlJzogJ1wiJyxcbiAgICBzaW5nbGU6IFwiJ1wiXG59O1xudmFyIHF1b3RlUkVzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAnZG91YmxlJzogLyhbXCJcXFxcXSkvZyxcbiAgICBzaW5nbGU6IC8oWydcXFxcXSkvZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnNwZWN0XyhvYmosIG9wdGlvbnMsIGRlcHRoLCBzZWVuKSB7XG4gICAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpICYmICFoYXMocXVvdGVzLCBvcHRzLnF1b3RlU3R5bGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcInF1b3RlU3R5bGVcIiBtdXN0IGJlIFwic2luZ2xlXCIgb3IgXCJkb3VibGVcIicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAgIGhhcyhvcHRzLCAnbWF4U3RyaW5nTGVuZ3RoJykgJiYgKHR5cGVvZiBvcHRzLm1heFN0cmluZ0xlbmd0aCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxuICAgICAgICAgICAgOiBvcHRzLm1heFN0cmluZ0xlbmd0aCAhPT0gbnVsbFxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcIm1heFN0cmluZ0xlbmd0aFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIEluZmluaXR5LCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgdmFyIGN1c3RvbUluc3BlY3QgPSBoYXMob3B0cywgJ2N1c3RvbUluc3BlY3QnKSA/IG9wdHMuY3VzdG9tSW5zcGVjdCA6IHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdXN0b21JbnNwZWN0ICE9PSAnYm9vbGVhbicgJiYgY3VzdG9tSW5zcGVjdCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiY3VzdG9tSW5zcGVjdFwiLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBgdHJ1ZWAsIGBmYWxzZWAsIG9yIGBcXCdzeW1ib2xcXCdgJyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSBudWxsXG4gICAgICAgICYmIG9wdHMuaW5kZW50ICE9PSAnXFx0J1xuICAgICAgICAmJiAhKHBhcnNlSW50KG9wdHMuaW5kZW50LCAxMCkgPT09IG9wdHMuaW5kZW50ICYmIG9wdHMuaW5kZW50ID4gMClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFwiaW5kZW50XCIgbXVzdCBiZSBcIlxcXFx0XCIsIGFuIGludGVnZXIgPiAwLCBvciBgbnVsbGAnKTtcbiAgICB9XG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXCJudW1lcmljU2VwYXJhdG9yXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGB0cnVlYCBvciBgZmFsc2VgJyk7XG4gICAgfVxuICAgIHZhciBudW1lcmljU2VwYXJhdG9yID0gb3B0cy5udW1lcmljU2VwYXJhdG9yO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvYmogPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZyhvYmosIG9wdHMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IFN0cmluZyhvYmopO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBiaWdJbnRTdHIpIDogYmlnSW50U3RyO1xuICAgIH1cblxuICAgIHZhciBtYXhEZXB0aCA9IHR5cGVvZiBvcHRzLmRlcHRoID09PSAndW5kZWZpbmVkJyA/IDUgOiBvcHRzLmRlcHRoO1xuICAgIGlmICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnKSB7IGRlcHRoID0gMDsgfVxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdbQXJyYXldJyA6ICdbT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IGdldEluZGVudChvcHRzLCBkZXB0aCk7XG5cbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlZW4gPSBbXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4T2Yoc2Vlbiwgb2JqKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHNlZW4gPSAkYXJyU2xpY2UuY2FsbChzZWVuKTtcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9JbmRlbnQpIHtcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xuICAgICAgICAgICAgICAgIGRlcHRoOiBvcHRzLmRlcHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgbmV3T3B0cy5xdW90ZVN0eWxlID0gb3B0cy5xdW90ZVN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNwZWN0Xyh2YWx1ZSwgb3B0cywgZGVwdGggKyAxLCBzZWVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNSZWdFeHAob2JqKSkgeyAvLyBpbiBvbGRlciBlbmdpbmVzLCByZWdleGVzIGFyZSBjYWxsYWJsZVxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xuICAgICAgICB2YXIga2V5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcbiAgICAgICAgcmV0dXJuICdbRnVuY3Rpb24nICsgKG5hbWUgPyAnOiAnICsgbmFtZSA6ICcgKGFub255bW91cyknKSArICddJyArIChrZXlzLmxlbmd0aCA+IDAgPyAnIHsgJyArICRqb2luLmNhbGwoa2V5cywgJywgJykgKyAnIH0nIDogJycpO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wob2JqKSkge1xuICAgICAgICB2YXIgc3ltU3RyaW5nID0gaGFzU2hhbW1lZFN5bWJvbHMgPyAkcmVwbGFjZS5jYWxsKFN0cmluZyhvYmopLCAvXihTeW1ib2xcXCguKlxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaGFzU2hhbW1lZFN5bWJvbHMgPyBtYXJrQm94ZWQoc3ltU3RyaW5nKSA6IHN5bVN0cmluZztcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgICAgIHZhciBzID0gJzwnICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpO1xuICAgICAgICB2YXIgYXR0cnMgPSBvYmouYXR0cmlidXRlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcyArPSAnICcgKyBhdHRyc1tpXS5uYW1lICsgJz0nICsgd3JhcFF1b3RlcyhxdW90ZShhdHRyc1tpXS52YWx1ZSksICdkb3VibGUnLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBzICs9ICc+JztcbiAgICAgICAgaWYgKG9iai5jaGlsZE5vZGVzICYmIG9iai5jaGlsZE5vZGVzLmxlbmd0aCkgeyBzICs9ICcuLi4nOyB9XG4gICAgICAgIHMgKz0gJzwvJyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKSArICc+JztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cbiAgICAgICAgdmFyIHhzID0gYXJyT2JqS2V5cyhvYmosIGluc3BlY3QpO1xuICAgICAgICBpZiAoaW5kZW50ICYmICFzaW5nbGVMaW5lVmFsdWVzKHhzKSkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1sgJyArICRqb2luLmNhbGwoeHMsICcsICcpICsgJyBdJztcbiAgICB9XG4gICAgaWYgKGlzRXJyb3Iob2JqKSkge1xuICAgICAgICB2YXIgcGFydHMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIGlmICghKCdjYXVzZScgaW4gRXJyb3IucHJvdG90eXBlKSAmJiAnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xuICAgICAgICAgICAgcmV0dXJuICd7IFsnICsgU3RyaW5nKG9iaikgKyAnXSAnICsgJGpvaW4uY2FsbCgkY29uY2F0LmNhbGwoJ1tjYXVzZV06ICcgKyBpbnNwZWN0KG9iai5jYXVzZSksIHBhcnRzKSwgJywgJykgKyAnIH0nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XG4gICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwocGFydHMsICcsICcpICsgJyB9JztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcbiAgICAgICAgaWYgKGluc3BlY3RTeW1ib2wgJiYgdHlwZW9mIG9ialtpbnNwZWN0U3ltYm9sXSA9PT0gJ2Z1bmN0aW9uJyAmJiB1dGlsSW5zcGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxJbnNwZWN0KG9iaiwgeyBkZXB0aDogbWF4RGVwdGggLSBkZXB0aCB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouaW5zcGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc01hcChvYmopKSB7XG4gICAgICAgIHZhciBtYXBQYXJ0cyA9IFtdO1xuICAgICAgICBpZiAobWFwRm9yRWFjaCkge1xuICAgICAgICAgICAgbWFwRm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBtYXBQYXJ0cy5wdXNoKGluc3BlY3Qoa2V5LCBvYmosIHRydWUpICsgJyA9PiAnICsgaW5zcGVjdCh2YWx1ZSwgb2JqKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbk9mKCdNYXAnLCBtYXBTaXplLmNhbGwob2JqKSwgbWFwUGFydHMsIGluZGVudCk7XG4gICAgfVxuICAgIGlmIChpc1NldChvYmopKSB7XG4gICAgICAgIHZhciBzZXRQYXJ0cyA9IFtdO1xuICAgICAgICBpZiAoc2V0Rm9yRWFjaCkge1xuICAgICAgICAgICAgc2V0Rm9yRWFjaC5jYWxsKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2V0UGFydHMucHVzaChpbnNwZWN0KHZhbHVlLCBvYmopKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ1NldCcsIHNldFNpemUuY2FsbChvYmopLCBzZXRQYXJ0cywgaW5kZW50KTtcbiAgICB9XG4gICAgaWYgKGlzV2Vha01hcChvYmopKSB7XG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrTWFwJyk7XG4gICAgfVxuICAgIGlmIChpc1dlYWtTZXQob2JqKSkge1xuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1NldCcpO1xuICAgIH1cbiAgICBpZiAoaXNXZWFrUmVmKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtSZWYnKTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KE51bWJlcihvYmopKSk7XG4gICAgfVxuICAgIGlmIChpc0JpZ0ludChvYmopKSB7XG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKSkpO1xuICAgIH1cbiAgICBpZiAoaXNCb29sZWFuKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChib29sZWFuVmFsdWVPZi5jYWxsKG9iaikpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJpbmcob2JqKSkge1xuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoU3RyaW5nKG9iaikpKTtcbiAgICB9XG4gICAgLy8gbm90ZTogaW4gSUUgOCwgc29tZXRpbWVzIGBnbG9iYWwgIT09IHdpbmRvd2AgYnV0IGJvdGggYXJlIHRoZSBwcm90b3R5cGVzIG9mIGVhY2ggb3RoZXJcbiAgICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuICd7IFtvYmplY3QgV2luZG93XSB9JztcbiAgICB9XG4gICAgaWYgKFxuICAgICAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIG9iaiA9PT0gZ2xvYmFsVGhpcylcbiAgICAgICAgfHwgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIG9iaiA9PT0gZ2xvYmFsKVxuICAgICkge1xuICAgICAgICByZXR1cm4gJ3sgW29iamVjdCBnbG9iYWxUaGlzXSB9JztcbiAgICB9XG4gICAgaWYgKCFpc0RhdGUob2JqKSAmJiAhaXNSZWdFeHAob2JqKSkge1xuICAgICAgICB2YXIgeXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XG4gICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgICAgIHZhciBwcm90b1RhZyA9IG9iaiBpbnN0YW5jZW9mIE9iamVjdCA/ICcnIDogJ251bGwgcHJvdG90eXBlJztcbiAgICAgICAgdmFyIHN0cmluZ1RhZyA9ICFpc1BsYWluT2JqZWN0ICYmIHRvU3RyaW5nVGFnICYmIE9iamVjdChvYmopID09PSBvYmogJiYgdG9TdHJpbmdUYWcgaW4gb2JqID8gJHNsaWNlLmNhbGwodG9TdHIob2JqKSwgOCwgLTEpIDogcHJvdG9UYWcgPyAnT2JqZWN0JyA6ICcnO1xuICAgICAgICB2YXIgY29uc3RydWN0b3JUYWcgPSBpc1BsYWluT2JqZWN0IHx8IHR5cGVvZiBvYmouY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgPyAnJyA6IG9iai5jb25zdHJ1Y3Rvci5uYW1lID8gb2JqLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgOiAnJztcbiAgICAgICAgdmFyIHRhZyA9IGNvbnN0cnVjdG9yVGFnICsgKHN0cmluZ1RhZyB8fCBwcm90b1RhZyA/ICdbJyArICRqb2luLmNhbGwoJGNvbmNhdC5jYWxsKFtdLCBzdHJpbmdUYWcgfHwgW10sIHByb3RvVGFnIHx8IFtdKSwgJzogJykgKyAnXSAnIDogJycpO1xuICAgICAgICBpZiAoeXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB0YWcgKyAne30nOyB9XG4gICAgICAgIGlmIChpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcgKyAneycgKyBpbmRlbnRlZEpvaW4oeXMsIGluZGVudCkgKyAnfSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyAkam9pbi5jYWxsKHlzLCAnLCAnKSArICcgfSc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcob2JqKTtcbn07XG5cbmZ1bmN0aW9uIHdyYXBRdW90ZXMocywgZGVmYXVsdFN0eWxlLCBvcHRzKSB7XG4gICAgdmFyIHN0eWxlID0gb3B0cy5xdW90ZVN0eWxlIHx8IGRlZmF1bHRTdHlsZTtcbiAgICB2YXIgcXVvdGVDaGFyID0gcXVvdGVzW3N0eWxlXTtcbiAgICByZXR1cm4gcXVvdGVDaGFyICsgcyArIHF1b3RlQ2hhcjtcbn1cblxuZnVuY3Rpb24gcXVvdGUocykge1xuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKFN0cmluZyhzKSwgL1wiL2csICcmcXVvdDsnKTtcbn1cblxuZnVuY3Rpb24gY2FuVHJ1c3RUb1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHRvU3RyaW5nVGFnIGluIG9iaiB8fCB0eXBlb2Ygb2JqW3RvU3RyaW5nVGFnXSAhPT0gJ3VuZGVmaW5lZCcpKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBBcnJheV0nICYmIGNhblRydXN0VG9TdHJpbmcob2JqKTsgfVxuZnVuY3Rpb24gaXNEYXRlKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nICYmIGNhblRydXN0VG9TdHJpbmcob2JqKTsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyAmJiBjYW5UcnVzdFRvU3RyaW5nKG9iaik7IH1cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBFcnJvcl0nICYmIGNhblRydXN0VG9TdHJpbmcob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBTdHJpbmddJyAmJiBjYW5UcnVzdFRvU3RyaW5nKG9iaik7IH1cbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgY2FuVHJ1c3RUb1N0cmluZyhvYmopOyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBCb29sZWFuXScgJiYgY2FuVHJ1c3RUb1N0cmluZyhvYmopOyB9XG5cbi8vIFN5bWJvbCBhbmQgQmlnSW50IGRvIGhhdmUgU3ltYm9sLnRvU3RyaW5nVGFnIGJ5IHNwZWMsIHNvIHRoYXQgY2FuJ3QgYmUgdXNlZCB0byBlbGltaW5hdGUgZmFsc2UgcG9zaXRpdmVzXG5mdW5jdGlvbiBpc1N5bWJvbChvYmopIHtcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBTeW1ib2w7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIXN5bVRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgc3ltVG9TdHJpbmcuY2FsbChvYmopO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaWdJbnQob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgIWJpZ0ludFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBiaWdJbnRWYWx1ZU9mLmNhbGwob2JqKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSBpbiB0aGlzOyB9O1xuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwga2V5KTtcbn1cblxuZnVuY3Rpb24gdG9TdHIob2JqKSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gbmFtZU9mKGYpIHtcbiAgICBpZiAoZi5uYW1lKSB7IHJldHVybiBmLm5hbWU7IH1cbiAgICB2YXIgbSA9ICRtYXRjaC5jYWxsKGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChmKSwgL15mdW5jdGlvblxccyooW1xcdyRdKykvKTtcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHsgcmV0dXJuIHhzLmluZGV4T2YoeCk7IH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHsgcmV0dXJuIGk7IH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc01hcCh4KSB7XG4gICAgaWYgKCFtYXBTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAocykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBNYXA7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtNYXAoeCkge1xuICAgIGlmICghd2Vha01hcEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2Vha1JlZih4KSB7XG4gICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2Vha1JlZkRlcmVmLmNhbGwoeCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NldCh4KSB7XG4gICAgaWYgKCFzZXRTaXplIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcFNpemUuY2FsbCh4KTtcbiAgICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dlYWtTZXQoeCkge1xuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB3ZWFrU2V0SGFzLmNhbGwoeCwgd2Vha1NldEhhcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha1NldDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XG4gICAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHguZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0U3RyaW5nKHN0ciwgb3B0cykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHN0ci5sZW5ndGggLSBvcHRzLm1heFN0cmluZ0xlbmd0aDtcbiAgICAgICAgdmFyIHRyYWlsZXIgPSAnLi4uICcgKyByZW1haW5pbmcgKyAnIG1vcmUgY2hhcmFjdGVyJyArIChyZW1haW5pbmcgPiAxID8gJ3MnIDogJycpO1xuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZygkc2xpY2UuY2FsbChzdHIsIDAsIG9wdHMubWF4U3RyaW5nTGVuZ3RoKSwgb3B0cykgKyB0cmFpbGVyO1xuICAgIH1cbiAgICB2YXIgcXVvdGVSRSA9IHF1b3RlUkVzW29wdHMucXVvdGVTdHlsZSB8fCAnc2luZ2xlJ107XG4gICAgcXVvdGVSRS5sYXN0SW5kZXggPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgdmFyIHMgPSAkcmVwbGFjZS5jYWxsKCRyZXBsYWNlLmNhbGwoc3RyLCBxdW90ZVJFLCAnXFxcXCQxJyksIC9bXFx4MDAtXFx4MWZdL2csIGxvd2J5dGUpO1xuICAgIHJldHVybiB3cmFwUXVvdGVzKHMsICdzaW5nbGUnLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gbG93Ynl0ZShjKSB7XG4gICAgdmFyIG4gPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIHggPSB7XG4gICAgICAgIDg6ICdiJyxcbiAgICAgICAgOTogJ3QnLFxuICAgICAgICAxMDogJ24nLFxuICAgICAgICAxMjogJ2YnLFxuICAgICAgICAxMzogJ3InXG4gICAgfVtuXTtcbiAgICBpZiAoeCkgeyByZXR1cm4gJ1xcXFwnICsgeDsgfVxuICAgIHJldHVybiAnXFxcXHgnICsgKG4gPCAweDEwID8gJzAnIDogJycpICsgJHRvVXBwZXJDYXNlLmNhbGwobi50b1N0cmluZygxNikpO1xufVxuXG5mdW5jdGlvbiBtYXJrQm94ZWQoc3RyKSB7XG4gICAgcmV0dXJuICdPYmplY3QoJyArIHN0ciArICcpJztcbn1cblxuZnVuY3Rpb24gd2Vha0NvbGxlY3Rpb25PZih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgKyAnIHsgPyB9Jztcbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKHR5cGUsIHNpemUsIGVudHJpZXMsIGluZGVudCkge1xuICAgIHZhciBqb2luZWRFbnRyaWVzID0gaW5kZW50ID8gaW5kZW50ZWRKb2luKGVudHJpZXMsIGluZGVudCkgOiAkam9pbi5jYWxsKGVudHJpZXMsICcsICcpO1xuICAgIHJldHVybiB0eXBlICsgJyAoJyArIHNpemUgKyAnKSB7JyArIGpvaW5lZEVudHJpZXMgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZUxpbmVWYWx1ZXMoeHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbmRleE9mKHhzW2ldLCAnXFxuJykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRlbnQob3B0cywgZGVwdGgpIHtcbiAgICB2YXIgYmFzZUluZGVudDtcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXHQnKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFx0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XG4gICAgICAgIGJhc2VJbmRlbnQgPSAkam9pbi5jYWxsKEFycmF5KG9wdHMuaW5kZW50ICsgMSksICcgJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IGJhc2VJbmRlbnQsXG4gICAgICAgIHByZXY6ICRqb2luLmNhbGwoQXJyYXkoZGVwdGggKyAxKSwgYmFzZUluZGVudClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRlZEpvaW4oeHMsIGluZGVudCkge1xuICAgIGlmICh4cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG4gICAgdmFyIGxpbmVKb2luZXIgPSAnXFxuJyArIGluZGVudC5wcmV2ICsgaW5kZW50LmJhc2U7XG4gICAgcmV0dXJuIGxpbmVKb2luZXIgKyAkam9pbi5jYWxsKHhzLCAnLCcgKyBsaW5lSm9pbmVyKSArICdcXG4nICsgaW5kZW50LnByZXY7XG59XG5cbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmopO1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChpc0Fycikge1xuICAgICAgICB4cy5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xuICAgIHZhciBzeW1NYXA7XG4gICAgaWYgKGhhc1NoYW1tZWRTeW1ib2xzKSB7XG4gICAgICAgIHN5bU1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHN5bXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHN5bU1hcFsnJCcgKyBzeW1zW2tdXSA9IHN5bXNba107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgaWYgKCFoYXMob2JqLCBrZXkpKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXG4gICAgICAgIGlmIChpc0FyciAmJiBTdHJpbmcoTnVtYmVyKGtleSkpID09PSBrZXkgJiYga2V5IDwgb2JqLmxlbmd0aCkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxuICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBzaGFtbWVkIFN5bWJvbHMsIHdoaWNoIGFyZSBzdG9yZWQgYXMgc3RyaW5ncywgZnJvbSBiZWluZyBpbmNsdWRlZCBpbiB0aGUgc3RyaW5nIGtleSBzZWN0aW9uXG4gICAgICAgICAgICBjb250aW51ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCwgbm8tY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmICgkdGVzdC5jYWxsKC9bXlxcdyRdLywga2V5KSkge1xuICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhzLnB1c2goa2V5ICsgJzogJyArIGluc3BlY3Qob2JqW2tleV0sIG9iaikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN5bXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpc0VudW1lcmFibGUuY2FsbChvYmosIHN5bXNbal0pKSB7XG4gICAgICAgICAgICAgICAgeHMucHVzaCgnWycgKyBpbnNwZWN0KHN5bXNbal0pICsgJ106ICcgKyBpbnNwZWN0KG9ialtzeW1zW2pdXSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG5cbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcblxuLypcbiogVGhpcyBmdW5jdGlvbiB0cmF2ZXJzZXMgdGhlIGxpc3QgcmV0dXJuaW5nIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleS5cbipcbiogVGhhdCBub2RlIGlzIGFsc28gbW92ZWQgdG8gdGhlIGhlYWQgb2YgdGhlIGxpc3QsIHNvIHRoYXQgaWYgaXQncyBhY2Nlc3NlZCBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LlxuKiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseSB1c2VkIG5vZGVzIGNhbiBiZSBhY2Nlc3NlZCByZWxhdGl2ZWx5IHF1aWNrbHkuXG4qL1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykubGlzdEdldE5vZGV9ICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBsaXN0R2V0Tm9kZSA9IGZ1bmN0aW9uIChsaXN0LCBrZXksIGlzRGVsZXRlKSB7XG5cdC8qKiBAdHlwZSB7dHlwZW9mIGxpc3QgfCBOb25OdWxsYWJsZTwodHlwZW9mIGxpc3QpWyduZXh0J10+fSAqL1xuXHR2YXIgcHJldiA9IGxpc3Q7XG5cdC8qKiBAdHlwZSB7KHR5cGVvZiBsaXN0KVsnbmV4dCddfSAqL1xuXHR2YXIgY3Vycjtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRmb3IgKDsgKGN1cnIgPSBwcmV2Lm5leHQpICE9IG51bGw7IHByZXYgPSBjdXJyKSB7XG5cdFx0aWYgKGN1cnIua2V5ID09PSBrZXkpIHtcblx0XHRcdHByZXYubmV4dCA9IGN1cnIubmV4dDtcblx0XHRcdGlmICghaXNEZWxldGUpIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xuXHRcdFx0XHRjdXJyLm5leHQgPSAvKiogQHR5cGUge05vbk51bGxhYmxlPHR5cGVvZiBsaXN0Lm5leHQ+fSAqLyAobGlzdC5uZXh0KTtcblx0XHRcdFx0bGlzdC5uZXh0ID0gY3VycjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGN1cnI7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9saXN0LmQudHMnKS5saXN0R2V0fSAqL1xudmFyIGxpc3RHZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5KSB7XG5cdGlmICghb2JqZWN0cykge1xuXHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0fVxuXHR2YXIgbm9kZSA9IGxpc3RHZXROb2RlKG9iamVjdHMsIGtleSk7XG5cdHJldHVybiBub2RlICYmIG5vZGUudmFsdWU7XG59O1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykubGlzdFNldH0gKi9cbnZhciBsaXN0U2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSwgdmFsdWUpIHtcblx0dmFyIG5vZGUgPSBsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xuXHRpZiAobm9kZSkge1xuXHRcdG5vZGUudmFsdWUgPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvLyBQcmVwZW5kIHRoZSBuZXcgbm9kZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cdFx0b2JqZWN0cy5uZXh0ID0gLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykuTGlzdE5vZGU8dHlwZW9mIHZhbHVlLCB0eXBlb2Yga2V5Pn0gKi8gKHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgbm8tZXh0cmEtcGFyZW5zXG5cdFx0XHRrZXk6IGtleSxcblx0XHRcdG5leHQ6IG9iamVjdHMubmV4dCxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH0pO1xuXHR9XG59O1xuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykubGlzdEhhc30gKi9cbnZhciBsaXN0SGFzID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xuXHRpZiAoIW9iamVjdHMpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICEhbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcbn07XG4vKiogQHR5cGUge2ltcG9ydCgnLi9saXN0LmQudHMnKS5saXN0RGVsZXRlfSAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgbGlzdERlbGV0ZSA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcblx0aWYgKG9iamVjdHMpIHtcblx0XHRyZXR1cm4gbGlzdEdldE5vZGUob2JqZWN0cywga2V5LCB0cnVlKTtcblx0fVxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWxMaXN0KCkge1xuXHQvKiogQHR5cGVkZWYge1JldHVyblR5cGU8dHlwZW9mIGdldFNpZGVDaGFubmVsTGlzdD59IENoYW5uZWwgKi9cblx0LyoqIEB0eXBlZGVmIHtQYXJhbWV0ZXJzPENoYW5uZWxbJ2dldCddPlswXX0gSyAqL1xuXHQvKiogQHR5cGVkZWYge1BhcmFtZXRlcnM8Q2hhbm5lbFsnc2V0J10+WzFdfSBWICovXG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vbGlzdC5kLnRzJykuUm9vdE5vZGU8ViwgSz4gfCB1bmRlZmluZWR9ICovIHZhciAkbztcblxuXHQvKiogQHR5cGUge0NoYW5uZWx9ICovXG5cdHZhciBjaGFubmVsID0ge1xuXHRcdGFzc2VydDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YXIgcm9vdCA9ICRvICYmICRvLm5leHQ7XG5cdFx0XHR2YXIgZGVsZXRlZE5vZGUgPSBsaXN0RGVsZXRlKCRvLCBrZXkpO1xuXHRcdFx0aWYgKGRlbGV0ZWROb2RlICYmIHJvb3QgJiYgcm9vdCA9PT0gZGVsZXRlZE5vZGUpIHtcblx0XHRcdFx0JG8gPSB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhIWRlbGV0ZWROb2RlO1xuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRyZXR1cm4gbGlzdEdldCgkbywga2V5KTtcblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuIGxpc3RIYXMoJG8sIGtleSk7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoISRvKSB7XG5cdFx0XHRcdC8vIEluaXRpYWxpemUgdGhlIGxpbmtlZCBsaXN0IGFzIGFuIGVtcHR5IG5vZGUsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2YgdGhlIGZpcnN0IG5vZGU6IHdlIGNhbiBhbHdheXMgcmVmZXIgdG8gaXQgYXMgKHByZXZpb3VzIG5vZGUpLm5leHQsIGluc3RlYWQgb2Ygc29tZXRoaW5nIGxpa2UgKGxpc3QpLmhlYWRcblx0XHRcdFx0JG8gPSB7XG5cdFx0XHRcdFx0bmV4dDogdm9pZCB1bmRlZmluZWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcblx0XHRcdGxpc3RTZXQoLyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2YgJG8+fSAqLyAoJG8pLCBrZXksIHZhbHVlKTtcblx0XHR9XG5cdH07XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZmlndXJlIG91dCB3aHkgdGhpcyBpcyBlcnJvcmluZ1xuXHRyZXR1cm4gY2hhbm5lbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2V2YWwnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gRXZhbEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yYW5nZScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBSYW5nZUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3N5bnRheCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBTeW50YXhFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdXJpJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFVSSUVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9hYnMnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5hYnM7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Zsb29yJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguZmxvb3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL21heCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLm1heDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vbWluJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubWluO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9wb3cnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gTWF0aC5wb3c7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JvdW5kJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgucm91bmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2lzTmFOJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBpc05hTihhKSB7XG5cdHJldHVybiBhICE9PSBhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyICRpc05hTiA9IHJlcXVpcmUoJy4vaXNOYU4nKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vc2lnbicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaWduKG51bWJlcikge1xuXHRpZiAoJGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bWJlcjtcblx0fVxuXHRyZXR1cm4gbnVtYmVyIDwgMCA/IC0xIDogKzE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9nT1BEJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG52YXIgJGdPUEQgPSByZXF1aXJlKCcuL2dPUEQnKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zaGFtcycpfSAqL1xuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHQvKiogQHR5cGUge3sgW2sgaW4gc3ltYm9sXT86IHVua25vd24gfX0gKi9cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yICh2YXIgXyBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG5cdFx0dmFyIGRlc2NyaXB0b3IgPSAvKiogQHR5cGUge1Byb3BlcnR5RGVzY3JpcHRvcn0gKi8gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzTmF0aXZlU3ltYm9scygpIHtcblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sKCdmb28nKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL1JlZmxlY3QuZ2V0UHJvdG90eXBlT2YnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gKHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKSB8fCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJ2VzLW9iamVjdC1hdG9tcycpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9PYmplY3QuZ2V0UHJvdG90eXBlT2YnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gJE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG52YXIgY29uY2F0dHkgPSBmdW5jdGlvbiBjb25jYXR0eShhLCBiKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV07XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBhcnJbaiArIGEubGVuZ3RoXSA9IGJbal07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBzbGljeSA9IGZ1bmN0aW9uIHNsaWN5KGFyckxpa2UsIG9mZnNldCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0IHx8IDAsIGogPSAwOyBpIDwgYXJyTGlrZS5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICAgIGFycltqXSA9IGFyckxpa2VbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuXG52YXIgam9pbnkgPSBmdW5jdGlvbiAoYXJyLCBqb2luZXIpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGFycltpXTtcbiAgICAgICAgaWYgKGkgKyAxIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IGpvaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5hcHBseSh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWN5KGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgIGNvbmNhdHR5KGFyZ3MsIGFyZ3VtZW50cylcbiAgICAgICAgKTtcblxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBtYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJnc1tpXSA9ICckJyArIGk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGpvaW55KGJvdW5kQXJncywgJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2Z1bmN0aW9uQ2FsbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZnVuY3Rpb25BcHBseScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JlZmxlY3RBcHBseScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdCAmJiBSZWZsZWN0LmFwcGx5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcblxudmFyICRhcHBseSA9IHJlcXVpcmUoJy4vZnVuY3Rpb25BcHBseScpO1xudmFyICRjYWxsID0gcmVxdWlyZSgnLi9mdW5jdGlvbkNhbGwnKTtcbnZhciAkcmVmbGVjdEFwcGx5ID0gcmVxdWlyZSgnLi9yZWZsZWN0QXBwbHknKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vYWN0dWFsQXBwbHknKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gJHJlZmxlY3RBcHBseSB8fCBiaW5kLmNhbGwoJGNhbGwsICRhcHBseSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xuXG52YXIgJGNhbGwgPSByZXF1aXJlKCcuL2Z1bmN0aW9uQ2FsbCcpO1xudmFyICRhY3R1YWxBcHBseSA9IHJlcXVpcmUoJy4vYWN0dWFsQXBwbHknKTtcblxuLyoqIEB0eXBlIHsoYXJnczogW0Z1bmN0aW9uLCB0aGlzQXJnPzogdW5rbm93biwgLi4uYXJnczogdW5rbm93bltdXSkgPT4gRnVuY3Rpb259IFRPRE8gRklYTUUsIGZpbmQgYSB3YXkgdG8gdXNlIGltcG9ydCgnLicpICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCaW5kQmFzaWMoYXJncykge1xuXHRpZiAoYXJncy5sZW5ndGggPCAxIHx8IHR5cGVvZiBhcmdzWzBdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2EgZnVuY3Rpb24gaXMgcmVxdWlyZWQnKTtcblx0fVxuXHRyZXR1cm4gJGFjdHVhbEFwcGx5KGJpbmQsICRjYWxsLCBhcmdzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC1hcHBseS1oZWxwZXJzJyk7XG52YXIgZ09QRCA9IHJlcXVpcmUoJ2dvcGQnKTtcblxudmFyIGhhc1Byb3RvQWNjZXNzb3I7XG50cnkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zLCBuby1wcm90b1xuXHRoYXNQcm90b0FjY2Vzc29yID0gLyoqIEB0eXBlIHt7IF9fcHJvdG9fXz86IHR5cGVvZiBBcnJheS5wcm90b3R5cGUgfX0gKi8gKFtdKS5fX3Byb3RvX18gPT09IEFycmF5LnByb3RvdHlwZTtcbn0gY2F0Y2ggKGUpIHtcblx0aWYgKCFlIHx8IHR5cGVvZiBlICE9PSAnb2JqZWN0JyB8fCAhKCdjb2RlJyBpbiBlKSB8fCBlLmNvZGUgIT09ICdFUlJfUFJPVE9fQUNDRVNTJykge1xuXHRcdHRocm93IGU7XG5cdH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xudmFyIGRlc2MgPSAhIWhhc1Byb3RvQWNjZXNzb3IgJiYgZ09QRCAmJiBnT1BEKE9iamVjdC5wcm90b3R5cGUsIC8qKiBAdHlwZSB7a2V5b2YgdHlwZW9mIE9iamVjdC5wcm90b3R5cGV9ICovICgnX19wcm90b19fJykpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciAkZ2V0UHJvdG90eXBlT2YgPSAkT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9nZXQnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZGVzYyAmJiB0eXBlb2YgZGVzYy5nZXQgPT09ICdmdW5jdGlvbidcblx0PyBjYWxsQmluZChbZGVzYy5nZXRdKVxuXHQ6IHR5cGVvZiAkZ2V0UHJvdG90eXBlT2YgPT09ICdmdW5jdGlvbidcblx0XHQ/IC8qKiBAdHlwZSB7aW1wb3J0KCcuL2dldCcpfSAqLyBmdW5jdGlvbiBnZXREdW5kZXIodmFsdWUpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdHJldHVybiAkZ2V0UHJvdG90eXBlT2YodmFsdWUgPT0gbnVsbCA/IHZhbHVlIDogJE9iamVjdCh2YWx1ZSkpO1xuXHRcdH1cblx0XHQ6IGZhbHNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVmbGVjdEdldFByb3RvID0gcmVxdWlyZSgnLi9SZWZsZWN0LmdldFByb3RvdHlwZU9mJyk7XG52YXIgb3JpZ2luYWxHZXRQcm90byA9IHJlcXVpcmUoJy4vT2JqZWN0LmdldFByb3RvdHlwZU9mJyk7XG5cbnZhciBnZXREdW5kZXJQcm90byA9IHJlcXVpcmUoJ2R1bmRlci1wcm90by9nZXQnKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVmbGVjdEdldFByb3RvXG5cdD8gZnVuY3Rpb24gZ2V0UHJvdG8oTykge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgY2FuJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmUsIGZvciBzb21lIHJlYXNvblxuXHRcdHJldHVybiByZWZsZWN0R2V0UHJvdG8oTyk7XG5cdH1cblx0OiBvcmlnaW5hbEdldFByb3RvXG5cdFx0PyBmdW5jdGlvbiBnZXRQcm90byhPKSB7XG5cdFx0XHRpZiAoIU8gfHwgKHR5cGVvZiBPICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgTyAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignZ2V0UHJvdG86IG5vdCBhbiBvYmplY3QnKTtcblx0XHRcdH1cblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgY2FuJ3QgbmFycm93IGluc2lkZSBhIGNsb3N1cmUsIGZvciBzb21lIHJlYXNvblxuXHRcdFx0cmV0dXJuIG9yaWdpbmFsR2V0UHJvdG8oTyk7XG5cdFx0fVxuXHRcdDogZ2V0RHVuZGVyUHJvdG9cblx0XHRcdD8gZnVuY3Rpb24gZ2V0UHJvdG8oTykge1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IG5hcnJvdyBpbnNpZGUgYSBjbG9zdXJlLCBmb3Igc29tZSByZWFzb25cblx0XHRcdFx0cmV0dXJuIGdldER1bmRlclByb3RvKE8pO1xuXHRcdFx0fVxuXHRcdFx0OiBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xudmFyICRoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChjYWxsLCAkaGFzT3duKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRPYmplY3QgPSByZXF1aXJlKCdlcy1vYmplY3QtYXRvbXMnKTtcblxudmFyICRFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycycpO1xudmFyICRFdmFsRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvZXZhbCcpO1xudmFyICRSYW5nZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3JhbmdlJyk7XG52YXIgJFJlZmVyZW5jZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3JlZicpO1xudmFyICRTeW50YXhFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy9zeW50YXgnKTtcbnZhciAkVHlwZUVycm9yID0gcmVxdWlyZSgnZXMtZXJyb3JzL3R5cGUnKTtcbnZhciAkVVJJRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdXJpJyk7XG5cbnZhciBhYnMgPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvYWJzJyk7XG52YXIgZmxvb3IgPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvZmxvb3InKTtcbnZhciBtYXggPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3MvbWF4Jyk7XG52YXIgbWluID0gcmVxdWlyZSgnbWF0aC1pbnRyaW5zaWNzL21pbicpO1xudmFyIHBvdyA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9wb3cnKTtcbnZhciByb3VuZCA9IHJlcXVpcmUoJ21hdGgtaW50cmluc2ljcy9yb3VuZCcpO1xudmFyIHNpZ24gPSByZXF1aXJlKCdtYXRoLWludHJpbnNpY3Mvc2lnbicpO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gcmVxdWlyZSgnZ29wZCcpO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ2VzLWRlZmluZS1wcm9wZXJ0eScpO1xuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IHJlcXVpcmUoJ2dldC1wcm90bycpO1xudmFyICRPYmplY3RHUE8gPSByZXF1aXJlKCdnZXQtcHJvdG8vT2JqZWN0LmdldFByb3RvdHlwZU9mJyk7XG52YXIgJFJlZmxlY3RHUE8gPSByZXF1aXJlKCdnZXQtcHJvdG8vUmVmbGVjdC5nZXRQcm90b3R5cGVPZicpO1xuXG52YXIgJGFwcGx5ID0gcmVxdWlyZSgnY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25BcHBseScpO1xudmFyICRjYWxsID0gcmVxdWlyZSgnY2FsbC1iaW5kLWFwcGx5LWhlbHBlcnMvZnVuY3Rpb25DYWxsJyk7XG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgfHwgIWdldFByb3RvID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8oVWludDhBcnJheSk7XG5cbnZhciBJTlRSSU5TSUNTID0ge1xuXHRfX3Byb3RvX186IG51bGwsXG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQmlnSW50NjRBcnJheSUnOiB0eXBlb2YgQmlnSW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQ2NEFycmF5LFxuXHQnJUJpZ1VpbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdVaW50NjRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdVaW50NjRBcnJheSxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6ICRFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiAkRXZhbEVycm9yLFxuXHQnJUZsb2F0MTZBcnJheSUnOiB0eXBlb2YgRmxvYXQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0MTZBcnJheSxcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiAkT2JqZWN0LFxuXHQnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJzogJGdPUEQsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiAkUmFuZ2VFcnJvcixcblx0JyVSZWZlcmVuY2VFcnJvciUnOiAkUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzIHx8ICFnZXRQcm90byA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgJiYgZ2V0UHJvdG8gPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6ICRVUklFcnJvcixcblx0JyVXZWFrTWFwJSc6IHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtNYXAsXG5cdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxuXHQnJVdlYWtTZXQlJzogdHlwZW9mIFdlYWtTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1NldCxcblxuXHQnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJSc6ICRjYWxsLFxuXHQnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnOiAkYXBwbHksXG5cdCclT2JqZWN0LmRlZmluZVByb3BlcnR5JSc6ICRkZWZpbmVQcm9wZXJ0eSxcblx0JyVPYmplY3QuZ2V0UHJvdG90eXBlT2YlJzogJE9iamVjdEdQTyxcblx0JyVNYXRoLmFicyUnOiBhYnMsXG5cdCclTWF0aC5mbG9vciUnOiBmbG9vcixcblx0JyVNYXRoLm1heCUnOiBtYXgsXG5cdCclTWF0aC5taW4lJzogbWluLFxuXHQnJU1hdGgucG93JSc6IHBvdyxcblx0JyVNYXRoLnJvdW5kJSc6IHJvdW5kLFxuXHQnJU1hdGguc2lnbiUnOiBzaWduLFxuXHQnJVJlZmxlY3QuZ2V0UHJvdG90eXBlT2YlJzogJFJlZmxlY3RHUE9cbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJ2hhc293bicpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoJGNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbCgkYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKCRjYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbCgkY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoJGNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XG5cbi8qIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzQuMTcuMTUvZGlzdC9sb2Rhc2guanMjTDY3MzUtTDY3NDQgKi9cbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7XG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7IC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcblx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHN0cmluZywgMCwgMSk7XG5cdHZhciBsYXN0ID0gJHN0clNsaWNlKHN0cmluZywgLTEpO1xuXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XG5cdH0gZWxzZSBpZiAobGFzdCA9PT0gJyUnICYmIGZpcnN0ICE9PSAnJScpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgJyk7XG5cdH1cblx0dmFyIHJlc3VsdCA9IFtdO1xuXHQkcmVwbGFjZShzdHJpbmcsIHJlUHJvcE5hbWUsIGZ1bmN0aW9uIChtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG5cdFx0cmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gcXVvdGUgPyAkcmVwbGFjZShzdWJTdHJpbmcsIHJlRXNjYXBlQ2hhciwgJyQxJykgOiBudW1iZXIgfHwgbWF0Y2g7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qIGVuZCBhZGFwdGF0aW9uICovXG5cbnZhciBnZXRCYXNlSW50cmluc2ljID0gZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xuXHR2YXIgYWxpYXM7XG5cdGlmIChoYXNPd24oTEVHQUNZX0FMSUFTRVMsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0YWxpYXMgPSBMRUdBQ1lfQUxJQVNFU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpbnRyaW5zaWNOYW1lID0gJyUnICsgYWxpYXNbMF0gKyAnJSc7XG5cdH1cblxuXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XG5cdFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcblx0XHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xuXHRcdFx0dmFsdWUgPSBkb0V2YWwoaW50cmluc2ljTmFtZSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmICFhbGxvd01pc3NpbmcpIHtcblx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIScpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGlhczogYWxpYXMsXG5cdFx0XHRuYW1lOiBpbnRyaW5zaWNOYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fTtcblx0fVxuXG5cdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QhJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdldEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLmxlbmd0aCA9PT0gMCkge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdpbnRyaW5zaWMgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgYWxsb3dNaXNzaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXHR9XG5cblx0aWYgKCRleGVjKC9eJT9bXiVdKiU/JC8sIG5hbWUpID09PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignYCVgIG1heSBub3QgYmUgcHJlc2VudCBhbnl3aGVyZSBidXQgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSBpbnRyaW5zaWMgbmFtZScpO1xuXHR9XG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xuXG52YXIgY2FsbEJpbmRCYXNpYyA9IHJlcXVpcmUoJ2NhbGwtYmluZC1hcHBseS1oZWxwZXJzJyk7XG5cbi8qKiBAdHlwZSB7KHRoaXNBcmc6IHN0cmluZywgc2VhcmNoU3RyaW5nOiBzdHJpbmcsIHBvc2l0aW9uPzogbnVtYmVyKSA9PiBudW1iZXJ9ICovXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZEJhc2ljKFtHZXRJbnRyaW5zaWMoJyVTdHJpbmcucHJvdG90eXBlLmluZGV4T2YlJyldKTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJvdW5kSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHQvKiBlc2xpbnQgbm8tZXh0cmEtcGFyZW5zOiAwICovXG5cblx0dmFyIGludHJpbnNpYyA9IC8qKiBAdHlwZSB7KHRoaXM6IHVua25vd24sIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93bn0gKi8gKEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZykpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kQmFzaWMoLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtpbnRyaW5zaWNdKSk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1ib3VuZCcpO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCdvYmplY3QtaW5zcGVjdCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG52YXIgJE1hcCA9IEdldEludHJpbnNpYygnJU1hcCUnLCB0cnVlKTtcblxuLyoqIEB0eXBlIHs8SywgVj4odGhpc0FyZzogTWFwPEssIFY+LCBrZXk6IEspID0+IFZ9ICovXG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbi8qKiBAdHlwZSB7PEssIFY+KHRoaXNBcmc6IE1hcDxLLCBWPiwga2V5OiBLLCB2YWx1ZTogVikgPT4gdm9pZH0gKi9cbnZhciAkbWFwU2V0ID0gY2FsbEJvdW5kKCdNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xuLyoqIEB0eXBlIHs8SywgVj4odGhpc0FyZzogTWFwPEssIFY+LCBrZXk6IEspID0+IGJvb2xlYW59ICovXG52YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcbi8qKiBAdHlwZSB7PEssIFY+KHRoaXNBcmc6IE1hcDxLLCBWPiwga2V5OiBLKSA9PiBib29sZWFufSAqL1xudmFyICRtYXBEZWxldGUgPSBjYWxsQm91bmQoJ01hcC5wcm90b3R5cGUuZGVsZXRlJywgdHJ1ZSk7XG4vKiogQHR5cGUgezxLLCBWPih0aGlzQXJnOiBNYXA8SywgVj4pID0+IG51bWJlcn0gKi9cbnZhciAkbWFwU2l6ZSA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zaXplJywgdHJ1ZSk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICEhJE1hcCAmJiAvKiogQHR5cGUge0V4Y2x1ZGU8aW1wb3J0KCcuJyksIGZhbHNlPn0gKi8gZnVuY3Rpb24gZ2V0U2lkZUNoYW5uZWxNYXAoKSB7XG5cdC8qKiBAdHlwZWRlZiB7UmV0dXJuVHlwZTx0eXBlb2YgZ2V0U2lkZUNoYW5uZWxNYXA+fSBDaGFubmVsICovXG5cdC8qKiBAdHlwZWRlZiB7UGFyYW1ldGVyczxDaGFubmVsWydnZXQnXT5bMF19IEsgKi9cblx0LyoqIEB0eXBlZGVmIHtQYXJhbWV0ZXJzPENoYW5uZWxbJ3NldCddPlsxXX0gViAqL1xuXG5cdC8qKiBAdHlwZSB7TWFwPEssIFY+IHwgdW5kZWZpbmVkfSAqLyB2YXIgJG07XG5cblx0LyoqIEB0eXBlIHtDaGFubmVsfSAqL1xuXHR2YXIgY2hhbm5lbCA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCRtKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSAkbWFwRGVsZXRlKCRtLCBrZXkpO1xuXHRcdFx0XHRpZiAoJG1hcFNpemUoJG0pID09PSAwKSB7XG5cdFx0XHRcdFx0JG0gPSB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiAoa2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0XHRcdGlmICgkbSkge1xuXHRcdFx0XHRyZXR1cm4gJG1hcEdldCgkbSwga2V5KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhczogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0aWYgKCRtKSB7XG5cdFx0XHRcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCEkbSkge1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGNhbid0IGhhbmRsZSBuYXJyb3dpbmcgYSB2YXJpYWJsZSBpbnNpZGUgYSBjbG9zdXJlXG5cdFx0XHRcdCRtID0gbmV3ICRNYXAoKTtcblx0XHRcdH1cblx0XHRcdCRtYXBTZXQoJG0sIGtleSwgdmFsdWUpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGZpZ3VyZSBvdXQgd2h5IFRTIGlzIGVycm9yaW5nIGhlcmVcblx0cmV0dXJuIGNoYW5uZWw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2V0SW50cmluc2ljID0gcmVxdWlyZSgnZ2V0LWludHJpbnNpYycpO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYm91bmQnKTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWluc3BlY3QnKTtcbnZhciBnZXRTaWRlQ2hhbm5lbE1hcCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbC1tYXAnKTtcblxudmFyICRUeXBlRXJyb3IgPSByZXF1aXJlKCdlcy1lcnJvcnMvdHlwZScpO1xudmFyICRXZWFrTWFwID0gR2V0SW50cmluc2ljKCclV2Vha01hcCUnLCB0cnVlKTtcblxuLyoqIEB0eXBlIHs8SyBleHRlbmRzIG9iamVjdCwgVj4odGhpc0FyZzogV2Vha01hcDxLLCBWPiwga2V5OiBLKSA9PiBWfSAqL1xudmFyICR3ZWFrTWFwR2V0ID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcbi8qKiBAdHlwZSB7PEsgZXh0ZW5kcyBvYmplY3QsIFY+KHRoaXNBcmc6IFdlYWtNYXA8SywgVj4sIGtleTogSywgdmFsdWU6IFYpID0+IHZvaWR9ICovXG52YXIgJHdlYWtNYXBTZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLnNldCcsIHRydWUpO1xuLyoqIEB0eXBlIHs8SyBleHRlbmRzIG9iamVjdCwgVj4odGhpc0FyZzogV2Vha01hcDxLLCBWPiwga2V5OiBLKSA9PiBib29sZWFufSAqL1xudmFyICR3ZWFrTWFwSGFzID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcbi8qKiBAdHlwZSB7PEsgZXh0ZW5kcyBvYmplY3QsIFY+KHRoaXNBcmc6IFdlYWtNYXA8SywgVj4sIGtleTogSykgPT4gYm9vbGVhbn0gKi9cbnZhciAkd2Vha01hcERlbGV0ZSA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlJywgdHJ1ZSk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9ICRXZWFrTWFwXG5cdD8gLyoqIEB0eXBlIHtFeGNsdWRlPGltcG9ydCgnLicpLCBmYWxzZT59ICovIGZ1bmN0aW9uIGdldFNpZGVDaGFubmVsV2Vha01hcCgpIHtcblx0XHQvKiogQHR5cGVkZWYge1JldHVyblR5cGU8dHlwZW9mIGdldFNpZGVDaGFubmVsV2Vha01hcD59IENoYW5uZWwgKi9cblx0XHQvKiogQHR5cGVkZWYge1BhcmFtZXRlcnM8Q2hhbm5lbFsnZ2V0J10+WzBdfSBLICovXG5cdFx0LyoqIEB0eXBlZGVmIHtQYXJhbWV0ZXJzPENoYW5uZWxbJ3NldCddPlsxXX0gViAqL1xuXG5cdFx0LyoqIEB0eXBlIHtXZWFrTWFwPEsgJiBvYmplY3QsIFY+IHwgdW5kZWZpbmVkfSAqLyB2YXIgJHdtO1xuXHRcdC8qKiBAdHlwZSB7Q2hhbm5lbCB8IHVuZGVmaW5lZH0gKi8gdmFyICRtO1xuXG5cdFx0LyoqIEB0eXBlIHtDaGFubmVsfSAqL1xuXHRcdHZhciBjaGFubmVsID0ge1xuXHRcdFx0YXNzZXJ0OiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdTaWRlIGNoYW5uZWwgZG9lcyBub3QgY29udGFpbiAnICsgaW5zcGVjdChrZXkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdFx0aWYgKCR3bSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICR3ZWFrTWFwRGVsZXRlKCR3bSwga2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZ2V0U2lkZUNoYW5uZWxNYXApIHtcblx0XHRcdFx0XHRpZiAoJG0pIHtcblx0XHRcdFx0XHRcdHJldHVybiAkbVsnZGVsZXRlJ10oa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGdldDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRpZiAoJFdlYWtNYXAgJiYga2V5ICYmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5ID09PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0XHRcdGlmICgkd20pIHtcblx0XHRcdFx0XHRcdHJldHVybiAkd2Vha01hcEdldCgkd20sIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAkbSAmJiAkbS5nZXQoa2V5KTtcblx0XHRcdH0sXG5cdFx0XHRoYXM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdFx0XHRpZiAoJHdtKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJHdlYWtNYXBIYXMoJHdtLCBrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISEkbSAmJiAkbS5oYXMoa2V5KTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XG5cdFx0XHRcdFx0aWYgKCEkd20pIHtcblx0XHRcdFx0XHRcdCR3bSA9IG5ldyAkV2Vha01hcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkd2Vha01hcFNldCgkd20sIGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGdldFNpZGVDaGFubmVsTWFwKSB7XG5cdFx0XHRcdFx0aWYgKCEkbSkge1xuXHRcdFx0XHRcdFx0JG0gPSBnZXRTaWRlQ2hhbm5lbE1hcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtcGFyZW5zXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtOb25OdWxsYWJsZTx0eXBlb2YgJG0+fSAqLyAoJG0pLnNldChrZXksIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE86IGZpZ3VyZSBvdXQgd2h5IHRoaXMgaXMgZXJyb3Jpbmdcblx0XHRyZXR1cm4gY2hhbm5lbDtcblx0fVxuXHQ6IGdldFNpZGVDaGFubmVsTWFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgJFR5cGVFcnJvciA9IHJlcXVpcmUoJ2VzLWVycm9ycy90eXBlJyk7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJ29iamVjdC1pbnNwZWN0Jyk7XG52YXIgZ2V0U2lkZUNoYW5uZWxMaXN0ID0gcmVxdWlyZSgnc2lkZS1jaGFubmVsLWxpc3QnKTtcbnZhciBnZXRTaWRlQ2hhbm5lbE1hcCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbC1tYXAnKTtcbnZhciBnZXRTaWRlQ2hhbm5lbFdlYWtNYXAgPSByZXF1aXJlKCdzaWRlLWNoYW5uZWwtd2Vha21hcCcpO1xuXG52YXIgbWFrZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbFdlYWtNYXAgfHwgZ2V0U2lkZUNoYW5uZWxNYXAgfHwgZ2V0U2lkZUNoYW5uZWxMaXN0O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaWRlQ2hhbm5lbCgpIHtcblx0LyoqIEB0eXBlZGVmIHtSZXR1cm5UeXBlPHR5cGVvZiBnZXRTaWRlQ2hhbm5lbD59IENoYW5uZWwgKi9cblxuXHQvKiogQHR5cGUge0NoYW5uZWwgfCB1bmRlZmluZWR9ICovIHZhciAkY2hhbm5lbERhdGE7XG5cblx0LyoqIEB0eXBlIHtDaGFubmVsfSAqL1xuXHR2YXIgY2hhbm5lbCA9IHtcblx0XHRhc3NlcnQ6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdGlmICghY2hhbm5lbC5oYXMoa2V5KSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignU2lkZSBjaGFubmVsIGRvZXMgbm90IGNvbnRhaW4gJyArIGluc3BlY3Qoa2V5KSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuICEhJGNoYW5uZWxEYXRhICYmICRjaGFubmVsRGF0YVsnZGVsZXRlJ10oa2V5KTtcblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cmV0dXJuICRjaGFubmVsRGF0YSAmJiAkY2hhbm5lbERhdGEuZ2V0KGtleSk7XG5cdFx0fSxcblx0XHRoYXM6IGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdHJldHVybiAhISRjaGFubmVsRGF0YSAmJiAkY2hhbm5lbERhdGEuaGFzKGtleSk7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRpZiAoISRjaGFubmVsRGF0YSkge1xuXHRcdFx0XHQkY2hhbm5lbERhdGEgPSBtYWtlQ2hhbm5lbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQkY2hhbm5lbERhdGEuc2V0KGtleSwgdmFsdWUpO1xuXHRcdH1cblx0fTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaWd1cmUgb3V0IHdoeSB0aGlzIGlzIGVycm9yaW5nXG5cdHJldHVybiBjaGFubmVsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG52YXIgRm9ybWF0ID0ge1xuICAgIFJGQzE3Mzg6ICdSRkMxNzM4JyxcbiAgICBSRkMzOTg2OiAnUkZDMzk4Nidcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXG4gICAgZm9ybWF0dGVyczoge1xuICAgICAgICBSRkMxNzM4OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcbiAgICAgICAgfSxcbiAgICAgICAgUkZDMzk4NjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogRm9ybWF0LlJGQzE3MzgsXG4gICAgUkZDMzk4NjogRm9ybWF0LlJGQzM5ODZcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgaGV4VGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgYXJyYXkucHVzaCgnJScgKyAoKGkgPCAxNiA/ICcwJyA6ICcnKSArIGkudG9TdHJpbmcoMTYpKS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG59KCkpO1xuXG52YXIgY29tcGFjdFF1ZXVlID0gZnVuY3Rpb24gY29tcGFjdFF1ZXVlKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBhcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gYXJyYXlUb09iamVjdChzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IHsgX19wcm90b19fOiBudWxsIH0gOiB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludCBuby1wYXJhbS1yZWFzc2lnbjogMCAqL1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnICYmIHR5cGVvZiBzb3VyY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAob3B0aW9ucyAmJiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpKVxuICAgICAgICAgICAgICAgIHx8ICFoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBzb3VyY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFt0YXJnZXRdLmNvbmNhdChzb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBtZXJnZVRhcmdldCA9IHRhcmdldDtcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmICFpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEl0ZW0gJiYgdHlwZW9mIHRhcmdldEl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IG1lcmdlKHRhcmdldEl0ZW0sIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoaGFzLmNhbGwoYWNjLCBrZXkpKSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IG1lcmdlKGFjY1trZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbWVyZ2VUYXJnZXQpO1xufTtcblxudmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnblNpbmdsZVNvdXJjZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB0YXJnZXQpO1xufTtcblxudmFyIGRlY29kZSA9IGZ1bmN0aW9uIChzdHIsIGRlZmF1bHREZWNvZGVyLCBjaGFyc2V0KSB7XG4gICAgdmFyIHN0cldpdGhvdXRQbHVzID0gc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgIGlmIChjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cy5yZXBsYWNlKC8lWzAtOWEtZl17Mn0vZ2ksIHVuZXNjYXBlKTtcbiAgICB9XG4gICAgLy8gdXRmLThcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cldpdGhvdXRQbHVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHJXaXRob3V0UGx1cztcbiAgICB9XG59O1xuXG52YXIgbGltaXQgPSAxMDI0O1xuXG4vKiBlc2xpbnQgb3BlcmF0b3ItbGluZWJyZWFrOiBbMiwgXCJiZWZvcmVcIl0gKi9cblxudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIsIGRlZmF1bHRFbmNvZGVyLCBjaGFyc2V0LCBraW5kLCBmb3JtYXQpIHtcbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IHN0cjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgc3RyaW5nID0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN0cik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGUoc3RyaW5nKS5yZXBsYWNlKC8ldVswLTlhLWZdezR9L2dpLCBmdW5jdGlvbiAoJDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJTI2JTIzJyArIHBhcnNlSW50KCQwLnNsaWNlKDIpLCAxNikgKyAnJTNCJztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaW5nLmxlbmd0aDsgaiArPSBsaW1pdCkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHN0cmluZy5sZW5ndGggPj0gbGltaXQgPyBzdHJpbmcuc2xpY2UoaiwgaiArIGxpbWl0KSA6IHN0cmluZztcbiAgICAgICAgdmFyIGFyciA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBzZWdtZW50LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYyA9PT0gMHgyRCAvLyAtXG4gICAgICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICAgICAgfHwgYyA9PT0gMHg1RiAvLyBfXG4gICAgICAgICAgICAgICAgfHwgYyA9PT0gMHg3RSAvLyB+XG4gICAgICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgICAgIHx8IChjID49IDB4NDEgJiYgYyA8PSAweDVBKSAvLyBhLXpcbiAgICAgICAgICAgICAgICB8fCAoYyA+PSAweDYxICYmIGMgPD0gMHg3QSkgLy8gQS1aXG4gICAgICAgICAgICAgICAgfHwgKGZvcm1hdCA9PT0gZm9ybWF0cy5SRkMxNzM4ICYmIChjID09PSAweDI4IHx8IGMgPT09IDB4MjkpKSAvLyAoIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGFyclthcnIubGVuZ3RoXSA9IHNlZ21lbnQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICBhcnJbYXJyLmxlbmd0aF0gPSBoZXhUYWJsZVtjXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV1cbiAgICAgICAgICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPj0gMHhFMDAwKSB7XG4gICAgICAgICAgICAgICAgYXJyW2Fyci5sZW5ndGhdID0gaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV1cbiAgICAgICAgICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildXG4gICAgICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHNlZ21lbnQuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XG5cbiAgICAgICAgICAgIGFyclthcnIubGVuZ3RoXSA9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDEyKSAmIDB4M0YpXVxuICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8ICgoYyA+PiA2KSAmIDB4M0YpXVxuICAgICAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ICs9IGFyci5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxudmFyIGNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KHZhbHVlKSB7XG4gICAgdmFyIHF1ZXVlID0gW3sgb2JqOiB7IG86IHZhbHVlIH0sIHByb3A6ICdvJyB9XTtcbiAgICB2YXIgcmVmcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgICB2YXIgb2JqID0gaXRlbS5vYmpbaXRlbS5wcm9wXTtcblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbal07XG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIHJlZnMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goeyBvYmo6IG9iaiwgcHJvcDoga2V5IH0pO1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcGFjdFF1ZXVlKHF1ZXVlKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBpc1JlZ0V4cCA9IGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG52YXIgaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhKG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpO1xufTtcblxudmFyIGNvbWJpbmUgPSBmdW5jdGlvbiBjb21iaW5lKGEsIGIpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KGEsIGIpO1xufTtcblxudmFyIG1heWJlTWFwID0gZnVuY3Rpb24gbWF5YmVNYXAodmFsLCBmbikge1xuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgbWFwcGVkLnB1c2goZm4odmFsW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZuKHZhbCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheVRvT2JqZWN0OiBhcnJheVRvT2JqZWN0LFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGNvbWJpbmU6IGNvbWJpbmUsXG4gICAgY29tcGFjdDogY29tcGFjdCxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gICAgaXNSZWdFeHA6IGlzUmVnRXhwLFxuICAgIG1heWJlTWFwOiBtYXliZU1hcCxcbiAgICBtZXJnZTogbWVyZ2Vcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnZXRTaWRlQ2hhbm5lbCA9IHJlcXVpcmUoJ3NpZGUtY2hhbm5lbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBjb21tYTogJ2NvbW1hJyxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7XG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xudmFyIHB1c2hUb0FycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFsdWVPckFycmF5KSB7XG4gICAgcHVzaC5hcHBseShhcnIsIGlzQXJyYXkodmFsdWVPckFycmF5KSA/IHZhbHVlT3JBcnJheSA6IFt2YWx1ZU9yQXJyYXldKTtcbn07XG5cbnZhciB0b0lTTyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG52YXIgZGVmYXVsdEZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd0VtcHR5QXJyYXlzOiBmYWxzZSxcbiAgICBhcnJheUZvcm1hdDogJ2luZGljZXMnLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYVJvdW5kVHJpcDogZmFsc2UsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZW5jb2RlOiB0cnVlLFxuICAgIGVuY29kZURvdEluS2V5czogZmFsc2UsXG4gICAgZW5jb2RlcjogdXRpbHMuZW5jb2RlLFxuICAgIGVuY29kZVZhbHVlc09ubHk6IGZhbHNlLFxuICAgIGZpbHRlcjogdm9pZCB1bmRlZmluZWQsXG4gICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICAgIGZvcm1hdHRlcjogZm9ybWF0cy5mb3JtYXR0ZXJzW2RlZmF1bHRGb3JtYXRdLFxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBpbmRpY2VzOiBmYWxzZSxcbiAgICBzZXJpYWxpemVEYXRlOiBmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XG4gICAgfSxcbiAgICBza2lwTnVsbHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBpc05vbk51bGxpc2hQcmltaXRpdmUgPSBmdW5jdGlvbiBpc05vbk51bGxpc2hQcmltaXRpdmUodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZydcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbidcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdzeW1ib2wnXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYmlnaW50Jztcbn07XG5cbnZhciBzZW50aW5lbCA9IHt9O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KFxuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBjb21tYVJvdW5kVHJpcCxcbiAgICBhbGxvd0VtcHR5QXJyYXlzLFxuICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICBza2lwTnVsbHMsXG4gICAgZW5jb2RlRG90SW5LZXlzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0LFxuICAgIGZvcm1hdHRlcixcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxuICAgIGNoYXJzZXQsXG4gICAgc2lkZUNoYW5uZWxcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG5cbiAgICB2YXIgdG1wU2MgPSBzaWRlQ2hhbm5lbDtcbiAgICB2YXIgc3RlcCA9IDA7XG4gICAgdmFyIGZpbmRGbGFnID0gZmFsc2U7XG4gICAgd2hpbGUgKCh0bXBTYyA9IHRtcFNjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZEZsYWcpIHtcbiAgICAgICAgLy8gV2hlcmUgb2JqZWN0IGxhc3QgYXBwZWFyZWQgaW4gdGhlIHJlZiB0cmVlXG4gICAgICAgIHZhciBwb3MgPSB0bXBTYy5nZXQob2JqZWN0KTtcbiAgICAgICAgc3RlcCArPSAxO1xuICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPT09IHN0ZXApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ3ljbGljIG9iamVjdCB2YWx1ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5kRmxhZyA9IHRydWU7IC8vIEJyZWFrIHdoaWxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0bXBTYy5nZXQoc2VudGluZWwpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc3RlcCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvYmogPSBzZXJpYWxpemVEYXRlKG9iaik7XG4gICAgfSBlbHNlIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICBvYmogPSB1dGlscy5tYXliZU1hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlciAmJiAhZW5jb2RlVmFsdWVzT25seSA/IGVuY29kZXIocHJlZml4LCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAna2V5JywgZm9ybWF0KSA6IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9ICcnO1xuICAgIH1cblxuICAgIGlmIChpc05vbk51bGxpc2hQcmltaXRpdmUob2JqKSB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpO1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIocHJlZml4KSArICc9JyArIGZvcm1hdHRlcihTdHJpbmcob2JqKSldO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIHZhciBvYmpLZXlzO1xuICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGpvaW4gZWxlbWVudHMgaW5cbiAgICAgICAgaWYgKGVuY29kZVZhbHVlc09ubHkgJiYgZW5jb2Rlcikge1xuICAgICAgICAgICAgb2JqID0gdXRpbHMubWF5YmVNYXAob2JqLCBlbmNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBvYmpLZXlzID0gW3sgdmFsdWU6IG9iai5sZW5ndGggPiAwID8gb2JqLmpvaW4oJywnKSB8fCBudWxsIDogdm9pZCB1bmRlZmluZWQgfV07XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIG9iaktleXMgPSBzb3J0ID8ga2V5cy5zb3J0KHNvcnQpIDoga2V5cztcbiAgICB9XG5cbiAgICB2YXIgZW5jb2RlZFByZWZpeCA9IGVuY29kZURvdEluS2V5cyA/IFN0cmluZyhwcmVmaXgpLnJlcGxhY2UoL1xcLi9nLCAnJTJFJykgOiBTdHJpbmcocHJlZml4KTtcblxuICAgIHZhciBhZGp1c3RlZFByZWZpeCA9IGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gZW5jb2RlZFByZWZpeCArICdbXScgOiBlbmNvZGVkUHJlZml4O1xuXG4gICAgaWYgKGFsbG93RW1wdHlBcnJheXMgJiYgaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdGVkUHJlZml4ICsgJ1tdJztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iaktleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGtleSA9IG9iaktleXNbal07XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAmJiB0eXBlb2Yga2V5LnZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBrZXkudmFsdWVcbiAgICAgICAgICAgIDogb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHNraXBOdWxscyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5jb2RlZEtleSA9IGFsbG93RG90cyAmJiBlbmNvZGVEb3RJbktleXMgPyBTdHJpbmcoa2V5KS5yZXBsYWNlKC9cXC4vZywgJyUyRScpIDogU3RyaW5nKGtleSk7XG4gICAgICAgIHZhciBrZXlQcmVmaXggPSBpc0FycmF5KG9iailcbiAgICAgICAgICAgID8gdHlwZW9mIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdmdW5jdGlvbicgPyBnZW5lcmF0ZUFycmF5UHJlZml4KGFkanVzdGVkUHJlZml4LCBlbmNvZGVkS2V5KSA6IGFkanVzdGVkUHJlZml4XG4gICAgICAgICAgICA6IGFkanVzdGVkUHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGVuY29kZWRLZXkgOiAnWycgKyBlbmNvZGVkS2V5ICsgJ10nKTtcblxuICAgICAgICBzaWRlQ2hhbm5lbC5zZXQob2JqZWN0LCBzdGVwKTtcbiAgICAgICAgdmFyIHZhbHVlU2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgICAgICB2YWx1ZVNpZGVDaGFubmVsLnNldChzZW50aW5lbCwgc2lkZUNoYW5uZWwpO1xuICAgICAgICBwdXNoVG9BcnJheSh2YWx1ZXMsIHN0cmluZ2lmeShcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAga2V5UHJlZml4LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxuICAgICAgICAgICAgYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgIGVuY29kZURvdEluS2V5cyxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgZW5jb2RlVmFsdWVzT25seSAmJiBpc0FycmF5KG9iaikgPyBudWxsIDogZW5jb2RlcixcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICBhbGxvd0RvdHMsXG4gICAgICAgICAgICBzZXJpYWxpemVEYXRlLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgZW5jb2RlVmFsdWVzT25seSxcbiAgICAgICAgICAgIGNoYXJzZXQsXG4gICAgICAgICAgICB2YWx1ZVNpZGVDaGFubmVsXG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgbm9ybWFsaXplU3RyaW5naWZ5T3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmFsbG93RW1wdHlBcnJheXMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgYWxsb3dFbXB0eUFycmF5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZW5jb2RlRG90SW5LZXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGVuY29kZURvdEluS2V5c2Agb3B0aW9uIGNhbiBvbmx5IGJlIGB0cnVlYCBvciBgZmFsc2VgLCB3aGVuIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZW5jb2RlciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRzLmNoYXJzZXQgfHwgZGVmYXVsdHMuY2hhcnNldDtcbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcbiAgICBpZiAodHlwZW9mIG9wdHMuZm9ybWF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWhhcy5jYWxsKGZvcm1hdHMuZm9ybWF0dGVycywgb3B0cy5mb3JtYXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0ID0gb3B0cy5mb3JtYXQ7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgIHZhciBmaWx0ZXIgPSBkZWZhdWx0cy5maWx0ZXI7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0FycmF5KG9wdHMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRzLmZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlGb3JtYXQ7XG4gICAgaWYgKG9wdHMuYXJyYXlGb3JtYXQgaW4gYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5hcnJheUZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKCdpbmRpY2VzJyBpbiBvcHRzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBkZWZhdWx0cy5hcnJheUZvcm1hdDtcbiAgICB9XG5cbiAgICBpZiAoJ2NvbW1hUm91bmRUcmlwJyBpbiBvcHRzICYmIHR5cGVvZiBvcHRzLmNvbW1hUm91bmRUcmlwICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGNvbW1hUm91bmRUcmlwYCBtdXN0IGJlIGEgYm9vbGVhbiwgb3IgYWJzZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRzLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gdHJ1ZSA/IHRydWUgOiBkZWZhdWx0cy5hbGxvd0RvdHMgOiAhIW9wdHMuYWxsb3dEb3RzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkUXVlcnlQcmVmaXg6IHR5cGVvZiBvcHRzLmFkZFF1ZXJ5UHJlZml4ID09PSAnYm9vbGVhbicgPyBvcHRzLmFkZFF1ZXJ5UHJlZml4IDogZGVmYXVsdHMuYWRkUXVlcnlQcmVmaXgsXG4gICAgICAgIGFsbG93RG90czogYWxsb3dEb3RzLFxuICAgICAgICBhbGxvd0VtcHR5QXJyYXlzOiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzID09PSAnYm9vbGVhbicgPyAhIW9wdHMuYWxsb3dFbXB0eUFycmF5cyA6IGRlZmF1bHRzLmFsbG93RW1wdHlBcnJheXMsXG4gICAgICAgIGFycmF5Rm9ybWF0OiBhcnJheUZvcm1hdCxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxuICAgICAgICBjb21tYVJvdW5kVHJpcDogISFvcHRzLmNvbW1hUm91bmRUcmlwLFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRzLmRlbGltaXRlcixcbiAgICAgICAgZW5jb2RlOiB0eXBlb2Ygb3B0cy5lbmNvZGUgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlIDogZGVmYXVsdHMuZW5jb2RlLFxuICAgICAgICBlbmNvZGVEb3RJbktleXM6IHR5cGVvZiBvcHRzLmVuY29kZURvdEluS2V5cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGVEb3RJbktleXMgOiBkZWZhdWx0cy5lbmNvZGVEb3RJbktleXMsXG4gICAgICAgIGVuY29kZXI6IHR5cGVvZiBvcHRzLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRzLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyLFxuICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5OiB0eXBlb2Ygb3B0cy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRzLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICAgIGZvcm1hdHRlcjogZm9ybWF0dGVyLFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcbiAgICAgICAgc2tpcE51bGxzOiB0eXBlb2Ygb3B0cy5za2lwTnVsbHMgPT09ICdib29sZWFuJyA/IG9wdHMuc2tpcE51bGxzIDogZGVmYXVsdHMuc2tpcE51bGxzLFxuICAgICAgICBzb3J0OiB0eXBlb2Ygb3B0cy5zb3J0ID09PSAnZnVuY3Rpb24nID8gb3B0cy5zb3J0IDogbnVsbCxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xuXG4gICAgdmFyIG9iaktleXM7XG4gICAgdmFyIGZpbHRlcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1tvcHRpb25zLmFycmF5Rm9ybWF0XTtcbiAgICB2YXIgY29tbWFSb3VuZFRyaXAgPSBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIG9wdGlvbnMuY29tbWFSb3VuZFRyaXA7XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXG4gICAgICAgICAgICBjb21tYVJvdW5kVHJpcCxcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dFbXB0eUFycmF5cyxcbiAgICAgICAgICAgIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nLFxuICAgICAgICAgICAgb3B0aW9ucy5za2lwTnVsbHMsXG4gICAgICAgICAgICBvcHRpb25zLmVuY29kZURvdEluS2V5cyxcbiAgICAgICAgICAgIG9wdGlvbnMuZW5jb2RlID8gb3B0aW9ucy5lbmNvZGVyIDogbnVsbCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5zb3J0LFxuICAgICAgICAgICAgb3B0aW9ucy5hbGxvd0RvdHMsXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBvcHRpb25zLmZvcm1hdCxcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0dGVyLFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxuICAgICAgICAgICAgb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICAgICAgc2lkZUNoYW5uZWxcbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMuYWRkUXVlcnlQcmVmaXggPT09IHRydWUgPyAnPycgOiAnJztcblxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudCgnJiMxMDAwMzsnKSwgdGhlIFwibnVtZXJpYyBlbnRpdHlcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXG4gICAgICAgICAgICBwcmVmaXggKz0gJ3V0Zjg9JUUyJTlDJTkzJic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gam9pbmVkLmxlbmd0aCA+IDAgPyBwcmVmaXggKyBqb2luZWQgOiAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBhbGxvd0RvdHM6IGZhbHNlLFxuICAgIGFsbG93RW1wdHlBcnJheXM6IGZhbHNlLFxuICAgIGFsbG93UHJvdG90eXBlczogZmFsc2UsXG4gICAgYWxsb3dTcGFyc2U6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcbiAgICBjb21tYTogZmFsc2UsXG4gICAgZGVjb2RlRG90SW5LZXlzOiBmYWxzZSxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgZHVwbGljYXRlczogJ2NvbWJpbmUnLFxuICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBmYWxzZSxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxuICAgIHBhcmFtZXRlckxpbWl0OiAxMDAwLFxuICAgIHBhcnNlQXJyYXlzOiB0cnVlLFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXG4gICAgc3RyaWN0RGVwdGg6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2UsXG4gICAgdGhyb3dPbkxpbWl0RXhjZWVkZWQ6IGZhbHNlXG59O1xuXG52YXIgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uICgkMCwgbnVtYmVyU3RyKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcbiAgICB9KTtcbn07XG5cbnZhciBwYXJzZUFycmF5VmFsdWUgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zLCBjdXJyZW50QXJyYXlMZW5ndGgpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiB2YWwuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aHJvd09uTGltaXRFeGNlZWRlZCAmJiBjdXJyZW50QXJyYXlMZW5ndGggPj0gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcnJheSBsaW1pdCBleGNlZWRlZC4gT25seSAnICsgb3B0aW9ucy5hcnJheUxpbWl0ICsgJyBlbGVtZW50JyArIChvcHRpb25zLmFycmF5TGltaXQgPT09IDEgPyAnJyA6ICdzJykgKyAnIGFsbG93ZWQgaW4gYW4gYXJyYXkuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbn07XG5cbi8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxuLy8gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIGJvZHkgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgcGFnZSBjb250YWluaW5nXG4vLyB0aGUgZm9ybSBpcyBpc28tODg1OS0xLCBvciB3aGVuIHRoZSBzdWJtaXR0ZWQgZm9ybSBoYXMgYW4gYWNjZXB0LWNoYXJzZXRcbi8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXG4vLyB0aGUg4pyTIGNoYXJhY3Rlciwgc3VjaCBhcyB1cy1hc2NpaS5cbnZhciBpc29TZW50aW5lbCA9ICd1dGY4PSUyNiUyMzEwMDAzJTNCJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpXG5cbi8vIFRoZXNlIGFyZSB0aGUgcGVyY2VudC1lbmNvZGVkIHV0Zi04IG9jdGV0cyByZXByZXNlbnRpbmcgYSBjaGVja21hcmssIGluZGljYXRpbmcgdGhhdCB0aGUgcmVxdWVzdCBhY3R1YWxseSBpcyB1dGYtOCBlbmNvZGVkLlxudmFyIGNoYXJzZXRTZW50aW5lbCA9ICd1dGY4PSVFMiU5QyU5Myc7IC8vIGVuY29kZVVSSUNvbXBvbmVudCgn4pyTJylcblxudmFyIHBhcnNlVmFsdWVzID0gZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZ1ZhbHVlcyhzdHIsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0geyBfX3Byb3RvX186IG51bGwgfTtcblxuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICBjbGVhblN0ciA9IGNsZWFuU3RyLnJlcGxhY2UoLyU1Qi9naSwgJ1snKS5yZXBsYWNlKC8lNUQvZ2ksICddJyk7XG5cbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQoXG4gICAgICAgIG9wdGlvbnMuZGVsaW1pdGVyLFxuICAgICAgICBvcHRpb25zLnRocm93T25MaW1pdEV4Y2VlZGVkID8gbGltaXQgKyAxIDogbGltaXRcbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMudGhyb3dPbkxpbWl0RXhjZWVkZWQgJiYgcGFydHMubGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1BhcmFtZXRlciBsaW1pdCBleGNlZWRlZC4gT25seSAnICsgbGltaXQgKyAnIHBhcmFtZXRlcicgKyAobGltaXQgPT09IDEgPyAnJyA6ICdzJykgKyAnIGFsbG93ZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxuICAgIHZhciBpO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XG4gICAgaWYgKG9wdGlvbnMuY2hhcnNldFNlbnRpbmVsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV0gPT09IGNoYXJzZXRTZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyc2V0ID0gJ2lzby04ODU5LTEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBwYXJ0cy5sZW5ndGg7IC8vIFRoZSBlc2xpbnQgc2V0dGluZ3MgZG8gbm90IGFsbG93IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpID09PSBza2lwSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIsIGNoYXJzZXQsICdrZXknKTtcblxuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXG4gICAgICAgICAgICAgICAgcGFyc2VBcnJheVZhbHVlKFxuICAgICAgICAgICAgICAgICAgICBwYXJ0LnNsaWNlKHBvcyArIDEpLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpc0FycmF5KG9ialtrZXldKSA/IG9ialtrZXldLmxlbmd0aCA6IDBcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbmNvZGVkVmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgJiYgb3B0aW9ucy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgJiYgY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXMoU3RyaW5nKHZhbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnQuaW5kZXhPZignW109JykgPiAtMSkge1xuICAgICAgICAgICAgdmFsID0gaXNBcnJheSh2YWwpID8gW3ZhbF0gOiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhpc3RpbmcgPSBoYXMuY2FsbChvYmosIGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZyAmJiBvcHRpb25zLmR1cGxpY2F0ZXMgPT09ICdjb21iaW5lJykge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1dGlscy5jb21iaW5lKG9ialtrZXldLCB2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKCFleGlzdGluZyB8fCBvcHRpb25zLmR1cGxpY2F0ZXMgPT09ICdsYXN0Jykge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24gKGNoYWluLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xuICAgIHZhciBjdXJyZW50QXJyYXlMZW5ndGggPSAwO1xuICAgIGlmIChjaGFpbi5sZW5ndGggPiAwICYmIGNoYWluW2NoYWluLmxlbmd0aCAtIDFdID09PSAnW10nKSB7XG4gICAgICAgIHZhciBwYXJlbnRLZXkgPSBjaGFpbi5zbGljZSgwLCAtMSkuam9pbignJyk7XG4gICAgICAgIGN1cnJlbnRBcnJheUxlbmd0aCA9IEFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWxbcGFyZW50S2V5XSA/IHZhbFtwYXJlbnRLZXldLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgdmFyIGxlYWYgPSB2YWx1ZXNQYXJzZWQgPyB2YWwgOiBwYXJzZUFycmF5VmFsdWUodmFsLCBvcHRpb25zLCBjdXJyZW50QXJyYXlMZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IGNoYWluLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBvYmo7XG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XG5cbiAgICAgICAgaWYgKHJvb3QgPT09ICdbXScgJiYgb3B0aW9ucy5wYXJzZUFycmF5cykge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5hbGxvd0VtcHR5QXJyYXlzICYmIChsZWFmID09PSAnJyB8fCAob3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgJiYgbGVhZiA9PT0gbnVsbCkpXG4gICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgIDogdXRpbHMuY29tYmluZShbXSwgbGVhZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IHsgX19wcm90b19fOiBudWxsIH0gOiB7fTtcbiAgICAgICAgICAgIHZhciBjbGVhblJvb3QgPSByb290LmNoYXJBdCgwKSA9PT0gJ1snICYmIHJvb3QuY2hhckF0KHJvb3QubGVuZ3RoIC0gMSkgPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgLTEpIDogcm9vdDtcbiAgICAgICAgICAgIHZhciBkZWNvZGVkUm9vdCA9IG9wdGlvbnMuZGVjb2RlRG90SW5LZXlzID8gY2xlYW5Sb290LnJlcGxhY2UoLyUyRS9nLCAnLicpIDogY2xlYW5Sb290O1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoZGVjb2RlZFJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXJzZUFycmF5cyAmJiBkZWNvZGVkUm9vdCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB7IDA6IGxlYWYgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgICAgICYmIHJvb3QgIT09IGRlY29kZWRSb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gZGVjb2RlZFJvb3RcbiAgICAgICAgICAgICAgICAmJiBpbmRleCA+PSAwXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlY29kZWRSb290ICE9PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgIG9ialtkZWNvZGVkUm9vdF0gPSBsZWFmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZiA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhZjtcbn07XG5cbnZhciBwYXJzZUtleXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nS2V5cyhnaXZlbktleSwgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gb3B0aW9ucy5kZXB0aCA+IDAgJiYgYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5cyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKG9wdGlvbnMuZGVwdGggPiAwICYmIChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBjaGVjayBzdHJpY3REZXB0aCBvcHRpb24gZm9yIHRocm93LCBlbHNlIGp1c3QgYWRkIHdoYXRldmVyIGlzIGxlZnRcblxuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdERlcHRoID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5wdXQgZGVwdGggZXhjZWVkZWQgZGVwdGggb3B0aW9uIG9mICcgKyBvcHRpb25zLmRlcHRoICsgJyBhbmQgc3RyaWN0RGVwdGggaXMgdHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaCgnWycgKyBrZXkuc2xpY2Uoc2VnbWVudC5pbmRleCkgKyAnXScpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCk7XG59O1xuXG52YXIgbm9ybWFsaXplUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5hbGxvd0VtcHR5QXJyYXlzICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYGFsbG93RW1wdHlBcnJheXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5kZWNvZGVEb3RJbktleXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLmRlY29kZURvdEluS2V5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BkZWNvZGVEb3RJbktleXNgIG9wdGlvbiBjYW4gb25seSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYCwgd2hlbiBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNoYXJzZXQgb3B0aW9uIG11c3QgYmUgZWl0aGVyIHV0Zi04LCBpc28tODg1OS0xLCBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMudGhyb3dPbkxpbWl0RXhjZWVkZWQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRzLnRocm93T25MaW1pdEV4Y2VlZGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHRocm93T25MaW1pdEV4Y2VlZGVkYCBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhcnNldCA9IHR5cGVvZiBvcHRzLmNoYXJzZXQgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuY2hhcnNldCA6IG9wdHMuY2hhcnNldDtcblxuICAgIHZhciBkdXBsaWNhdGVzID0gdHlwZW9mIG9wdHMuZHVwbGljYXRlcyA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kdXBsaWNhdGVzIDogb3B0cy5kdXBsaWNhdGVzO1xuXG4gICAgaWYgKGR1cGxpY2F0ZXMgIT09ICdjb21iaW5lJyAmJiBkdXBsaWNhdGVzICE9PSAnZmlyc3QnICYmIGR1cGxpY2F0ZXMgIT09ICdsYXN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZHVwbGljYXRlcyBvcHRpb24gbXVzdCBiZSBlaXRoZXIgY29tYmluZSwgZmlyc3QsIG9yIGxhc3QnKTtcbiAgICB9XG5cbiAgICB2YXIgYWxsb3dEb3RzID0gdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IG9wdHMuZGVjb2RlRG90SW5LZXlzID09PSB0cnVlID8gdHJ1ZSA6IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxvd0RvdHM6IGFsbG93RG90cyxcbiAgICAgICAgYWxsb3dFbXB0eUFycmF5czogdHlwZW9mIG9wdHMuYWxsb3dFbXB0eUFycmF5cyA9PT0gJ2Jvb2xlYW4nID8gISFvcHRzLmFsbG93RW1wdHlBcnJheXMgOiBkZWZhdWx0cy5hbGxvd0VtcHR5QXJyYXlzLFxuICAgICAgICBhbGxvd1Byb3RvdHlwZXM6IHR5cGVvZiBvcHRzLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXMsXG4gICAgICAgIGFsbG93U3BhcnNlOiB0eXBlb2Ygb3B0cy5hbGxvd1NwYXJzZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1NwYXJzZSA6IGRlZmF1bHRzLmFsbG93U3BhcnNlLFxuICAgICAgICBhcnJheUxpbWl0OiB0eXBlb2Ygb3B0cy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMuYXJyYXlMaW1pdCA6IGRlZmF1bHRzLmFycmF5TGltaXQsXG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcbiAgICAgICAgY29tbWE6IHR5cGVvZiBvcHRzLmNvbW1hID09PSAnYm9vbGVhbicgPyBvcHRzLmNvbW1hIDogZGVmYXVsdHMuY29tbWEsXG4gICAgICAgIGRlY29kZURvdEluS2V5czogdHlwZW9mIG9wdHMuZGVjb2RlRG90SW5LZXlzID09PSAnYm9vbGVhbicgPyBvcHRzLmRlY29kZURvdEluS2V5cyA6IGRlZmF1bHRzLmRlY29kZURvdEluS2V5cyxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXG4gICAgICAgIGRlbGltaXRlcjogdHlwZW9mIG9wdHMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRzLmRlbGltaXRlcikgPyBvcHRzLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcixcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uLCBuby1leHRyYS1wYXJlbnNcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcbiAgICAgICAgZHVwbGljYXRlczogZHVwbGljYXRlcyxcbiAgICAgICAgaWdub3JlUXVlcnlQcmVmaXg6IG9wdHMuaWdub3JlUXVlcnlQcmVmaXggPT09IHRydWUsXG4gICAgICAgIGludGVycHJldE51bWVyaWNFbnRpdGllczogdHlwZW9mIG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzID09PSAnYm9vbGVhbicgPyBvcHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyA6IGRlZmF1bHRzLmludGVycHJldE51bWVyaWNFbnRpdGllcyxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcbiAgICAgICAgcGFyc2VBcnJheXM6IG9wdHMucGFyc2VBcnJheXMgIT09IGZhbHNlLFxuICAgICAgICBwbGFpbk9iamVjdHM6IHR5cGVvZiBvcHRzLnBsYWluT2JqZWN0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5wbGFpbk9iamVjdHMgOiBkZWZhdWx0cy5wbGFpbk9iamVjdHMsXG4gICAgICAgIHN0cmljdERlcHRoOiB0eXBlb2Ygb3B0cy5zdHJpY3REZXB0aCA9PT0gJ2Jvb2xlYW4nID8gISFvcHRzLnN0cmljdERlcHRoIDogZGVmYXVsdHMuc3RyaWN0RGVwdGgsXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgdGhyb3dPbkxpbWl0RXhjZWVkZWQ6IHR5cGVvZiBvcHRzLnRocm93T25MaW1pdEV4Y2VlZGVkID09PSAnYm9vbGVhbicgPyBvcHRzLnRocm93T25MaW1pdEV4Y2VlZGVkIDogZmFsc2VcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVQYXJzZU9wdGlvbnMob3B0cyk7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8geyBfX3Byb3RvX186IG51bGwgfSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IHsgX19wcm90b19fOiBudWxsIH0gOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG4gICAgICAgIG9iaiA9IHV0aWxzLm1lcmdlKG9iaiwgbmV3T2JqLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd1NwYXJzZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiLypcbiAqIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbiAqIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuICogZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbiAqIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuICogREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4gKiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4gKiBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUvJyk7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8qXG4gKiBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuICogY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG4gKi9cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW14/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gIC8qXG4gICAqIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAqIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAqL1xuICBkZWxpbXMgPSBbXG4gICAgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXG4gIF0sXG5cbiAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgdW53aXNlID0gW1xuICAgICd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCdcbiAgXS5jb25jYXQoZGVsaW1zKSxcblxuICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAvKlxuICAgKiBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgKiBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAqIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgKiB0aGVtLlxuICAgKi9cbiAgbm9uSG9zdENoYXJzID0gW1xuICAgICclJywgJy8nLCAnPycsICc7JywgJyMnXG4gIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICBob3N0RW5kaW5nQ2hhcnMgPSBbXG4gICAgJy8nLCAnPycsICcjJ1xuICBdLFxuICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICBqYXZhc2NyaXB0OiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgfSxcbiAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgIGphdmFzY3JpcHQ6IHRydWUsXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICB9LFxuICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgIGh0dHA6IHRydWUsXG4gICAgaHR0cHM6IHRydWUsXG4gICAgZnRwOiB0cnVlLFxuICAgIGdvcGhlcjogdHJ1ZSxcbiAgICBmaWxlOiB0cnVlLFxuICAgICdodHRwOic6IHRydWUsXG4gICAgJ2h0dHBzOic6IHRydWUsXG4gICAgJ2Z0cDonOiB0cnVlLFxuICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAnZmlsZTonOiB0cnVlXG4gIH0sXG4gIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXMnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHR5cGVvZiB1cmwgPT09ICdvYmplY3QnICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8qXG4gICAqIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAgKiBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgICogU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgICovXG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICBzcGxpdHRlciA9IHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpID8gJz8nIDogJyMnLFxuICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvKlxuICAgKiB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgKiBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gICAqL1xuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLypcbiAgICogZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgICogdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAgKiByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gICAqIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICAgKi9cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkAvXStAW15AL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiYgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8qXG4gICAgICogdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgICAqIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgICpcbiAgICAgKiBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgICogdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAgKiBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgICAqIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAgKlxuICAgICAqIGV4OlxuICAgICAqIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgICogaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuICAgICAqL1xuXG4gICAgLypcbiAgICAgKiB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgICogUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cbiAgICAgKi9cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHsgaG9zdEVuZCA9IGhlYzsgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgICogYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgICovXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qXG4gICAgICAgKiBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAgKiBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgICovXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAgKiBQdWxsIHRoYXQgb2ZmLlxuICAgICAqL1xuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7IGhvc3RFbmQgPSBoZWM7IH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkgeyBob3N0RW5kID0gcmVzdC5sZW5ndGg7IH1cblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvKlxuICAgICAqIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgICogc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICAgKi9cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8qXG4gICAgICogaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAgKiBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICAgKi9cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgKiB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICogd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAgKiBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8qXG4gICAgICAgKiBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgICAqIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgICAqIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgICAqIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvKlxuICAgICAqIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAgKiB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgICAqL1xuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgICogY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICAgKi9cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLypcbiAgICAgKiBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgICogZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgICogbmVlZCB0byBiZS5cbiAgICAgKi9cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKSB7IGNvbnRpbnVlOyB9XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgeyB0aGlzLnBhdGhuYW1lID0gcmVzdDsgfVxuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLypcbiAgICogZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgICogSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgICogdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAgKiB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICAgKi9cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7IG9iaiA9IHVybFBhcnNlKG9iaik7IH1cbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgeyByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopOyB9XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICBob3N0ID0gZmFsc2UsXG4gICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/IHRoaXMuaG9zdG5hbWUgOiAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJiB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSwge1xuICAgICAgYXJyYXlGb3JtYXQ6ICdyZXBlYXQnLFxuICAgICAgYWRkUXVlcnlQcmVmaXg6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHsgcHJvdG9jb2wgKz0gJzonOyB9XG5cbiAgLypcbiAgICogb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gICAqIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gICAqL1xuICBpZiAodGhpcy5zbGFzaGVzIHx8ICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHsgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTsgfVxuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgeyBoYXNoID0gJyMnICsgaGFzaDsgfVxuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgeyBzZWFyY2ggPSAnPycgKyBzZWFyY2g7IH1cblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuIHJlbGF0aXZlOyB9XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gIGlmICh0eXBlb2YgcmVsYXRpdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8qXG4gICAqIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAgKiBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICovXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKSB7IHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldOyB9XG4gICAgfVxuXG4gICAgLy8gdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZTtcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvKlxuICAgICAqIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgKiB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgKiBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAgKiBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAqIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAgKiBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgICAqIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgICAqIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgKi9cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkgeyB9XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHsgcmVsYXRpdmUuaG9zdCA9ICcnOyB9XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSB7IHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7IH1cbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgeyByZWxQYXRoLnVuc2hpZnQoJycpOyB9XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSB7IHJlbFBhdGgudW5zaGlmdCgnJyk7IH1cbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICBpc1JlbEFicyA9IHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsXG4gICAgbXVzdEVuZEFicyA9IGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8IChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSksXG4gICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8qXG4gICAqIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICogbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAgKiB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAqIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAqIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICAgKi9cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgeyBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7IH0gZWxzZSB7IHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7IH1cbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSB7IHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0OyB9IGVsc2UgeyByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7IH1cbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycgPyByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnID8gcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8qXG4gICAgICogaXQncyByZWxhdGl2ZVxuICAgICAqIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGlmICghc3JjUGF0aCkgeyBzcmNQYXRoID0gW107IH1cbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKHJlbGF0aXZlLnNlYXJjaCAhPSBudWxsKSB7XG4gICAgLypcbiAgICAgKiBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICogbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAgKiBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICAgKi9cbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0O1xuICAgICAgLypcbiAgICAgICAqIG9jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgKiB0aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgKiB1cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgICAqL1xuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lICE9PSBudWxsIHx8IHJlc3VsdC5zZWFyY2ggIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvKlxuICAgICAqIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgKiB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgICAqL1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICAgKiBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICogaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gICAqIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAqL1xuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJztcblxuICAvKlxuICAgKiBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gICAqIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gICAqL1xuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiYgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHwgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IGlzQWJzb2x1dGUgPyAnJyA6IHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWU7XG4gICAgLypcbiAgICAgKiBvY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAqIHRoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgKiB1cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgKi9cbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWU7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoc3JjUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH1cblxuICAvLyB0byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAocmVzdWx0LnBhdGhuYW1lICE9PSBudWxsIHx8IHJlc3VsdC5zZWFyY2ggIT09IG51bGwpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5peGlmeSA9IGV4cG9ydHMuZ2V0V3JpdGVTeW5jQXJncyA9IGV4cG9ydHMuZ2V0V3JpdGVBcmdzID0gZXhwb3J0cy5idWZUb1VpbnQ4ID0gZXhwb3J0cy5pc1dpbiA9IHZvaWQgMDtcbmV4cG9ydHMucHJvbWlzaWZ5ID0gcHJvbWlzaWZ5O1xuZXhwb3J0cy52YWxpZGF0ZUNhbGxiYWNrID0gdmFsaWRhdGVDYWxsYmFjaztcbmV4cG9ydHMubW9kZVRvTnVtYmVyID0gbW9kZVRvTnVtYmVyO1xuZXhwb3J0cy5udWxsQ2hlY2sgPSBudWxsQ2hlY2s7XG5leHBvcnRzLnBhdGhUb0ZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWU7XG5leHBvcnRzLmNyZWF0ZUVycm9yID0gY3JlYXRlRXJyb3I7XG5leHBvcnRzLmdlblJuZFN0cjYgPSBnZW5SbmRTdHI2O1xuZXhwb3J0cy5mbGFnc1RvTnVtYmVyID0gZmxhZ3NUb051bWJlcjtcbmV4cG9ydHMuaXNGZCA9IGlzRmQ7XG5leHBvcnRzLnZhbGlkYXRlRmQgPSB2YWxpZGF0ZUZkO1xuZXhwb3J0cy5zdHJlYW1Ub0J1ZmZlciA9IHN0cmVhbVRvQnVmZmVyO1xuZXhwb3J0cy5kYXRhVG9CdWZmZXIgPSBkYXRhVG9CdWZmZXI7XG5leHBvcnRzLmJ1ZmZlclRvRW5jb2RpbmcgPSBidWZmZXJUb0VuY29kaW5nO1xuZXhwb3J0cy5pc1JlYWRhYmxlU3RyZWFtID0gaXNSZWFkYWJsZVN0cmVhbTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2Vycm9yc1wiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcIi4uL2ludGVybmFsL2J1ZmZlclwiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vZW5jb2RpbmdcIik7XG5jb25zdCBidWZmZXJfMiA9IHJlcXVpcmUoXCIuLi9pbnRlcm5hbC9idWZmZXJcIik7XG5jb25zdCBxdWV1ZU1pY3JvdGFza18xID0gcmVxdWlyZShcIi4uL3F1ZXVlTWljcm90YXNrXCIpO1xuZXhwb3J0cy5pc1dpbiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5mdW5jdGlvbiBwcm9taXNpZnkoZnMsIGZuLCBnZXRSZXN1bHQgPSBpbnB1dCA9PiBpbnB1dCkge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBmc1tmbl0uYmluZChmcykoLi4uYXJncywgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldFJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGNvbnN0YW50c18xLkVSUlNUUi5DQik7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gX21vZGVUb051bWJlcihtb2RlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gbW9kZTtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobW9kZSwgOCk7XG4gICAgaWYgKGRlZilcbiAgICAgICAgcmV0dXJuIG1vZGVUb051bWJlcihkZWYpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBtb2RlVG9OdW1iZXIobW9kZSwgZGVmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gX21vZGVUb051bWJlcihtb2RlLCBkZWYpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnbnVtYmVyJyB8fCBpc05hTihyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbnN0YW50c18xLkVSUlNUUi5NT0RFX0lOVCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG51bGxDaGVjayhwYXRoLCBjYWxsYmFjaykge1xuICAgIGlmICgoJycgKyBwYXRoKS5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGVyID0gbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcgd2l0aG91dCBudWxsIGJ5dGVzJyk7XG4gICAgICAgIGVyLmNvZGUgPSAnRU5PRU5UJztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IGVyO1xuICAgICAgICAoMCwgcXVldWVNaWNyb3Rhc2tfMS5kZWZhdWx0KSgoKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEZyb21VUkxQb3NpeCh1cmwpIHtcbiAgICBpZiAodXJsLmhvc3RuYW1lICE9PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlR5cGVFcnJvcignRVJSX0lOVkFMSURfRklMRV9VUkxfSE9TVCcsIHByb2Nlc3MucGxhdGZvcm0pO1xuICAgIH1cbiAgICBjb25zdCBwYXRobmFtZSA9IHVybC5wYXRobmFtZTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHBhdGhuYW1lLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGlmIChwYXRobmFtZVtuXSA9PT0gJyUnKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlyZCA9IHBhdGhuYW1lLmNvZGVQb2ludEF0KG4gKyAyKSB8IDB4MjA7XG4gICAgICAgICAgICBpZiAocGF0aG5hbWVbbiArIDFdID09PSAnMicgJiYgdGhpcmQgPT09IDEwMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuVHlwZUVycm9yKCdFUlJfSU5WQUxJRF9GSUxFX1VSTF9QQVRIJywgJ211c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCAvIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb0ZpbGVuYW1lKHBhdGgpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcGF0aCA9ICgwLCBidWZmZXJfMi5idWZmZXJGcm9tKShwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyAmJiAhYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgcmVxdWlyZSgndXJsJykuVVJMKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbnN0YW50c18xLkVSUlNUUi5QQVRIX1NUUik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb25zdGFudHNfMS5FUlJTVFIuUEFUSF9TVFIpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBnZXRQYXRoRnJvbVVSTFBvc2l4KHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoU3RyaW5nID0gU3RyaW5nKHBhdGgpO1xuICAgIG51bGxDaGVjayhwYXRoU3RyaW5nKTtcbiAgICAvLyByZXR1cm4gc2xhc2gocGF0aFN0cmluZyk7XG4gICAgcmV0dXJuIHBhdGhTdHJpbmc7XG59XG5jb25zdCBFTk9FTlQgPSAnRU5PRU5UJztcbmNvbnN0IEVCQURGID0gJ0VCQURGJztcbmNvbnN0IEVJTlZBTCA9ICdFSU5WQUwnO1xuY29uc3QgRVBFUk0gPSAnRVBFUk0nO1xuY29uc3QgRVBST1RPID0gJ0VQUk9UTyc7XG5jb25zdCBFRVhJU1QgPSAnRUVYSVNUJztcbmNvbnN0IEVOT1RESVIgPSAnRU5PVERJUic7XG5jb25zdCBFTUZJTEUgPSAnRU1GSUxFJztcbmNvbnN0IEVBQ0NFUyA9ICdFQUNDRVMnO1xuY29uc3QgRUlTRElSID0gJ0VJU0RJUic7XG5jb25zdCBFTk9URU1QVFkgPSAnRU5PVEVNUFRZJztcbmNvbnN0IEVOT1NZUyA9ICdFTk9TWVMnO1xuY29uc3QgRVJSX0ZTX0VJU0RJUiA9ICdFUlJfRlNfRUlTRElSJztcbmNvbnN0IEVSUl9PVVRfT0ZfUkFOR0UgPSAnRVJSX09VVF9PRl9SQU5HRSc7XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvckNvZGUsIGZ1bmMgPSAnJywgcGF0aCA9ICcnLCBwYXRoMiA9ICcnKSB7XG4gICAgbGV0IHBhdGhGb3JtYXR0ZWQgPSAnJztcbiAgICBpZiAocGF0aClcbiAgICAgICAgcGF0aEZvcm1hdHRlZCA9IGAgJyR7cGF0aH0nYDtcbiAgICBpZiAocGF0aDIpXG4gICAgICAgIHBhdGhGb3JtYXR0ZWQgKz0gYCAtPiAnJHtwYXRoMn0nYDtcbiAgICBzd2l0Y2ggKGVycm9yQ29kZSkge1xuICAgICAgICBjYXNlIEVOT0VOVDpcbiAgICAgICAgICAgIHJldHVybiBgRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5LCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRUJBREY6XG4gICAgICAgICAgICByZXR1cm4gYEVCQURGOiBiYWQgZmlsZSBkZXNjcmlwdG9yLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRUlOVkFMOlxuICAgICAgICAgICAgcmV0dXJuIGBFSU5WQUw6IGludmFsaWQgYXJndW1lbnQsICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFUEVSTTpcbiAgICAgICAgICAgIHJldHVybiBgRVBFUk06IG9wZXJhdGlvbiBub3QgcGVybWl0dGVkLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRVBST1RPOlxuICAgICAgICAgICAgcmV0dXJuIGBFUFJPVE86IHByb3RvY29sIGVycm9yLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRUVYSVNUOlxuICAgICAgICAgICAgcmV0dXJuIGBFRVhJU1Q6IGZpbGUgYWxyZWFkeSBleGlzdHMsICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFTk9URElSOlxuICAgICAgICAgICAgcmV0dXJuIGBFTk9URElSOiBub3QgYSBkaXJlY3RvcnksICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFSVNESVI6XG4gICAgICAgICAgICByZXR1cm4gYEVJU0RJUjogaWxsZWdhbCBvcGVyYXRpb24gb24gYSBkaXJlY3RvcnksICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFQUNDRVM6XG4gICAgICAgICAgICByZXR1cm4gYEVBQ0NFUzogcGVybWlzc2lvbiBkZW5pZWQsICR7ZnVuY30ke3BhdGhGb3JtYXR0ZWR9YDtcbiAgICAgICAgY2FzZSBFTk9URU1QVFk6XG4gICAgICAgICAgICByZXR1cm4gYEVOT1RFTVBUWTogZGlyZWN0b3J5IG5vdCBlbXB0eSwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVNRklMRTpcbiAgICAgICAgICAgIHJldHVybiBgRU1GSUxFOiB0b28gbWFueSBvcGVuIGZpbGVzLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgICAgIGNhc2UgRU5PU1lTOlxuICAgICAgICAgICAgcmV0dXJuIGBFTk9TWVM6IGZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZCwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBjYXNlIEVSUl9GU19FSVNESVI6XG4gICAgICAgICAgICByZXR1cm4gYFtFUlJfRlNfRUlTRElSXTogUGF0aCBpcyBhIGRpcmVjdG9yeTogJHtmdW5jfSByZXR1cm5lZCBFSVNESVIgKGlzIGEgZGlyZWN0b3J5KSAke3BhdGh9YDtcbiAgICAgICAgY2FzZSBFUlJfT1VUX09GX1JBTkdFOlxuICAgICAgICAgICAgcmV0dXJuIGBbRVJSX09VVF9PRl9SQU5HRV06IHZhbHVlIG91dCBvZiByYW5nZSwgJHtmdW5jfSR7cGF0aEZvcm1hdHRlZH1gO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGAke2Vycm9yQ29kZX06IGVycm9yIG9jY3VycmVkLCAke2Z1bmN9JHtwYXRoRm9ybWF0dGVkfWA7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRXJyb3IoZXJyb3JDb2RlLCBmdW5jID0gJycsIHBhdGggPSAnJywgcGF0aDIgPSAnJywgQ29uc3RydWN0b3IgPSBFcnJvcikge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IENvbnN0cnVjdG9yKGZvcm1hdEVycm9yKGVycm9yQ29kZSwgZnVuYywgcGF0aCwgcGF0aDIpKTtcbiAgICBlcnJvci5jb2RlID0gZXJyb3JDb2RlO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIGVycm9yLnBhdGggPSBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBnZW5SbmRTdHI2KCkge1xuICAgIGNvbnN0IHN0ciA9IChNYXRoLnJhbmRvbSgpICsgMSkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KTtcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNilcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBnZW5SbmRTdHI2KCk7XG59XG5mdW5jdGlvbiBmbGFnc1RvTnVtYmVyKGZsYWdzKSB7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICBpZiAodHlwZW9mIGZsYWdzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmbGFnc051bSA9IGNvbnN0YW50c18xLkZMQUdTW2ZsYWdzXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFnc051bSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gZmxhZ3NOdW07XG4gICAgfVxuICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoZm9ybWF0RXJyb3IoRVJSU1RSX0ZMQUcoZmxhZ3MpKSk7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UeXBlRXJyb3IoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsICdmbGFncycsIGZsYWdzKTtcbn1cbmZ1bmN0aW9uIGlzRmQocGF0aCkge1xuICAgIHJldHVybiBwYXRoID4+PiAwID09PSBwYXRoO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVGZChmZCkge1xuICAgIGlmICghaXNGZChmZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihjb25zdGFudHNfMS5FUlJTVFIuRkQpO1xufVxuZnVuY3Rpb24gc3RyZWFtVG9CdWZmZXIoc3RyZWFtKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4gY2h1bmtzLnB1c2goY2h1bmspKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoY2h1bmtzKSkpO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRhdGFUb0J1ZmZlcihkYXRhLCBlbmNvZGluZyA9IGVuY29kaW5nXzEuRU5DT0RJTkdfVVRGOCkge1xuICAgIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gKDAsIGJ1ZmZlcl8yLmJ1ZmZlckZyb20pKGRhdGEpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuICgwLCBidWZmZXJfMi5idWZmZXJGcm9tKShTdHJpbmcoZGF0YSksIGVuY29kaW5nKTtcbn1cbmNvbnN0IGJ1ZlRvVWludDggPSAoYnVmKSA9PiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5idWZUb1VpbnQ4ID0gYnVmVG9VaW50ODtcbmNvbnN0IGdldFdyaXRlQXJncyA9IChmZCwgYSwgYiwgYywgZCwgZSkgPT4ge1xuICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBsZW5ndGg7XG4gICAgbGV0IHBvc2l0aW9uID0gbnVsbDtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGNvbnN0IHRpcGEgPSB0eXBlb2YgYTtcbiAgICBjb25zdCB0aXBiID0gdHlwZW9mIGI7XG4gICAgY29uc3QgdGlwYyA9IHR5cGVvZiBjO1xuICAgIGNvbnN0IHRpcGQgPSB0eXBlb2YgZDtcbiAgICBpZiAodGlwYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRpcGIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aXBjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aXBkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGM7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGM7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGQ7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0aXBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGlwYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBiO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpcGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gYjtcbiAgICAgICAgICAgIGVuY29kaW5nID0gYztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBidWYgPSBkYXRhVG9CdWZmZXIoYSwgZW5jb2RpbmcpO1xuICAgIGlmICh0aXBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGVuZ3RoID0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgY2IgPSB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gW2ZkLCB0aXBhID09PSAnc3RyaW5nJywgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNiXTtcbn07XG5leHBvcnRzLmdldFdyaXRlQXJncyA9IGdldFdyaXRlQXJncztcbmNvbnN0IGdldFdyaXRlU3luY0FyZ3MgPSAoZmQsIGEsIGIsIGMsIGQpID0+IHtcbiAgICB2YWxpZGF0ZUZkKGZkKTtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgbGV0IG9mZnNldDtcbiAgICBsZXQgbGVuZ3RoO1xuICAgIGxldCBwb3NpdGlvbjtcbiAgICBjb25zdCBpc0J1ZmZlciA9IHR5cGVvZiBhICE9PSAnc3RyaW5nJztcbiAgICBpZiAoaXNCdWZmZXIpIHtcbiAgICAgICAgb2Zmc2V0ID0gKGIgfHwgMCkgfCAwO1xuICAgICAgICBsZW5ndGggPSBjO1xuICAgICAgICBwb3NpdGlvbiA9IGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3NpdGlvbiA9IGI7XG4gICAgICAgIGVuY29kaW5nID0gYztcbiAgICB9XG4gICAgY29uc3QgYnVmID0gZGF0YVRvQnVmZmVyKGEsIGVuY29kaW5nKTtcbiAgICBpZiAoaXNCdWZmZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gW2ZkLCBidWYsIG9mZnNldCB8fCAwLCBsZW5ndGgsIHBvc2l0aW9uXTtcbn07XG5leHBvcnRzLmdldFdyaXRlU3luY0FyZ3MgPSBnZXRXcml0ZVN5bmNBcmdzO1xuZnVuY3Rpb24gYnVmZmVyVG9FbmNvZGluZyhidWZmZXIsIGVuY29kaW5nKSB7XG4gICAgaWYgKCFlbmNvZGluZyB8fCBlbmNvZGluZyA9PT0gJ2J1ZmZlcicpXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSB7XG4gICAgcmV0dXJuIChzdHJlYW0gIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHN0cmVhbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHN0cmVhbS5waXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBzdHJlYW0ub24gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID09PSB0cnVlKTtcbn1cbmNvbnN0IGlzU2VwYXJhdG9yID0gKHN0ciwgaSkgPT4ge1xuICAgIGxldCBjaGFyID0gc3RyW2ldO1xuICAgIHJldHVybiBpID4gMCAmJiAoY2hhciA9PT0gJy8nIHx8IChleHBvcnRzLmlzV2luICYmIGNoYXIgPT09ICdcXFxcJykpO1xufTtcbmNvbnN0IHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yID0gKHN0cikgPT4ge1xuICAgIGxldCBpID0gc3RyLmxlbmd0aCAtIDE7XG4gICAgaWYgKGkgPCAyKVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIHdoaWxlIChpc1NlcGFyYXRvcihzdHIsIGkpKVxuICAgICAgICBpLS07XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaSArIDEpO1xufTtcbmNvbnN0IG5vcm1hbGl6ZVBhdGggPSAoc3RyLCBzdHJpcFRyYWlsaW5nKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcL10rL2csICcvJyk7XG4gICAgaWYgKHN0cmlwVHJhaWxpbmcgIT09IGZhbHNlKVxuICAgICAgICBzdHIgPSByZW1vdmVUcmFpbGluZ1NlcGFyYXRvcihzdHIpO1xuICAgIHJldHVybiBzdHI7XG59O1xuY29uc3QgdW5peGlmeSA9IChmaWxlcGF0aCwgc3RyaXBUcmFpbGluZyA9IHRydWUpID0+IHtcbiAgICBpZiAoZXhwb3J0cy5pc1dpbikge1xuICAgICAgICBmaWxlcGF0aCA9IG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIHN0cmlwVHJhaWxpbmcpO1xuICAgICAgICByZXR1cm4gZmlsZXBhdGgucmVwbGFjZSgvXihbYS16QS1aXSs6fFxcLlxcLykvLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcGF0aDtcbn07XG5leHBvcnRzLnVuaXhpZnkgPSB1bml4aWZ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmlsZUhhbmRsZSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jbGFzcyBGaWxlSGFuZGxlIHtcbiAgICBjb25zdHJ1Y3RvcihmcywgZmQpIHtcbiAgICAgICAgdGhpcy5mcyA9IGZzO1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgfVxuICAgIGFwcGVuZEZpbGUoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdhcHBlbmRGaWxlJykodGhpcy5mZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNobW9kKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnZmNobW9kJykodGhpcy5mZCwgbW9kZSk7XG4gICAgfVxuICAgIGNob3duKHVpZCwgZ2lkKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2ZjaG93bicpKHRoaXMuZmQsIHVpZCwgZ2lkKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2Nsb3NlJykodGhpcy5mZCk7XG4gICAgfVxuICAgIGRhdGFzeW5jKCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdmZGF0YXN5bmMnKSh0aGlzLmZkKTtcbiAgICB9XG4gICAgY3JlYXRlUmVhZFN0cmVhbShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZzLmNyZWF0ZVJlYWRTdHJlYW0oJycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZmQ6IHRoaXMgfSkpO1xuICAgIH1cbiAgICBjcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZzLmNyZWF0ZVdyaXRlU3RyZWFtKCcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZkOiB0aGlzIH0pKTtcbiAgICB9XG4gICAgcmVhZGFibGVXZWJTdHJlYW0ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHB1bGw6IGFzeW5jIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMucmVhZEZpbGUoKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlYWQoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAncmVhZCcsIGJ5dGVzUmVhZCA9PiAoeyBieXRlc1JlYWQsIGJ1ZmZlciB9KSkodGhpcy5mZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgIH1cbiAgICByZWFkdihidWZmZXJzLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdyZWFkdicsIGJ5dGVzUmVhZCA9PiAoeyBieXRlc1JlYWQsIGJ1ZmZlcnMgfSkpKHRoaXMuZmQsIGJ1ZmZlcnMsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmVhZEZpbGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdyZWFkRmlsZScpKHRoaXMuZmQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnZnN0YXQnKSh0aGlzLmZkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnZnN5bmMnKSh0aGlzLmZkKTtcbiAgICB9XG4gICAgdHJ1bmNhdGUobGVuKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2Z0cnVuY2F0ZScpKHRoaXMuZmQsIGxlbik7XG4gICAgfVxuICAgIHV0aW1lcyhhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnZnV0aW1lcycpKHRoaXMuZmQsIGF0aW1lLCBtdGltZSk7XG4gICAgfVxuICAgIHdyaXRlKGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3dyaXRlJywgYnl0ZXNXcml0dGVuID0+ICh7IGJ5dGVzV3JpdHRlbiwgYnVmZmVyIH0pKSh0aGlzLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIHdyaXRldihidWZmZXJzLCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICd3cml0ZXYnLCBieXRlc1dyaXR0ZW4gPT4gKHsgYnl0ZXNXcml0dGVuLCBidWZmZXJzIH0pKSh0aGlzLmZkLCBidWZmZXJzLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIHdyaXRlRmlsZShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3dyaXRlRmlsZScpKHRoaXMuZmQsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsZUhhbmRsZSA9IEZpbGVIYW5kbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlSGFuZGxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Gc1Byb21pc2VzID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNsYXNzIEZzUHJvbWlzZXMge1xuICAgIGNvbnN0cnVjdG9yKGZzLCBGaWxlSGFuZGxlKSB7XG4gICAgICAgIHRoaXMuZnMgPSBmcztcbiAgICAgICAgdGhpcy5GaWxlSGFuZGxlID0gRmlsZUhhbmRsZTtcbiAgICAgICAgdGhpcy5jb25zdGFudHMgPSBjb25zdGFudHNfMS5jb25zdGFudHM7XG4gICAgICAgIHRoaXMuY3AgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2NwJyk7XG4gICAgICAgIHRoaXMub3BlbmRpciA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnb3BlbmRpcicpO1xuICAgICAgICB0aGlzLnN0YXRmcyA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnc3RhdGZzJyk7XG4gICAgICAgIHRoaXMubHV0aW1lcyA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnbHV0aW1lcycpO1xuICAgICAgICB0aGlzLmFjY2VzcyA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnYWNjZXNzJyk7XG4gICAgICAgIHRoaXMuY2htb2QgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2NobW9kJyk7XG4gICAgICAgIHRoaXMuY2hvd24gPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2Nob3duJyk7XG4gICAgICAgIHRoaXMuY29weUZpbGUgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2NvcHlGaWxlJyk7XG4gICAgICAgIHRoaXMubGNobW9kID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdsY2htb2QnKTtcbiAgICAgICAgdGhpcy5sY2hvd24gPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2xjaG93bicpO1xuICAgICAgICB0aGlzLmxpbmsgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2xpbmsnKTtcbiAgICAgICAgdGhpcy5sc3RhdCA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnbHN0YXQnKTtcbiAgICAgICAgdGhpcy5ta2RpciA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnbWtkaXInKTtcbiAgICAgICAgdGhpcy5ta2R0ZW1wID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdta2R0ZW1wJyk7XG4gICAgICAgIHRoaXMucmVhZGRpciA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAncmVhZGRpcicpO1xuICAgICAgICB0aGlzLnJlYWRsaW5rID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdyZWFkbGluaycpO1xuICAgICAgICB0aGlzLnJlYWxwYXRoID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKHRoaXMuZnMsICdyZWFscGF0aCcpO1xuICAgICAgICB0aGlzLnJlbmFtZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAncmVuYW1lJyk7XG4gICAgICAgIHRoaXMucm1kaXIgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3JtZGlyJyk7XG4gICAgICAgIHRoaXMucm0gPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3JtJyk7XG4gICAgICAgIHRoaXMuc3RhdCA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnc3RhdCcpO1xuICAgICAgICB0aGlzLnN5bWxpbmsgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3N5bWxpbmsnKTtcbiAgICAgICAgdGhpcy50cnVuY2F0ZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAndHJ1bmNhdGUnKTtcbiAgICAgICAgdGhpcy51bmxpbmsgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3VubGluaycpO1xuICAgICAgICB0aGlzLnV0aW1lcyA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAndXRpbWVzJyk7XG4gICAgICAgIHRoaXMucmVhZEZpbGUgPSAoaWQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ3JlYWRGaWxlJykoaWQgaW5zdGFuY2VvZiB0aGlzLkZpbGVIYW5kbGUgPyBpZC5mZCA6IGlkLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBlbmRGaWxlID0gKHBhdGgsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ2FwcGVuZEZpbGUnKShwYXRoIGluc3RhbmNlb2YgdGhpcy5GaWxlSGFuZGxlID8gcGF0aC5mZCA6IHBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wZW4gPSAocGF0aCwgZmxhZ3MgPSAncicsIG1vZGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnByb21pc2lmeSkodGhpcy5mcywgJ29wZW4nLCBmZCA9PiBuZXcgdGhpcy5GaWxlSGFuZGxlKHRoaXMuZnMsIGZkKSkocGF0aCwgZmxhZ3MsIG1vZGUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndyaXRlRmlsZSA9IChpZCwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YVByb21pc2UgPSAoMCwgdXRpbF8xLmlzUmVhZGFibGVTdHJlYW0pKGRhdGEpID8gKDAsIHV0aWxfMS5zdHJlYW1Ub0J1ZmZlcikoZGF0YSkgOiBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVByb21pc2UudGhlbihkYXRhID0+ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSh0aGlzLmZzLCAnd3JpdGVGaWxlJykoaWQgaW5zdGFuY2VvZiB0aGlzLkZpbGVIYW5kbGUgPyBpZC5mZCA6IGlkLCBkYXRhLCBvcHRpb25zKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2F0Y2ggPSAoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRnNQcm9taXNlcyA9IEZzUHJvbWlzZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gc1Byb21pc2VzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKTtcbiAgcmV0dXJuIGcubmV4dCA9IHZlcmIoMCksIGdbXCJ0aHJvd1wiXSA9IHZlcmIoMSksIGdbXCJyZXR1cm5cIl0gPSB2ZXJiKDIpLCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG52YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICByZXR1cm4gYXI7XG4gIH07XG4gIHJldHVybiBvd25LZXlzKG8pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZSwgaW5uZXI7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgICBpZiAoYXN5bmMpIGlubmVyID0gZGlzcG9zZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGlmIChpbm5lcikgZGlzcG9zZSA9IGZ1bmN0aW9uKCkgeyB0cnkgeyBpbm5lci5jYWxsKHRoaXMpOyB9IGNhdGNoIChlKSB7IHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgfSB9O1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICB2YXIgciwgcyA9IDA7XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKHIgPSBlbnYuc3RhY2sucG9wKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghci5hc3luYyAmJiBzID09PSAxKSByZXR1cm4gcyA9IDAsIGVudi5zdGFjay5wdXNoKHIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICBpZiAoci5kaXNwb3NlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHIuZGlzcG9zZS5jYWxsKHIudmFsdWUpO1xuICAgICAgICAgIGlmIChyLmFzeW5jKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBzIHw9IDE7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA9PT0gMSkgcmV0dXJuIGVudi5oYXNFcnJvciA/IFByb21pc2UucmVqZWN0KGVudi5lcnJvcikgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uKHBhdGgsIHByZXNlcnZlSnN4KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLlxcLj9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLih0c3gpJHwoKD86XFwuZCk/KSgoPzpcXC5bXi4vXSs/KT8pXFwuKFtjbV0/KXRzJC9pLCBmdW5jdGlvbiAobSwgdHN4LCBkLCBleHQsIGNtKSB7XG4gICAgICAgICAgcmV0dXJuIHRzeCA/IHByZXNlcnZlSnN4ID8gXCIuanN4XCIgOiBcIi5qc1wiIDogZCAmJiAoIWV4dCB8fCAhY20pID8gbSA6IChkICsgZXh0ICsgXCIuXCIgKyBjbS50b0xvd2VyQ2FzZSgpICsgXCJqc1wiKTtcbiAgICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19lc0RlY29yYXRlLFxuICBfX3J1bkluaXRpYWxpemVycyxcbiAgX19wcm9wS2V5LFxuICBfX3NldEZ1bmN0aW9uTmFtZSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG4gIF9fcmV3cml0ZVJlbGF0aXZlSW1wb3J0RXh0ZW5zaW9uLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmludFRyZWUgPSB2b2lkIDA7XG5jb25zdCBwcmludFRyZWUgPSAodGFiID0gJycsIGNoaWxkcmVuKSA9PiB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBsYXN0ID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pXG4gICAgICAgIGlmIChjaGlsZHJlbltsYXN0XSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3Q7IGkrKykge1xuICAgICAgICBjb25zdCBmbiA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoIWZuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IGxhc3Q7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gZm4odGFiICsgKGlzTGFzdCA/ICcgJyA6ICfilIInKSArICcgICcpO1xuICAgICAgICBjb25zdCBicmFuY2ggPSBjaGlsZCA/IChpc0xhc3QgPyAn4pSU4pSAJyA6ICfilJzilIAnKSA6ICfilIInO1xuICAgICAgICBzdHIgKz0gJ1xcbicgKyB0YWIgKyBicmFuY2ggKyAoY2hpbGQgPyAnICcgKyBjaGlsZCA6ICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5leHBvcnRzLnByaW50VHJlZSA9IHByaW50VHJlZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmludEJpbmFyeSA9IHZvaWQgMDtcbmNvbnN0IHByaW50QmluYXJ5ID0gKHRhYiA9ICcnLCBjaGlsZHJlbikgPT4ge1xuICAgIGNvbnN0IGxlZnQgPSBjaGlsZHJlblswXSwgcmlnaHQgPSBjaGlsZHJlblsxXTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgaWYgKGxlZnQpXG4gICAgICAgIHN0ciArPSAnXFxuJyArIHRhYiArICfihpAgJyArIGxlZnQodGFiICsgJyAgJyk7XG4gICAgaWYgKHJpZ2h0KVxuICAgICAgICBzdHIgKz0gJ1xcbicgKyB0YWIgKyAn4oaSICcgKyByaWdodCh0YWIgKyAnICAnKTtcbiAgICByZXR1cm4gc3RyO1xufTtcbmV4cG9ydHMucHJpbnRCaW5hcnkgPSBwcmludEJpbmFyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ByaW50VHJlZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcmludEJpbmFyeVwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3Tm90QWxsb3dlZEVycm9yID0gZXhwb3J0cy5uZXdUeXBlTWlzbWF0Y2hFcnJvciA9IGV4cG9ydHMubmV3Tm90Rm91bmRFcnJvciA9IGV4cG9ydHMuYXNzZXJ0Q2FuV3JpdGUgPSBleHBvcnRzLmFzc2VydE5hbWUgPSBleHBvcnRzLmJhc2VuYW1lID0gZXhwb3J0cy5jdHggPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIE5vZGVGc2FDb250ZXh0fS5cbiAqL1xuY29uc3QgY3R4ID0gKHBhcnRpYWwgPSB7fSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgc2VwYXJhdG9yOiAnLycsIHN5bmNIYW5kbGVBbGxvd2VkOiBmYWxzZSwgbW9kZTogJ3JlYWQnIH0sIHBhcnRpYWwpO1xufTtcbmV4cG9ydHMuY3R4ID0gY3R4O1xuY29uc3QgYmFzZW5hbWUgPSAocGF0aCwgc2VwYXJhdG9yKSA9PiB7XG4gICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gc2VwYXJhdG9yKVxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgY29uc3QgbGFzdFNsYXNoSW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgcmV0dXJuIGxhc3RTbGFzaEluZGV4ID09PSAtMSA/IHBhdGggOiBwYXRoLnNsaWNlKGxhc3RTbGFzaEluZGV4ICsgMSk7XG59O1xuZXhwb3J0cy5iYXNlbmFtZSA9IGJhc2VuYW1lO1xuY29uc3QgbmFtZVJlZ2V4ID0gL14oXFwuezEsMn0pJHxeKC4qKFtcXC9cXFxcXSkuKikkLztcbmNvbnN0IGFzc2VydE5hbWUgPSAobmFtZSwgbWV0aG9kLCBrbGFzcykgPT4ge1xuICAgIGNvbnN0IGlzSW52YWxpZCA9ICFuYW1lIHx8IG5hbWVSZWdleC50ZXN0KG5hbWUpO1xuICAgIGlmIChpc0ludmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZH0nIG9uICcke2tsYXNzfSc6IE5hbWUgaXMgbm90IGFsbG93ZWQuYCk7XG59O1xuZXhwb3J0cy5hc3NlcnROYW1lID0gYXNzZXJ0TmFtZTtcbmNvbnN0IGFzc2VydENhbldyaXRlID0gKG1vZGUpID0+IHtcbiAgICBpZiAobW9kZSAhPT0gJ3JlYWR3cml0ZScpXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSByZXF1ZXN0IGlzIG5vdCBhbGxvd2VkIGJ5IHRoZSB1c2VyIGFnZW50IG9yIHRoZSBwbGF0Zm9ybSBpbiB0aGUgY3VycmVudCBjb250ZXh0LicsICdOb3RBbGxvd2VkRXJyb3InKTtcbn07XG5leHBvcnRzLmFzc2VydENhbldyaXRlID0gYXNzZXJ0Q2FuV3JpdGU7XG5jb25zdCBuZXdOb3RGb3VuZEVycm9yID0gKCkgPT4gbmV3IERPTUV4Y2VwdGlvbignQSByZXF1ZXN0ZWQgZmlsZSBvciBkaXJlY3RvcnkgY291bGQgbm90IGJlIGZvdW5kIGF0IHRoZSB0aW1lIGFuIG9wZXJhdGlvbiB3YXMgcHJvY2Vzc2VkLicsICdOb3RGb3VuZEVycm9yJyk7XG5leHBvcnRzLm5ld05vdEZvdW5kRXJyb3IgPSBuZXdOb3RGb3VuZEVycm9yO1xuY29uc3QgbmV3VHlwZU1pc21hdGNoRXJyb3IgPSAoKSA9PiBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgcGF0aCBzdXBwbGllZCBleGlzdHMsIGJ1dCB3YXMgbm90IGFuIGVudHJ5IG9mIHJlcXVlc3RlZCB0eXBlLicsICdUeXBlTWlzbWF0Y2hFcnJvcicpO1xuZXhwb3J0cy5uZXdUeXBlTWlzbWF0Y2hFcnJvciA9IG5ld1R5cGVNaXNtYXRjaEVycm9yO1xuY29uc3QgbmV3Tm90QWxsb3dlZEVycm9yID0gKCkgPT4gbmV3IERPTUV4Y2VwdGlvbignUGVybWlzc2lvbiBub3QgZ3JhbnRlZC4nLCAnTm90QWxsb3dlZEVycm9yJyk7XG5leHBvcnRzLm5ld05vdEFsbG93ZWRFcnJvciA9IG5ld05vdEFsbG93ZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvVHJlZVN5bmMgPSB2b2lkIDA7XG5jb25zdCB0cmVlX2R1bXBfMSA9IHJlcXVpcmUoXCJ0cmVlLWR1bXBcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vbm9kZS10by1mc2EvdXRpbFwiKTtcbmNvbnN0IHRvVHJlZVN5bmMgPSAoZnMsIG9wdHMgPSB7fSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBvcHRzLnNlcGFyYXRvciB8fCAnLyc7XG4gICAgbGV0IGRpciA9IG9wdHMuZGlyIHx8IHNlcGFyYXRvcjtcbiAgICBpZiAoZGlyW2Rpci5sZW5ndGggLSAxXSAhPT0gc2VwYXJhdG9yKVxuICAgICAgICBkaXIgKz0gc2VwYXJhdG9yO1xuICAgIGNvbnN0IHRhYiA9IG9wdHMudGFiIHx8ICcnO1xuICAgIGNvbnN0IGRlcHRoID0gKF9hID0gb3B0cy5kZXB0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTA7XG4gICAgbGV0IHN1YnRyZWUgPSAnICguLi4pJztcbiAgICBpZiAoZGVwdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBmcy5yZWFkZGlyU3luYyhkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcbiAgICAgICAgc3VidHJlZSA9ICgwLCB0cmVlX2R1bXBfMS5wcmludFRyZWUpKHRhYiwgbGlzdC5tYXAoZW50cnkgPT4gdGFiID0+IHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLnRvVHJlZVN5bmMpKGZzLCB7IGRpcjogZGlyICsgZW50cnkubmFtZSwgZGVwdGg6IGRlcHRoIC0gMSwgdGFiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJyArIGVudHJ5Lm5hbWUgKyAnIOKGkiAnICsgZnMucmVhZGxpbmtTeW5jKGRpciArIGVudHJ5Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnICsgZW50cnkubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlID0gKDAsIHV0aWxfMS5iYXNlbmFtZSkoZGlyLCBzZXBhcmF0b3IpICsgc2VwYXJhdG9yO1xuICAgIHJldHVybiBiYXNlICsgc3VidHJlZTtcbn07XG5leHBvcnRzLnRvVHJlZVN5bmMgPSB0b1RyZWVTeW5jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFdyaXRlRmlsZU9wdGlvbnMgPSBleHBvcnRzLndyaXRlRmlsZURlZmF1bHRzID0gZXhwb3J0cy5nZXRSZWFscGF0aE9wdHNBbmRDYiA9IGV4cG9ydHMuZ2V0UmVhbHBhdGhPcHRpb25zID0gZXhwb3J0cy5nZXRTdGF0T3B0c0FuZENiID0gZXhwb3J0cy5nZXRTdGF0T3B0aW9ucyA9IGV4cG9ydHMuZ2V0QXBwZW5kRmlsZU9wdHNBbmRDYiA9IGV4cG9ydHMuZ2V0QXBwZW5kRmlsZU9wdHMgPSBleHBvcnRzLmdldE9wZW5kaXJPcHRzQW5kQ2IgPSBleHBvcnRzLmdldE9wZW5kaXJPcHRpb25zID0gZXhwb3J0cy5nZXRSZWFkZGlyT3B0c0FuZENiID0gZXhwb3J0cy5nZXRSZWFkZGlyT3B0aW9ucyA9IGV4cG9ydHMuZ2V0UmVhZEZpbGVPcHRpb25zID0gZXhwb3J0cy5nZXRSbU9wdHNBbmRDYiA9IGV4cG9ydHMuZ2V0Um1kaXJPcHRpb25zID0gZXhwb3J0cy5nZXREZWZhdWx0T3B0c0FuZENiID0gZXhwb3J0cy5nZXREZWZhdWx0T3B0cyA9IGV4cG9ydHMub3B0c0RlZmF1bHRzID0gZXhwb3J0cy5nZXRNa2Rpck9wdGlvbnMgPSB2b2lkIDA7XG5leHBvcnRzLmdldE9wdGlvbnMgPSBnZXRPcHRpb25zO1xuZXhwb3J0cy5vcHRzR2VuZXJhdG9yID0gb3B0c0dlbmVyYXRvcjtcbmV4cG9ydHMub3B0c0FuZENiR2VuZXJhdG9yID0gb3B0c0FuZENiR2VuZXJhdG9yO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL2VuY29kaW5nXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IG1rZGlyRGVmYXVsdHMgPSB7XG4gICAgbW9kZTogNTExIC8qIE1PREUuRElSICovLFxuICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG59O1xuY29uc3QgZ2V0TWtkaXJPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWtkaXJEZWZhdWx0cywgeyBtb2RlOiBvcHRpb25zIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBta2RpckRlZmF1bHRzLCBvcHRpb25zKTtcbn07XG5leHBvcnRzLmdldE1rZGlyT3B0aW9ucyA9IGdldE1rZGlyT3B0aW9ucztcbmNvbnN0IEVSUlNUUl9PUFRTID0gdGlwZW9mID0+IGBFeHBlY3RlZCBvcHRpb25zIHRvIGJlIGVpdGhlciBhbiBvYmplY3Qgb3IgYSBzdHJpbmcsIGJ1dCBnb3QgJHt0aXBlb2Z9IGluc3RlYWRgO1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucykge1xuICAgIGxldCBvcHRzO1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0aXBlb2YgPSB0eXBlb2Ygb3B0aW9ucztcbiAgICAgICAgc3dpdGNoICh0aXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSX09QVFModGlwZW9mKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICdidWZmZXInKVxuICAgICAgICAoMCwgZW5jb2RpbmdfMS5hc3NlcnRFbmNvZGluZykob3B0cy5lbmNvZGluZyk7XG4gICAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBvcHRzR2VuZXJhdG9yKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT4gZ2V0T3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0T3B0cykge1xuICAgIHJldHVybiAob3B0aW9ucywgY2FsbGJhY2spID0+IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gW2dldE9wdHMoKSwgb3B0aW9uc10gOiBbZ2V0T3B0cyhvcHRpb25zKSwgKDAsIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKShjYWxsYmFjayldO1xufVxuZXhwb3J0cy5vcHRzRGVmYXVsdHMgPSB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4Jyxcbn07XG5leHBvcnRzLmdldERlZmF1bHRPcHRzID0gb3B0c0dlbmVyYXRvcihleHBvcnRzLm9wdHNEZWZhdWx0cyk7XG5leHBvcnRzLmdldERlZmF1bHRPcHRzQW5kQ2IgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZXhwb3J0cy5nZXREZWZhdWx0T3B0cyk7XG5jb25zdCBybWRpckRlZmF1bHRzID0ge1xuICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG59O1xuY29uc3QgZ2V0Um1kaXJPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcm1kaXJEZWZhdWx0cywgb3B0aW9ucyk7XG59O1xuZXhwb3J0cy5nZXRSbWRpck9wdGlvbnMgPSBnZXRSbWRpck9wdGlvbnM7XG5jb25zdCBnZXRSbU9wdHMgPSBvcHRzR2VuZXJhdG9yKGV4cG9ydHMub3B0c0RlZmF1bHRzKTtcbmV4cG9ydHMuZ2V0Um1PcHRzQW5kQ2IgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0Um1PcHRzKTtcbmNvbnN0IHJlYWRGaWxlT3B0c0RlZmF1bHRzID0ge1xuICAgIGZsYWc6ICdyJyxcbn07XG5leHBvcnRzLmdldFJlYWRGaWxlT3B0aW9ucyA9IG9wdHNHZW5lcmF0b3IocmVhZEZpbGVPcHRzRGVmYXVsdHMpO1xuY29uc3QgcmVhZGRpckRlZmF1bHRzID0ge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgcmVjdXJzaXZlOiBmYWxzZSxcbiAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZSxcbn07XG5leHBvcnRzLmdldFJlYWRkaXJPcHRpb25zID0gb3B0c0dlbmVyYXRvcihyZWFkZGlyRGVmYXVsdHMpO1xuZXhwb3J0cy5nZXRSZWFkZGlyT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGV4cG9ydHMuZ2V0UmVhZGRpck9wdGlvbnMpO1xuY29uc3Qgb3BlbmRpckRlZmF1bHRzID0ge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgYnVmZmVyU2l6ZTogMzIsXG4gICAgcmVjdXJzaXZlOiBmYWxzZSxcbn07XG5leHBvcnRzLmdldE9wZW5kaXJPcHRpb25zID0gb3B0c0dlbmVyYXRvcihvcGVuZGlyRGVmYXVsdHMpO1xuZXhwb3J0cy5nZXRPcGVuZGlyT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGV4cG9ydHMuZ2V0T3BlbmRpck9wdGlvbnMpO1xuY29uc3QgYXBwZW5kRmlsZURlZmF1bHRzID0ge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogNDM4IC8qIE1PREUuREVGQVVMVCAqLyxcbiAgICBmbGFnOiBjb25zdGFudHNfMS5GTEFHU1tjb25zdGFudHNfMS5GTEFHUy5hXSxcbn07XG5leHBvcnRzLmdldEFwcGVuZEZpbGVPcHRzID0gb3B0c0dlbmVyYXRvcihhcHBlbmRGaWxlRGVmYXVsdHMpO1xuZXhwb3J0cy5nZXRBcHBlbmRGaWxlT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGV4cG9ydHMuZ2V0QXBwZW5kRmlsZU9wdHMpO1xuY29uc3Qgc3RhdERlZmF1bHRzID0ge1xuICAgIGJpZ2ludDogZmFsc2UsXG59O1xuY29uc3QgZ2V0U3RhdE9wdGlvbnMgPSAob3B0aW9ucyA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBzdGF0RGVmYXVsdHMsIG9wdGlvbnMpO1xuZXhwb3J0cy5nZXRTdGF0T3B0aW9ucyA9IGdldFN0YXRPcHRpb25zO1xuY29uc3QgZ2V0U3RhdE9wdHNBbmRDYiA9IChvcHRpb25zLCBjYWxsYmFjaykgPT4gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBbKDAsIGV4cG9ydHMuZ2V0U3RhdE9wdGlvbnMpKCksIG9wdGlvbnNdIDogWygwLCBleHBvcnRzLmdldFN0YXRPcHRpb25zKShvcHRpb25zKSwgKDAsIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKShjYWxsYmFjayldO1xuZXhwb3J0cy5nZXRTdGF0T3B0c0FuZENiID0gZ2V0U3RhdE9wdHNBbmRDYjtcbmNvbnN0IHJlYWxwYXRoRGVmYXVsdHMgPSBleHBvcnRzLm9wdHNEZWZhdWx0cztcbmV4cG9ydHMuZ2V0UmVhbHBhdGhPcHRpb25zID0gb3B0c0dlbmVyYXRvcihyZWFscGF0aERlZmF1bHRzKTtcbmV4cG9ydHMuZ2V0UmVhbHBhdGhPcHRzQW5kQ2IgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZXhwb3J0cy5nZXRSZWFscGF0aE9wdGlvbnMpO1xuZXhwb3J0cy53cml0ZUZpbGVEZWZhdWx0cyA9IHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDQzOCAvKiBNT0RFLkRFRkFVTFQgKi8sXG4gICAgZmxhZzogY29uc3RhbnRzXzEuRkxBR1NbY29uc3RhbnRzXzEuRkxBR1Mud10sXG59O1xuZXhwb3J0cy5nZXRXcml0ZUZpbGVPcHRpb25zID0gb3B0c0dlbmVyYXRvcihleHBvcnRzLndyaXRlRmlsZURlZmF1bHRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL25vZGUvdXRpbFwiKTtcbmNvbnN0IERpcmVudF8xID0gcmVxdWlyZShcIi4vRGlyZW50XCIpO1xuLyoqXG4gKiBBIGRpcmVjdG9yeSBzdHJlYW0sIGxpa2UgYGZzLkRpcmAuXG4gKi9cbmNsYXNzIERpciB7XG4gICAgY29uc3RydWN0b3IobGluaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLml0ZXJhdG9ySW5mbyA9IFtdO1xuICAgICAgICB0aGlzLnBhdGggPSBsaW5rLmdldFBhcmVudFBhdGgoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRvckluZm8ucHVzaChsaW5rLmNoaWxkcmVuW1N5bWJvbC5pdGVyYXRvcl0oKSk7XG4gICAgfVxuICAgIHdyYXBBc3luYyhtZXRob2QsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0Z1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbiAgICBwcm9taXNpZnkob2JqLCBmbikge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRnVuY3Rpb24ob2JqW2ZuXSkpIHtcbiAgICAgICAgICAgICAgICBvYmpbZm5dLmJpbmQob2JqKSguLi5hcmdzLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZUJhc2UoKSB7IH1cbiAgICByZWFkQmFzZShpdGVyYXRvckluZm8pIHtcbiAgICAgICAgbGV0IGRvbmU7XG4gICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGxldCBsaW5rO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgKHsgZG9uZSwgdmFsdWUgfSA9IGl0ZXJhdG9ySW5mb1tpdGVyYXRvckluZm8ubGVuZ3RoIC0gMV0ubmV4dCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgW25hbWUsIGxpbmtdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChuYW1lID09PSAnLicgfHwgbmFtZSA9PT0gJy4uJyk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9ySW5mby5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3JJbmZvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlY3Vyc2l2ZSAmJiBsaW5rLmNoaWxkcmVuLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3JJbmZvLnB1c2gobGluay5jaGlsZHJlbltTeW1ib2wuaXRlcmF0b3JdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gRGlyZW50XzEuZGVmYXVsdC5idWlsZChsaW5rLCB0aGlzLm9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjbG9zZUJhc2VBc3luYyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmNsb3NlQmFzZSwgW10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgY2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUJhc2VBc3luYyhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNpZnkodGhpcywgJ2Nsb3NlQmFzZUFzeW5jJykoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZVN5bmMoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VCYXNlKCk7XG4gICAgfVxuICAgIHJlYWRCYXNlQXN5bmMoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZWFkQmFzZSwgW3RoaXMuaXRlcmF0b3JJbmZvXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZWFkKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZEJhc2VBc3luYyhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNpZnkodGhpcywgJ3JlYWRCYXNlQXN5bmMnKSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRTeW5jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQmFzZSh0aGlzLml0ZXJhdG9ySW5mbyk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9ySW5mbyA9IFtdO1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGl0ZXJhdG9ySW5mby5wdXNoKF90aGlzLmxpbmsuY2hpbGRyZW5bU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICAgICAgLy8gYXV4aWxpYXJ5IG9iamVjdCBzbyBwcm9taXNpZnkoKSBjYW4gYmUgdXNlZFxuICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgICAgcmVhZEJhc2VBc3luYyhjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzLndyYXBBc3luYyhfdGhpcy5yZWFkQmFzZSwgW2l0ZXJhdG9ySW5mb10sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpckVudCA9IGF3YWl0IF90aGlzLnByb21pc2lmeShvLCAncmVhZEJhc2VBc3luYycpKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpckVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGRpckVudCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGlyID0gRGlyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GU1dhdGNoZXIgPSBleHBvcnRzLlN0YXRXYXRjaGVyID0gZXhwb3J0cy5Wb2x1bWUgPSB2b2lkIDA7XG5leHBvcnRzLmZpbGVuYW1lVG9TdGVwcyA9IGZpbGVuYW1lVG9TdGVwcztcbmV4cG9ydHMucGF0aFRvU3RlcHMgPSBwYXRoVG9TdGVwcztcbmV4cG9ydHMuZGF0YVRvU3RyID0gZGF0YVRvU3RyO1xuZXhwb3J0cy50b1VuaXhUaW1lc3RhbXAgPSB0b1VuaXhUaW1lc3RhbXA7XG5jb25zdCBwYXRoTW9kdWxlID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBub2RlXzEgPSByZXF1aXJlKFwiLi9ub2RlXCIpO1xuY29uc3QgU3RhdHNfMSA9IHJlcXVpcmUoXCIuL1N0YXRzXCIpO1xuY29uc3QgRGlyZW50XzEgPSByZXF1aXJlKFwiLi9EaXJlbnRcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2J1ZmZlclwiKTtcbmNvbnN0IHF1ZXVlTWljcm90YXNrXzEgPSByZXF1aXJlKFwiLi9xdWV1ZU1pY3JvdGFza1wiKTtcbmNvbnN0IHByb2Nlc3NfMSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NcIik7XG5jb25zdCBzZXRUaW1lb3V0VW5yZWZfMSA9IHJlcXVpcmUoXCIuL3NldFRpbWVvdXRVbnJlZlwiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xuY29uc3QgRmlsZUhhbmRsZV8xID0gcmVxdWlyZShcIi4vbm9kZS9GaWxlSGFuZGxlXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgRnNQcm9taXNlc18xID0gcmVxdWlyZShcIi4vbm9kZS9Gc1Byb21pc2VzXCIpO1xuY29uc3QgcHJpbnRfMSA9IHJlcXVpcmUoXCIuL3ByaW50XCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9ub2RlL2NvbnN0YW50c1wiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL25vZGUvb3B0aW9uc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL25vZGUvdXRpbFwiKTtcbmNvbnN0IERpcl8xID0gcmVxdWlyZShcIi4vRGlyXCIpO1xuY29uc3QgcmVzb2x2ZUNyb3NzUGxhdGZvcm0gPSBwYXRoTW9kdWxlLnJlc29sdmU7XG5jb25zdCB7IE9fUkRPTkxZLCBPX1dST05MWSwgT19SRFdSLCBPX0NSRUFULCBPX0VYQ0wsIE9fVFJVTkMsIE9fQVBQRU5ELCBPX0RJUkVDVE9SWSwgT19TWU1MSU5LLCBGX09LLCBDT1BZRklMRV9FWENMLCBDT1BZRklMRV9GSUNMT05FX0ZPUkNFLCB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuY29uc3QgeyBzZXAsIHJlbGF0aXZlLCBqb2luLCBkaXJuYW1lIH0gPSBwYXRoTW9kdWxlLnBvc2l4ID8gcGF0aE1vZHVsZS5wb3NpeCA6IHBhdGhNb2R1bGU7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENvbnN0YW50c1xuY29uc3Qga01pblBvb2xTcGFjZSA9IDEyODtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRXJyb3IgbWVzc2FnZXNcbmNvbnN0IEVQRVJNID0gJ0VQRVJNJztcbmNvbnN0IEVOT0VOVCA9ICdFTk9FTlQnO1xuY29uc3QgRUJBREYgPSAnRUJBREYnO1xuY29uc3QgRUlOVkFMID0gJ0VJTlZBTCc7XG5jb25zdCBFRVhJU1QgPSAnRUVYSVNUJztcbmNvbnN0IEVOT1RESVIgPSAnRU5PVERJUic7XG5jb25zdCBFTUZJTEUgPSAnRU1GSUxFJztcbmNvbnN0IEVBQ0NFUyA9ICdFQUNDRVMnO1xuY29uc3QgRUlTRElSID0gJ0VJU0RJUic7XG5jb25zdCBFTk9URU1QVFkgPSAnRU5PVEVNUFRZJztcbmNvbnN0IEVOT1NZUyA9ICdFTk9TWVMnO1xuY29uc3QgRVJSX0ZTX0VJU0RJUiA9ICdFUlJfRlNfRUlTRElSJztcbmNvbnN0IEVSUl9PVVRfT0ZfUkFOR0UgPSAnRVJSX09VVF9PRl9SQU5HRSc7XG5sZXQgcmVzb2x2ZSA9IChmaWxlbmFtZSwgYmFzZSA9IHByb2Nlc3NfMS5kZWZhdWx0LmN3ZCgpKSA9PiByZXNvbHZlQ3Jvc3NQbGF0Zm9ybShiYXNlLCBmaWxlbmFtZSk7XG5pZiAodXRpbF8xLmlzV2luKSB7XG4gICAgY29uc3QgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIHJlc29sdmUgPSAoZmlsZW5hbWUsIGJhc2UpID0+ICgwLCB1dGlsXzEudW5peGlmeSkoX3Jlc29sdmUoZmlsZW5hbWUsIGJhc2UpKTtcbn1cbmZ1bmN0aW9uIGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSwgYmFzZSkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gcmVzb2x2ZShmaWxlbmFtZSwgYmFzZSk7XG4gICAgY29uc3QgZnVsbFBhdGhTYW5zU2xhc2ggPSBmdWxsUGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgaWYgKCFmdWxsUGF0aFNhbnNTbGFzaClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIHJldHVybiBmdWxsUGF0aFNhbnNTbGFzaC5zcGxpdChzZXApO1xufVxuZnVuY3Rpb24gcGF0aFRvU3RlcHMocGF0aCkge1xuICAgIHJldHVybiBmaWxlbmFtZVRvU3RlcHMoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCkpO1xufVxuZnVuY3Rpb24gZGF0YVRvU3RyKGRhdGEsIGVuY29kaW5nID0gZW5jb2RpbmdfMS5FTkNPRElOR19VVEY4KSB7XG4gICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gKDAsIGJ1ZmZlcl8xLmJ1ZmZlckZyb20pKGRhdGEpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBTdHJpbmcoZGF0YSk7XG59XG4vLyBjb252ZXJ0cyBEYXRlIG9yIG51bWJlciB0byBhIGZyYWN0aW9uYWwgVU5JWCB0aW1lc3RhbXBcbmZ1bmN0aW9uIHRvVW5peFRpbWVzdGFtcCh0aW1lKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHRyaXBsZS1lcXVhbHNcbiAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnICYmICt0aW1lID09IHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICt0aW1lO1xuICAgIH1cbiAgICBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKHRpbWUpKSB7XG4gICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0aW1lOiAnICsgdGltZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVVpZCh1aWQpIHtcbiAgICBpZiAodHlwZW9mIHVpZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihjb25zdGFudHNfMi5FUlJTVFIuVUlEKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlR2lkKGdpZCkge1xuICAgIGlmICh0eXBlb2YgZ2lkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGNvbnN0YW50c18yLkVSUlNUUi5HSUQpO1xufVxuZnVuY3Rpb24gZmxhdHRlbkpTT04obmVzdGVkSlNPTikge1xuICAgIGNvbnN0IGZsYXRKU09OID0ge307XG4gICAgZnVuY3Rpb24gZmxhdHRlbihwYXRoUHJlZml4LCBub2RlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBpbiBub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50T3JOb2RlID0gbm9kZVtwYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IGpvaW5lZFBhdGggPSBqb2luKHBhdGhQcmVmaXgsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50T3JOb2RlID09PSAnc3RyaW5nJyB8fCBjb250ZW50T3JOb2RlIGluc3RhbmNlb2YgYnVmZmVyXzEuQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgZmxhdEpTT05bam9pbmVkUGF0aF0gPSBjb250ZW50T3JOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnRPck5vZGUgPT09ICdvYmplY3QnICYmIGNvbnRlbnRPck5vZGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoY29udGVudE9yTm9kZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGVtcHR5IGRpcmVjdG9yaWVzIG5lZWQgYW4gZXhwbGljaXQgZW50cnkgYW5kIHRoZXJlZm9yZSBnZXQgaGFuZGxlZCBpbiBgZWxzZWAsIG5vbi1lbXB0eSBvbmVzIGFyZSBpbXBsaWNpdGx5IGNvbnNpZGVyZWRcbiAgICAgICAgICAgICAgICBmbGF0dGVuKGpvaW5lZFBhdGgsIGNvbnRlbnRPck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2l0aG91dCB0aGlzIGJyYW5jaCBudWxsLCBlbXB0eS1vYmplY3Qgb3Igbm9uLW9iamVjdCBlbnRyaWVzIHdvdWxkIG5vdCBiZSBoYW5kbGVkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAgIC8vIGJ5IGJvdGggZnJvbUpTT04oKSBhbmQgZnJvbU5lc3RlZEpTT04oKVxuICAgICAgICAgICAgICAgIGZsYXRKU09OW2pvaW5lZFBhdGhdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmbGF0dGVuKCcnLCBuZXN0ZWRKU09OKTtcbiAgICByZXR1cm4gZmxhdEpTT047XG59XG5jb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcbi8qKlxuICogYFZvbHVtZWAgcmVwcmVzZW50cyBhIGZpbGUgc3lzdGVtLlxuICovXG5jbGFzcyBWb2x1bWUge1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjd2QpIHtcbiAgICAgICAgY29uc3Qgdm9sID0gbmV3IFZvbHVtZSgpO1xuICAgICAgICB2b2wuZnJvbUpTT04oanNvbiwgY3dkKTtcbiAgICAgICAgcmV0dXJuIHZvbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21OZXN0ZWRKU09OKGpzb24sIGN3ZCkge1xuICAgICAgICBjb25zdCB2b2wgPSBuZXcgVm9sdW1lKCk7XG4gICAgICAgIHZvbC5mcm9tTmVzdGVkSlNPTihqc29uLCBjd2QpO1xuICAgICAgICByZXR1cm4gdm9sO1xuICAgIH1cbiAgICBnZXQgcHJvbWlzZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb21pc2VzQXBpID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9taXNlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZXNBcGk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzID0ge30pIHtcbiAgICAgICAgLy8gSS1ub2RlIG51bWJlciBjb3VudGVyLlxuICAgICAgICB0aGlzLmlubyA9IDA7XG4gICAgICAgIC8vIEEgbWFwcGluZyBmb3IgaS1ub2RlIG51bWJlcnMgdG8gaS1ub2RlcyAoYE5vZGVgKTtcbiAgICAgICAgdGhpcy5pbm9kZXMgPSB7fTtcbiAgICAgICAgLy8gTGlzdCBvZiByZWxlYXNlZCBpLW5vZGUgbnVtYmVycywgZm9yIHJldXNlLlxuICAgICAgICB0aGlzLnJlbGVhc2VkSW5vcyA9IFtdO1xuICAgICAgICAvLyBBIG1hcHBpbmcgZm9yIGZpbGUgZGVzY3JpcHRvcnMgdG8gYEZpbGVgcy5cbiAgICAgICAgdGhpcy5mZHMgPSB7fTtcbiAgICAgICAgLy8gQSBsaXN0IG9mIHJldXNhYmxlIChvcGVuZWQgYW5kIGNsb3NlZCkgZmlsZSBkZXNjcmlwdG9ycywgdGhhdCBzaG91bGQgYmVcbiAgICAgICAgLy8gdXNlZCBmaXJzdCBiZWZvcmUgY3JlYXRpbmcgYSBuZXcgZmlsZSBkZXNjcmlwdG9yLlxuICAgICAgICB0aGlzLnJlbGVhc2VkRmRzID0gW107XG4gICAgICAgIC8vIE1heCBudW1iZXIgb2Ygb3BlbiBmaWxlcy5cbiAgICAgICAgdGhpcy5tYXhGaWxlcyA9IDEwMDAwO1xuICAgICAgICAvLyBDdXJyZW50IG51bWJlciBvZiBvcGVuIGZpbGVzLlxuICAgICAgICB0aGlzLm9wZW5GaWxlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvbWlzZXNBcGkgPSBuZXcgRnNQcm9taXNlc18xLkZzUHJvbWlzZXModGhpcywgRmlsZUhhbmRsZV8xLkZpbGVIYW5kbGUpO1xuICAgICAgICB0aGlzLnN0YXRXYXRjaGVycyA9IHt9O1xuICAgICAgICB0aGlzLmNwU3luYyA9IG5vdEltcGxlbWVudGVkO1xuICAgICAgICB0aGlzLnN0YXRmc1N5bmMgPSBub3RJbXBsZW1lbnRlZDtcbiAgICAgICAgdGhpcy5jcCA9IG5vdEltcGxlbWVudGVkO1xuICAgICAgICB0aGlzLnN0YXRmcyA9IG5vdEltcGxlbWVudGVkO1xuICAgICAgICB0aGlzLm9wZW5Bc0Jsb2IgPSBub3RJbXBsZW1lbnRlZDtcbiAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBOb2RlOiBub2RlXzEuTm9kZSwgTGluazogbm9kZV8xLkxpbmssIEZpbGU6IG5vZGVfMS5GaWxlIH0sIHByb3BzKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuY3JlYXRlTGluaygpO1xuICAgICAgICByb290LnNldE5vZGUodGhpcy5jcmVhdGVOb2RlKGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGRElSIHwgMG83NzcpKTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgICAgIHRoaXMuU3RhdFdhdGNoZXIgPSBjbGFzcyBleHRlbmRzIFN0YXRXYXRjaGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfUmVhZFN0cmVhbSA9IEZzUmVhZFN0cmVhbTtcbiAgICAgICAgdGhpcy5SZWFkU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBfUmVhZFN0cmVhbSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoc2VsZiwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9Xcml0ZVN0cmVhbSA9IEZzV3JpdGVTdHJlYW07XG4gICAgICAgIHRoaXMuV3JpdGVTdHJlYW0gPSBjbGFzcyBleHRlbmRzIF9Xcml0ZVN0cmVhbSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoc2VsZiwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuRlNXYXRjaGVyID0gY2xhc3MgZXh0ZW5kcyBGU1dhdGNoZXIge1xuICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIoc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJvb3Quc2V0Q2hpbGQoJy4nLCByb290KTtcbiAgICAgICAgcm9vdC5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgcm9vdC5zZXRDaGlsZCgnLi4nLCByb290KTtcbiAgICAgICAgcm9vdC5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB9XG4gICAgY3JlYXRlTGluayhwYXJlbnQsIG5hbWUsIGlzRGlyZWN0b3J5ID0gZmFsc2UsIG1vZGUpIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5wcm9wcy5MaW5rKHRoaXMsIG51bGwsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlTGluazogbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBleHBsaWNpdCBwZXJtaXNzaW9uIGlzIHByb3ZpZGVkLCB1c2UgZGVmYXVsdHMgYmFzZWQgb24gdHlwZVxuICAgICAgICBjb25zdCBmaW5hbFBlcm0gPSBtb2RlICE9PSBudWxsICYmIG1vZGUgIT09IHZvaWQgMCA/IG1vZGUgOiAoaXNEaXJlY3RvcnkgPyAwbzc3NyA6IDBvNjY2KTtcbiAgICAgICAgLy8gVG8gcHJldmVudCBtYWtpbmcgYSBicmVha2luZyBjaGFuZ2UsIGBtb2RlYCBjYW4gYWxzbyBqdXN0IGJlIGEgcGVybWlzc2lvbiBudW1iZXJcbiAgICAgICAgLy8gYW5kIHRoZSBmaWxlIHR5cGUgaXMgc2V0IGJhc2VkIG9uIGBpc0RpcmVjdG9yeWBcbiAgICAgICAgY29uc3QgaGFzRmlsZVR5cGUgPSBtb2RlICYmIG1vZGUgJiBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRk1UO1xuICAgICAgICBjb25zdCBtb2RlVHlwZSA9IGhhc0ZpbGVUeXBlID8gbW9kZSAmIGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGTVQgOiBpc0RpcmVjdG9yeSA/IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGRElSIDogY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZSRUc7XG4gICAgICAgIGNvbnN0IGZpbmFsTW9kZSA9IChmaW5hbFBlcm0gJiB+Y29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZNVCkgfCBtb2RlVHlwZTtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5jcmVhdGVDaGlsZChuYW1lLCB0aGlzLmNyZWF0ZU5vZGUoZmluYWxNb2RlKSk7XG4gICAgfVxuICAgIGRlbGV0ZUxpbmsobGluaykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBsaW5rLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBuZXdJbm9OdW1iZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2VkRmQgPSB0aGlzLnJlbGVhc2VkSW5vcy5wb3AoKTtcbiAgICAgICAgaWYgKHJlbGVhc2VkRmQpXG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZWRGZDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubyA9ICh0aGlzLmlubyArIDEpICUgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlubztcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXdGZE51bWJlcigpIHtcbiAgICAgICAgY29uc3QgcmVsZWFzZWRGZCA9IHRoaXMucmVsZWFzZWRGZHMucG9wKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVsZWFzZWRGZCA9PT0gJ251bWJlcicgPyByZWxlYXNlZEZkIDogVm9sdW1lLmZkLS07XG4gICAgfVxuICAgIGNyZWF0ZU5vZGUobW9kZSkge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IHRoaXMucHJvcHMuTm9kZSh0aGlzLm5ld0lub051bWJlcigpLCBtb2RlKTtcbiAgICAgICAgdGhpcy5pbm9kZXNbbm9kZS5pbm9dID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGRlbGV0ZU5vZGUobm9kZSkge1xuICAgICAgICBub2RlLmRlbCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5pbm9kZXNbbm9kZS5pbm9dO1xuICAgICAgICB0aGlzLnJlbGVhc2VkSW5vcy5wdXNoKG5vZGUuaW5vKTtcbiAgICB9XG4gICAgd2FsayhzdGVwc09yRmlsZW5hbWVPckxpbmssIHJlc29sdmVTeW1saW5rcyA9IGZhbHNlLCBjaGVja0V4aXN0ZW5jZSA9IGZhbHNlLCBjaGVja0FjY2VzcyA9IGZhbHNlLCBmdW5jTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBzdGVwcztcbiAgICAgICAgbGV0IGZpbGVuYW1lO1xuICAgICAgICBpZiAoc3RlcHNPckZpbGVuYW1lT3JMaW5rIGluc3RhbmNlb2Ygbm9kZV8xLkxpbmspIHtcbiAgICAgICAgICAgIHN0ZXBzID0gc3RlcHNPckZpbGVuYW1lT3JMaW5rLnN0ZXBzO1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBzZXAgKyBzdGVwcy5qb2luKHNlcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0ZXBzT3JGaWxlbmFtZU9yTGluayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKHN0ZXBzT3JGaWxlbmFtZU9yTGluayk7XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHN0ZXBzT3JGaWxlbmFtZU9yTGluaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ZXBzID0gc3RlcHNPckZpbGVuYW1lT3JMaW5rO1xuICAgICAgICAgICAgZmlsZW5hbWUgPSBzZXAgKyBzdGVwcy5qb2luKHNlcCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnIgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3Vyci5nZXROb2RlKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBhY2Nlc3MgcGVybWlzc2lvbnMgaWYgY3VycmVudCBsaW5rIGlzIGEgZGlyZWN0b3J5XG4gICAgICAgICAgICBpZiAobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrQWNjZXNzICYmICFub2RlLmNhbkV4ZWN1dGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFQUNDRVMsIGZ1bmNOYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdGVwcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFTk9URElSLCBmdW5jTmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyciA9IChfYSA9IGN1cnIuZ2V0Q2hpbGQoc3RlcHNbaV0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZXhpc3RlbmNlIG9mIGN1cnJlbnQgbGlua1xuICAgICAgICAgICAgaWYgKCFjdXJyKVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0V4aXN0ZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRU5PRU5ULCBmdW5jTmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gY3VyciA9PT0gbnVsbCB8fCBjdXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyLmdldE5vZGUoKTtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgc3ltbGlua1xuICAgICAgICAgICAgaWYgKHJlc29sdmVTeW1saW5rcyAmJiBub2RlLmlzU3ltbGluaygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcGF0aE1vZHVsZS5pc0Fic29sdXRlKG5vZGUuc3ltbGluaylcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLnN5bWxpbmtcbiAgICAgICAgICAgICAgICAgICAgOiBqb2luKHBhdGhNb2R1bGUuZGlybmFtZShjdXJyLmdldFBhdGgoKSksIG5vZGUuc3ltbGluayk7IC8vIFJlbGF0aXZlIHRvIHN5bWxpbmsncyBwYXJlbnRcbiAgICAgICAgICAgICAgICBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhyZXNvbHZlZFBhdGgpLmNvbmNhdChzdGVwcy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGN1cnIgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBgTGlua2AgKGhhcmQgbGluaykgcmVmZXJlbmNlZCBieSBwYXRoIFwic3BsaXRcIiBpbnRvIHN0ZXBzLlxuICAgIGdldExpbmsoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhzdGVwcywgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIEp1c3QgbGluayBgZ2V0TGlua2AsIGJ1dCB0aHJvd3MgYSBjb3JyZWN0IHVzZXIgZXJyb3IsIGlmIGxpbmsgdG8gZm91bmQuXG4gICAgZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsIGZ1bmNOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZmlsZW5hbWUsIGZhbHNlLCB0cnVlLCB0cnVlLCBmdW5jTmFtZSk7XG4gICAgfVxuICAgIC8vIEp1c3QgbGlrZSBgZ2V0TGlua2AsIGJ1dCBhbHNvIGRlcmVmZXJlbmNlL3Jlc29sdmVzIHN5bWJvbGljIGxpbmtzLlxuICAgIGdldFJlc29sdmVkTGluayhmaWxlbmFtZU9yU3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmaWxlbmFtZU9yU3RlcHMsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIEp1c3QgbGlrZSBgZ2V0TGlua09yVGhyb3dgLCBidXQgYWxzbyBkZXJlZmVyZW5jZS9yZXNvbHZlcyBzeW1ib2xpYyBsaW5rcy5cbiAgICBnZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCBmdW5jTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZpbGVuYW1lLCB0cnVlLCB0cnVlLCB0cnVlLCBmdW5jTmFtZSk7XG4gICAgfVxuICAgIHJlc29sdmVTeW1saW5rcyhsaW5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlc29sdmVkTGluayhsaW5rLnN0ZXBzLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgLy8gSnVzdCBsaWtlIGBnZXRMaW5rT3JUaHJvd2AsIGJ1dCBhbHNvIHZlcmlmaWVzIHRoYXQgdGhlIGxpbmsgaXMgYSBkaXJlY3RvcnkuXG4gICAgZ2V0TGlua0FzRGlyT3JUaHJvdyhmaWxlbmFtZSwgZnVuY05hbWUpIHtcbiAgICAgICAgY29uc3QgbGluayA9IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsIGZ1bmNOYW1lKTtcbiAgICAgICAgaWYgKCFsaW5rLmdldE5vZGUoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRU5PVERJUiwgZnVuY05hbWUsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaW1tZWRpYXRlIHBhcmVudCBkaXJlY3Rvcnkgb2YgdGhlIGxpbmsuXG4gICAgZ2V0TGlua1BhcmVudChzdGVwcykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5rKHN0ZXBzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIGdldExpbmtQYXJlbnRBc0Rpck9yVGhyb3coZmlsZW5hbWVPclN0ZXBzLCBmdW5jTmFtZSkge1xuICAgICAgICBjb25zdCBzdGVwcyA9IChmaWxlbmFtZU9yU3RlcHMgaW5zdGFuY2VvZiBBcnJheSA/IGZpbGVuYW1lT3JTdGVwcyA6IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZU9yU3RlcHMpKS5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gc2VwICsgc3RlcHMuam9pbihzZXApO1xuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgZnVuY05hbWUpO1xuICAgICAgICBpZiAoIWxpbmsuZ2V0Tm9kZSgpLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFTk9URElSLCBmdW5jTmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9XG4gICAgZ2V0RmlsZUJ5RmQoZmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmRzW1N0cmluZyhmZCldO1xuICAgIH1cbiAgICBnZXRGaWxlQnlGZE9yVGhyb3coZmQsIGZ1bmNOYW1lKSB7XG4gICAgICAgIGlmICghKDAsIHV0aWxfMS5pc0ZkKShmZCkpXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoY29uc3RhbnRzXzIuRVJSU1RSLkZEKTtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoZmQpO1xuICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFQkFERiwgZnVuY05hbWUpO1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRvZG8gVGhpcyBpcyBub3QgdXNlZCBhbnltb3JlLiBSZW1vdmUuXG4gICAgICovXG4gICAgLypcbiAgICBwcml2YXRlIGdldE5vZGVCeUlkT3JDcmVhdGUoaWQ6IFRGaWxlSWQsIGZsYWdzOiBudW1iZXIsIHBlcm06IG51bWJlcik6IE5vZGUge1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoaWQpO1xuICAgICAgICBpZiAoIWZpbGUpIHRocm93IEVycm9yKCdGaWxlIG50byBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gZmlsZS5ub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBwYXRoVG9TdGVwcyhpZCBhcyBQYXRoTGlrZSk7XG4gICAgICAgIGxldCBsaW5rID0gdGhpcy5nZXRMaW5rKHN0ZXBzKTtcbiAgICAgICAgaWYgKGxpbmspIHJldHVybiBsaW5rLmdldE5vZGUoKTtcbiAgXG4gICAgICAgIC8vIFRyeSBjcmVhdGluZyBhIG5vZGUgaWYgbm90IGZvdW5kLlxuICAgICAgICBpZiAoZmxhZ3MgJiBPX0NSRUFUKSB7XG4gICAgICAgICAgY29uc3QgZGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgICAgaWYgKGRpckxpbmspIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxpbmsgPSB0aGlzLmNyZWF0ZUxpbmsoZGlyTGluaywgbmFtZSwgZmFsc2UsIHBlcm0pO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU5PRU5ULCAnZ2V0Tm9kZUJ5SWRPckNyZWF0ZScsIHBhdGhUb0ZpbGVuYW1lKGlkKSk7XG4gICAgICB9XG4gICAgfVxuICAgICovXG4gICAgd3JhcEFzeW5jKG1ldGhvZCwgYXJncywgY2FsbGJhY2spIHtcbiAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF90b0pTT04obGluayA9IHRoaXMucm9vdCwganNvbiA9IHt9LCBwYXRoLCBhc0J1ZmZlcikge1xuICAgICAgICBsZXQgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IGxpbmsuY2hpbGRyZW47XG4gICAgICAgIGlmIChsaW5rLmdldE5vZGUoKS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBuZXcgTWFwKFtbbGluay5nZXROYW1lKCksIGxpbmsucGFyZW50LmdldENoaWxkKGxpbmsuZ2V0TmFtZSgpKV1dKTtcbiAgICAgICAgICAgIGxpbmsgPSBsaW5rLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY2hpbGRyZW4ua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJy4nIHx8IG5hbWUgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbGluay5nZXRDaGlsZChuYW1lKTtcbiAgICAgICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ190b0pTT046IHVuZXhwZWN0ZWQgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGQuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBjaGlsZC5nZXRQYXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gcmVsYXRpdmUocGF0aCwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGpzb25bZmlsZW5hbWVdID0gYXNCdWZmZXIgPyBub2RlLmdldEJ1ZmZlcigpIDogbm9kZS5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvSlNPTihjaGlsZCwganNvbiwgcGF0aCwgYXNCdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkaXJQYXRoID0gbGluay5nZXRQYXRoKCk7XG4gICAgICAgIGlmIChwYXRoKVxuICAgICAgICAgICAgZGlyUGF0aCA9IHJlbGF0aXZlKHBhdGgsIGRpclBhdGgpO1xuICAgICAgICBpZiAoZGlyUGF0aCAmJiBpc0VtcHR5KSB7XG4gICAgICAgICAgICBqc29uW2RpclBhdGhdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgdG9KU09OKHBhdGhzLCBqc29uID0ge30sIGlzUmVsYXRpdmUgPSBmYWxzZSwgYXNCdWZmZXIgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBsaW5rcyA9IFtdO1xuICAgICAgICBpZiAocGF0aHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpXG4gICAgICAgICAgICAgICAgcGF0aHMgPSBbcGF0aHNdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpbmtzLnB1c2godGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxpbmtzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgbGlua3MpXG4gICAgICAgICAgICB0aGlzLl90b0pTT04obGluaywganNvbiwgaXNSZWxhdGl2ZSA/IGxpbmsuZ2V0UGF0aCgpIDogJycsIGFzQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8vIFRPRE86IGBjd2RgIHNob3VsZCBwcm9iYWJseSBub3QgaW52b2tlIGBwcm9jZXNzLmN3ZCgpYC5cbiAgICBmcm9tSlNPTihqc29uLCBjd2QgPSBwcm9jZXNzXzEuZGVmYXVsdC5jd2QoKSkge1xuICAgICAgICBmb3IgKGxldCBmaWxlbmFtZSBpbiBqc29uKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0ganNvbltmaWxlbmFtZV07XG4gICAgICAgICAgICBmaWxlbmFtZSA9IHJlc29sdmUoZmlsZW5hbWUsIGN3ZCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGRhdGEgaW5zdGFuY2VvZiBidWZmZXJfMS5CdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBkaXJuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1rZGlycEJhc2UoZGlyLCA1MTEgLyogTU9ERS5ESVIgKi8pO1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVGaWxlU3luYyhmaWxlbmFtZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1rZGlycEJhc2UoZmlsZW5hbWUsIDUxMSAvKiBNT0RFLkRJUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbU5lc3RlZEpTT04oanNvbiwgY3dkKSB7XG4gICAgICAgIHRoaXMuZnJvbUpTT04oZmxhdHRlbkpTT04oanNvbiksIGN3ZCk7XG4gICAgfVxuICAgIHRvVHJlZShvcHRzID0geyBzZXBhcmF0b3I6IHNlcCB9KSB7XG4gICAgICAgIHJldHVybiAoMCwgcHJpbnRfMS50b1RyZWVTeW5jKSh0aGlzLCBvcHRzKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaW5vID0gMDtcbiAgICAgICAgdGhpcy5pbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZElub3MgPSBbXTtcbiAgICAgICAgdGhpcy5mZHMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcyA9IFtdO1xuICAgICAgICB0aGlzLm9wZW5GaWxlcyA9IDA7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuY3JlYXRlTGluaygpO1xuICAgICAgICB0aGlzLnJvb3Quc2V0Tm9kZSh0aGlzLmNyZWF0ZU5vZGUoY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZESVIgfCAwbzc3NykpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgaW50ZXJmYWNlXG4gICAgbW91bnRTeW5jKG1vdW50cG9pbnQsIGpzb24pIHtcbiAgICAgICAgdGhpcy5mcm9tSlNPTihqc29uLCBtb3VudHBvaW50KTtcbiAgICB9XG4gICAgb3BlbkxpbmsobGluaywgZmxhZ3NOdW0sIHJlc29sdmVTeW1saW5rcyA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3BlbkZpbGVzID49IHRoaXMubWF4RmlsZXMpIHtcbiAgICAgICAgICAgIC8vIFRvbyBtYW55IG9wZW4gZmlsZXMuXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFTUZJTEUsICdvcGVuJywgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmUgc3ltbGlua3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEBUT0RPOiBUaGlzIHNob3VsZCBiZSBzdXBlcmZsdW91cy4gVGhpcyBtZXRob2QgaXMgb25seSBldmVyIGNhbGxlZCBieSBvcGVuRmlsZSgpLCB3aGljaCBkb2VzIGl0cyBvd24gc3ltbGluayByZXNvbHV0aW9uXG4gICAgICAgIC8vIHByaW9yIHRvIGNhbGxpbmcuXG4gICAgICAgIGxldCByZWFsTGluayA9IGxpbms7XG4gICAgICAgIGlmIChyZXNvbHZlU3ltbGlua3MpXG4gICAgICAgICAgICByZWFsTGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyhsaW5rLmdldFBhdGgoKSwgJ29wZW4nKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHJlYWxMaW5rLmdldE5vZGUoKTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBub2RlIGlzIGEgZGlyZWN0b3J5XG4gICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3NOdW0gJiAoT19SRE9OTFkgfCBPX1JEV1IgfCBPX1dST05MWSkpICE9PSBPX1JET05MWSlcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFSVNESVIsICdvcGVuJywgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZsYWdzTnVtICYgT19ESVJFQ1RPUlkpXG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRU5PVERJUiwgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgbm9kZSBwZXJtaXNzaW9uc1xuICAgICAgICBpZiAoIShmbGFnc051bSAmIE9fV1JPTkxZKSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLmNhblJlYWQoKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVBQ0NFUywgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZmxhZ3NOdW0gJiBPX1JET05MWSkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5jYW5Xcml0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRUFDQ0VTLCAnb3BlbicsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWxlID0gbmV3IHRoaXMucHJvcHMuRmlsZShsaW5rLCBub2RlLCBmbGFnc051bSwgdGhpcy5uZXdGZE51bWJlcigpKTtcbiAgICAgICAgdGhpcy5mZHNbZmlsZS5mZF0gPSBmaWxlO1xuICAgICAgICB0aGlzLm9wZW5GaWxlcysrO1xuICAgICAgICBpZiAoZmxhZ3NOdW0gJiBPX1RSVU5DKVxuICAgICAgICAgICAgZmlsZS50cnVuY2F0ZSgpO1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG4gICAgb3BlbkZpbGUoZmlsZW5hbWUsIGZsYWdzTnVtLCBtb2RlTnVtLCByZXNvbHZlU3ltbGlua3MgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgbGV0IGxpbms7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5rID0gcmVzb2x2ZVN5bWxpbmtzID8gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCAnb3BlbicpIDogdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ29wZW4nKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpbGUgYWxyZWFkeSBleGlzdGVkIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZSBpdCBleGNsdXNpdmVseSAoT19DUkVBVCBhbmQgT19FWENMIGZsYWdzIGFyZSBzZXQpLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBlcnJvciwgc2VlIGh0dHBzOi8vcHVicy5vcGVuZ3JvdXAub3JnL29ubGluZXB1YnMvMDA5Njk1Mzk5L2Z1bmN0aW9ucy9vcGVuLmh0bWw6XG4gICAgICAgICAgICAvLyBcIklmIE9fQ1JFQVQgYW5kIE9fRVhDTCBhcmUgc2V0LCBvcGVuKCkgc2hhbGwgZmFpbCBpZiB0aGUgZmlsZSBleGlzdHMuXCJcbiAgICAgICAgICAgIGlmIChsaW5rICYmIGZsYWdzTnVtICYgT19DUkVBVCAmJiBmbGFnc051bSAmIE9fRVhDTClcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFRVhJU1QsICdvcGVuJywgZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIFRyeSBjcmVhdGluZyBhIG5ldyBmaWxlLCBpZiBpdCBkb2VzIG5vdCBleGlzdCBhbmQgT19DUkVBVCBmbGFnIGlzIHNldC5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIEVOT0VOVCBjYW1lIGZyb20gb25lIG9mIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJtZWRpYXRlIGRpcmVjdG9yaWVzIGluc3RlYWQgb2YgdGhlIGZpbGUgaXRzZWxmLlxuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBFTk9FTlQgJiYgZmxhZ3NOdW0gJiBPX0NSRUFUKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlybmFtZSA9IHBhdGhNb2R1bGUuZGlybmFtZShmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyTGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyhkaXJuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJOb2RlID0gZGlyTGluay5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcGxhY2Ugd2UgY3JlYXRlIHRoZSBuZXcgZmlsZSBpcyBhY3R1YWxseSBhIGRpcmVjdG9yeSBhbmQgdGhhdCB3ZSBhcmUgYWxsb3dlZCB0byBkbyBzbzpcbiAgICAgICAgICAgICAgICBpZiAoIWRpck5vZGUuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRU5PVERJUiwgJ29wZW4nLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXJOb2RlLmNhbkV4ZWN1dGUoKSB8fCAhZGlyTm9kZS5jYW5Xcml0ZSgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFQUNDRVMsICdvcGVuJywgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBkaWZmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggd291bGQgc2ltcGx5IG5vdCBjcmVhdGUgYSBmaWxlIHVubGVzcyBtb2RlTnVtIHdhcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgY3VycmVudCBOb2RlIHZlcnNpb25zIHdpbGwgZGVmYXVsdCB0byAwbzY2Ni5cbiAgICAgICAgICAgICAgICBtb2RlTnVtICE9PSBudWxsICYmIG1vZGVOdW0gIT09IHZvaWQgMCA/IG1vZGVOdW0gOiAobW9kZU51bSA9IDBvNjY2KTtcbiAgICAgICAgICAgICAgICBsaW5rID0gdGhpcy5jcmVhdGVMaW5rKGRpckxpbmssIHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdLCBmYWxzZSwgbW9kZU51bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5rKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbkxpbmsobGluaywgZmxhZ3NOdW0sIHJlc29sdmVTeW1saW5rcyk7XG4gICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVOT0VOVCwgJ29wZW4nLCBmaWxlbmFtZSk7XG4gICAgfVxuICAgIG9wZW5CYXNlKGZpbGVuYW1lLCBmbGFnc051bSwgbW9kZU51bSwgcmVzb2x2ZVN5bWxpbmtzID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5vcGVuRmlsZShmaWxlbmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0sIHJlc29sdmVTeW1saW5rcyk7XG4gICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVOT0VOVCwgJ29wZW4nLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBmaWxlLmZkO1xuICAgIH1cbiAgICBvcGVuU3luYyhwYXRoLCBmbGFncywgbW9kZSA9IDQzOCAvKiBNT0RFLkRFRkFVTFQgKi8pIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgKDEpIG1vZGU7ICgyKSBwYXRoOyAoMykgZmxhZ3MgLSBpbiB0aGF0IG9yZGVyLlxuICAgICAgICBjb25zdCBtb2RlTnVtID0gKDAsIHV0aWxfMS5tb2RlVG9OdW1iZXIpKG1vZGUpO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICBjb25zdCBmbGFnc051bSA9ICgwLCB1dGlsXzEuZmxhZ3NUb051bWJlcikoZmxhZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuQmFzZShmaWxlTmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0sICEoZmxhZ3NOdW0gJiBPX1NZTUxJTkspKTtcbiAgICB9XG4gICAgb3BlbihwYXRoLCBmbGFncywgYSwgYikge1xuICAgICAgICBsZXQgbW9kZSA9IGE7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IGI7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbW9kZSA9IDQzOCAvKiBNT0RFLkRFRkFVTFQgKi87XG4gICAgICAgICAgICBjYWxsYmFjayA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgNDM4IC8qIE1PREUuREVGQVVMVCAqLztcbiAgICAgICAgY29uc3QgbW9kZU51bSA9ICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShtb2RlKTtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgY29uc3QgZmxhZ3NOdW0gPSAoMCwgdXRpbF8xLmZsYWdzVG9OdW1iZXIpKGZsYWdzKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5vcGVuQmFzZSwgW2ZpbGVOYW1lLCBmbGFnc051bSwgbW9kZU51bSwgIShmbGFnc051bSAmIE9fU1lNTElOSyldLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGNsb3NlRmlsZShmaWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5mZHNbZmlsZS5mZF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub3BlbkZpbGVzLS07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZkc1tmaWxlLmZkXTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcy5wdXNoKGZpbGUuZmQpO1xuICAgIH1cbiAgICBjbG9zZVN5bmMoZmQpIHtcbiAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZUZkKShmZCk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2Nsb3NlJyk7XG4gICAgICAgIHRoaXMuY2xvc2VGaWxlKGZpbGUpO1xuICAgIH1cbiAgICBjbG9zZShmZCwgY2FsbGJhY2spIHtcbiAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZUZkKShmZCk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2Nsb3NlJyk7XG4gICAgICAgIC8vIE5PVEU6IG5vdCBjYWxsaW5nIGNsb3NlU3luYyBiZWNhdXNlIHdlIGNhbiByZXNldCBpbiBiZXR3ZWVuIGNsb3NlIGFuZCBjbG9zZVN5bmNcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5jbG9zZUZpbGUsIFtmaWxlXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBvcGVuRmlsZU9yR2V0QnlJZChpZCwgZmxhZ3NOdW0sIG1vZGVOdW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmZkc1tpZF07XG4gICAgICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRU5PRU5UKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbkZpbGUoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkoaWQpLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZEJhc2UoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRVJSX09VVF9PRl9SQU5HRSwgJ3JlYWQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgUmFuZ2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkKTtcbiAgICAgICAgaWYgKGZpbGUubm9kZS5pc1N5bWxpbmsoKSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRVBFUk0sICdyZWFkJywgZmlsZS5saW5rLmdldFBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGUucmVhZChidWZmZXIsIE51bWJlcihvZmZzZXQpLCBOdW1iZXIobGVuZ3RoKSwgcG9zaXRpb24gPT09IC0xIHx8IHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgPyB1bmRlZmluZWQgOiBwb3NpdGlvbik7XG4gICAgfVxuICAgIHJlYWRTeW5jKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICAoMCwgdXRpbF8xLnZhbGlkYXRlRmQpKGZkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEJhc2UoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmVhZChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICAvLyBUaGlzIGBpZmAgYnJhbmNoIGlzIGZyb20gTm9kZS5qc1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHF1ZXVlTWljcm90YXNrXzEuZGVmYXVsdCkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMCwgYnVmZmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMucmVhZEJhc2UoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcywgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVhZHZCYXNlKGZkLCBidWZmZXJzLCBwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQpO1xuICAgICAgICBsZXQgcCA9IHBvc2l0aW9uICE9PSBudWxsICYmIHBvc2l0aW9uICE9PSB2b2lkIDAgPyBwb3NpdGlvbiA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHAgPT09IC0xKSB7XG4gICAgICAgICAgICBwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlc1JlYWQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGZpbGUucmVhZChidWZmZXIsIDAsIGJ1ZmZlci5ieXRlTGVuZ3RoLCBwKTtcbiAgICAgICAgICAgIHAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBieXRlc1JlYWQgKz0gYnl0ZXM7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgPCBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgIH1cbiAgICByZWFkdihmZCwgYnVmZmVycywgYSwgYikge1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBhO1xuICAgICAgICBsZXQgY2FsbGJhY2sgPSBiO1xuICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2spKGNhbGxiYWNrKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5yZWFkdkJhc2UoZmQsIGJ1ZmZlcnMsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcywgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlYWR2U3luYyhmZCwgYnVmZmVycywgcG9zaXRpb24pIHtcbiAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZUZkKShmZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWR2QmFzZShmZCwgYnVmZmVycywgcG9zaXRpb24pO1xuICAgIH1cbiAgICByZWFkRmlsZUJhc2UoaWQsIGZsYWdzTnVtLCBlbmNvZGluZykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBpc1VzZXJGZCA9IHR5cGVvZiBpZCA9PT0gJ251bWJlcic7XG4gICAgICAgIGNvbnN0IHVzZXJPd25zRmQgPSBpc1VzZXJGZCAmJiAoMCwgdXRpbF8xLmlzRmQpKGlkKTtcbiAgICAgICAgbGV0IGZkO1xuICAgICAgICBpZiAodXNlck93bnNGZClcbiAgICAgICAgICAgIGZkID0gaWQ7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShpZCk7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCAnb3BlbicpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFSVNESVIsICdvcGVuJywgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICAgICAgZmQgPSB0aGlzLm9wZW5TeW5jKGlkLCBmbGFnc051bSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICgwLCB1dGlsXzEuYnVmZmVyVG9FbmNvZGluZykodGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQpLmdldEJ1ZmZlcigpLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoIXVzZXJPd25zRmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVhZEZpbGVTeW5jKGZpbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCBvcHRpb25zXzEuZ2V0UmVhZEZpbGVPcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmxhZ3NOdW0gPSAoMCwgdXRpbF8xLmZsYWdzVG9OdW1iZXIpKG9wdHMuZmxhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWxlQmFzZShmaWxlLCBmbGFnc051bSwgb3B0cy5lbmNvZGluZyk7XG4gICAgfVxuICAgIHJlYWRGaWxlKGlkLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRzLCBjYWxsYmFja10gPSAoMCwgb3B0aW9uc18xLm9wdHNBbmRDYkdlbmVyYXRvcikob3B0aW9uc18xLmdldFJlYWRGaWxlT3B0aW9ucykoYSwgYik7XG4gICAgICAgIGNvbnN0IGZsYWdzTnVtID0gKDAsIHV0aWxfMS5mbGFnc1RvTnVtYmVyKShvcHRzLmZsYWcpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJlYWRGaWxlQmFzZSwgW2lkLCBmbGFnc051bSwgb3B0cy5lbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd3JpdGVCYXNlKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsICd3cml0ZScpO1xuICAgICAgICBpZiAoZmlsZS5ub2RlLmlzU3ltbGluaygpKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFQkFERiwgJ3dyaXRlJywgZmlsZS5saW5rLmdldFBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGUud3JpdGUoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24gPT09IC0xIHx8IHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgPyB1bmRlZmluZWQgOiBwb3NpdGlvbik7XG4gICAgfVxuICAgIHdyaXRlU3luYyhmZCwgYSwgYiwgYywgZCkge1xuICAgICAgICBjb25zdCBbLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbl0gPSAoMCwgdXRpbF8xLmdldFdyaXRlU3luY0FyZ3MpKGZkLCBhLCBiLCBjLCBkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCYXNlKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIHdyaXRlKGZkLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIGNvbnN0IFssIGFzU3RyLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2JdID0gKDAsIHV0aWxfMS5nZXRXcml0ZUFyZ3MpKGZkLCBhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy53cml0ZUJhc2UoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGJ5dGVzLCBidWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgYnl0ZXMsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JpdGV2QmFzZShmZCwgYnVmZmVycywgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkKTtcbiAgICAgICAgbGV0IHAgPSBwb3NpdGlvbiAhPT0gbnVsbCAmJiBwb3NpdGlvbiAhPT0gdm9pZCAwID8gcG9zaXRpb24gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChwID09PSAtMSkge1xuICAgICAgICAgICAgcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnl0ZXNXcml0dGVuID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGJ1ZmZlci5idWZmZXIsIGJ1ZmZlci5ieXRlT2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGZpbGUud3JpdGUobm9kZUJ1ZiwgMCwgbm9kZUJ1Zi5ieXRlTGVuZ3RoLCBwKTtcbiAgICAgICAgICAgIHAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBieXRlc1dyaXR0ZW4gKz0gYnl0ZXM7XG4gICAgICAgICAgICBpZiAoYnl0ZXMgPCBub2RlQnVmLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbjtcbiAgICB9XG4gICAgd3JpdGV2KGZkLCBidWZmZXJzLCBhLCBiKSB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IGE7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IGI7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLndyaXRldkJhc2UoZmQsIGJ1ZmZlcnMsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcywgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyaXRldlN5bmMoZmQsIGJ1ZmZlcnMsIHBvc2l0aW9uKSB7XG4gICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVGZCkoZmQpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZXZCYXNlKGZkLCBidWZmZXJzLCBwb3NpdGlvbik7XG4gICAgfVxuICAgIHdyaXRlRmlsZUJhc2UoaWQsIGJ1ZiwgZmxhZ3NOdW0sIG1vZGVOdW0pIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3dyaXRlRmlsZUJhc2UnLCBpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIC8vIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGVCeUlkT3JDcmVhdGUoaWQsIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgLy8gbm9kZS5zZXRCdWZmZXIoYnVmKTtcbiAgICAgICAgY29uc3QgaXNVc2VyRmQgPSB0eXBlb2YgaWQgPT09ICdudW1iZXInO1xuICAgICAgICBsZXQgZmQ7XG4gICAgICAgIGlmIChpc1VzZXJGZClcbiAgICAgICAgICAgIGZkID0gaWQ7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmQgPSB0aGlzLm9wZW5CYXNlKCgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKGlkKSwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgICAgICAgICAgLy8gZmQgPSB0aGlzLm9wZW5TeW5jKGlkIGFzIFBhdGhMaWtlLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBmbGFnc051bSAmIE9fQVBQRU5EID8gdW5kZWZpbmVkIDogMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdHRlbiA9IHRoaXMud3JpdGVTeW5jKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHdyaXR0ZW47XG4gICAgICAgICAgICAgICAgbGVuZ3RoIC09IHdyaXR0ZW47XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHdyaXR0ZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoIWlzVXNlckZkKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUZpbGVTeW5jKGlkLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgb3B0aW9uc18xLmdldFdyaXRlRmlsZU9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmbGFnc051bSA9ICgwLCB1dGlsXzEuZmxhZ3NUb051bWJlcikob3B0cy5mbGFnKTtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9ICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShvcHRzLm1vZGUpO1xuICAgICAgICBjb25zdCBidWYgPSAoMCwgdXRpbF8xLmRhdGFUb0J1ZmZlcikoZGF0YSwgb3B0cy5lbmNvZGluZyk7XG4gICAgICAgIHRoaXMud3JpdGVGaWxlQmFzZShpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgfVxuICAgIHdyaXRlRmlsZShpZCwgZGF0YSwgYSwgYikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGE7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IGI7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNfMS53cml0ZUZpbGVEZWZhdWx0cztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYiA9ICgwLCB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaykoY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIG9wdGlvbnNfMS5nZXRXcml0ZUZpbGVPcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZmxhZ3NOdW0gPSAoMCwgdXRpbF8xLmZsYWdzVG9OdW1iZXIpKG9wdHMuZmxhZyk7XG4gICAgICAgIGNvbnN0IG1vZGVOdW0gPSAoMCwgdXRpbF8xLm1vZGVUb051bWJlcikob3B0cy5tb2RlKTtcbiAgICAgICAgY29uc3QgYnVmID0gKDAsIHV0aWxfMS5kYXRhVG9CdWZmZXIpKGRhdGEsIG9wdHMuZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLndyaXRlRmlsZUJhc2UsIFtpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bV0sIGNiKTtcbiAgICB9XG4gICAgbGlua0Jhc2UoZmlsZW5hbWUxLCBmaWxlbmFtZTIpIHtcbiAgICAgICAgbGV0IGxpbmsxO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluazEgPSB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lMSwgJ2xpbmsnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBBdWdtZW50IGVycm9yIHdpdGggZmlsZW5hbWUyXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUpXG4gICAgICAgICAgICAgICAgZXJyID0gKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoZXJyLmNvZGUsICdsaW5rJywgZmlsZW5hbWUxLCBmaWxlbmFtZTIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpcm5hbWUyID0gcGF0aE1vZHVsZS5kaXJuYW1lKGZpbGVuYW1lMik7XG4gICAgICAgIGxldCBkaXIyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlyMiA9IHRoaXMuZ2V0TGlua09yVGhyb3coZGlybmFtZTIsICdsaW5rJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQXVnbWVudCBlcnJvciB3aXRoIGZpbGVuYW1lMVxuICAgICAgICAgICAgaWYgKGVyci5jb2RlKVxuICAgICAgICAgICAgICAgIGVyciA9ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKGVyci5jb2RlLCAnbGluaycsIGZpbGVuYW1lMSwgZmlsZW5hbWUyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gcGF0aE1vZHVsZS5iYXNlbmFtZShmaWxlbmFtZTIpO1xuICAgICAgICAvLyBDaGVjayBpZiBuZXcgZmlsZSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgaWYgKGRpcjIuZ2V0Q2hpbGQobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFRVhJU1QsICdsaW5rJywgZmlsZW5hbWUxLCBmaWxlbmFtZTIpO1xuICAgICAgICBjb25zdCBub2RlID0gbGluazEuZ2V0Tm9kZSgpO1xuICAgICAgICBub2RlLm5saW5rKys7XG4gICAgICAgIGRpcjIuY3JlYXRlQ2hpbGQobmFtZSwgbm9kZSk7XG4gICAgfVxuICAgIGNvcHlGaWxlQmFzZShzcmMsIGRlc3QsIGZsYWdzKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICAgIGlmIChmbGFncyAmIENPUFlGSUxFX0VYQ0wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0c1N5bmMoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFRVhJU1QsICdjb3B5RmlsZScsIHNyYywgZGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgQ09QWUZJTEVfRklDTE9ORV9GT1JDRSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRU5PU1lTLCAnY29weUZpbGUnLCBzcmMsIGRlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVGaWxlQmFzZShkZXN0LCBidWYsIGNvbnN0YW50c18yLkZMQUdTLncsIDQzOCAvKiBNT0RFLkRFRkFVTFQgKi8pO1xuICAgIH1cbiAgICBjb3B5RmlsZVN5bmMoc3JjLCBkZXN0LCBmbGFncykge1xuICAgICAgICBjb25zdCBzcmNGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHNyYyk7XG4gICAgICAgIGNvbnN0IGRlc3RGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKGRlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5RmlsZUJhc2Uoc3JjRmlsZW5hbWUsIGRlc3RGaWxlbmFtZSwgKGZsYWdzIHx8IDApIHwgMCk7XG4gICAgfVxuICAgIGNvcHlGaWxlKHNyYywgZGVzdCwgYSwgYikge1xuICAgICAgICBjb25zdCBzcmNGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHNyYyk7XG4gICAgICAgIGNvbnN0IGRlc3RGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKGRlc3QpO1xuICAgICAgICBsZXQgZmxhZ3M7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmbGFncyA9IDA7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbGFncyA9IGE7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKShjYWxsYmFjayk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuY29weUZpbGVCYXNlLCBbc3JjRmlsZW5hbWUsIGRlc3RGaWxlbmFtZSwgZmxhZ3NdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGxpbmtTeW5jKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhdGhGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKGV4aXN0aW5nUGF0aCk7XG4gICAgICAgIGNvbnN0IG5ld1BhdGhGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKG5ld1BhdGgpO1xuICAgICAgICB0aGlzLmxpbmtCYXNlKGV4aXN0aW5nUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpO1xuICAgIH1cbiAgICBsaW5rKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXRoRmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShleGlzdGluZ1BhdGgpO1xuICAgICAgICBjb25zdCBuZXdQYXRoRmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5saW5rQmFzZSwgW2V4aXN0aW5nUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHVubGlua0Jhc2UoZmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgbGluayA9IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsICd1bmxpbmsnKTtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgaXQgaXMgZmlsZSwgZGlyLCBvdGhlci4uLlxuICAgICAgICBpZiAobGluay5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRGlyIG5vdCBlbXB0eS4uLicpO1xuICAgICAgICB0aGlzLmRlbGV0ZUxpbmsobGluayk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5ubGluay0tO1xuICAgICAgICAvLyBXaGVuIGFsbCBoYXJkIGxpbmtzIHRvIGktbm9kZSBhcmUgZGVsZXRlZCwgcmVtb3ZlIHRoZSBpLW5vZGUsIHRvby5cbiAgICAgICAgaWYgKG5vZGUubmxpbmsgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubGlua1N5bmMocGF0aCkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICB0aGlzLnVubGlua0Jhc2UoZmlsZW5hbWUpO1xuICAgIH1cbiAgICB1bmxpbmsocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy51bmxpbmtCYXNlLCBbZmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHN5bWxpbmtCYXNlKHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgcGF0aFN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKHBhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIENoZWNrIGlmIGRpcmVjdG9yeSBleGlzdHMsIHdoZXJlIHdlIGFib3V0IHRvIGNyZWF0ZSBhIHN5bWxpbmsuXG4gICAgICAgIGxldCBkaXJMaW5rO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudEFzRGlyT3JUaHJvdyhwYXRoU3RlcHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIENhdGNoIGVycm9yIHRvIHBvcHVsYXRlIHdpdGggdGhlIGNvcnJlY3QgZmllbGRzIC0gZ2V0TGlua1BhcmVudEFzRGlyT3JUaHJvdyB3b24ndCBiZSBhd2FyZSBvZiB0aGUgc2Vjb25kIHBhdGhcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSlcbiAgICAgICAgICAgICAgICBlcnIgPSAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShlcnIuY29kZSwgJ3N5bWxpbmsnLCB0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gcGF0aFN0ZXBzW3BhdGhTdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbmV3IGZpbGUgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIGlmIChkaXJMaW5rLmdldENoaWxkKG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRUVYSVNULCAnc3ltbGluaycsIHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpO1xuICAgICAgICAvLyBDaGVjayBwZXJtaXNzaW9ucyBvbiB0aGUgcGF0aCB3aGVyZSB3ZSBhcmUgY3JlYXRpbmcgdGhlIHN5bWxpbmsuXG4gICAgICAgIC8vIE5vdGUgd2UncmUgbm90IGNoZWNraW5nIHBlcm1pc3Npb25zIG9uIHRoZSB0YXJnZXQgcGF0aDogSXQgaXMgbm90IGFuIGVycm9yIHRvIGNyZWF0ZSBhIHN5bWxpbmsgdG8gYVxuICAgICAgICAvLyBub24tZXhpc3RlbnQgb3IgaW5hY2Nlc3NpYmxlIHRhcmdldFxuICAgICAgICBjb25zdCBub2RlID0gZGlyTGluay5nZXROb2RlKCk7XG4gICAgICAgIGlmICghbm9kZS5jYW5FeGVjdXRlKCkgfHwgIW5vZGUuY2FuV3JpdGUoKSlcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVBQ0NFUywgJ3N5bWxpbmsnLCB0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gQ3JlYXRlIHN5bWxpbmsuXG4gICAgICAgIGNvbnN0IHN5bWxpbmsgPSBkaXJMaW5rLmNyZWF0ZUNoaWxkKG5hbWUpO1xuICAgICAgICBzeW1saW5rLmdldE5vZGUoKS5tYWtlU3ltbGluayh0YXJnZXRGaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBzeW1saW5rO1xuICAgIH1cbiAgICAvLyBgdHlwZWAgYXJndW1lbnQgd29ya3Mgb25seSBvbiBXaW5kb3dzLlxuICAgIHN5bWxpbmtTeW5jKHRhcmdldCwgcGF0aCwgdHlwZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHRhcmdldCk7XG4gICAgICAgIGNvbnN0IHBhdGhGaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICB0aGlzLnN5bWxpbmtCYXNlKHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpO1xuICAgIH1cbiAgICBzeW1saW5rKHRhcmdldCwgcGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgwLCB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaykodHlwZW9mIGEgPT09ICdmdW5jdGlvbicgPyBhIDogYik7XG4gICAgICAgIGNvbnN0IHRhcmdldEZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgcGF0aEZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuc3ltbGlua0Jhc2UsIFt0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZWFscGF0aEJhc2UoZmlsZW5hbWUsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IHJlYWxMaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCAncmVhbHBhdGgnKTtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcpKHJlYWxMaW5rLmdldFBhdGgoKSB8fCAnLycsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmVhbHBhdGhTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHBhdGhCYXNlKCgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpLCAoMCwgb3B0aW9uc18xLmdldFJlYWxwYXRoT3B0aW9ucykob3B0aW9ucykuZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZWFscGF0aChwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRzLCBjYWxsYmFja10gPSAoMCwgb3B0aW9uc18xLmdldFJlYWxwYXRoT3B0c0FuZENiKShhLCBiKTtcbiAgICAgICAgY29uc3QgcGF0aEZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVhbHBhdGhCYXNlLCBbcGF0aEZpbGVuYW1lLCBvcHRzLmVuY29kaW5nXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBsc3RhdEJhc2UoZmlsZW5hbWUsIGJpZ2ludCA9IGZhbHNlLCB0aHJvd0lmTm9FbnRyeSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBsaW5rO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGluayA9IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsICdsc3RhdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRU5PRU5UICYmICF0aHJvd0lmTm9FbnRyeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGxpbmsuZ2V0Tm9kZSgpLCBiaWdpbnQpO1xuICAgIH1cbiAgICBsc3RhdFN5bmMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHRocm93SWZOb0VudHJ5ID0gdHJ1ZSwgYmlnaW50ID0gZmFsc2UgfSA9ICgwLCBvcHRpb25zXzEuZ2V0U3RhdE9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5sc3RhdEJhc2UoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIGJpZ2ludCwgdGhyb3dJZk5vRW50cnkpO1xuICAgIH1cbiAgICBsc3RhdChwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFt7IHRocm93SWZOb0VudHJ5ID0gdHJ1ZSwgYmlnaW50ID0gZmFsc2UgfSwgY2FsbGJhY2tdID0gKDAsIG9wdGlvbnNfMS5nZXRTdGF0T3B0c0FuZENiKShhLCBiKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5sc3RhdEJhc2UsIFsoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKSwgYmlnaW50LCB0aHJvd0lmTm9FbnRyeV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RhdEJhc2UoZmlsZW5hbWUsIGJpZ2ludCA9IGZhbHNlLCB0aHJvd0lmTm9FbnRyeSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGxpbms7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCAnc3RhdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRU5PRU5UICYmICF0aHJvd0lmTm9FbnRyeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGxpbmsuZ2V0Tm9kZSgpLCBiaWdpbnQpO1xuICAgIH1cbiAgICBzdGF0U3luYyhwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmlnaW50ID0gdHJ1ZSwgdGhyb3dJZk5vRW50cnkgPSB0cnVlIH0gPSAoMCwgb3B0aW9uc18xLmdldFN0YXRPcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdEJhc2UoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIGJpZ2ludCwgdGhyb3dJZk5vRW50cnkpO1xuICAgIH1cbiAgICBzdGF0KHBhdGgsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgW3sgYmlnaW50ID0gZmFsc2UsIHRocm93SWZOb0VudHJ5ID0gdHJ1ZSB9LCBjYWxsYmFja10gPSAoMCwgb3B0aW9uc18xLmdldFN0YXRPcHRzQW5kQ2IpKGEsIGIpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnN0YXRCYXNlLCBbKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIGJpZ2ludCwgdGhyb3dJZk5vRW50cnldLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZzdGF0QmFzZShmZCwgYmlnaW50ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoZmQpO1xuICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFQkFERiwgJ2ZzdGF0Jyk7XG4gICAgICAgIHJldHVybiBTdGF0c18xLmRlZmF1bHQuYnVpbGQoZmlsZS5ub2RlLCBiaWdpbnQpO1xuICAgIH1cbiAgICBmc3RhdFN5bmMoZmQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnN0YXRCYXNlKGZkLCAoMCwgb3B0aW9uc18xLmdldFN0YXRPcHRpb25zKShvcHRpb25zKS5iaWdpbnQpO1xuICAgIH1cbiAgICBmc3RhdChmZCwgYSwgYikge1xuICAgICAgICBjb25zdCBbb3B0cywgY2FsbGJhY2tdID0gKDAsIG9wdGlvbnNfMS5nZXRTdGF0T3B0c0FuZENiKShhLCBiKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mc3RhdEJhc2UsIFtmZCwgb3B0cy5iaWdpbnRdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJlbmFtZUJhc2Uob2xkUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpIHtcbiAgICAgICAgbGV0IGxpbms7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KG9sZFBhdGhGaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gQXVnbWVudCBlcnIgd2l0aCBuZXdQYXRoRmlsZW5hbWVcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSlcbiAgICAgICAgICAgICAgICBlcnIgPSAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShlcnIuY29kZSwgJ3JlbmFtZScsIG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiBpdCBpcyBkaXJlY3RvcnksIGlmIG5vbi1lbXB0eSwgd2UgY2Fubm90IG1vdmUgaXQsIHJpZ2h0P1xuICAgICAgICAvLyBDaGVjayBkaXJlY3RvcnkgZXhpc3RzIGZvciB0aGUgbmV3IGxvY2F0aW9uLlxuICAgICAgICBsZXQgbmV3UGF0aERpckxpbms7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdQYXRoRGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudEFzRGlyT3JUaHJvdyhuZXdQYXRoRmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIEF1Z21lbnQgZXJyb3Igd2l0aCBvbGRQYXRoRmlsZW5hbWVcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSlcbiAgICAgICAgICAgICAgICBlcnIgPSAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShlcnIuY29kZSwgJ3JlbmFtZScsIG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBBbHNvIHRyZWF0IGNhc2VzIHdpdGggZGlyZWN0b3JpZXMgYW5kIHN5bWJvbGljIGxpbmtzLlxuICAgICAgICAvLyBUT0RPOiBTZWU6IGh0dHA6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9yZW5hbWUuMi5odG1sXG4gICAgICAgIC8vIFJlbW92ZSBoYXJkIGxpbmsgZnJvbSBvbGQgZm9sZGVyLlxuICAgICAgICBjb25zdCBvbGRMaW5rUGFyZW50ID0gbGluay5wYXJlbnQ7XG4gICAgICAgIC8vIENoZWNrIHdlIGhhdmUgYWNjZXNzIGFuZCB3cml0ZSBwZXJtaXNzaW9ucyBpbiBib3RoIHBsYWNlc1xuICAgICAgICBjb25zdCBvbGRQYXJlbnROb2RlID0gb2xkTGlua1BhcmVudC5nZXROb2RlKCk7XG4gICAgICAgIGNvbnN0IG5ld1BhdGhEaXJOb2RlID0gbmV3UGF0aERpckxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoIW9sZFBhcmVudE5vZGUuY2FuRXhlY3V0ZSgpIHx8XG4gICAgICAgICAgICAhb2xkUGFyZW50Tm9kZS5jYW5Xcml0ZSgpIHx8XG4gICAgICAgICAgICAhbmV3UGF0aERpck5vZGUuY2FuRXhlY3V0ZSgpIHx8XG4gICAgICAgICAgICAhbmV3UGF0aERpck5vZGUuY2FuV3JpdGUoKSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRUFDQ0VTLCAncmVuYW1lJywgb2xkUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIG9sZExpbmtQYXJlbnQuZGVsZXRlQ2hpbGQobGluayk7XG4gICAgICAgIC8vIFJlbmFtZSBzaG91bGQgb3ZlcndyaXRlIHRoZSBuZXcgcGF0aCwgaWYgdGhhdCBleGlzdHMuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXRoTW9kdWxlLmJhc2VuYW1lKG5ld1BhdGhGaWxlbmFtZSk7XG4gICAgICAgIGxpbmsubmFtZSA9IG5hbWU7XG4gICAgICAgIGxpbmsuc3RlcHMgPSBbLi4ubmV3UGF0aERpckxpbmsuc3RlcHMsIG5hbWVdO1xuICAgICAgICBuZXdQYXRoRGlyTGluay5zZXRDaGlsZChsaW5rLmdldE5hbWUoKSwgbGluayk7XG4gICAgfVxuICAgIHJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICBjb25zdCBvbGRQYXRoRmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShvbGRQYXRoKTtcbiAgICAgICAgY29uc3QgbmV3UGF0aEZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkobmV3UGF0aCk7XG4gICAgICAgIHRoaXMucmVuYW1lQmFzZShvbGRQYXRoRmlsZW5hbWUsIG5ld1BhdGhGaWxlbmFtZSk7XG4gICAgfVxuICAgIHJlbmFtZShvbGRQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBvbGRQYXRoRmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShvbGRQYXRoKTtcbiAgICAgICAgY29uc3QgbmV3UGF0aEZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkobmV3UGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVuYW1lQmFzZSwgW29sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBleGlzdHNCYXNlKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3RhdEJhc2UoZmlsZW5hbWUpO1xuICAgIH1cbiAgICBleGlzdHNTeW5jKHBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4aXN0c0Jhc2UoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGlzdHMocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IEVycm9yKGNvbnN0YW50c18yLkVSUlNUUi5DQik7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLmV4aXN0c0Jhc2UoZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY2Nlc3NCYXNlKGZpbGVuYW1lLCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCAnYWNjZXNzJyk7XG4gICAgfVxuICAgIGFjY2Vzc1N5bmMocGF0aCwgbW9kZSA9IEZfT0spIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgbW9kZSA9IG1vZGUgfCAwO1xuICAgICAgICB0aGlzLmFjY2Vzc0Jhc2UoZmlsZW5hbWUsIG1vZGUpO1xuICAgIH1cbiAgICBhY2Nlc3MocGF0aCwgYSwgYikge1xuICAgICAgICBsZXQgbW9kZSA9IEZfT0s7XG4gICAgICAgIGxldCBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtb2RlID0gYSB8IDA7IC8vIGNhc3QgdG8gbnVtYmVyXG4gICAgICAgICAgICBjYWxsYmFjayA9ICgwLCB1dGlsXzEudmFsaWRhdGVDYWxsYmFjaykoYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5hY2Nlc3NCYXNlLCBbZmlsZW5hbWUsIG1vZGVdLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGFwcGVuZEZpbGVTeW5jKGlkLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgb3B0aW9uc18xLmdldEFwcGVuZEZpbGVPcHRzKShvcHRpb25zKTtcbiAgICAgICAgLy8gZm9yY2UgYXBwZW5kIGJlaGF2aW9yIHdoZW4gdXNpbmcgYSBzdXBwbGllZCBmaWxlIGRlc2NyaXB0b3JcbiAgICAgICAgaWYgKCFvcHRzLmZsYWcgfHwgKDAsIHV0aWxfMS5pc0ZkKShpZCkpXG4gICAgICAgICAgICBvcHRzLmZsYWcgPSAnYSc7XG4gICAgICAgIHRoaXMud3JpdGVGaWxlU3luYyhpZCwgZGF0YSwgb3B0cyk7XG4gICAgfVxuICAgIGFwcGVuZEZpbGUoaWQsIGRhdGEsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgW29wdHMsIGNhbGxiYWNrXSA9ICgwLCBvcHRpb25zXzEuZ2V0QXBwZW5kRmlsZU9wdHNBbmRDYikoYSwgYik7XG4gICAgICAgIC8vIGZvcmNlIGFwcGVuZCBiZWhhdmlvciB3aGVuIHVzaW5nIGEgc3VwcGxpZWQgZmlsZSBkZXNjcmlwdG9yXG4gICAgICAgIGlmICghb3B0cy5mbGFnIHx8ICgwLCB1dGlsXzEuaXNGZCkoaWQpKVxuICAgICAgICAgICAgb3B0cy5mbGFnID0gJ2EnO1xuICAgICAgICB0aGlzLndyaXRlRmlsZShpZCwgZGF0YSwgb3B0cywgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZWFkZGlyQmFzZShmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGlua09yVGhyb3coZmlsZW5hbWUsICdzY2FuZGlyJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFub2RlLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFTk9URElSLCAnc2NhbmRpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgLy8gQ2hlY2sgd2UgaGF2ZSBwZXJtaXNzaW9uc1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVhZCgpKVxuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRUFDQ0VTLCAnc2NhbmRpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IFtdOyAvLyBvdXRwdXQgbGlzdFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbGluay5jaGlsZHJlbi5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbGluay5nZXRDaGlsZChuYW1lKTtcbiAgICAgICAgICAgIGlmICghY2hpbGQgfHwgbmFtZSA9PT0gJy4nIHx8IG5hbWUgPT09ICcuLicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsaXN0LnB1c2goRGlyZW50XzEuZGVmYXVsdC5idWlsZChjaGlsZCwgb3B0aW9ucy5lbmNvZGluZykpO1xuICAgICAgICAgICAgLy8gcmVjdXJzaW9uXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZWN1cnNpdmUgJiYgY2hpbGQuY2hpbGRyZW4uc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3Vyc2VPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyByZWN1cnNpdmU6IHRydWUsIHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRMaXN0ID0gdGhpcy5yZWFkZGlyQmFzZShjaGlsZC5nZXRQYXRoKCksIHJlY3Vyc2VPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goLi4uY2hpbGRMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxfMS5pc1dpbiAmJiBvcHRpb25zLmVuY29kaW5nICE9PSAnYnVmZmVyJylcbiAgICAgICAgICAgIGxpc3Quc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPCBiLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYS5uYW1lID4gYi5uYW1lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy53aXRoRmlsZVR5cGVzKVxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIGxldCBmaWxlbmFtZTIgPSBmaWxlbmFtZTtcbiAgICAgICAgaWYgKHV0aWxfMS5pc1dpbikge1xuICAgICAgICAgICAgZmlsZW5hbWUyID0gZmlsZW5hbWUyLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdC5tYXAoZGlyZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIGxldCBmdWxsUGF0aCA9IHBhdGhNb2R1bGUuam9pbihkaXJlbnQucGFyZW50UGF0aCwgZGlyZW50Lm5hbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxfMS5pc1dpbikge1xuICAgICAgICAgICAgICAgICAgICBmdWxsUGF0aCA9IGZ1bGxQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGxQYXRoLnJlcGxhY2UoZmlsZW5hbWUyICsgcGF0aE1vZHVsZS5wb3NpeC5zZXAsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXJlbnQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlYWRkaXJTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCBvcHRpb25zXzEuZ2V0UmVhZGRpck9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZGlyQmFzZShmaWxlbmFtZSwgb3B0cyk7XG4gICAgfVxuICAgIHJlYWRkaXIocGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBbb3B0aW9ucywgY2FsbGJhY2tdID0gKDAsIG9wdGlvbnNfMS5nZXRSZWFkZGlyT3B0c0FuZENiKShhLCBiKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZWFkZGlyQmFzZSwgW2ZpbGVuYW1lLCBvcHRpb25zXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZWFkbGlua0Jhc2UoZmlsZW5hbWUsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCAncmVhZGxpbmsnKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoIW5vZGUuaXNTeW1saW5rKCkpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFSU5WQUwsICdyZWFkbGluaycsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcpKG5vZGUuc3ltbGluaywgZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZWFkbGlua1N5bmMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIG9wdGlvbnNfMS5nZXREZWZhdWx0T3B0cykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRsaW5rQmFzZShmaWxlbmFtZSwgb3B0cy5lbmNvZGluZyk7XG4gICAgfVxuICAgIHJlYWRsaW5rKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgY29uc3QgW29wdHMsIGNhbGxiYWNrXSA9ICgwLCBvcHRpb25zXzEuZ2V0RGVmYXVsdE9wdHNBbmRDYikoYSwgYik7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVhZGxpbmtCYXNlLCBbZmlsZW5hbWUsIG9wdHMuZW5jb2RpbmddLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZzeW5jQmFzZShmZCkge1xuICAgICAgICB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2ZzeW5jJyk7XG4gICAgfVxuICAgIGZzeW5jU3luYyhmZCkge1xuICAgICAgICB0aGlzLmZzeW5jQmFzZShmZCk7XG4gICAgfVxuICAgIGZzeW5jKGZkLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmZzeW5jQmFzZSwgW2ZkXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmZGF0YXN5bmNCYXNlKGZkKSB7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZmRhdGFzeW5jJyk7XG4gICAgfVxuICAgIGZkYXRhc3luY1N5bmMoZmQpIHtcbiAgICAgICAgdGhpcy5mZGF0YXN5bmNCYXNlKGZkKTtcbiAgICB9XG4gICAgZmRhdGFzeW5jKGZkLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmZkYXRhc3luY0Jhc2UsIFtmZF0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnRydW5jYXRlQmFzZShmZCwgbGVuKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2Z0cnVuY2F0ZScpO1xuICAgICAgICBmaWxlLnRydW5jYXRlKGxlbik7XG4gICAgfVxuICAgIGZ0cnVuY2F0ZVN5bmMoZmQsIGxlbikge1xuICAgICAgICB0aGlzLmZ0cnVuY2F0ZUJhc2UoZmQsIGxlbik7XG4gICAgfVxuICAgIGZ0cnVuY2F0ZShmZCwgYSwgYikge1xuICAgICAgICBjb25zdCBsZW4gPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogMDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoMCwgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2spKHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGIgOiBhKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mdHJ1bmNhdGVCYXNlLCBbZmQsIGxlbl0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdHJ1bmNhdGVCYXNlKHBhdGgsIGxlbikge1xuICAgICAgICBjb25zdCBmZCA9IHRoaXMub3BlblN5bmMocGF0aCwgJ3IrJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZ0cnVuY2F0ZVN5bmMoZmQsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogYGlkYCBzaG91bGQgYmUgYSBmaWxlIGRlc2NyaXB0b3Igb3IgYSBwYXRoLiBgaWRgIGFzIGZpbGUgZGVzY3JpcHRvciB3aWxsXG4gICAgICogbm90IGJlIHN1cHBvcnRlZCBzb29uLlxuICAgICAqL1xuICAgIHRydW5jYXRlU3luYyhpZCwgbGVuKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmlzRmQpKGlkKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ0cnVuY2F0ZVN5bmMoaWQsIGxlbik7XG4gICAgICAgIHRoaXMudHJ1bmNhdGVCYXNlKGlkLCBsZW4pO1xuICAgIH1cbiAgICB0cnVuY2F0ZShpZCwgYSwgYikge1xuICAgICAgICBjb25zdCBsZW4gPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBhIDogMDtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoMCwgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2spKHR5cGVvZiBhID09PSAnbnVtYmVyJyA/IGIgOiBhKTtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuaXNGZCkoaWQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnRydW5jYXRlKGlkLCBsZW4sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy50cnVuY2F0ZUJhc2UsIFtpZCwgbGVuXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmdXRpbWVzQmFzZShmZCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2Z1dGltZXMnKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGZpbGUubm9kZTtcbiAgICAgICAgbm9kZS5hdGltZSA9IG5ldyBEYXRlKGF0aW1lICogMTAwMCk7XG4gICAgICAgIG5vZGUubXRpbWUgPSBuZXcgRGF0ZShtdGltZSAqIDEwMDApO1xuICAgIH1cbiAgICBmdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIHRoaXMuZnV0aW1lc0Jhc2UoZmQsIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSkpO1xuICAgIH1cbiAgICBmdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnV0aW1lc0Jhc2UsIFtmZCwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdXRpbWVzQmFzZShmaWxlbmFtZSwgYXRpbWUsIG10aW1lLCBmb2xsb3dTeW1saW5rcyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbGluayA9IGZvbGxvd1N5bWxpbmtzXG4gICAgICAgICAgICA/IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ3V0aW1lcycpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsICdsdXRpbWVzJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5hdGltZSA9IG5ldyBEYXRlKGF0aW1lICogMTAwMCk7XG4gICAgICAgIG5vZGUubXRpbWUgPSBuZXcgRGF0ZShtdGltZSAqIDEwMDApO1xuICAgIH1cbiAgICB1dGltZXNTeW5jKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICB0aGlzLnV0aW1lc0Jhc2UoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSksIHRydWUpO1xuICAgIH1cbiAgICB1dGltZXMocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnV0aW1lc0Jhc2UsIFsoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKSwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKSwgdHJ1ZV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbHV0aW1lc1N5bmMocGF0aCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIHRoaXMudXRpbWVzQmFzZSgoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKSwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKSwgZmFsc2UpO1xuICAgIH1cbiAgICBsdXRpbWVzKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy51dGltZXNCYXNlLCBbKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSksIGZhbHNlXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBta2RpckJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdXNlciB0cmllcyB0byBjcmVhdGUgcm9vdCBkaXIgYGZzLm1rZGlyU3luYygnLycpYC5cbiAgICAgICAgaWYgKCFzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVFWElTVCwgJ21rZGlyJywgZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpciA9IHRoaXMuZ2V0TGlua1BhcmVudEFzRGlyT3JUaHJvdyhmaWxlbmFtZSwgJ21rZGlyJyk7XG4gICAgICAgIC8vIENoZWNrIHBhdGggYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRpci5nZXRDaGlsZChuYW1lKSlcbiAgICAgICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVFWElTVCwgJ21rZGlyJywgZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBub2RlID0gZGlyLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFub2RlLmNhbldyaXRlKCkgfHwgIW5vZGUuY2FuRXhlY3V0ZSgpKVxuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRUFDQ0VTLCAnbWtkaXInLCBmaWxlbmFtZSk7XG4gICAgICAgIGRpci5jcmVhdGVDaGlsZChuYW1lLCB0aGlzLmNyZWF0ZU5vZGUoY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZESVIgfCBtb2RlTnVtKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZGlyZWN0b3J5IHRyZWUgcmVjdXJzaXZlbHkuXG4gICAgICovXG4gICAgbWtkaXJwQmFzZShmaWxlbmFtZSwgbW9kZU51bSkge1xuICAgICAgICBsZXQgY3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIGxldCBjdXJyID0gbnVsbDtcbiAgICAgICAgbGV0IGkgPSBzdGVwcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxvbmdlc3Qgc3VicGF0aCBvZiBmaWxlbmFtZSB0aGF0IHN0aWxsIGV4aXN0czpcbiAgICAgICAgZm9yIChpID0gc3RlcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY3VyciA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKHN0ZXBzLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgIGlmIChjdXJyKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3Vycikge1xuICAgICAgICAgICAgY3VyciA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGN1cnIgaXMgbm93IHRoZSBsYXN0IGRpcmVjdG9yeSB0aGF0IHN0aWxsIGV4aXN0cy5cbiAgICAgICAgLy8gKElmIG5vbmUgb2YgdGhlbSBleGlzdGVkLCBjdXJyIGlzIHRoZSByb290LilcbiAgICAgICAgLy8gQ2hlY2sgYWNjZXNzIHRoZSBsYXp5IHdheTpcbiAgICAgICAgY3VyciA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyhzZXAgKyBzdGVwcy5zbGljZSgwLCBpKS5qb2luKHNlcCksICdta2RpcicpO1xuICAgICAgICAvLyBTdGFydCBjcmVhdGluZyBkaXJlY3RvcmllczpcbiAgICAgICAgZm9yIChpOyBpIDwgc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjdXJyLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3ZSBoYXZlIHBlcm1pc3Npb25zXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmNhbkV4ZWN1dGUoKSB8fCAhbm9kZS5jYW5Xcml0ZSgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFQUNDRVMsICdta2RpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsXzEuY3JlYXRlRXJyb3IpKEVOT1RESVIsICdta2RpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY3VyciA9IGN1cnIuY3JlYXRlQ2hpbGQoc3RlcHNbaV0sIHRoaXMuY3JlYXRlTm9kZShjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkRJUiB8IG1vZGVOdW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlZCA/IGZpbGVuYW1lIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBta2RpclN5bmMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIG9wdGlvbnNfMS5nZXRNa2Rpck9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtb2RlTnVtID0gKDAsIHV0aWxfMS5tb2RlVG9OdW1iZXIpKG9wdHMubW9kZSwgMG83NzcpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICBpZiAob3B0cy5yZWN1cnNpdmUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ta2RpcnBCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKTtcbiAgICAgICAgdGhpcy5ta2RpckJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pO1xuICAgIH1cbiAgICBta2RpcihwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgb3B0aW9uc18xLmdldE1rZGlyT3B0aW9ucykoYSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKDAsIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKSh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyA/IGEgOiBiKTtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9ICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShvcHRzLm1vZGUsIDBvNzc3KTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgaWYgKG9wdHMucmVjdXJzaXZlKVxuICAgICAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ta2RpcnBCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubWtkaXJCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG1rZHRlbXBCYXNlKHByZWZpeCwgZW5jb2RpbmcsIHJldHJ5ID0gNSkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHByZWZpeCArICgwLCB1dGlsXzEuZ2VuUm5kU3RyNikoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubWtkaXJCYXNlKGZpbGVuYW1lLCA1MTEgLyogTU9ERS5ESVIgKi8pO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcpKGZpbGVuYW1lLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBFRVhJU1QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0cnkgPiAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ta2R0ZW1wQmFzZShwcmVmaXgsIGVuY29kaW5nLCByZXRyeSAtIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgdGVtcCBkaXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1rZHRlbXBTeW5jKHByZWZpeCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGVuY29kaW5nIH0gPSAoMCwgb3B0aW9uc18xLmdldERlZmF1bHRPcHRzKShvcHRpb25zKTtcbiAgICAgICAgaWYgKCFwcmVmaXggfHwgdHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlbmFtZSBwcmVmaXggaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgKDAsIHV0aWxfMS5udWxsQ2hlY2spKHByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLm1rZHRlbXBCYXNlKHByZWZpeCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICBta2R0ZW1wKHByZWZpeCwgYSwgYikge1xuICAgICAgICBjb25zdCBbeyBlbmNvZGluZyB9LCBjYWxsYmFja10gPSAoMCwgb3B0aW9uc18xLmdldERlZmF1bHRPcHRzQW5kQ2IpKGEsIGIpO1xuICAgICAgICBpZiAoIXByZWZpeCB8fCB0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGVuYW1lIHByZWZpeCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBpZiAoISgwLCB1dGlsXzEubnVsbENoZWNrKShwcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLm1rZHRlbXBCYXNlLCBbcHJlZml4LCBlbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcm1kaXJCYXNlKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgb3B0aW9uc18xLmdldFJtZGlyT3B0aW9ucykob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldExpbmtBc0Rpck9yVGhyb3coZmlsZW5hbWUsICdybWRpcicpO1xuICAgICAgICAvLyBDaGVjayBkaXJlY3RvcnkgaXMgZW1wdHkuXG4gICAgICAgIGlmIChsaW5rLmxlbmd0aCAmJiAhb3B0cy5yZWN1cnNpdmUpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFTk9URU1QVFksICdybWRpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kZWxldGVMaW5rKGxpbmspO1xuICAgIH1cbiAgICBybWRpclN5bmMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJtZGlyQmFzZSgoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJtZGlyKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCBvcHRpb25zXzEuZ2V0Um1kaXJPcHRpb25zKShhKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoMCwgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2spKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nID8gYSA6IGIpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJtZGlyQmFzZSwgWygwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpLCBvcHRzXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBybUJhc2UoZmlsZW5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBcInN0YXRcIiBpcyB1c2VkIHRvIG1hdGNoIE5vZGUncyBuYXRpdmUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgbGV0IGxpbms7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCAnc3RhdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIFNpbGVudGx5IGlnbm9yZSBtaXNzaW5nIHBhdGhzIGlmIGZvcmNlIG9wdGlvbiBpcyB0cnVlXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEVOT0VOVCAmJiBvcHRpb25zLmZvcmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmsuZ2V0Tm9kZSgpLmlzRGlyZWN0b3J5KCkgJiYgIW9wdGlvbnMucmVjdXJzaXZlKVxuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRVJSX0ZTX0VJU0RJUiwgJ3JtJywgZmlsZW5hbWUpO1xuICAgICAgICAvLyBDaGVjayBwZXJtaXNzaW9uc1xuICAgICAgICBpZiAoIWxpbmsucGFyZW50LmdldE5vZGUoKS5jYW5Xcml0ZSgpKVxuICAgICAgICAgICAgdGhyb3cgKDAsIHV0aWxfMS5jcmVhdGVFcnJvcikoRUFDQ0VTLCAncm0nLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZGVsZXRlTGluayhsaW5rKTtcbiAgICB9XG4gICAgcm1TeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ybUJhc2UoKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBybShwYXRoLCBhLCBiKSB7XG4gICAgICAgIGNvbnN0IFtvcHRzLCBjYWxsYmFja10gPSAoMCwgb3B0aW9uc18xLmdldFJtT3B0c0FuZENiKShhLCBiKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ybUJhc2UsIFsoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKSwgb3B0c10sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZmNobW9kQmFzZShmZCwgbW9kZU51bSkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsICdmY2htb2QnKTtcbiAgICAgICAgZmlsZS5jaG1vZChtb2RlTnVtKTtcbiAgICB9XG4gICAgZmNobW9kU3luYyhmZCwgbW9kZSkge1xuICAgICAgICB0aGlzLmZjaG1vZEJhc2UoZmQsICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShtb2RlKSk7XG4gICAgfVxuICAgIGZjaG1vZChmZCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mY2htb2RCYXNlLCBbZmQsICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShtb2RlKV0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgY2htb2RCYXNlKGZpbGVuYW1lLCBtb2RlTnVtLCBmb2xsb3dTeW1saW5rcyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbGluayA9IGZvbGxvd1N5bWxpbmtzXG4gICAgICAgICAgICA/IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ2NobW9kJylcbiAgICAgICAgICAgIDogdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ2NobW9kJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5jaG1vZChtb2RlTnVtKTtcbiAgICB9XG4gICAgY2htb2RTeW5jKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9ICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShtb2RlKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgdGhpcy5jaG1vZEJhc2UoZmlsZW5hbWUsIG1vZGVOdW0sIHRydWUpO1xuICAgIH1cbiAgICBjaG1vZChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBtb2RlTnVtID0gKDAsIHV0aWxfMS5tb2RlVG9OdW1iZXIpKG1vZGUpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmNobW9kQmFzZSwgW2ZpbGVuYW1lLCBtb2RlTnVtXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBsY2htb2RCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKSB7XG4gICAgICAgIHRoaXMuY2htb2RCYXNlKGZpbGVuYW1lLCBtb2RlTnVtLCBmYWxzZSk7XG4gICAgfVxuICAgIGxjaG1vZFN5bmMocGF0aCwgbW9kZSkge1xuICAgICAgICBjb25zdCBtb2RlTnVtID0gKDAsIHV0aWxfMS5tb2RlVG9OdW1iZXIpKG1vZGUpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICB0aGlzLmxjaG1vZEJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pO1xuICAgIH1cbiAgICBsY2htb2QocGF0aCwgbW9kZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgbW9kZU51bSA9ICgwLCB1dGlsXzEubW9kZVRvTnVtYmVyKShtb2RlKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5sY2htb2RCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZjaG93bkJhc2UoZmQsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZmNob3duJykuY2hvd24odWlkLCBnaWQpO1xuICAgIH1cbiAgICBmY2hvd25TeW5jKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB2YWxpZGF0ZVVpZCh1aWQpO1xuICAgICAgICB2YWxpZGF0ZUdpZChnaWQpO1xuICAgICAgICB0aGlzLmZjaG93bkJhc2UoZmQsIHVpZCwgZ2lkKTtcbiAgICB9XG4gICAgZmNob3duKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mY2hvd25CYXNlLCBbZmQsIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBjaG93bkJhc2UoZmlsZW5hbWUsIHVpZCwgZ2lkKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGlua09yVGhyb3coZmlsZW5hbWUsICdjaG93bicpO1xuICAgICAgICBjb25zdCBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgIG5vZGUuY2hvd24odWlkLCBnaWQpO1xuICAgICAgICAvLyBpZihub2RlLmlzRmlsZSgpIHx8IG5vZGUuaXNTeW1saW5rKCkpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfSBlbHNlIGlmKG5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBXaGF0IGRvIHdlIGRvIGhlcmU/XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgY2hvd25TeW5jKHBhdGgsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMuY2hvd25CYXNlKCgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpLCB1aWQsIGdpZCk7XG4gICAgfVxuICAgIGNob3duKHBhdGgsIHVpZCwgZ2lkLCBjYWxsYmFjaykge1xuICAgICAgICB2YWxpZGF0ZVVpZCh1aWQpO1xuICAgICAgICB2YWxpZGF0ZUdpZChnaWQpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmNob3duQmFzZSwgWygwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpLCB1aWQsIGdpZF0sIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbGNob3duQmFzZShmaWxlbmFtZSwgdWlkLCBnaWQpIHtcbiAgICAgICAgdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ2xjaG93bicpLmdldE5vZGUoKS5jaG93bih1aWQsIGdpZCk7XG4gICAgfVxuICAgIGxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy5sY2hvd25CYXNlKCgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpLCB1aWQsIGdpZCk7XG4gICAgfVxuICAgIGxjaG93bihwYXRoLCB1aWQsIGdpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5sY2hvd25CYXNlLCBbKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCksIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICB3YXRjaEZpbGUocGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGE7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGI7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGlzdGVuZXIgPSBhO1xuICAgICAgICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wid2F0Y2hGaWxlKClcIiByZXF1aXJlcyBhIGxpc3RlbmVyIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGludGVydmFsID0gNTAwNztcbiAgICAgICAgbGV0IHBlcnNpc3RlbnQgPSB0cnVlO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnRlcnZhbCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBvcHRpb25zLmludGVydmFsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBlcnNpc3RlbnQgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgICAgICBwZXJzaXN0ZW50ID0gb3B0aW9ucy5wZXJzaXN0ZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCB3YXRjaGVyID0gdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdO1xuICAgICAgICBpZiAoIXdhdGNoZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXIgPSBuZXcgdGhpcy5TdGF0V2F0Y2hlcigpO1xuICAgICAgICAgICAgd2F0Y2hlci5zdGFydChmaWxlbmFtZSwgcGVyc2lzdGVudCwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdID0gd2F0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgICB3YXRjaGVyLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB3YXRjaGVyO1xuICAgIH1cbiAgICB1bndhdGNoRmlsZShwYXRoLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICBjb25zdCB3YXRjaGVyID0gdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdO1xuICAgICAgICBpZiAoIXdhdGNoZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdhdGNoZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhdGNoZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2F0Y2hlci5saXN0ZW5lckNvdW50KCdjaGFuZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgd2F0Y2hlci5zdG9wKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3JlYXRlV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHdhdGNoKHBhdGg6IFBhdGhMaWtlKTogRlNXYXRjaGVyO1xuICAgIC8vIHdhdGNoKHBhdGg6IFBhdGhMaWtlLCBvcHRpb25zPzogSVdhdGNoT3B0aW9ucyB8IHN0cmluZyk6IEZTV2F0Y2hlcjtcbiAgICB3YXRjaChwYXRoLCBvcHRpb25zLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICBsZXQgZ2l2ZW5PcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBnaXZlbk9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgbGV0IHsgcGVyc2lzdGVudCwgcmVjdXJzaXZlLCBlbmNvZGluZyB9ID0gKDAsIG9wdGlvbnNfMS5nZXREZWZhdWx0T3B0cykoZ2l2ZW5PcHRpb25zKTtcbiAgICAgICAgaWYgKHBlcnNpc3RlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBlcnNpc3RlbnQgPSB0cnVlO1xuICAgICAgICBpZiAocmVjdXJzaXZlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IG5ldyB0aGlzLkZTV2F0Y2hlcigpO1xuICAgICAgICB3YXRjaGVyLnN0YXJ0KGZpbGVuYW1lLCBwZXJzaXN0ZW50LCByZWN1cnNpdmUsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB3YXRjaGVyLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhdGNoZXI7XG4gICAgfVxuICAgIG9wZW5kaXJCYXNlKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGlua09yVGhyb3coZmlsZW5hbWUsICdzY2FuZGlyJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFub2RlLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICB0aHJvdyAoMCwgdXRpbF8xLmNyZWF0ZUVycm9yKShFTk9URElSLCAnc2NhbmRpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXJfMS5EaXIobGluaywgb3B0aW9ucyk7XG4gICAgfVxuICAgIG9wZW5kaXJTeW5jKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9ICgwLCBvcHRpb25zXzEuZ2V0T3BlbmRpck9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuZGlyQmFzZShmaWxlbmFtZSwgb3B0cyk7XG4gICAgfVxuICAgIG9wZW5kaXIocGF0aCwgYSwgYikge1xuICAgICAgICBjb25zdCBbb3B0aW9ucywgY2FsbGJhY2tdID0gKDAsIG9wdGlvbnNfMS5nZXRPcGVuZGlyT3B0c0FuZENiKShhLCBiKTtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSAoMCwgdXRpbF8xLnBhdGhUb0ZpbGVuYW1lKShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5vcGVuZGlyQmFzZSwgW2ZpbGVuYW1lLCBvcHRpb25zXSwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuVm9sdW1lID0gVm9sdW1lO1xuLyoqXG4gKiBHbG9iYWwgZmlsZSBkZXNjcmlwdG9yIGNvdW50ZXIuIFVOSVggZmlsZSBkZXNjcmlwdG9ycyBzdGFydCBmcm9tIDAgYW5kIGdvIHNlcXVlbnRpYWxseVxuICogdXAsIHNvIGhlcmUsIGluIG9yZGVyIG5vdCB0byBjb25mbGljdCB3aXRoIHRoZW0sIHdlIGNob29zZSBzb21lIGJpZyBudW1iZXIgYW5kIGRlc2NyZWFzZVxuICogdGhlIGZpbGUgZGVzY3JpcHRvciBvZiBldmVyeSBuZXcgb3BlbmVkIGZpbGUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHRvZG8gVGhpcyBzaG91bGQgbm90IGJlIHN0YXRpYywgcmlnaHQ/XG4gKi9cblZvbHVtZS5mZCA9IDB4N2ZmZmZmZmY7XG5mdW5jdGlvbiBlbWl0U3RvcChzZWxmKSB7XG4gICAgc2VsZi5lbWl0KCdzdG9wJyk7XG59XG5jbGFzcyBTdGF0V2F0Y2hlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iodm9sKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25JbnRlcnZhbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnZvbC5zdGF0U3luYyh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNDaGFuZ2VkKHN0YXRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHN0YXRzLCB0aGlzLnByZXYpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXYgPSBzdGF0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52b2wgPSB2b2w7XG4gICAgfVxuICAgIGxvb3AoKSB7XG4gICAgICAgIHRoaXMudGltZW91dFJlZiA9IHRoaXMuc2V0VGltZW91dCh0aGlzLm9uSW50ZXJ2YWwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBoYXNDaGFuZ2VkKHN0YXRzKSB7XG4gICAgICAgIC8vIGlmKCF0aGlzLnByZXYpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRzLm10aW1lTXMgPiB0aGlzLnByZXYubXRpbWVNcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc3RhdHMubmxpbmsgIT09IHRoaXMucHJldi5ubGluaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KHBhdGgsIHBlcnNpc3RlbnQgPSB0cnVlLCBpbnRlcnZhbCA9IDUwMDcpIHtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9ICgwLCB1dGlsXzEucGF0aFRvRmlsZW5hbWUpKHBhdGgpO1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQgPSBwZXJzaXN0ZW50XG4gICAgICAgICAgICA/IHNldFRpbWVvdXQuYmluZCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsKVxuICAgICAgICAgICAgOiBzZXRUaW1lb3V0VW5yZWZfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMudm9sLnN0YXRTeW5jKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmxvb3AoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gICAgICAgICgwLCBxdWV1ZU1pY3JvdGFza18xLmRlZmF1bHQpKCgpID0+IHtcbiAgICAgICAgICAgIGVtaXRTdG9wLmNhbGwodGhpcywgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdFdhdGNoZXIgPSBTdGF0V2F0Y2hlcjtcbi8qIHRzbGludDpkaXNhYmxlIG5vLXZhci1rZXl3b3JkIHByZWZlci1jb25zdCAqL1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSZWFkU3RyZWFtXG52YXIgcG9vbDtcbmZ1bmN0aW9uIGFsbG9jTmV3UG9vbChwb29sU2l6ZSkge1xuICAgIHBvb2wgPSAoMCwgYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUpKHBvb2xTaXplKTtcbiAgICBwb29sLnVzZWQgPSAwO1xufVxudXRpbC5pbmhlcml0cyhGc1JlYWRTdHJlYW0sIHN0cmVhbV8xLlJlYWRhYmxlKTtcbmV4cG9ydHMuUmVhZFN0cmVhbSA9IEZzUmVhZFN0cmVhbTtcbmZ1bmN0aW9uIEZzUmVhZFN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRnNSZWFkU3RyZWFtKSlcbiAgICAgICAgcmV0dXJuIG5ldyBGc1JlYWRTdHJlYW0odm9sLCBwYXRoLCBvcHRpb25zKTtcbiAgICB0aGlzLl92b2wgPSB2b2w7XG4gICAgLy8gYSBsaXR0bGUgYml0IGJpZ2dlciBidWZmZXIgYW5kIHdhdGVyIG1hcmtzIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgKDAsIG9wdGlvbnNfMS5nZXRPcHRpb25zKShvcHRpb25zLCB7fSkpO1xuICAgIGlmIChvcHRpb25zLmhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucy5oaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0O1xuICAgIHN0cmVhbV8xLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5wYXRoID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgdGhpcy5mZCA9IG9wdGlvbnMuZmQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0eXBlb2Ygb3B0aW9ucy5mZCAhPT0gJ251bWJlcicgPyBvcHRpb25zLmZkLmZkIDogb3B0aW9ucy5mZDtcbiAgICB0aGlzLmZsYWdzID0gb3B0aW9ucy5mbGFncyA9PT0gdW5kZWZpbmVkID8gJ3InIDogb3B0aW9ucy5mbGFncztcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCA/IDBvNjY2IDogb3B0aW9ucy5tb2RlO1xuICAgIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gb3B0aW9ucy5lbmQ7XG4gICAgdGhpcy5hdXRvQ2xvc2UgPSBvcHRpb25zLmF1dG9DbG9zZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYXV0b0Nsb3NlO1xuICAgIHRoaXMucG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMDtcbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic3RhcnRcIiBvcHRpb24gbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmVuZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5kXCIgb3B0aW9uIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic3RhcnRcIiBvcHRpb24gbXVzdCBiZSA8PSBcImVuZFwiIG9wdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgdGhpcy5fdm9sLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIChlciwgZmQpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5mZCA9IGZkO1xuICAgICAgICBzZWxmLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEuXG4gICAgICAgIHNlbGYucmVhZCgpO1xuICAgIH0pO1xufTtcbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWQobik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCBrTWluUG9vbFNwYWNlKSB7XG4gICAgICAgIC8vIGRpc2NhcmQgdGhlIG9sZCBwb29sLlxuICAgICAgICBhbGxvY05ld1Bvb2wodGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICB9XG4gICAgLy8gR3JhYiBhbm90aGVyIHJlZmVyZW5jZSB0byB0aGUgcG9vbCBpbiB0aGUgY2FzZSB0aGF0IHdoaWxlIHdlJ3JlXG4gICAgLy8gaW4gdGhlIHRocmVhZCBwb29sIGFub3RoZXIgcmVhZCgpIGZpbmlzaGVzIHVwIHRoZSBwb29sLCBhbmRcbiAgICAvLyBhbGxvY2F0ZXMgYSBuZXcgb25lLlxuICAgIHZhciB0aGlzUG9vbCA9IHBvb2w7XG4gICAgdmFyIHRvUmVhZCA9IE1hdGgubWluKHBvb2wubGVuZ3RoIC0gcG9vbC51c2VkLCBuKTtcbiAgICB2YXIgc3RhcnQgPSBwb29sLnVzZWQ7XG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRvUmVhZCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5wb3MgKyAxLCB0b1JlYWQpO1xuICAgIC8vIGFscmVhZHkgcmVhZCBldmVyeXRoaW5nIHdlIHdlcmUgc3VwcG9zZWQgdG8gcmVhZCFcbiAgICAvLyB0cmVhdCBhcyBFT0YuXG4gICAgaWYgKHRvUmVhZCA8PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKG51bGwpO1xuICAgIC8vIHRoZSBhY3R1YWwgcmVhZC5cbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgdGhpcy5fdm9sLnJlYWQodGhpcy5mZCwgcG9vbCwgcG9vbC51c2VkLCB0b1JlYWQsIHRoaXMucG9zLCBvbnJlYWQpO1xuICAgIC8vIG1vdmUgdGhlIHBvb2wgcG9zaXRpb25zLCBhbmQgaW50ZXJuYWwgcG9zaXRpb24gZm9yIHJlYWRpbmcuXG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMucG9zICs9IHRvUmVhZDtcbiAgICBwb29sLnVzZWQgKz0gdG9SZWFkO1xuICAgIGZ1bmN0aW9uIG9ucmVhZChlciwgYnl0ZXNSZWFkKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0Nsb3NlICYmIHNlbGYuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ieXRlc1JlYWQgKz0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzUG9vbC5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlc1JlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICAgIHRoaXMuY2xvc2UoZXJyMiA9PiB7XG4gICAgICAgIGNiKGVyciB8fCBlcnIyKTtcbiAgICB9KTtcbn07XG5Gc1JlYWRTdHJlYW0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChjYilcbiAgICAgICAgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcbiAgICBpZiAodGhpcy5jbG9zZWQgfHwgdHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlT25PcGVuKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHF1ZXVlTWljcm90YXNrXzEuZGVmYXVsdCkoKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKTtcbiAgICB9XG4gICAgLy8gU2luY2UgTm9kZSAxOCwgdGhlcmUgaXMgb25seSBhIGdldHRlciBmb3IgJy5jbG9zZWQnLlxuICAgIC8vIFRoZSBmaXJzdCBicmFuY2ggbWltaWNzIG90aGVyIHNldHRlcnMgZnJvbSBSZWFkYWJsZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE4LjAuMC9saWIvaW50ZXJuYWwvc3RyZWFtcy9yZWFkYWJsZS5qcyNMMTI0M1xuICAgIGlmICh0eXBlb2YgKChfYSA9IHRoaXMuX3JlYWRhYmxlU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZWQpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl92b2wuY2xvc2UodGhpcy5mZCwgZXIgPT4ge1xuICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSk7XG4gICAgdGhpcy5mZCA9IG51bGw7XG59O1xuLy8gbmVlZGVkIGJlY2F1c2UgYXMgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHNcbi8vIHRoYXQgZG9lcyBub3QgbWF0Y2ggdGhpcy5jbG9zZSgpIHNpZ25hdHVyZVxuZnVuY3Rpb24gY2xvc2VPbk9wZW4oZmQpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG59XG51dGlsLmluaGVyaXRzKEZzV3JpdGVTdHJlYW0sIHN0cmVhbV8xLldyaXRhYmxlKTtcbmV4cG9ydHMuV3JpdGVTdHJlYW0gPSBGc1dyaXRlU3RyZWFtO1xuZnVuY3Rpb24gRnNXcml0ZVN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRnNXcml0ZVN0cmVhbSkpXG4gICAgICAgIHJldHVybiBuZXcgRnNXcml0ZVN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpO1xuICAgIHRoaXMuX3ZvbCA9IHZvbDtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgKDAsIG9wdGlvbnNfMS5nZXRPcHRpb25zKShvcHRpb25zLCB7fSkpO1xuICAgIHN0cmVhbV8xLldyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5wYXRoID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgdGhpcy5mZCA9IG9wdGlvbnMuZmQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0eXBlb2Ygb3B0aW9ucy5mZCAhPT0gJ251bWJlcicgPyBvcHRpb25zLmZkLmZkIDogb3B0aW9ucy5mZDtcbiAgICB0aGlzLmZsYWdzID0gb3B0aW9ucy5mbGFncyA9PT0gdW5kZWZpbmVkID8gJ3cnIDogb3B0aW9ucy5mbGFncztcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgPT09IHVuZGVmaW5lZCA/IDBvNjY2IDogb3B0aW9ucy5tb2RlO1xuICAgIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuYXV0b0Nsb3NlID0gb3B0aW9ucy5hdXRvQ2xvc2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdGlvbnMuYXV0b0Nsb3NlO1xuICAgIHRoaXMucG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzdGFydFwiIG9wdGlvbiBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic3RhcnRcIiBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuY29kaW5nKVxuICAgICAgICB0aGlzLnNldERlZmF1bHRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAvLyBkaXNwb3NlIG9uIGZpbmlzaC5cbiAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdm9sLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UgJiYgdGhpcy5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmQgPSBmZDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgYnVmZmVyXzEuQnVmZmVyIHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YScpKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShkYXRhLCBlbmNvZGluZywgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLXRoaXMtYXNzaWdubWVudFxuICAgIHRoaXMuX3ZvbC53cml0ZSh0aGlzLmZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgdGhpcy5wb3MsIChlciwgYnl0ZXMpID0+IHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UgJiYgc2VsZi5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgICAgICBjYigpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnBvcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLnBvcyArPSBkYXRhLmxlbmd0aDtcbn07XG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGV2ID0gZnVuY3Rpb24gKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGV2KGRhdGEsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLXRoaXMtYXNzaWdubWVudFxuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjaHVuayA9IGRhdGFbaV0uY2h1bms7XG4gICAgICAgIGNodW5rc1tpXSA9IGNodW5rO1xuICAgICAgICBzaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgIHRoaXMuX3ZvbC53cml0ZSh0aGlzLmZkLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXMucG9zLCAoZXIsIGJ5dGVzKSA9PiB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGVzdHJveSlcbiAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ieXRlc1dyaXR0ZW4gKz0gYnl0ZXM7XG4gICAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMucG9zICs9IHNpemU7XG59O1xuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGNiKVxuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuICAgIGlmICh0aGlzLmNsb3NlZCB8fCB0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2VPbk9wZW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgcXVldWVNaWNyb3Rhc2tfMS5kZWZhdWx0KSgoKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJykpO1xuICAgIH1cbiAgICAvLyBTaW5jZSBOb2RlIDE4LCB0aGVyZSBpcyBvbmx5IGEgZ2V0dGVyIGZvciAnLmNsb3NlZCcuXG4gICAgLy8gVGhlIGZpcnN0IGJyYW5jaCBtaW1pY3Mgb3RoZXIgc2V0dGVycyBmcm9tIFdyaXRhYmxlLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92MTguMC4wL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3dyaXRhYmxlLmpzI0w3NjZcbiAgICBpZiAodHlwZW9mICgoX2EgPSB0aGlzLl93cml0YWJsZVN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2VkKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fdm9sLmNsb3NlKHRoaXMuZmQsIGVyID0+IHtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIHRoaXMuZmQgPSBudWxsO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveTtcbi8vIFRoZXJlIGlzIG5vIHNodXRkb3duKCkgZm9yIGZpbGVzLlxuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveVNvb24gPSBGc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5lbmQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZTV2F0Y2hlclxuY2xhc3MgRlNXYXRjaGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2b2wpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5fZmlsZW5hbWVFbmNvZGVkID0gJyc7XG4gICAgICAgIC8vIF9wZXJzaXN0ZW50OiBib29sZWFuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2RpbmdfMS5FTkNPRElOR19VVEY4O1xuICAgICAgICAvLyBpbm9kZSAtPiByZW1vdmVyc1xuICAgICAgICB0aGlzLl9saXN0ZW5lclJlbW92ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9vblBhcmVudENoaWxkID0gKGxpbmspID0+IHtcbiAgICAgICAgICAgIGlmIChsaW5rLmdldE5hbWUoKSA9PT0gdGhpcy5fZ2V0TmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgncmVuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VtaXQgPSAodHlwZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB0eXBlLCB0aGlzLl9maWxlbmFtZUVuY29kZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wZXJzaXN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX3BlcnNpc3QsIDFlNik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3ZvbCA9IHZvbDtcbiAgICAgICAgLy8gVE9ETzogRW1pdCBcImVycm9yXCIgbWVzc2FnZXMgd2hlbiB3YXRjaGluZy5cbiAgICAgICAgLy8gdGhpcy5faGFuZGxlLm9uY2hhbmdlID0gZnVuY3Rpb24oc3RhdHVzLCBldmVudFR5cGUsIGZpbGVuYW1lKSB7XG4gICAgICAgIC8vICAgICBpZiAoc3RhdHVzIDwgMCkge1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuX2hhbmRsZS5jbG9zZSgpO1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IGVycm9yID0gIWZpbGVuYW1lID9cbiAgICAgICAgLy8gICAgICAgICAgICAgZXJybm9FeGNlcHRpb24oc3RhdHVzLCAnRXJyb3Igd2F0Y2hpbmcgZmlsZSBmb3IgY2hhbmdlczonKSA6XG4gICAgICAgIC8vICAgICAgICAgICAgIGVycm5vRXhjZXB0aW9uKHN0YXR1cywgYEVycm9yIHdhdGNoaW5nIGZpbGUgJHtmaWxlbmFtZX0gZm9yIGNoYW5nZXM6YCk7XG4gICAgICAgIC8vICAgICAgICAgZXJyb3IuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLmVtaXQoJ2NoYW5nZScsIGV2ZW50VHlwZSwgZmlsZW5hbWUpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9O1xuICAgIH1cbiAgICBfZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzW3RoaXMuX3N0ZXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzdGFydChwYXRoLCBwZXJzaXN0ZW50ID0gdHJ1ZSwgcmVjdXJzaXZlID0gZmFsc2UsIGVuY29kaW5nID0gZW5jb2RpbmdfMS5FTkNPRElOR19VVEY4KSB7XG4gICAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIHV0aWxfMS5wYXRoVG9GaWxlbmFtZSkocGF0aCk7XG4gICAgICAgIHRoaXMuX3N0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKHRoaXMuX2ZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5fZmlsZW5hbWVFbmNvZGVkID0gKDAsIGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZykodGhpcy5fZmlsZW5hbWUpO1xuICAgICAgICAvLyB0aGlzLl9wZXJzaXN0ZW50ID0gcGVyc2lzdGVudDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlID0gcmVjdXJzaXZlO1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fbGluayA9IHRoaXMuX3ZvbC5nZXRMaW5rT3JUaHJvdyh0aGlzLl9maWxlbmFtZSwgJ0ZTV2F0Y2hlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGB3YXRjaCAke3RoaXMuX2ZpbGVuYW1lfSAke2Vyci5jb2RlfWApO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IGVyci5jb2RlO1xuICAgICAgICAgICAgZXJyb3IuZXJybm8gPSBlcnIuY29kZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhdGNoTGlua05vZGVDaGFuZ2VkID0gKGxpbmspID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVwYXRoID0gbGluay5nZXRQYXRoKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgICAgICBjb25zdCBvbk5vZGVDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gcmVsYXRpdmUodGhpcy5fZmlsZW5hbWUsIGZpbGVwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gdGhpcy5fZ2V0TmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdjaGFuZ2UnLCAnY2hhbmdlJywgZmlsZW5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGUub24oJ2NoYW5nZScsIG9uTm9kZUNoYW5nZSk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVycyA9IChfYSA9IHRoaXMuX2xpc3RlbmVyUmVtb3ZlcnMuZ2V0KG5vZGUuaW5vKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICByZW1vdmVycy5wdXNoKCgpID0+IG5vZGUucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIG9uTm9kZUNoYW5nZSkpO1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJSZW1vdmVycy5zZXQobm9kZS5pbm8sIHJlbW92ZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2F0Y2hMaW5rQ2hpbGRyZW5DaGFuZ2VkID0gKGxpbmspID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgICAgIC8vIHdoZW4gYSBuZXcgbGluayBhZGRlZFxuICAgICAgICAgICAgY29uc3Qgb25MaW5rQ2hpbGRBZGQgPSAobCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgJ3JlbmFtZScsIHJlbGF0aXZlKHRoaXMuX2ZpbGVuYW1lLCBsLmdldFBhdGgoKSkpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyAxLiB3YXRjaCBjaGFuZ2VzIG9mIHRoZSBuZXcgbGluay1ub2RlXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoTGlua05vZGVDaGFuZ2VkKGwpO1xuICAgICAgICAgICAgICAgICAgICAvLyAyLiB3YXRjaCBjaGFuZ2VzIG9mIHRoZSBuZXcgbGluay1ub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hMaW5rQ2hpbGRyZW5DaGFuZ2VkKGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHdoZW4gYSBuZXcgbGluayBkZWxldGVkXG4gICAgICAgICAgICBjb25zdCBvbkxpbmtDaGlsZERlbGV0ZSA9IChsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgdGhlIGNoaWxkcmVuIG5vZGVzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlTGlua05vZGVMaXN0ZW5lcnMgPSAoY3VyTGluaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm8gPSBjdXJMaW5rLmdldE5vZGUoKS5pbm87XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZXJzID0gdGhpcy5fbGlzdGVuZXJSZW1vdmVycy5nZXQoaW5vKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVycy5mb3JFYWNoKHIgPT4gcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyUmVtb3ZlcnMuZGVsZXRlKGlubyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgY2hpbGRMaW5rXSBvZiBjdXJMaW5rLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTGluayAmJiBuYW1lICE9PSAnLicgJiYgbmFtZSAhPT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpbmtOb2RlTGlzdGVuZXJzKGNoaWxkTGluayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlbW92ZUxpbmtOb2RlTGlzdGVuZXJzKGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgJ3JlbmFtZScsIHJlbGF0aXZlKHRoaXMuX2ZpbGVuYW1lLCBsLmdldFBhdGgoKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuIG5vZGVzIGNoYW5nZWRcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGNoaWxkTGlua10gb2YgbGluay5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRMaW5rICYmIG5hbWUgIT09ICcuJyAmJiBuYW1lICE9PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdGNoTGlua05vZGVDaGFuZ2VkKGNoaWxkTGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGluayBjaGlsZHJlbiBhZGQvcmVtb3ZlXG4gICAgICAgICAgICBsaW5rLm9uKCdjaGlsZDphZGQnLCBvbkxpbmtDaGlsZEFkZCk7XG4gICAgICAgICAgICBsaW5rLm9uKCdjaGlsZDpkZWxldGUnLCBvbkxpbmtDaGlsZERlbGV0ZSk7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVycyA9IChfYSA9IHRoaXMuX2xpc3RlbmVyUmVtb3ZlcnMuZ2V0KG5vZGUuaW5vKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICByZW1vdmVycy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsaW5rLnJlbW92ZUxpc3RlbmVyKCdjaGlsZDphZGQnLCBvbkxpbmtDaGlsZEFkZCk7XG4gICAgICAgICAgICAgICAgbGluay5yZW1vdmVMaXN0ZW5lcignY2hpbGQ6ZGVsZXRlJywgb25MaW5rQ2hpbGREZWxldGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgY2hpbGRMaW5rXSBvZiBsaW5rLmNoaWxkcmVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRMaW5rICYmIG5hbWUgIT09ICcuJyAmJiBuYW1lICE9PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaExpbmtDaGlsZHJlbkNoYW5nZWQoY2hpbGRMaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2F0Y2hMaW5rTm9kZUNoYW5nZWQodGhpcy5fbGluayk7XG4gICAgICAgIHdhdGNoTGlua0NoaWxkcmVuQ2hhbmdlZCh0aGlzLl9saW5rKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudC5vbignY2hpbGQ6YWRkJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgICAgICBwYXJlbnQuc2V0TWF4TGlzdGVuZXJzKHBhcmVudC5nZXRNYXhMaXN0ZW5lcnMoKSArIDEpO1xuICAgICAgICAgICAgcGFyZW50Lm9uKCdjaGlsZDpkZWxldGUnLCB0aGlzLl9vblBhcmVudENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyc2lzdGVudClcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3QoKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyUmVtb3ZlcnMuZm9yRWFjaChyZW1vdmVycyA9PiB7XG4gICAgICAgICAgICByZW1vdmVycy5mb3JFYWNoKHIgPT4gcigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyUmVtb3ZlcnMuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudC5yZW1vdmVMaXN0ZW5lcignY2hpbGQ6YWRkJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlTGlzdGVuZXIoJ2NoaWxkOmRlbGV0ZScsIHRoaXMuX29uUGFyZW50Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GU1dhdGNoZXIgPSBGU1dhdGNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12b2x1bWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZzU3luY2hyb25vdXNBcGlMaXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5mc1N5bmNocm9ub3VzQXBpTGlzdCA9IFtcbiAgICAnYWNjZXNzU3luYycsXG4gICAgJ2FwcGVuZEZpbGVTeW5jJyxcbiAgICAnY2htb2RTeW5jJyxcbiAgICAnY2hvd25TeW5jJyxcbiAgICAnY2xvc2VTeW5jJyxcbiAgICAnY29weUZpbGVTeW5jJyxcbiAgICAnZXhpc3RzU3luYycsXG4gICAgJ2ZjaG1vZFN5bmMnLFxuICAgICdmY2hvd25TeW5jJyxcbiAgICAnZmRhdGFzeW5jU3luYycsXG4gICAgJ2ZzdGF0U3luYycsXG4gICAgJ2ZzeW5jU3luYycsXG4gICAgJ2Z0cnVuY2F0ZVN5bmMnLFxuICAgICdmdXRpbWVzU3luYycsXG4gICAgJ2xjaG1vZFN5bmMnLFxuICAgICdsY2hvd25TeW5jJyxcbiAgICAnbGlua1N5bmMnLFxuICAgICdsc3RhdFN5bmMnLFxuICAgICdta2RpclN5bmMnLFxuICAgICdta2R0ZW1wU3luYycsXG4gICAgJ29wZW5TeW5jJyxcbiAgICAncmVhZGRpclN5bmMnLFxuICAgICdyZWFkRmlsZVN5bmMnLFxuICAgICdyZWFkbGlua1N5bmMnLFxuICAgICdyZWFkU3luYycsXG4gICAgJ3JlYWR2U3luYycsXG4gICAgJ3JlYWxwYXRoU3luYycsXG4gICAgJ3JlbmFtZVN5bmMnLFxuICAgICdybWRpclN5bmMnLFxuICAgICdybVN5bmMnLFxuICAgICdzdGF0U3luYycsXG4gICAgJ3N5bWxpbmtTeW5jJyxcbiAgICAndHJ1bmNhdGVTeW5jJyxcbiAgICAndW5saW5rU3luYycsXG4gICAgJ3V0aW1lc1N5bmMnLFxuICAgICdsdXRpbWVzU3luYycsXG4gICAgJ3dyaXRlRmlsZVN5bmMnLFxuICAgICd3cml0ZVN5bmMnLFxuICAgICd3cml0ZXZTeW5jJyxcbiAgICAvLyAnY3BTeW5jJyxcbiAgICAvLyAnc3RhdGZzU3luYycsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnNTeW5jaHJvbm91c0FwaUxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZzQ2FsbGJhY2tBcGlMaXN0ID0gdm9pZCAwO1xuZXhwb3J0cy5mc0NhbGxiYWNrQXBpTGlzdCA9IFtcbiAgICAnYWNjZXNzJyxcbiAgICAnYXBwZW5kRmlsZScsXG4gICAgJ2NobW9kJyxcbiAgICAnY2hvd24nLFxuICAgICdjbG9zZScsXG4gICAgJ2NvcHlGaWxlJyxcbiAgICAnY3JlYXRlUmVhZFN0cmVhbScsXG4gICAgJ2NyZWF0ZVdyaXRlU3RyZWFtJyxcbiAgICAnZXhpc3RzJyxcbiAgICAnZmNobW9kJyxcbiAgICAnZmNob3duJyxcbiAgICAnZmRhdGFzeW5jJyxcbiAgICAnZnN0YXQnLFxuICAgICdmc3luYycsXG4gICAgJ2Z0cnVuY2F0ZScsXG4gICAgJ2Z1dGltZXMnLFxuICAgICdsY2htb2QnLFxuICAgICdsY2hvd24nLFxuICAgICdsaW5rJyxcbiAgICAnbHN0YXQnLFxuICAgICdta2RpcicsXG4gICAgJ21rZHRlbXAnLFxuICAgICdvcGVuJyxcbiAgICAncmVhZCcsXG4gICAgJ3JlYWR2JyxcbiAgICAncmVhZGRpcicsXG4gICAgJ3JlYWRGaWxlJyxcbiAgICAncmVhZGxpbmsnLFxuICAgICdyZWFscGF0aCcsXG4gICAgJ3JlbmFtZScsXG4gICAgJ3JtJyxcbiAgICAncm1kaXInLFxuICAgICdzdGF0JyxcbiAgICAnc3ltbGluaycsXG4gICAgJ3RydW5jYXRlJyxcbiAgICAndW5saW5rJyxcbiAgICAndW53YXRjaEZpbGUnLFxuICAgICd1dGltZXMnLFxuICAgICdsdXRpbWVzJyxcbiAgICAnd2F0Y2gnLFxuICAgICd3YXRjaEZpbGUnLFxuICAgICd3cml0ZScsXG4gICAgJ3dyaXRldicsXG4gICAgJ3dyaXRlRmlsZScsXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnNDYWxsYmFja0FwaUxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1lbWZzID0gZXhwb3J0cy5mcyA9IGV4cG9ydHMudm9sID0gZXhwb3J0cy5Wb2x1bWUgPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZUZzRnJvbVZvbHVtZSA9IGNyZWF0ZUZzRnJvbVZvbHVtZTtcbmNvbnN0IFN0YXRzXzEgPSByZXF1aXJlKFwiLi9TdGF0c1wiKTtcbmNvbnN0IERpcmVudF8xID0gcmVxdWlyZShcIi4vRGlyZW50XCIpO1xuY29uc3Qgdm9sdW1lXzEgPSByZXF1aXJlKFwiLi92b2x1bWVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb2x1bWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvbHVtZV8xLlZvbHVtZTsgfSB9KTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZnNTeW5jaHJvbm91c0FwaUxpc3RfMSA9IHJlcXVpcmUoXCIuL25vZGUvbGlzdHMvZnNTeW5jaHJvbm91c0FwaUxpc3RcIik7XG5jb25zdCBmc0NhbGxiYWNrQXBpTGlzdF8xID0gcmVxdWlyZShcIi4vbm9kZS9saXN0cy9mc0NhbGxiYWNrQXBpTGlzdFwiKTtcbmNvbnN0IHsgRl9PSywgUl9PSywgV19PSywgWF9PSyB9ID0gY29uc3RhbnRzXzEuY29uc3RhbnRzO1xuLy8gRGVmYXVsdCB2b2x1bWUuXG5leHBvcnRzLnZvbCA9IG5ldyB2b2x1bWVfMS5Wb2x1bWUoKTtcbmZ1bmN0aW9uIGNyZWF0ZUZzRnJvbVZvbHVtZSh2b2wpIHtcbiAgICBjb25zdCBmcyA9IHsgRl9PSywgUl9PSywgV19PSywgWF9PSywgY29uc3RhbnRzOiBjb25zdGFudHNfMS5jb25zdGFudHMsIFN0YXRzOiBTdGF0c18xLmRlZmF1bHQsIERpcmVudDogRGlyZW50XzEuZGVmYXVsdCB9O1xuICAgIC8vIEJpbmQgRlMgbWV0aG9kcy5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBmc1N5bmNocm9ub3VzQXBpTGlzdF8xLmZzU3luY2hyb25vdXNBcGlMaXN0KVxuICAgICAgICBpZiAodHlwZW9mIHZvbFttZXRob2RdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZnNbbWV0aG9kXSA9IHZvbFttZXRob2RdLmJpbmQodm9sKTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBmc0NhbGxiYWNrQXBpTGlzdF8xLmZzQ2FsbGJhY2tBcGlMaXN0KVxuICAgICAgICBpZiAodHlwZW9mIHZvbFttZXRob2RdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZnNbbWV0aG9kXSA9IHZvbFttZXRob2RdLmJpbmQodm9sKTtcbiAgICBmcy5TdGF0V2F0Y2hlciA9IHZvbC5TdGF0V2F0Y2hlcjtcbiAgICBmcy5GU1dhdGNoZXIgPSB2b2wuRlNXYXRjaGVyO1xuICAgIGZzLldyaXRlU3RyZWFtID0gdm9sLldyaXRlU3RyZWFtO1xuICAgIGZzLlJlYWRTdHJlYW0gPSB2b2wuUmVhZFN0cmVhbTtcbiAgICBmcy5wcm9taXNlcyA9IHZvbC5wcm9taXNlcztcbiAgICBmcy5fdG9Vbml4VGltZXN0YW1wID0gdm9sdW1lXzEudG9Vbml4VGltZXN0YW1wO1xuICAgIGZzLl9fdm9sID0gdm9sO1xuICAgIHJldHVybiBmcztcbn1cbmV4cG9ydHMuZnMgPSBjcmVhdGVGc0Zyb21Wb2x1bWUoZXhwb3J0cy52b2wpO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGUgc3lzdGVtIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBqc29uIEZpbGUgc3lzdGVtIHN0cnVjdHVyZSBleHByZXNzZWQgYXMgYSBKU09OIG9iamVjdC5cbiAqICAgICAgICBVc2UgYG51bGxgIGZvciBlbXB0eSBkaXJlY3RvcmllcyBhbmQgZW1wdHkgc3RyaW5nIGZvciBlbXB0eSBmaWxlcy5cbiAqIEBwYXJhbSBjd2QgQ3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS4gVGhlIEpTT04gc3RydWN0dXJlIHdpbGwgYmUgY3JlYXRlZFxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoaXMgcGF0aC5cbiAqIEByZXR1cm5zIEEgYG1lbWZzYCBmaWxlIHN5c3RlbSBpbnN0YW5jZSwgd2hpY2ggaXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvclxuICogICAgICAgICAgdGhlIGBmc2AgbW9kdWxlLlxuICovXG5jb25zdCBtZW1mcyA9IChqc29uID0ge30sIGN3ZCA9ICcvJykgPT4ge1xuICAgIGNvbnN0IHZvbCA9IHZvbHVtZV8xLlZvbHVtZS5mcm9tTmVzdGVkSlNPTihqc29uLCBjd2QpO1xuICAgIGNvbnN0IGZzID0gY3JlYXRlRnNGcm9tVm9sdW1lKHZvbCk7XG4gICAgcmV0dXJuIHsgZnMsIHZvbCB9O1xufTtcbmV4cG9ydHMubWVtZnMgPSBtZW1mcztcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtb2R1bGUuZXhwb3J0cyksIGV4cG9ydHMuZnMpO1xubW9kdWxlLmV4cG9ydHMuc2VtYW50aWMgPSB0cnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0ICogYXMgbWVtZnNFeHBvcnRlZCBmcm9tICdtZW1mcydcblxuY29uc3QgeyBjcmVhdGVGc0Zyb21Wb2x1bWUsIFZvbHVtZSwgZnMsIG1lbWZzIH0gPSBtZW1mc0V4cG9ydGVkXG5cbmV4cG9ydCB7IGNyZWF0ZUZzRnJvbVZvbHVtZSwgVm9sdW1lLCBmcywgbWVtZnMsIG1lbWZzRXhwb3J0ZWQgfVxuIl0sIm5hbWVzIjpbImNvbnN0YW50cyIsIlN0YXRzXzEiLCJyZXF1aXJlJCQwIiwiU3RhdHMiLCJiYXNlNjQuZnJvbUJ5dGVBcnJheSIsImllZWU3NTQucmVhZCIsImllZWU3NTQud3JpdGUiLCJlcnJvcnMiLCJiYXNlNjQudG9CeXRlQXJyYXkiLCJhc3NlcnRNb2R1bGUiLCJicm93c2VyTW9kdWxlIiwicHJpbW9yZGlhbHMiLCJ1dGlsJDEiLCJ1dGlsIiwiaGFzUmVxdWlyZWRFcnJvcnMiLCJyZXF1aXJlRXJyb3JzIiwicmVxdWlyZUluc3BlY3QiLCJ2YWxpZGF0b3JzIiwiaGFzUmVxdWlyZWRWYWxpZGF0b3JzIiwicmVxdWlyZVZhbGlkYXRvcnMiLCJoYXNSZXF1aXJlZENvbnN0YW50cyIsInJlcXVpcmVDb25zdGFudHMiLCJ1cmwiLCJoYXNSZXF1aXJlZFVybCIsInJlcXVpcmVVcmwiLCJoYXNSZXF1aXJlZEluc3BlY3QiLCJwcm9jZXNzIiwiaW5zcGVjdCIsIlByb3h5IiwicmVxdWlyZSQkMSIsImdsb2JhbCIsIkRpcmVudF8xIiwiRGlyZW50IiwicHJvY2Vzc18xIiwiZXZlbnRzTW9kdWxlIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwicXVldWVNaWNyb3Rhc2tfMSIsInNldFRpbWVvdXRVbnJlZl8xIiwic2V0VGltZW91dFVucmVmIiwicmVxdWlyZSQkNSIsInV0aWxzIiwiZW5kT2ZTdHJlYW1Nb2R1bGUiLCJyZXF1aXJlJCQ2IiwicmVxdWlyZSQkNyIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsInJlcXVpcmUkJDEyIiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxNCIsInJlcXVpcmUkJDE1Iiwic3RyZWFtTW9kdWxlIiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNyIsInJlcXVpcmUkJDE4IiwidGhpcyIsInVuZGVmaW5lZCIsInJlcXVpcmUkJDE5IiwicmVxdWlyZSQkMjAiLCJyZXF1aXJlJCQyMSIsInJlcXVpcmUkJDIyIiwicmVxdWlyZSQkMjMiLCJyZXF1aXJlJCQyNCIsImxpYiIsIkZpbGVIYW5kbGVfMSIsIkZpbGVIYW5kbGUiLCJGc1Byb21pc2VzXzEiLCJGc1Byb21pc2VzIiwicHJpbnRUcmVlXzEiLCJwcmludFRyZWUiLCJwcmludEJpbmFyeV8xIiwicHJpbnRCaW5hcnkiLCJEaXJfMSIsIkRpciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsQ0FBQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQWMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDQSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQVksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEVBQUUsQ0FBQztBQUM3RCxDQUFpQkEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDMUIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFpQixDQUFHLENBQUEsQ0FBQTtDQUNoQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxFQUFFLENBQUM7Q0FDWCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxFQUFFLENBQUM7Q0FDWCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEVBQUUsQ0FBQztDQUNULENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDYixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDZCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDZCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFJLENBQUEsQ0FBQSxDQUFBO0NBQ2IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ2QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQTtDQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUNkLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEVBQUUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ2YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBRSxDQUFBO0NBQ1gsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQUcsQ0FBQSxDQUFBO0NBQ1gsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsRUFBRSxDQUFHLENBQUEsQ0FBQTtDQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUcsQ0FBQSxDQUFBO0NBQ1osQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsRUFBRSxDQUFJLENBQUEsQ0FBQSxDQUFBO0NBQ2QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVcsRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ2pCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ2xCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sRUFBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ2YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxFQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDZixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsRUFBRSxDQUFJLENBQUEsQ0FBQSxDQUFBO0NBQ2hCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUcsQ0FBQSxDQUFBO0NBQ1osQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBRyxDQUFBLENBQUE7Q0FDWixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFHLENBQUEsQ0FBQTtDQUNaLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUUsQ0FBQTtDQUNYLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUUsQ0FBQTtDQUNYLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUUsQ0FBQTtDQUNYLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUUsQ0FBQTtDQUNYLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUM7Q0FDVixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFDO0NBQ1YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBQztDQUNWLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUM7Q0FDVixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFDO0NBQ1YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEVBQUUsQ0FBQztDQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxFQUFFLENBQUM7Q0FDUCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksRUFBRSxDQUFDO0NBQ1AsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEVBQUUsQ0FBQztDQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFpQixFQUFFLENBQUM7Q0FDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFzQixFQUFFLENBQUM7Q0FDekIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFtQixFQUFFLENBQUM7Q0FDdEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFzQixFQUFFLENBQUM7Q0FDekIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUE0QixFQUFFLENBQUM7Q0FDL0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLEVBQUUsQ0FBQztDQUNoQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWdCLEVBQUUsQ0FBQztDQUNuQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQXNCLEVBQUUsQ0FBQztDQUM1QixDQUFBO0FBQ0Q7Ozs7Ozs7OztBQ25EQSxDQUFBLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBYyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUNDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBWSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksRUFBRSxDQUFDO0FBQzdELENBQWFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUN0QixDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVcsQ0FBR0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBc0IsQ0FBQSxDQUFBO0NBQzFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEVBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLE9BQU8sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxPQUFPLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDeEcsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFDO0NBQ1IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEtBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLEVBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsS0FBSyxDQUFFLENBQUE7QUFDdkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksS0FBSyxDQUFFLENBQUE7QUFDakMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsR0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQ3RELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWEsQ0FBRyxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sR0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFDO0FBQ25GLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxLQUFLLENBQUMsQ0FBQSxDQUFBLENBQUcsR0FBRyxDQUFhLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsR0FBRyxDQUFDO0FBQ3RDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEtBQUssQ0FBQyxDQUFBLENBQUEsQ0FBRyxHQUFHLENBQWEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxHQUFHLENBQUM7Q0FDOUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsYUFBYSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUM7QUFDN0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsS0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sR0FBRyxDQUFhLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsSUFBSSxDQUFDO0NBQ25DLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxhQUFhLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUM7Q0FDbkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBYSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDO0FBQ2xELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEtBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxHQUFHLENBQWEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUM7QUFDdkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMzQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzNCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDM0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ3ZCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDO0NBQzlDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDO0NBQzlDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxPQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDO0FBQ3RELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMvQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFXLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUMzQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxNQUFNLENBQUUsQ0FBQTtBQUNwQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFZLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsTUFBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsT0FBTyxDQUFDO0FBQ3JFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxPQUFPLENBQUM7QUFDckUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBWSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLE9BQU8sQ0FBQztBQUNyRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFZLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFZLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3ZDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsS0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFHLEdBQUcsQ0FBYSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQztDQUM1QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxhQUFhLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQztDQUNyQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLGFBQWEsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUM7QUFDL0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsT0FBTyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ0ksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBa0IsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBRSxDQUFBO0NBQ3pCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN4RCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksV0FBVyxDQUFHLENBQUEsQ0FBQTtBQUNsQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxPQUFPLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFrQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxPQUFPLENBQUM7QUFDL0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBRyxDQUFBLENBQUE7QUFDYixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxPQUFPLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFrQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxPQUFPLENBQUM7QUFDL0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLGFBQWEsQ0FBRyxDQUFBLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsT0FBTyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBa0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsT0FBTyxDQUFDO0FBQy9DLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxpQkFBaUIsQ0FBRyxDQUFBLENBQUE7QUFDeEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsT0FBTyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBa0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsT0FBTyxDQUFDO0FBQy9DLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxjQUFjLENBQUcsQ0FBQSxDQUFBO0FBQ3JCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLE9BQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQWtCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLE9BQU8sQ0FBQztBQUMvQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksTUFBTSxDQUFHLENBQUEsQ0FBQTtBQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLE9BQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQWtCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLE9BQU8sQ0FBQztBQUMvQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksUUFBUSxDQUFHLENBQUEsQ0FBQTtBQUNmLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLE9BQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQWtCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFFBQVEsQ0FBQztBQUNoRCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7QUFDQSxDQUFBRCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUdFLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckIsQ0FBQUYsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBR0UsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBa0IsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNyQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBbUIsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3RCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBcUIsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFeEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLFNBQVMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ2hCLENBQUEsQ0FBQSxDQUFBLENBQUksR0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLFVBQVUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFM0QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLEtBQUssQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFBLENBQUUsR0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sRUFBRSxDQUFDLENBQUEsQ0FBQSxDQUFHLEdBQUcsQ0FBRSxDQUFBLENBQUEsQ0FBRSxDQUFDLENBQUUsQ0FBQTtBQUNqRCxDQUFBLENBQUEsQ0FBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFDLENBQUE7Q0FDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ2xDLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUMvQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7Q0FFL0IsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRSxDQUFBO0FBQ3ZCLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFaEIsQ0FBQSxDQUFBLENBQUUsSUFBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBRSxDQUFBO0FBQ25CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQWdELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwRSxDQUFBLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBRSxJQUFJLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxHQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDaEMsQ0FBQSxDQUFBLENBQUUsSUFBSSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFbEMsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUMvQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNOLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUE7O0FBRXZCLENBQUEsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQWUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25DLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDQSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ3hCLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFDLENBQUE7QUFDdkIsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFBO0NBQzVCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUMsQ0FBQyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsZUFBZSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsRCxDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsV0FBVyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLGVBQWUsQ0FBRSxDQUFBO0NBQ3BELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUMsQ0FBQyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsZUFBZSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsRCxDQUFBOztDQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRSxDQUFBO0FBQzNCLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDeEIsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUMsQ0FBQTtBQUN2QixDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFlLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFDLENBQUE7O0FBRTlCLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLGVBQWUsQ0FBQyxDQUFBOztDQUU3RCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxPQUFPLENBQUcsQ0FBQSxDQUFBLENBQUE7O0FBRWhCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZSxDQUFHLENBQUEsQ0FBQTtBQUM5QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLFFBQVEsQ0FBRyxDQUFBLENBQUE7Q0FDWCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRU4sQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ04sQ0FBQSxDQUFBLENBQUUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQy9CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBO0NBQ0QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRSxDQUFBLENBQUEsQ0FBQTtBQUN6QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksRUFBRSxDQUFDLENBQUE7QUFDOUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFBO0NBQ3ZDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQTtDQUNqQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFFLENBQUEsQ0FBQyxHQUFHLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQy9CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUUsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2xDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxHQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxFQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsR0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzNCLENBQUEsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQzdCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBO0NBQ0QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUE7QUFDeEMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQTtBQUM1QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sRUFBRSxDQUFDLENBQUEsQ0FBQSxDQUFHLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMzQixDQUFBLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFlLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUM3QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQTtDQUNELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQSxDQUFBLENBQUE7QUFDekMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFBO0FBQzdDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUE7Q0FDeEMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBRSxDQUFBLENBQUMsR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbEMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEVBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDM0IsQ0FBQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDVCxDQUFBOztDQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFlLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUE7Q0FDN0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sTUFBTSxDQUFDLENBQUEsQ0FBQSxDQUFHLElBQUksQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFHLElBQUksQ0FBQyxDQUFBO0FBQ2pDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUcsSUFBSSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsSUFBSSxDQUFDLENBQUE7QUFDNUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBQyxDQUFBLENBQUEsQ0FBRyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsSUFBSSxDQUFDLENBQUE7QUFDM0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUNyQixDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsV0FBVyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLEVBQUUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxHQUFHLENBQUUsQ0FBQTtBQUN6QyxDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ0osQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDZixDQUFBLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRSxDQUFBO0FBQ3ZDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBO0NBQ0QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDM0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQTtBQUNwQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBZSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxHQUFHLENBQUMsQ0FBQTtBQUNwQyxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRSxDQUFBO0FBQ3ZCLENBQUE7O0NBRUEsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBYSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQTtBQUMvQixDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ04sQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsQixDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ3hCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEtBQUssQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ1osQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBYyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUU1QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFFLEtBQUssQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFBLENBQUUsSUFBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxHQUFHLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxFQUFFLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxjQUFjLENBQUUsQ0FBQTtDQUN0RSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxXQUFXLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFjLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFjLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUE7QUFDL0YsQ0FBQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQ3hCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFHLEdBQUcsQ0FBQyxDQUFBO0NBQ25CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUNkLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFBO0NBQ2hCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQUMsQ0FBQTtDQUN6QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNOLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBRSxDQUFBO0FBQy9CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsR0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUcsR0FBRyxDQUFDLENBQUE7Q0FDM0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQ2QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksRUFBRSxDQUFDLENBQUE7Q0FDakIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFHLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBQyxDQUFBO0NBQ3pCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQUMsQ0FBQTtDQUN6QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUUsQ0FBQTtBQUN0QixDQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUNwSkEsQ0FBWSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxVQUFVLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsTUFBTSxDQUFFLENBQUE7Q0FDM0QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFFLENBQUEsQ0FBQTtDQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDbkMsQ0FBQSxDQUFBLENBQUUsSUFBSSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzNCLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ3BCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEtBQUssQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ1osQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEMsQ0FBQSxDQUFBLENBQUUsSUFBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ3RCLENBQUEsQ0FBQSxDQUFFLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sR0FBRyxDQUFDLENBQUE7O0FBRTNCLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBOztDQUVMLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUE7Q0FDNUIsQ0FBQSxDQUFBLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNmLENBQUEsQ0FBQSxDQUFFLEtBQUssQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ1QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFBOztDQUUxRSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBO0NBQzVCLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDZixDQUFBLENBQUEsQ0FBRSxLQUFLLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUNULENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBRSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQTs7QUFFNUUsQ0FBQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQTtDQUNYLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNaLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxJQUFJLENBQUUsQ0FBQTtBQUN6QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzdDLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDTCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDeEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1osQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUUsQ0FBQSxDQUFDLEdBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUNoRCxDQUFBLENBQUE7O0FBRUEsQ0FBQSxPQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsTUFBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLE1BQU0sQ0FBRSxDQUFBO0FBQ3JFLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQTtDQUNWLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDbkMsQ0FBQSxDQUFBLENBQUUsSUFBSSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzNCLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ3BCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLEVBQUUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxFQUFFLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUE7Q0FDL0QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQTtBQUNoQyxDQUFBLENBQUEsQ0FBRSxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNyQixDQUFBLENBQUEsQ0FBRSxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsS0FBSyxDQUFHLENBQUEsQ0FBQSxDQUFDLEtBQUssQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxHQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBOztBQUU1RCxDQUFBLENBQUEsQ0FBRSxLQUFLLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztDQUV0QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFFLENBQUE7Q0FDdEMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsS0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUMzQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1IsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNULENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxLQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDN0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUUsQ0FBQTtBQUMzQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBO0FBQ1AsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNYLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFFLENBQUE7Q0FDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBRSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3pDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFFLENBQUE7QUFDeEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQTtBQUNQLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQUUsQ0FBQTtBQUMzQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNWLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssTUFBTSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsR0FBRyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUUsQ0FBQTtBQUMvQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxHQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksSUFBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxFQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtDQUN4QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7Q0FDTCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUMsQ0FBQSxDQUFFLEtBQUssQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMzRCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNWLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBOztDQUVFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFBOztBQUVoRixDQUFBLENBQUEsQ0FBRSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BCLENBQUEsQ0FBQSxDQUFFLElBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0NBQ1IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFBOztDQUU3RSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFHLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoQyxDQUFBLENBQUE7Ozs7OztBQ3BGQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFNQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFtQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3pCLENBQUEsQ0FBRSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdEUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sTUFBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUMsNEJBQTRCLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2pELENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRU4sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0saUJBQWlCLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFMUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sWUFBWSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3JCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLFVBQVUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRW5CLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7QUFDQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQW1CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQWlCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUU5QyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQW1CLElBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLEtBQUssQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqRSxDQUFBLENBQUEsQ0FBQSxDQUFJLE9BQU8sQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssVUFBVSxDQUFFLENBQUE7QUFDekMsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDZixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQTJFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQy9FLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDSixDQUFBLENBQUEsQ0FBQTtBQUNBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLGlCQUFpQixDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQzlCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQ04sQ0FBQSxDQUFBLENBQUEsQ0FBSSxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUMsQ0FBQTtBQUNoQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBRSxDQUFBLENBQUEsQ0FBQTtBQUNsRCxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBYyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsS0FBSyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckQsQ0FBQSxDQUFBLENBQUEsQ0FBSSxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFjLENBQUMsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBRyxFQUFFLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3pCLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUNkLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1gsQ0FBQSxDQUFBO0FBQ0E7O0FBRUEsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxjQUFjLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFFLENBQUE7QUFDbEQsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsRUFBRSxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxFQUFFLENBQVksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsUUFBUSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdkMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEIsQ0FBQSxDQUFBO0FBQ0EsQ0FBQyxDQUFBOztBQUVELENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsY0FBYyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLFFBQVEsQ0FBRSxDQUFBO0FBQ2xELENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLEVBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUNsQixDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuQixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFFBQVEsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3ZDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEIsQ0FBQSxDQUFBO0FBQ0EsQ0FBQyxDQUFBOztBQUVELENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFZLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUE7QUFDL0IsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBRSxDQUFBO0FBQzdCLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sSUFBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsYUFBYSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxHQUFHLENBQWdDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbEYsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUUsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25DLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQWMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM3QyxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDVDs7QUFFQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsTUFBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFnQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsTUFBTSxDQUFFLENBQUE7QUFDaEQsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLFFBQVEsQ0FBRSxDQUFBO0FBQy9CLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQWdCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxRQUFRLENBQUUsQ0FBQTtBQUM5QyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxJQUFJLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3pCLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBO0FBQzFCLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxPQUFPLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxHQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQixFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzNDOztBQUVBLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUV0QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxJQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFnQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsTUFBTSxDQUFFLENBQUE7QUFDaEQsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLFFBQVEsQ0FBRSxDQUFBO0FBQ2pDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLEVBQUUsQ0FBZ0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDN0MsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxJQUFJLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLE1BQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFFLENBQUE7QUFDakMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQWEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDOUIsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRSxDQUFBO0FBQ3JCLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sSUFBSSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN2QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUE2RSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbkYsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFzQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzVELENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLElBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsV0FBVyxDQUFDLENBQUEsQ0FBQTtBQUNwQyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLENBQUMsQ0FBQyxDQUFFLENBQUE7QUFDeEQsQ0FBQSxDQUFBLENBQUEsQ0FBSSxPQUFPLENBQWUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsS0FBSyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZ0IsRUFBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMxRCxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFpQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFXLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzlDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsaUJBQWlCLENBQUMsQ0FBQSxDQUFBO0FBQzNDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFpQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQTtBQUMvRCxDQUFBLENBQUEsQ0FBQSxDQUFJLE9BQU8sQ0FBZSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxLQUFLLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQixFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFELENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssUUFBUSxDQUFFLENBQUE7QUFDakMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxJQUFJLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3ZCLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBOztBQUVBLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxPQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoRCxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxPQUFPLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLEtBQUssQ0FBRSxDQUFBO0FBQzVDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQWdCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN4RCxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzVCLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRWhCLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxJQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDakUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxLQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFXLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFFLENBQUE7QUFDdkQsQ0FBQSxDQUFBLENBQUEsQ0FBSSxPQUFPLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUMsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWdCLEVBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEYsQ0FBQSxDQUFBOztBQUVBLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxJQUFJLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3JCLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBNkUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2pGLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFzQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFELENBQUEsQ0FBQTtBQUNBOztBQUVBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxLQUFLLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQixDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBO0FBQ3pELENBQUEsQ0FBRSxPQUFPLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxLQUFLLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQixFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzdDLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxjQUFjLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDNUQsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFeEMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFFLENBQUE7QUFDM0IsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxRQUFRLENBQUUsQ0FBQTtBQUNoQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUF3QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoRSxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFFLENBQUE7QUFDdkIsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxJQUFJLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxhQUFhLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksR0FBRyxDQUFnQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2hGLENBQUEsQ0FBQTtBQUNBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLEtBQUssQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksRUFBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxRQUFRLENBQUUsQ0FBQTtBQUN0QyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFFLENBQUE7QUFDakIsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUM1QixDQUFBLENBQUE7QUFDQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFFLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQy9CLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBWSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDOUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLFlBQVksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUNwQyxDQUFBLENBQUE7QUFDQSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUE7QUFDMUI7O0FBRUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxLQUFLLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsSUFBSSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUUsQ0FBQTtBQUMvQyxDQUFBLENBQUUsT0FBTyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxJQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEVBQUUsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25DLENBQUE7O0FBRUEsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQTtBQUM1QixDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBWSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxHQUFHLENBQUM7QUFDdEQ7O0FBRUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLElBQUksQ0FBRSxDQUFBO0FBQ3JDLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUE7QUFDekIsQ0FBQTtBQUNBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxJQUFJLENBQUUsQ0FBQTtBQUN6QyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFXLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQ3pCLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLFFBQVEsQ0FBRSxDQUFBO0FBQ3ZDLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLE9BQU8sQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxRQUFRLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBRSxDQUFBO0FBQ3ZELENBQUEsQ0FBQSxDQUFBLENBQUksUUFBUSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNmLENBQUEsQ0FBQTs7QUFFQSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsVUFBVSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFDLENBQUUsQ0FBQTtBQUNwQyxDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBb0IsR0FBRyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdkQsQ0FBQSxDQUFBOztBQUVBLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNoRCxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBWSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRS9CLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUUzQyxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBO0FBQ3pCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDN0IsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNUOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWEsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFFLENBQUE7QUFDL0IsQ0FBQSxDQUFFLE1BQU0sQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsR0FBRyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsS0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNoRSxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2pDLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUUsQ0FBQTtBQUN0QyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3hCLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNUOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWEsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUUsQ0FBQTtBQUNuQyxDQUFBLENBQUUsSUFBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsU0FBUyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUUsQ0FBQTtBQUN6QyxDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3pDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBZSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3hFLENBQUEsQ0FBQTtBQUNBLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQWEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoQzs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxlQUFlLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxNQUFNLENBQUUsQ0FBQTtBQUNyRCxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUUsQ0FBQTtBQUN2RCxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQXNDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDL0QsQ0FBQSxDQUFBOztBQUVBLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFDLENBQUUsQ0FBQTtBQUNyRCxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQXNDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDL0QsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ04sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksVUFBVSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsSUFBSSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssU0FBUyxDQUFFLENBQUE7QUFDeEQsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM5QixDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxTQUFTLENBQUUsQ0FBQTtBQUNuQyxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxVQUFVLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLEVBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFDLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxHQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsRCxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFjLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxHQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRTdDLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNUOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUUsQ0FBQTtBQUMxQixDQUFBLENBQUUsSUFBSSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFFBQVEsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUUsQ0FBQTtBQUM1QixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ3RDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBOztBQUVoQyxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFFLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDYixDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUVBLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFDLENBQUEsQ0FBRSxDQUFDLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQzNCLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssU0FBUyxDQUFFLENBQUE7QUFDaEMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBRyxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVcsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBRSxDQUFBO0FBQ25FLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBWSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDO0FBQzNCLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBYSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBO0FBQzVCLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksS0FBSyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxPQUFPLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRSxDQUFBO0FBQ3hELENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQ2pDLENBQUEsQ0FBQTtBQUNBOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQTtBQUMxQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBRSxDQUFBO0FBQzlCLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBaUQsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMxRSxDQUF5QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLEdBQUcsQ0FBWSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxRQUFRLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFFLENBQUEsQ0FBQTtBQUNBLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLE1BQU0sQ0FBRyxDQUFBLENBQUE7QUFDbEI7O0FBRUEsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBO0FBQzdCLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxNQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN6QixDQUFBLENBQUEsQ0FBQSxDQUFJLE1BQU0sQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNiLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxPQUFPLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM3Qjs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxTQUFTLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFFLENBQUE7QUFDeEMsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksSUFBSSxDQUFDLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDMUIsQ0FBQTs7QUFFQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLE9BQU8sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsT0FBTyxDQUFFLENBQUEsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFFLENBQUE7QUFDekMsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDLENBQUMsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFFLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFDLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMxRSxDQUFBLENBQUUsSUFBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUMsQ0FBQyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUMsQ0FBQyxDQUFDLENBQUUsQ0FBQTtBQUNsRCxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLElBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdkIsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNOLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxFQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRXRCLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1osQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRVosQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQyxDQUFBLENBQUUsQ0FBQyxDQUFDLENBQUUsQ0FBQSxDQUFDLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUUsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUN0RCxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUFBO0FBQ3ZCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUNiLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxFQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQixDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsRUFBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BCLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsU0FBUyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxRQUFRLENBQUUsQ0FBQTtBQUNuRCxDQUFBLENBQUUsUUFBUSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFdBQVcsQ0FBRSxDQUFBLENBQUEsQ0FBQTtBQUN4QyxDQUFBLENBQUEsQ0FBQSxDQUFJLEtBQUssQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2QsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2YsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUEsQ0FBQSxDQUFJLEtBQUssQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2pCLENBQUEsQ0FBQSxDQUFBLENBQUksS0FBSyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDakIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2YsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUEsQ0FBQSxDQUFBLENBQUksS0FBSyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDYixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDSixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDYixDQUFBLENBQUE7QUFDQSxDQUFBOztBQUVBLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxNQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUE7QUFDL0MsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxPQUFPLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUUsQ0FBQTtBQUM1QixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUE2QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckUsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxJQUFJLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFFLENBQUE7QUFDekIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQztBQUN6QixDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNOLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFFLENBQUE7QUFDNUIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDYixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFFLENBQUE7QUFDdEMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sTUFBTSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN4QixDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxNQUFNLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLE1BQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVcsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFDLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNaLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBRSxDQUFBO0FBQ3BDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQyxDQUFBO0FBQ3BCLENBQUEsQ0FBQSxDQUFBLENBQUksSUFBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsR0FBRyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUUsQ0FBQTtBQUNyQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUcsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQTtBQUM1QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsUUFBUSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFFLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUN4RCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDNUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxVQUFVLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUE7QUFDckMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUcsQ0FBQSxDQUFBO0FBQ2IsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDVixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQ3RDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUE2QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdkUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1gsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2YsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFFLENBQUE7QUFDdkMsQ0FBQSxDQUFFLElBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxRQUFRLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFFLENBQUE7QUFDL0IsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLE1BQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbEIsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVcsQ0FBQyxDQUFFLENBQUE7QUFDckUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLE1BQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsQixDQUFBLENBQUE7QUFDQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxRQUFRLENBQUUsQ0FBQTtBQUNsQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLElBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdkIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBNEUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsRixDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQixHQUFHLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2hDLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckIsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbEUsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsRUFBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUV0QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksV0FBVyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEIsQ0FBQSxDQUFFLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1gsQ0FBQSxDQUFBLENBQUEsQ0FBSSxRQUFRLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNmLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDakIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckIsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sR0FBRyxDQUFHLENBQUEsQ0FBQTtBQUNyQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoQixDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxHQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN2QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNyQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ04sQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksV0FBVyxDQUFFLENBQUE7QUFDekIsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxXQUFXLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM1RCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsUUFBUSxDQUFHLENBQUEsQ0FBQSxDQUFDLEVBQUUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLEVBQUUsQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM5QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsV0FBVyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3RCLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7QUFDQTtBQUNBLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsVUFBVSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUVwQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxZQUFZLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLEdBQUcsQ0FBRSxDQUFBO0FBQzdDLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLFdBQVcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUVwQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksS0FBSyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsSUFBSSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFFLENBQUE7QUFDeEMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxLQUFLLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDWixDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLElBQUksQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUUsQ0FBQTtBQUMzQixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNYLENBQUEsQ0FBQTs7QUFFQSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUE7QUFDOUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDZixDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUNoQixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNYLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxHQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLENBQUUsS0FBSyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUViLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQTtBQUNwQixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNYLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFNUIsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sSUFBSSxDQUFFLENBQUE7QUFDZixDQUFBLENBQUEsQ0FBQSxDQUFJLFFBQVEsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsT0FBTyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxJQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFHLENBQUEsQ0FBQTs7QUFFeEMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLE9BQU8sQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxJQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFHLENBQUEsQ0FBQTs7QUFFekMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxPQUFPLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxJQUFJLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFHLENBQUEsQ0FBQTs7QUFFMUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbkIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sS0FBSyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbkIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLE9BQU8sQ0FBVyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsSUFBSSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLEVBQUUsQ0FBRyxDQUFBLENBQUE7O0FBRTNDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxPQUFPLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLElBQUksQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxFQUFFLENBQUcsQ0FBQSxDQUFBOztBQUUzQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2pCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxLQUFLLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNyQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsT0FBTyxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLElBQUksQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxFQUFFLENBQUcsQ0FBQSxDQUFBOztBQUU1QyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ04sQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksV0FBVyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sSUFBSSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQW9CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzVFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxRQUFRLENBQUcsQ0FBQSxDQUFBLENBQUMsUUFBUSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsRUFBRSxDQUFXLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzlDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxXQUFXLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdEIsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQTtBQUNBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFN0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsSUFBSSxDQUFFLENBQUEsQ0FBQyxFQUFFLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBRSxDQUFBO0FBQ3hCLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFDLENBQUE7QUFDZixDQUFBLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ1osQ0FBQSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNUOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLE1BQU0sQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUM3QyxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUEsQ0FBRSxJQUFJLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBRSxDQUFBO0FBQ3JCLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBMkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEUsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRSxDQUFBO0FBQ25DLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBRSxDQUFBLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDdkIsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDVCxDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLE1BQU0sQ0FBSSxDQUFBLENBQUEsQ0FBQTtBQUM3QyxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25CLENBQUEsQ0FBRSxJQUFJLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBRSxDQUFBO0FBQ3JCLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBMkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEUsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRSxDQUFBO0FBQ25DLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBRSxDQUFBLENBQUMsR0FBRyxDQUFDLENBQUE7QUFDdkIsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFFLENBQUEsQ0FBQyxHQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBO0FBQzNCLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxNQUFNLENBQUksQ0FBQSxDQUFBLENBQUE7QUFDN0MsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuQixDQUFBLENBQUUsSUFBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUUsQ0FBQTtBQUNyQixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQTJDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BFLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUUsQ0FBQTtBQUNuQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFBO0FBQ3ZCLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRSxDQUFBLENBQUMsR0FBRyxDQUFDLENBQUEsQ0FBRSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQTtBQUMzQixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUUsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUE7QUFDM0IsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFFLENBQUEsQ0FBQyxHQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBO0FBQzNCLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsUUFBUSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxRQUFRLENBQUksQ0FBQSxDQUFBLENBQUE7QUFDakQsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN0QixDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxFQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMzQixDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEtBQUssQ0FBQyxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRSxDQUFBLENBQUMsRUFBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM5RCxDQUFBLENBQUUsT0FBTyxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLEtBQUssQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLEVBQUUsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDM0MsQ0FBQTs7QUFFQSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFNBQVMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQWMsR0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFNBQVMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRW5ELENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsU0FBUyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEdBQUcsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQzlDLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBQyxDQUEyQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDMUUsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxFQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDekIsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sTUFBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFDLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3JDLENBQUE7O0FBRUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLE9BQU8sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsT0FBTyxDQUFJLENBQUEsQ0FBQSxDQUFBO0FBQy9DLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1osQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEdBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2QsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFHLEdBQUcsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLFFBQVEsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFDLENBQUEsQ0FBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsRUFBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25FLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBRSxHQUFHLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNoQyxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM1QixDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBSSxtQkFBbUIsQ0FBRSxDQUFBO0FBQ3pCLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBbUIsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMzRDs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxTQUFTLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxLQUFLLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxFQUFFLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxPQUFPLENBQUUsQ0FBQTtBQUNyRixDQUFBLENBQUUsSUFBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFDLENBQUUsQ0FBQTtBQUN0QyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsSUFBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqRSxDQUFBLENBQUE7QUFDQSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsUUFBUSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBRSxDQUFBO0FBQ2hDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sSUFBSSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN2QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFrRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN4RSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFnQixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdkMsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUUsQ0FBQTtBQUMzQixDQUFBLENBQUEsQ0FBQSxDQUFJLEtBQUssQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNaLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFFLENBQUE7QUFDekIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEdBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDbkMsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUUsQ0FBQTtBQUMvQixDQUFBLENBQUEsQ0FBQSxDQUFJLFNBQVMsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNoQixDQUFBLENBQUE7QUFDQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFFLENBQUE7QUFDN0IsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuQixDQUFBLENBQUE7O0FBRUEsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksS0FBSyxDQUFHLENBQUEsQ0FBQSxDQUFDLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsTUFBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLElBQUksQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sR0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFFLENBQUE7QUFDbEYsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFvQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzdDLENBQUEsQ0FBQTs7QUFFQSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxTQUFTLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxJQUFJLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEdBQUcsQ0FBRSxDQUFBO0FBQzVDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNYLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFFLENBQUE7QUFDNUIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1gsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxLQUFLLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDYixDQUFBLENBQUUsR0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1gsQ0FBQSxDQUFFLFNBQVMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUUsT0FBTyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUVmLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLEVBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFOUIsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BCLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2hCLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxHQUFHLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQTs7QUFFM0IsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLFFBQVEsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEQsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLFVBQVUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUcsQ0FBQSxDQUFBLENBQUE7O0FBRTVDLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUUsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUNoQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFFLENBQUE7QUFDdkMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFBO0FBQ3RCLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxFQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQixDQUFBLENBQUUsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsRUFBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BCLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFvQixDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUUsQ0FBQTtBQUN2RSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFFLElBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLEVBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUVsQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssUUFBUSxDQUFFLENBQUE7QUFDdEMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxRQUFRLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDZixDQUFBLENBQUEsQ0FBQSxDQUFJLFVBQVUsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUNqQixDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsVUFBVSxDQUFFLENBQUE7QUFDdEMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxVQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDakIsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLFdBQVcsQ0FBRSxDQUFBO0FBQ3ZDLENBQUEsQ0FBQSxDQUFBLENBQUksVUFBVSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDakIsQ0FBQSxDQUFBO0FBQ0EsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzFCLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFFLENBQUE7QUFDL0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFDLElBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUE7QUFDN0MsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBRSxVQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuRCxDQUFBLENBQUUsSUFBSSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUUsQ0FBQTtBQUNuQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ3RDLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUUsQ0FBQTtBQUM3QixDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRyxDQUFBLENBQUEsQ0FBQTtBQUMxQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDaEIsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLFFBQVEsQ0FBRSxDQUFBO0FBQy9CLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsR0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxFQUFFLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ25DLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxJQUFJLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsUUFBUSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBRSxDQUFBO0FBQzVCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBQyxDQUFFLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2IsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFZLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQTtBQUM5RCxDQUFBLENBQUEsQ0FBRyxNQUFNLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssUUFBUSxDQUFFLENBQUE7QUFDdEMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNwQixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksT0FBTyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsU0FBUyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRSxDQUFBO0FBQzVELENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksR0FBRyxDQUFFLENBQUE7QUFDZixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxFQUFFLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDeEUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNiLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUcsRUFBRSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzVFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBWSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxFQUFFLENBQUcsQ0FBQSxDQUFBO0FBQ2hFLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQXNDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDNUQ7O0FBRUEsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFFLENBQUE7QUFDNUQsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksU0FBUyxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ2xCLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDdEIsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFdEIsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFFLENBQUE7QUFDOUIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxRQUFRLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFXLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzNDLENBQUEsQ0FBQSxDQUFBLENBQUksSUFBSSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLE1BQU0sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsS0FBSyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNuRCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsUUFBUSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsSUFBSSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLFVBQVUsQ0FBRSxDQUFBO0FBQzNELENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFHLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUM1QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2YsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxTQUFTLENBQUcsQ0FBQSxDQUFBLENBQUE7QUFDbEIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sU0FBUyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbkIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sU0FBUyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDbkIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sVUFBVSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEIsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsU0FBUyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFFLENBQUE7QUFDekIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUUsQ0FBQTtBQUN6QixDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBQztBQUNsQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDWCxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxPQUFPLENBQUcsQ0FBQSxDQUFBLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUMzQyxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBOztBQUVBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxHQUFHLENBQUUsQ0FBQTtBQUNYLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxVQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNyQixDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFFLENBQUUsQ0FBQTtBQUM3QyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLElBQUksQ0FBQyxDQUFBLENBQUEsQ0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLEVBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUssRUFBRSxDQUFHLENBQUEsQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQzlFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUSxJQUFJLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUUsQ0FBQSxDQUFBLENBQUUsVUFBVSxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQzVDLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2IsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksVUFBVSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLEVBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN4QyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsVUFBVSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckIsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDVCxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxTQUFTLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3JFLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFJLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFFLENBQUUsQ0FBQTtBQUN0QyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFJLEtBQUssQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsQixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFHLENBQUMsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBUyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBQSxDQUFFLENBQUUsQ0FBQTtBQUMxQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsSUFBSSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSyxJQUFJLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBRSxDQUFBLENBQUMsQ0FBQyxDQUFFLENBQUE7QUFDL0MsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVSxLQUFLLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNsQixDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDVixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3hCLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxDQUFBLENBQUE7O0FBRUEsQ0FBQSxDQUFFLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNUOztBQUVBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVMsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFFLENBQUE7QUFDMUUsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDckQsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsUUFBUSxDQUFFLENBQUE7QUFDeEUsQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU8sQ0FBb0IsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFVLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQUksQ0FBQSxDQUFBLENBQUE7QUFDbkUsQ0FBQTs7QUFFQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFXLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLFFBQVEsQ0FBRSxDQUFBO0FBQ2hGLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPLENBQW9CLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFLLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDcEUsQ0FBQTs7QUFFQSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsRUFBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsTUFBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQTtBQUNoRCxDQUFBLENBQUUsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUMsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzdCLENBQUEsQ0FBRSxNQUFNLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFHLENBQUcsQ0FBQSxDQUFBLENBQUMsTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNqQyxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQTtBQUNmLENBQUEsQ0FBQSxDQUFBLENBQUksTUFBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNiLENBQUEsQ0FBQSxDQUFHLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ1QsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDMUIsQ0FBQSxDQUFBLENBQUEsQ0FBSSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLENBQUUsQ0FBQTtBQUM1QixDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxNQUFNLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2YsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBQTs7QUFFQSxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFeEIsQ0FBQSxDQUFFLElBQUksQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFFLENBQUE7QUFDM0IsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFHLENBQUEsQ0FBQSxDQUFBO0FBQ3RCLENBQUEsQ0FBQTtBQUNBLENBQUEsQ0FBRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUE7QUFDTixDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLENBQUMsQ0FBQSxDQUFBLENBQUcsQ0FBQyxDQUFBLENBQUUsQ0FBQyxDQUFBLENBQUEsQ0FBRyxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBRSxDQUFBLENBQUMsQ0FBRSxDQUFBO0FBQy9CLENBQUEsQ0FBQSxDQUFBLENBQUksTUFBTSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRyxDQUFRLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxNQUFNLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFBLENBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBRSxDQUFBLENBQUE7QUFDdkQsQ0FBQSxDQUFBLENBQUEsQ0FBSSxJQUFJLENBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUMsRUFBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ3BDLENBQUEsQ0FBQSxDQUFBLENBQUksR0FBRyxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBQyxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUN0QixDQUFBLENBQUE7QUFDQSxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUNUOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFTLEVBQUUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLE1BQU0sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUE7QUFDakQsQ0FBQSxDQUFFLE9BQU8sQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFDLFdBQVcsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQUcsQ0FBQSxDQUFBLENBQUMsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUcsTUFBTSxDQUFDLENBQUEsQ0FBRSxHQUFHLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxFQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ2pGOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsRUFBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsTUFBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFNLENBQUUsQ0FBQTtBQUNsRCxDQUFBLENBQUUsQ0FBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFVLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVksQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFDLENBQUEsQ0FBRSxDQUFHLENBQUEsQ0FBQSxDQUFBLENBQUUsQ0FBTSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQzdEOztBQUVBLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBVyxFQUFFLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBRSxNQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBO0FBQ25ELENBQUEsQ0FBRSxDQUFPLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVUsQ0FBQyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFhLENBQUMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBQyxDQUFBLENBQUUsQ0FBRyxDQUFBLENBQUEsQ0FBQSxDQUFFLENBQU0sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBRSxDQUFNLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUM5RDs7QUFFQSxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBUyxFQUFFLENBQUcsQ0FBQSxDQUFBLENBQUEsQ0FBRSxNQUFNLENBQUUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBTSxDQUFFLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU0sQ0FBRSxDQUFBO0FBQ2pELENBQUEsQ0FBRSxPQUFPLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQyxjQUFjLENBQUMsQ0FBQSxDQUFB